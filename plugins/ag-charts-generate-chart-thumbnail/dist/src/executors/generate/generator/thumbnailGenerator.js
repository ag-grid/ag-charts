"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "generateThumbnail", {
    enumerable: true,
    get: function() {
        return generateThumbnail;
    }
});
const _interop_require_default = require("@swc/helpers/_/_interop_require_default");
const _canvas = require("canvas");
const _jsdom = require("jsdom");
const _path = /*#__PURE__*/ _interop_require_default._(require("path"));
const _sharp = /*#__PURE__*/ _interop_require_default._(require("sharp"));
const _agchartscommunity = require("ag-charts-community");
require("ag-charts-enterprise");
const _agchartsgenerateexamplefiles = require("ag-charts-generate-example-files");
const _agchartstest = require("ag-charts-test");
const _constants = require("./constants");
const _getChartLayout = require("./getChartLayout");
const _patchOptions = require("./patchOptions");
async function generateThumbnail({ example, theme, outputPath, dpi, mockText }) {
    const { entryFileName, files = {} } = example;
    const entryFile = files[entryFileName];
    const preamble = Object.entries(files).map(([fileName, contents])=>{
        if (fileName.endsWith('.js') && fileName !== entryFileName) {
            return contents;
        } else {
            return '';
        }
    });
    const { optionsById } = (0, _agchartsgenerateexamplefiles.transformPlainEntryFile)(entryFile, preamble);
    const { rows, columns, charts } = (0, _getChartLayout.getChartLayout)(files['index.html']);
    let output;
    if (charts.length > 1) {
        const canvas = new _canvas.Canvas(_constants.DEFAULT_THUMBNAIL_WIDTH * dpi, _constants.DEFAULT_THUMBNAIL_HEIGHT * dpi);
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = _constants.BACKGROUND_COLORS[theme];
        ctx.fillRect(0, 0, _constants.DEFAULT_THUMBNAIL_WIDTH * dpi, _constants.DEFAULT_THUMBNAIL_HEIGHT * dpi);
        output = {
            multiple: true,
            canvas,
            ctx
        };
    } else {
        output = {
            multiple: false,
            buffer: undefined
        };
    }
    for (const { id, row, column } of charts){
        /* TODO: Initialize these once */ const { window, window: { document } } = new _jsdom.JSDOM(`<html><head><style></style></head><body></body></html>`);
        // Note - we'll need one instance per DPI setting
        const mockCtx = _agchartstest.mockCanvas.setup({
            width: _constants.DEFAULT_THUMBNAIL_WIDTH * dpi,
            height: _constants.DEFAULT_THUMBNAIL_HEIGHT * dpi,
            document,
            mockText
        });
        const chartProxy = _agchartscommunity.AgCharts.create({
            animation: {
                enabled: false
            },
            document,
            window,
            width: _constants.DEFAULT_THUMBNAIL_WIDTH,
            height: _constants.DEFAULT_THUMBNAIL_HEIGHT,
            overrideDevicePixelRatio: dpi
        });
        /* End TODO */ const options = optionsById.get(id);
        if (options == null) {
            throw new Error(`No options found for container with id "${id}"`);
        }
        (0, _patchOptions.patchOptions)(options, theme);
        const containerWidth = _constants.DEFAULT_THUMBNAIL_WIDTH / columns | 0;
        const containerHeight = _constants.DEFAULT_THUMBNAIL_HEIGHT / rows | 0;
        let width;
        let height;
        if (options.width != null) {
            const detailContainerHeight = _constants.DETAIL_FULL_HEIGHT / rows;
            let aspectRatio = options.width / detailContainerHeight;
            aspectRatio = Math.min(Math.max(aspectRatio, _constants.MIN_ASPECT_RATIO), _constants.MAX_ASPECT_RATIO);
            width = Math.min(containerHeight * aspectRatio, containerWidth);
            height = containerHeight;
        } else if (options.height == null) {
            width = containerWidth;
            height = containerHeight;
        } else {
            const detailContainerWidth = _constants.DETAIL_FULL_WIDTH / columns;
            let aspectRatio = detailContainerWidth / options.height;
            aspectRatio = Math.min(Math.max(aspectRatio, _constants.MIN_ASPECT_RATIO), _constants.MAX_ASPECT_RATIO);
            width = containerWidth;
            height = Math.min(containerWidth / aspectRatio, containerHeight);
        }
        const x0 = containerWidth * column + (containerWidth - width) / 2 | 0;
        const y0 = containerHeight * row + (containerHeight - height) / 2 | 0;
        _agchartscommunity.AgCharts.update(chartProxy, {
            ...options,
            animation: {
                enabled: false
            },
            document,
            window,
            width,
            height,
            overrideDevicePixelRatio: dpi
        });
        const chart = chartProxy.chart;
        await chart.waitForUpdate(5_000);
        if (output.multiple === true) {
            output.ctx.drawImage(mockCtx.ctx.nodeCanvas, 0, 0, width * dpi, height * dpi, x0 * dpi, y0 * dpi, width * dpi, height * dpi);
        } else {
            output.buffer = mockCtx.ctx.nodeCanvas.toBuffer('image/png');
        }
    }
    const buffer = output.multiple === true ? output.canvas.toBuffer('image/png') : output.buffer;
    const sharpBuffer = (0, _sharp.default)(buffer);
    const dpiExt = dpi === 1 ? '' : `@${dpi}x`;
    const fontExt = mockText ? '-platform-agnostic' : '';
    const baseFilename = `${theme}${fontExt}${dpiExt}`;
    await Promise.all([
        sharpBuffer.clone().png().toFile(_path.default.join(outputPath, `${baseFilename}.png`)),
        sharpBuffer.clone().webp({
            quality: 90
        }).toFile(_path.default.join(outputPath, `${baseFilename}.webp`))
    ]);
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9leGVjdXRvcnMvZ2VuZXJhdGUvZ2VuZXJhdG9yL3RodW1ibmFpbEdlbmVyYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYW52YXMsIHR5cGUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIH0gZnJvbSAnY2FudmFzJztcbmltcG9ydCB7IEpTRE9NIH0gZnJvbSAnanNkb20nO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc2hhcnAgZnJvbSAnc2hhcnAnO1xuXG5pbXBvcnQgeyB0eXBlIEFnQ2hhcnRUaGVtZU5hbWUsIEFnQ2hhcnRzIH0gZnJvbSAnYWctY2hhcnRzLWNvbW11bml0eSc7XG5pbXBvcnQgJ2FnLWNoYXJ0cy1lbnRlcnByaXNlJztcbmltcG9ydCB7IHR5cGUgR2VuZXJhdGVkQ29udGVudHMsIHRyYW5zZm9ybVBsYWluRW50cnlGaWxlIH0gZnJvbSAnYWctY2hhcnRzLWdlbmVyYXRlLWV4YW1wbGUtZmlsZXMnO1xuaW1wb3J0IHsgbW9ja0NhbnZhcyB9IGZyb20gJ2FnLWNoYXJ0cy10ZXN0JztcblxuaW1wb3J0IHtcbiAgICBCQUNLR1JPVU5EX0NPTE9SUyxcbiAgICBERUZBVUxUX1RIVU1CTkFJTF9IRUlHSFQsXG4gICAgREVGQVVMVF9USFVNQk5BSUxfV0lEVEgsXG4gICAgREVUQUlMX0ZVTExfSEVJR0hULFxuICAgIERFVEFJTF9GVUxMX1dJRFRILFxuICAgIE1BWF9BU1BFQ1RfUkFUSU8sXG4gICAgTUlOX0FTUEVDVF9SQVRJTyxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0Q2hhcnRMYXlvdXQgfSBmcm9tICcuL2dldENoYXJ0TGF5b3V0JztcbmltcG9ydCB7IHBhdGNoT3B0aW9ucyB9IGZyb20gJy4vcGF0Y2hPcHRpb25zJztcblxuaW50ZXJmYWNlIFBhcmFtcyB7XG4gICAgZXhhbXBsZTogR2VuZXJhdGVkQ29udGVudHM7XG4gICAgdGhlbWU6IEFnQ2hhcnRUaGVtZU5hbWU7XG4gICAgb3V0cHV0UGF0aDogc3RyaW5nO1xuICAgIGRwaTogbnVtYmVyO1xuICAgIG1vY2tUZXh0OiBib29sZWFuO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUaHVtYm5haWwoeyBleGFtcGxlLCB0aGVtZSwgb3V0cHV0UGF0aCwgZHBpLCBtb2NrVGV4dCB9OiBQYXJhbXMpIHtcbiAgICBjb25zdCB7IGVudHJ5RmlsZU5hbWUsIGZpbGVzID0ge30gfSA9IGV4YW1wbGU7XG5cbiAgICBjb25zdCBlbnRyeUZpbGUgPSBmaWxlc1tlbnRyeUZpbGVOYW1lXTtcblxuICAgIGNvbnN0IHByZWFtYmxlID0gT2JqZWN0LmVudHJpZXMoZmlsZXMpLm1hcCgoW2ZpbGVOYW1lLCBjb250ZW50c10pID0+IHtcbiAgICAgICAgaWYgKGZpbGVOYW1lLmVuZHNXaXRoKCcuanMnKSAmJiBmaWxlTmFtZSAhPT0gZW50cnlGaWxlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgeyBvcHRpb25zQnlJZCB9ID0gdHJhbnNmb3JtUGxhaW5FbnRyeUZpbGUoZW50cnlGaWxlLCBwcmVhbWJsZSk7XG5cbiAgICBjb25zdCB7IHJvd3MsIGNvbHVtbnMsIGNoYXJ0cyB9ID0gZ2V0Q2hhcnRMYXlvdXQoZmlsZXNbJ2luZGV4Lmh0bWwnXSk7XG5cbiAgICBsZXQgb3V0cHV0OiB7IG11bHRpcGxlOiB0cnVlOyBjYW52YXM6IENhbnZhczsgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfSB8IHsgbXVsdGlwbGU6IGZhbHNlOyBidWZmZXI6IEJ1ZmZlciB9O1xuICAgIGlmIChjaGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBuZXcgQ2FudmFzKERFRkFVTFRfVEhVTUJOQUlMX1dJRFRIICogZHBpLCBERUZBVUxUX1RIVU1CTkFJTF9IRUlHSFQgKiBkcGkpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gQkFDS0dST1VORF9DT0xPUlNbdGhlbWVdO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgREVGQVVMVF9USFVNQk5BSUxfV0lEVEggKiBkcGksIERFRkFVTFRfVEhVTUJOQUlMX0hFSUdIVCAqIGRwaSk7XG5cbiAgICAgICAgb3V0cHV0ID0geyBtdWx0aXBsZTogdHJ1ZSwgY2FudmFzLCBjdHggfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSB7IG11bHRpcGxlOiBmYWxzZSwgYnVmZmVyOiB1bmRlZmluZWQhIH07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB7IGlkLCByb3csIGNvbHVtbiB9IG9mIGNoYXJ0cykge1xuICAgICAgICAvKiBUT0RPOiBJbml0aWFsaXplIHRoZXNlIG9uY2UgKi9cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgd2luZG93LFxuICAgICAgICAgICAgd2luZG93OiB7IGRvY3VtZW50IH0sXG4gICAgICAgIH0gPSBuZXcgSlNET00oYDxodG1sPjxoZWFkPjxzdHlsZT48L3N0eWxlPjwvaGVhZD48Ym9keT48L2JvZHk+PC9odG1sPmApO1xuXG4gICAgICAgIC8vIE5vdGUgLSB3ZSdsbCBuZWVkIG9uZSBpbnN0YW5jZSBwZXIgRFBJIHNldHRpbmdcbiAgICAgICAgY29uc3QgbW9ja0N0eCA9IG1vY2tDYW52YXMuc2V0dXAoe1xuICAgICAgICAgICAgd2lkdGg6IERFRkFVTFRfVEhVTUJOQUlMX1dJRFRIICogZHBpLFxuICAgICAgICAgICAgaGVpZ2h0OiBERUZBVUxUX1RIVU1CTkFJTF9IRUlHSFQgKiBkcGksXG4gICAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICAgIG1vY2tUZXh0LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjaGFydFByb3h5ID0gQWdDaGFydHMuY3JlYXRlKHtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgICAgICB3aW5kb3csXG4gICAgICAgICAgICB3aWR0aDogREVGQVVMVF9USFVNQk5BSUxfV0lEVEgsXG4gICAgICAgICAgICBoZWlnaHQ6IERFRkFVTFRfVEhVTUJOQUlMX0hFSUdIVCxcbiAgICAgICAgICAgIG92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbzogZHBpLFxuICAgICAgICB9IGFzIGFueSk7XG4gICAgICAgIC8qIEVuZCBUT0RPICovXG5cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG9wdGlvbnNCeUlkLmdldChpZCk7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gb3B0aW9ucyBmb3VuZCBmb3IgY29udGFpbmVyIHdpdGggaWQgXCIke2lkfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0Y2hPcHRpb25zKG9wdGlvbnMsIHRoZW1lKTtcblxuICAgICAgICBjb25zdCBjb250YWluZXJXaWR0aCA9IChERUZBVUxUX1RIVU1CTkFJTF9XSURUSCAvIGNvbHVtbnMpIHwgMDtcbiAgICAgICAgY29uc3QgY29udGFpbmVySGVpZ2h0ID0gKERFRkFVTFRfVEhVTUJOQUlMX0hFSUdIVCAvIHJvd3MpIHwgMDtcblxuICAgICAgICBsZXQgd2lkdGg6IG51bWJlcjtcbiAgICAgICAgbGV0IGhlaWdodDogbnVtYmVyO1xuICAgICAgICBpZiAob3B0aW9ucy53aWR0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkZXRhaWxDb250YWluZXJIZWlnaHQgPSBERVRBSUxfRlVMTF9IRUlHSFQgLyByb3dzO1xuICAgICAgICAgICAgbGV0IGFzcGVjdFJhdGlvID0gb3B0aW9ucy53aWR0aCAvIGRldGFpbENvbnRhaW5lckhlaWdodDtcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvID0gTWF0aC5taW4oTWF0aC5tYXgoYXNwZWN0UmF0aW8sIE1JTl9BU1BFQ1RfUkFUSU8pLCBNQVhfQVNQRUNUX1JBVElPKTtcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5taW4oY29udGFpbmVySGVpZ2h0ICogYXNwZWN0UmF0aW8sIGNvbnRhaW5lcldpZHRoKTtcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGNvbnRhaW5lcldpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGV0YWlsQ29udGFpbmVyV2lkdGggPSBERVRBSUxfRlVMTF9XSURUSCAvIGNvbHVtbnM7XG4gICAgICAgICAgICBsZXQgYXNwZWN0UmF0aW8gPSBkZXRhaWxDb250YWluZXJXaWR0aCAvIG9wdGlvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgYXNwZWN0UmF0aW8gPSBNYXRoLm1pbihNYXRoLm1heChhc3BlY3RSYXRpbywgTUlOX0FTUEVDVF9SQVRJTyksIE1BWF9BU1BFQ1RfUkFUSU8pO1xuICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWluKGNvbnRhaW5lcldpZHRoIC8gYXNwZWN0UmF0aW8sIGNvbnRhaW5lckhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB4MCA9IChjb250YWluZXJXaWR0aCAqIGNvbHVtbiArIChjb250YWluZXJXaWR0aCAtIHdpZHRoKSAvIDIpIHwgMDtcbiAgICAgICAgY29uc3QgeTAgPSAoY29udGFpbmVySGVpZ2h0ICogcm93ICsgKGNvbnRhaW5lckhlaWdodCAtIGhlaWdodCkgLyAyKSB8IDA7XG5cbiAgICAgICAgQWdDaGFydHMudXBkYXRlKGNoYXJ0UHJveHksIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBhbmltYXRpb246IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIGRvY3VtZW50LFxuICAgICAgICAgICAgd2luZG93LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBvdmVycmlkZURldmljZVBpeGVsUmF0aW86IGRwaSxcbiAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gKGNoYXJ0UHJveHkgYXMgYW55KS5jaGFydDtcbiAgICAgICAgYXdhaXQgY2hhcnQud2FpdEZvclVwZGF0ZSg1XzAwMCk7XG5cbiAgICAgICAgaWYgKG91dHB1dC5tdWx0aXBsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgb3V0cHV0LmN0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgbW9ja0N0eC5jdHgubm9kZUNhbnZhcyxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgd2lkdGggKiBkcGksXG4gICAgICAgICAgICAgICAgaGVpZ2h0ICogZHBpLFxuICAgICAgICAgICAgICAgIHgwICogZHBpLFxuICAgICAgICAgICAgICAgIHkwICogZHBpLFxuICAgICAgICAgICAgICAgIHdpZHRoICogZHBpLFxuICAgICAgICAgICAgICAgIGhlaWdodCAqIGRwaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5idWZmZXIgPSBtb2NrQ3R4LmN0eC5ub2RlQ2FudmFzLnRvQnVmZmVyKCdpbWFnZS9wbmcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IG91dHB1dC5tdWx0aXBsZSA9PT0gdHJ1ZSA/IG91dHB1dC5jYW52YXMudG9CdWZmZXIoJ2ltYWdlL3BuZycpIDogb3V0cHV0LmJ1ZmZlcjtcblxuICAgIGNvbnN0IHNoYXJwQnVmZmVyID0gc2hhcnAoYnVmZmVyKTtcblxuICAgIGNvbnN0IGRwaUV4dCA9IGRwaSA9PT0gMSA/ICcnIDogYEAke2RwaX14YDtcbiAgICBjb25zdCBmb250RXh0ID0gbW9ja1RleHQgPyAnLXBsYXRmb3JtLWFnbm9zdGljJyA6ICcnO1xuICAgIGNvbnN0IGJhc2VGaWxlbmFtZSA9IGAke3RoZW1lfSR7Zm9udEV4dH0ke2RwaUV4dH1gO1xuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBzaGFycEJ1ZmZlclxuICAgICAgICAgICAgLmNsb25lKClcbiAgICAgICAgICAgIC5wbmcoKVxuICAgICAgICAgICAgLnRvRmlsZShwYXRoLmpvaW4ob3V0cHV0UGF0aCwgYCR7YmFzZUZpbGVuYW1lfS5wbmdgKSksXG4gICAgICAgIHNoYXJwQnVmZmVyXG4gICAgICAgICAgICAuY2xvbmUoKVxuICAgICAgICAgICAgLndlYnAoeyBxdWFsaXR5OiA5MCB9KVxuICAgICAgICAgICAgLnRvRmlsZShwYXRoLmpvaW4ob3V0cHV0UGF0aCwgYCR7YmFzZUZpbGVuYW1lfS53ZWJwYCkpLFxuICAgIF0pO1xufVxuIl0sIm5hbWVzIjpbImdlbmVyYXRlVGh1bWJuYWlsIiwiZXhhbXBsZSIsInRoZW1lIiwib3V0cHV0UGF0aCIsImRwaSIsIm1vY2tUZXh0IiwiZW50cnlGaWxlTmFtZSIsImZpbGVzIiwiZW50cnlGaWxlIiwicHJlYW1ibGUiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwiZmlsZU5hbWUiLCJjb250ZW50cyIsImVuZHNXaXRoIiwib3B0aW9uc0J5SWQiLCJ0cmFuc2Zvcm1QbGFpbkVudHJ5RmlsZSIsInJvd3MiLCJjb2x1bW5zIiwiY2hhcnRzIiwiZ2V0Q2hhcnRMYXlvdXQiLCJvdXRwdXQiLCJsZW5ndGgiLCJjYW52YXMiLCJDYW52YXMiLCJERUZBVUxUX1RIVU1CTkFJTF9XSURUSCIsIkRFRkFVTFRfVEhVTUJOQUlMX0hFSUdIVCIsImN0eCIsImdldENvbnRleHQiLCJmaWxsU3R5bGUiLCJCQUNLR1JPVU5EX0NPTE9SUyIsImZpbGxSZWN0IiwibXVsdGlwbGUiLCJidWZmZXIiLCJ1bmRlZmluZWQiLCJpZCIsInJvdyIsImNvbHVtbiIsIndpbmRvdyIsImRvY3VtZW50IiwiSlNET00iLCJtb2NrQ3R4IiwibW9ja0NhbnZhcyIsInNldHVwIiwid2lkdGgiLCJoZWlnaHQiLCJjaGFydFByb3h5IiwiQWdDaGFydHMiLCJjcmVhdGUiLCJhbmltYXRpb24iLCJlbmFibGVkIiwib3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvIiwib3B0aW9ucyIsImdldCIsIkVycm9yIiwicGF0Y2hPcHRpb25zIiwiY29udGFpbmVyV2lkdGgiLCJjb250YWluZXJIZWlnaHQiLCJkZXRhaWxDb250YWluZXJIZWlnaHQiLCJERVRBSUxfRlVMTF9IRUlHSFQiLCJhc3BlY3RSYXRpbyIsIk1hdGgiLCJtaW4iLCJtYXgiLCJNSU5fQVNQRUNUX1JBVElPIiwiTUFYX0FTUEVDVF9SQVRJTyIsImRldGFpbENvbnRhaW5lcldpZHRoIiwiREVUQUlMX0ZVTExfV0lEVEgiLCJ4MCIsInkwIiwidXBkYXRlIiwiY2hhcnQiLCJ3YWl0Rm9yVXBkYXRlIiwiZHJhd0ltYWdlIiwibm9kZUNhbnZhcyIsInRvQnVmZmVyIiwic2hhcnBCdWZmZXIiLCJzaGFycCIsImRwaUV4dCIsImZvbnRFeHQiLCJiYXNlRmlsZW5hbWUiLCJQcm9taXNlIiwiYWxsIiwiY2xvbmUiLCJwbmciLCJ0b0ZpbGUiLCJwYXRoIiwiam9pbiIsIndlYnAiLCJxdWFsaXR5Il0sIm1hcHBpbmdzIjoiOzs7OytCQThCc0JBOzs7ZUFBQUE7Ozs7d0JBOUJnQzt1QkFDaEM7K0RBQ0w7Z0VBQ0M7bUNBRThCO1FBQ3pDOzhDQUN5RDs4QkFDckM7MkJBVXBCO2dDQUN3Qjs4QkFDRjtBQVV0QixlQUFlQSxrQkFBa0IsRUFBRUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsR0FBRyxFQUFFQyxRQUFRLEVBQVU7SUFDekYsTUFBTSxFQUFFQyxhQUFhLEVBQUVD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