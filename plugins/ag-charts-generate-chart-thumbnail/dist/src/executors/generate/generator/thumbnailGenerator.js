"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "generateExample", {
    enumerable: true,
    get: function() {
        return generateExample;
    }
});
const _interop_require_default = require("@swc/helpers/_/_interop_require_default");
const _canvas = require("canvas");
const _jsdom = require("jsdom");
const _path = /*#__PURE__*/ _interop_require_default._(require("path"));
const _sharp = /*#__PURE__*/ _interop_require_default._(require("sharp"));
const _agchartscommunity = require("ag-charts-community");
require("ag-charts-enterprise");
const _agchartsgenerateexamplefiles = require("ag-charts-generate-example-files");
const _agchartstest = require("ag-charts-test");
const _constants = require("./constants");
const _getChartLayout = require("./getChartLayout");
const _patchOptions = require("./patchOptions");
async function generateExample({ example, theme, outputPath, dpi }) {
    const { entryFileName, files = {} } = example;
    const entryFile = files[entryFileName];
    const preamble = Object.entries(files).map(([fileName, contents])=>{
        if (fileName.endsWith('.js') && fileName !== entryFileName) {
            return contents;
        } else {
            return '';
        }
    });
    const { optionsById } = (0, _agchartsgenerateexamplefiles.transformPlainEntryFile)(entryFile, preamble);
    const { rows, columns, charts } = (0, _getChartLayout.getChartLayout)(files['index.html']);
    let output;
    if (charts.length > 1) {
        const canvas = new _canvas.Canvas(_constants.DEFAULT_THUMBNAIL_WIDTH * dpi, _constants.DEFAULT_THUMBNAIL_HEIGHT * dpi);
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = _constants.BACKGROUND_COLORS[theme];
        ctx.fillRect(0, 0, _constants.DEFAULT_THUMBNAIL_WIDTH * dpi, _constants.DEFAULT_THUMBNAIL_HEIGHT * dpi);
        output = {
            multiple: true,
            canvas,
            ctx
        };
    } else {
        output = {
            multiple: false,
            buffer: undefined
        };
    }
    for (const { id, row, column } of charts){
        /* TODO: Initialize these once */ const { window, window: { document } } = new _jsdom.JSDOM(`<html><head><style></style></head><body></body></html>`);
        // Note - we'll need one instance per DPI setting
        const mockCtx = _agchartstest.mockCanvas.setup({
            width: _constants.DEFAULT_THUMBNAIL_WIDTH * dpi,
            height: _constants.DEFAULT_THUMBNAIL_HEIGHT * dpi,
            document,
            mockText: false
        });
        const chartProxy = _agchartscommunity.AgCharts.create({
            animation: {
                enabled: false
            },
            document,
            window,
            width: _constants.DEFAULT_THUMBNAIL_WIDTH,
            height: _constants.DEFAULT_THUMBNAIL_HEIGHT,
            overrideDevicePixelRatio: dpi
        });
        /* End TODO */ const options = optionsById.get(id);
        if (options == null) {
            throw new Error(`No options found for container with id "${id}"`);
        }
        (0, _patchOptions.patchOptions)(options, theme);
        const containerWidth = _constants.DEFAULT_THUMBNAIL_WIDTH / columns | 0;
        const containerHeight = _constants.DEFAULT_THUMBNAIL_HEIGHT / rows | 0;
        let width;
        let height;
        if (options.width != null) {
            const detailContainerHeight = _constants.DETAIL_FULL_HEIGHT / rows;
            let aspectRatio = options.width / detailContainerHeight;
            aspectRatio = Math.min(Math.max(aspectRatio, _constants.MIN_ASPECT_RATIO), _constants.MAX_ASPECT_RATIO);
            width = Math.min(containerHeight * aspectRatio, containerWidth);
            height = containerHeight;
        } else if (options.height == null) {
            width = containerWidth;
            height = containerHeight;
        } else {
            const detailContainerWidth = _constants.DETAIL_FULL_WIDTH / columns;
            let aspectRatio = detailContainerWidth / options.height;
            aspectRatio = Math.min(Math.max(aspectRatio, _constants.MIN_ASPECT_RATIO), _constants.MAX_ASPECT_RATIO);
            width = containerWidth;
            height = Math.min(containerWidth / aspectRatio, containerHeight);
        }
        const x0 = containerWidth * column + (containerWidth - width) / 2 | 0;
        const y0 = containerHeight * row + (containerHeight - height) / 2 | 0;
        _agchartscommunity.AgCharts.update(chartProxy, {
            ...options,
            animation: {
                enabled: false
            },
            document,
            window,
            width,
            height,
            overrideDevicePixelRatio: dpi
        });
        const chart = chartProxy.chart;
        await chart.waitForUpdate(5_000);
        if (output.multiple === true) {
            output.ctx.drawImage(mockCtx.ctx.nodeCanvas, 0, 0, width * dpi, height * dpi, x0 * dpi, y0 * dpi, width * dpi, height * dpi);
        } else {
            output.buffer = mockCtx.ctx.nodeCanvas.toBuffer('image/png');
        }
    }
    const buffer = output.multiple === true ? output.canvas.toBuffer('image/png') : output.buffer;
    const s = (0, _sharp.default)(buffer);
    const dpiExt = dpi === 1 ? '' : `@${dpi}x`;
    await Promise.all([
        s.clone().png().toFile(_path.default.join(outputPath, `${theme}${dpiExt}.png`)),
        s.clone().webp({
            quality: 90
        }).toFile(_path.default.join(outputPath, `${theme}${dpiExt}.webp`))
    ]);
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9leGVjdXRvcnMvZ2VuZXJhdGUvZ2VuZXJhdG9yL3RodW1ibmFpbEdlbmVyYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYW52YXMsIHR5cGUgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIH0gZnJvbSAnY2FudmFzJztcbmltcG9ydCB7IEpTRE9NIH0gZnJvbSAnanNkb20nO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgc2hhcnAgZnJvbSAnc2hhcnAnO1xuXG5pbXBvcnQgeyB0eXBlIEFnQ2hhcnRUaGVtZU5hbWUsIEFnQ2hhcnRzIH0gZnJvbSAnYWctY2hhcnRzLWNvbW11bml0eSc7XG5pbXBvcnQgJ2FnLWNoYXJ0cy1lbnRlcnByaXNlJztcbmltcG9ydCB7IHR5cGUgR2VuZXJhdGVkQ29udGVudHMsIHRyYW5zZm9ybVBsYWluRW50cnlGaWxlIH0gZnJvbSAnYWctY2hhcnRzLWdlbmVyYXRlLWV4YW1wbGUtZmlsZXMnO1xuaW1wb3J0IHsgbW9ja0NhbnZhcyB9IGZyb20gJ2FnLWNoYXJ0cy10ZXN0JztcblxuaW1wb3J0IHtcbiAgICBCQUNLR1JPVU5EX0NPTE9SUyxcbiAgICBERUZBVUxUX1RIVU1CTkFJTF9IRUlHSFQsXG4gICAgREVGQVVMVF9USFVNQk5BSUxfV0lEVEgsXG4gICAgREVUQUlMX0ZVTExfSEVJR0hULFxuICAgIERFVEFJTF9GVUxMX1dJRFRILFxuICAgIE1BWF9BU1BFQ1RfUkFUSU8sXG4gICAgTUlOX0FTUEVDVF9SQVRJTyxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0Q2hhcnRMYXlvdXQgfSBmcm9tICcuL2dldENoYXJ0TGF5b3V0JztcbmltcG9ydCB7IHBhdGNoT3B0aW9ucyB9IGZyb20gJy4vcGF0Y2hPcHRpb25zJztcblxuaW50ZXJmYWNlIFBhcmFtcyB7XG4gICAgZXhhbXBsZTogR2VuZXJhdGVkQ29udGVudHM7XG4gICAgdGhlbWU6IEFnQ2hhcnRUaGVtZU5hbWU7XG4gICAgb3V0cHV0UGF0aDogc3RyaW5nO1xuICAgIGRwaTogbnVtYmVyO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVFeGFtcGxlKHsgZXhhbXBsZSwgdGhlbWUsIG91dHB1dFBhdGgsIGRwaSB9OiBQYXJhbXMpIHtcbiAgICBjb25zdCB7IGVudHJ5RmlsZU5hbWUsIGZpbGVzID0ge30gfSA9IGV4YW1wbGU7XG5cbiAgICBjb25zdCBlbnRyeUZpbGUgPSBmaWxlc1tlbnRyeUZpbGVOYW1lXTtcblxuICAgIGNvbnN0IHByZWFtYmxlID0gT2JqZWN0LmVudHJpZXMoZmlsZXMpLm1hcCgoW2ZpbGVOYW1lLCBjb250ZW50c10pID0+IHtcbiAgICAgICAgaWYgKGZpbGVOYW1lLmVuZHNXaXRoKCcuanMnKSAmJiBmaWxlTmFtZSAhPT0gZW50cnlGaWxlTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgeyBvcHRpb25zQnlJZCB9ID0gdHJhbnNmb3JtUGxhaW5FbnRyeUZpbGUoZW50cnlGaWxlLCBwcmVhbWJsZSk7XG5cbiAgICBjb25zdCB7IHJvd3MsIGNvbHVtbnMsIGNoYXJ0cyB9ID0gZ2V0Q2hhcnRMYXlvdXQoZmlsZXNbJ2luZGV4Lmh0bWwnXSk7XG5cbiAgICBsZXQgb3V0cHV0OiB7IG11bHRpcGxlOiB0cnVlOyBjYW52YXM6IENhbnZhczsgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgfSB8IHsgbXVsdGlwbGU6IGZhbHNlOyBidWZmZXI6IEJ1ZmZlciB9O1xuICAgIGlmIChjaGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBuZXcgQ2FudmFzKERFRkFVTFRfVEhVTUJOQUlMX1dJRFRIICogZHBpLCBERUZBVUxUX1RIVU1CTkFJTF9IRUlHSFQgKiBkcGkpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gQkFDS0dST1VORF9DT0xPUlNbdGhlbWVdO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgREVGQVVMVF9USFVNQk5BSUxfV0lEVEggKiBkcGksIERFRkFVTFRfVEhVTUJOQUlMX0hFSUdIVCAqIGRwaSk7XG5cbiAgICAgICAgb3V0cHV0ID0geyBtdWx0aXBsZTogdHJ1ZSwgY2FudmFzLCBjdHggfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSB7IG11bHRpcGxlOiBmYWxzZSwgYnVmZmVyOiB1bmRlZmluZWQhIH07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB7IGlkLCByb3csIGNvbHVtbiB9IG9mIGNoYXJ0cykge1xuICAgICAgICAvKiBUT0RPOiBJbml0aWFsaXplIHRoZXNlIG9uY2UgKi9cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgd2luZG93LFxuICAgICAgICAgICAgd2luZG93OiB7IGRvY3VtZW50IH0sXG4gICAgICAgIH0gPSBuZXcgSlNET00oYDxodG1sPjxoZWFkPjxzdHlsZT48L3N0eWxlPjwvaGVhZD48Ym9keT48L2JvZHk+PC9odG1sPmApO1xuXG4gICAgICAgIC8vIE5vdGUgLSB3ZSdsbCBuZWVkIG9uZSBpbnN0YW5jZSBwZXIgRFBJIHNldHRpbmdcbiAgICAgICAgY29uc3QgbW9ja0N0eCA9IG1vY2tDYW52YXMuc2V0dXAoe1xuICAgICAgICAgICAgd2lkdGg6IERFRkFVTFRfVEhVTUJOQUlMX1dJRFRIICogZHBpLFxuICAgICAgICAgICAgaGVpZ2h0OiBERUZBVUxUX1RIVU1CTkFJTF9IRUlHSFQgKiBkcGksXG4gICAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICAgIG1vY2tUZXh0OiBmYWxzZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY2hhcnRQcm94eSA9IEFnQ2hhcnRzLmNyZWF0ZSh7XG4gICAgICAgICAgICBhbmltYXRpb246IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgICAgICAgIGRvY3VtZW50LFxuICAgICAgICAgICAgd2luZG93LFxuICAgICAgICAgICAgd2lkdGg6IERFRkFVTFRfVEhVTUJOQUlMX1dJRFRILFxuICAgICAgICAgICAgaGVpZ2h0OiBERUZBVUxUX1RIVU1CTkFJTF9IRUlHSFQsXG4gICAgICAgICAgICBvdmVycmlkZURldmljZVBpeGVsUmF0aW86IGRwaSxcbiAgICAgICAgfSBhcyBhbnkpO1xuICAgICAgICAvKiBFbmQgVE9ETyAqL1xuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBvcHRpb25zQnlJZC5nZXQoaWQpO1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG9wdGlvbnMgZm91bmQgZm9yIGNvbnRhaW5lciB3aXRoIGlkIFwiJHtpZH1cImApO1xuICAgICAgICB9XG4gICAgICAgIHBhdGNoT3B0aW9ucyhvcHRpb25zLCB0aGVtZSk7XG5cbiAgICAgICAgY29uc3QgY29udGFpbmVyV2lkdGggPSAoREVGQVVMVF9USFVNQk5BSUxfV0lEVEggLyBjb2x1bW5zKSB8IDA7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckhlaWdodCA9IChERUZBVUxUX1RIVU1CTkFJTF9IRUlHSFQgLyByb3dzKSB8IDA7XG5cbiAgICAgICAgbGV0IHdpZHRoOiBudW1iZXI7XG4gICAgICAgIGxldCBoZWlnaHQ6IG51bWJlcjtcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZGV0YWlsQ29udGFpbmVySGVpZ2h0ID0gREVUQUlMX0ZVTExfSEVJR0hUIC8gcm93cztcbiAgICAgICAgICAgIGxldCBhc3BlY3RSYXRpbyA9IG9wdGlvbnMud2lkdGggLyBkZXRhaWxDb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgICBhc3BlY3RSYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KGFzcGVjdFJhdGlvLCBNSU5fQVNQRUNUX1JBVElPKSwgTUFYX0FTUEVDVF9SQVRJTyk7XG4gICAgICAgICAgICB3aWR0aCA9IE1hdGgubWluKGNvbnRhaW5lckhlaWdodCAqIGFzcGVjdFJhdGlvLCBjb250YWluZXJXaWR0aCk7XG4gICAgICAgICAgICBoZWlnaHQgPSBjb250YWluZXJIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWlnaHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgd2lkdGggPSBjb250YWluZXJXaWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbENvbnRhaW5lcldpZHRoID0gREVUQUlMX0ZVTExfV0lEVEggLyBjb2x1bW5zO1xuICAgICAgICAgICAgbGV0IGFzcGVjdFJhdGlvID0gZGV0YWlsQ29udGFpbmVyV2lkdGggLyBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvID0gTWF0aC5taW4oTWF0aC5tYXgoYXNwZWN0UmF0aW8sIE1JTl9BU1BFQ1RfUkFUSU8pLCBNQVhfQVNQRUNUX1JBVElPKTtcbiAgICAgICAgICAgIHdpZHRoID0gY29udGFpbmVyV2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1pbihjb250YWluZXJXaWR0aCAvIGFzcGVjdFJhdGlvLCBjb250YWluZXJIZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeDAgPSAoY29udGFpbmVyV2lkdGggKiBjb2x1bW4gKyAoY29udGFpbmVyV2lkdGggLSB3aWR0aCkgLyAyKSB8IDA7XG4gICAgICAgIGNvbnN0IHkwID0gKGNvbnRhaW5lckhlaWdodCAqIHJvdyArIChjb250YWluZXJIZWlnaHQgLSBoZWlnaHQpIC8gMikgfCAwO1xuXG4gICAgICAgIEFnQ2hhcnRzLnVwZGF0ZShjaGFydFByb3h5LCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICAgIHdpbmRvdyxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvOiBkcGksXG4gICAgICAgIH0gYXMgYW55KTtcblxuICAgICAgICBjb25zdCBjaGFydCA9IChjaGFydFByb3h5IGFzIGFueSkuY2hhcnQ7XG4gICAgICAgIGF3YWl0IGNoYXJ0LndhaXRGb3JVcGRhdGUoNV8wMDApO1xuXG4gICAgICAgIGlmIChvdXRwdXQubXVsdGlwbGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG91dHB1dC5jdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgICAgIG1vY2tDdHguY3R4Lm5vZGVDYW52YXMsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIHdpZHRoICogZHBpLFxuICAgICAgICAgICAgICAgIGhlaWdodCAqIGRwaSxcbiAgICAgICAgICAgICAgICB4MCAqIGRwaSxcbiAgICAgICAgICAgICAgICB5MCAqIGRwaSxcbiAgICAgICAgICAgICAgICB3aWR0aCAqIGRwaSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgKiBkcGlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQuYnVmZmVyID0gbW9ja0N0eC5jdHgubm9kZUNhbnZhcy50b0J1ZmZlcignaW1hZ2UvcG5nJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBvdXRwdXQubXVsdGlwbGUgPT09IHRydWUgPyBvdXRwdXQuY2FudmFzLnRvQnVmZmVyKCdpbWFnZS9wbmcnKSA6IG91dHB1dC5idWZmZXI7XG5cbiAgICBjb25zdCBzID0gc2hhcnAoYnVmZmVyKTtcblxuICAgIGNvbnN0IGRwaUV4dCA9IGRwaSA9PT0gMSA/ICcnIDogYEAke2RwaX14YDtcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgc1xuICAgICAgICAgICAgLmNsb25lKClcbiAgICAgICAgICAgIC5wbmcoKVxuICAgICAgICAgICAgLnRvRmlsZShwYXRoLmpvaW4ob3V0cHV0UGF0aCwgYCR7dGhlbWV9JHtkcGlFeHR9LnBuZ2ApKSxcbiAgICAgICAgc1xuICAgICAgICAgICAgLmNsb25lKClcbiAgICAgICAgICAgIC53ZWJwKHsgcXVhbGl0eTogOTAgfSlcbiAgICAgICAgICAgIC50b0ZpbGUocGF0aC5qb2luKG91dHB1dFBhdGgsIGAke3RoZW1lfSR7ZHBpRXh0fS53ZWJwYCkpLFxuICAgIF0pO1xufVxuIl0sIm5hbWVzIjpbImdlbmVyYXRlRXhhbXBsZSIsImV4YW1wbGUiLCJ0aGVtZSIsIm91dHB1dFBhdGgiLCJkcGkiLCJlbnRyeUZpbGVOYW1lIiwiZmlsZXMiLCJlbnRyeUZpbGUiLCJwcmVhbWJsZSIsIk9iamVjdCIsImVudHJpZXMiLCJtYXAiLCJmaWxlTmFtZSIsImNvbnRlbnRzIiwiZW5kc1dpdGgiLCJvcHRpb25zQnlJZCIsInRyYW5zZm9ybVBsYWluRW50cnlGaWxlIiwicm93cyIsImNvbHVtbnMiLCJjaGFydHMiLCJnZXRDaGFydExheW91dCIsIm91dHB1dCIsImxlbmd0aCIsImNhbnZhcyIsIkNhbnZhcyIsIkRFRkFVTFRfVEhVTUJOQUlMX1dJRFRIIiwiREVGQVVMVF9USFVNQk5BSUxfSEVJR0hUIiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxTdHlsZSIsIkJBQ0tHUk9VTkRfQ09MT1JTIiwiZmlsbFJlY3QiLCJtdWx0aXBsZSIsImJ1ZmZlciIsInVuZGVmaW5lZCIsImlkIiwicm93IiwiY29sdW1uIiwid2luZG93IiwiZG9jdW1lbnQiLCJKU0RPTSIsIm1vY2tDdHgiLCJtb2NrQ2FudmFzIiwic2V0dXAiLCJ3aWR0aCIsImhlaWdodCIsIm1vY2tUZXh0IiwiY2hhcnRQcm94eSIsIkFnQ2hhcnRzIiwiY3JlYXRlIiwiYW5pbWF0aW9uIiwiZW5hYmxlZCIsIm92ZXJyaWRlRGV2aWNlUGl4ZWxSYXRpbyIsIm9wdGlvbnMiLCJnZXQiLCJFcnJvciIsInBhdGNoT3B0aW9ucyIsImNvbnRhaW5lcldpZHRoIiwiY29udGFpbmVySGVpZ2h0IiwiZGV0YWlsQ29udGFpbmVySGVpZ2h0IiwiREVUQUlMX0ZVTExfSEVJR0hUIiwiYXNwZWN0UmF0aW8iLCJNYXRoIiwibWluIiwibWF4IiwiTUlOX0FTUEVDVF9SQVRJTyIsIk1BWF9BU1BFQ1RfUkFUSU8iLCJkZXRhaWxDb250YWluZXJXaWR0aCIsIkRFVEFJTF9GVUxMX1dJRFRIIiwieDAiLCJ5MCIsInVwZGF0ZSIsImNoYXJ0Iiwid2FpdEZvclVwZGF0ZSIsImRyYXdJbWFnZSIsIm5vZGVDYW52YXMiLCJ0b0J1ZmZlciIsInMiLCJzaGFycCIsImRwaUV4dCIsIlByb21pc2UiLCJhbGwiLCJjbG9uZSIsInBuZyIsInRvRmlsZSIsInBhdGgiLCJqb2luIiwid2VicCIsInF1YWxpdHkiXSwibWFwcGluZ3MiOiI7Ozs7K0JBNkJzQkE7OztlQUFBQTs7Ozt3QkE3QmdDO3VCQUNoQzsrREFDTDtnRUFDQzttQ0FFOEI7UUFDekM7OENBQ3lEOzhCQUNyQzsyQkFVcEI7Z0NBQ3dCOzhCQUNGO0FBU3RCLGVBQWVBLGdCQUFnQixFQUFFQyxPQUFPLEVBQUVDLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxHQUFHLEVBQVU7SUFDN0UsTUFBTSxFQUFFQyxhQUFhLEVBQUVDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBR0w7SUFFdEMsTUFBTU0sWUFBWUQsS0FBSyxDQUFDRCxjQUFjO0lBRXRDLE1BQU1HLFdBQVdDLE9BQU9DLE9BQU8sQ0FBQ0osT0FBT0ssR0FBRyxDQUFDLENBQUMsQ0FBQ0MsVUFBVUMsU0FBUztRQUM1RCxJQUFJRCxTQUFTRSxRQUFRLENBQUMsVUFBVUYsYUFBYVAsZUFBZTtZQUN4RCxPQUFPUTtRQUNYLE9BQU87WUFDSCxPQUFPO1FBQ1g7SUFD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