#!node

const fs = require('fs');
const path = require('path');
const tsNode = require('ts-node');
const glob = require('glob');

tsNode.register();

const dir = process.argv[2];
if (!fs.readdirSync(dir)) {
    console.error("Can't find direction: " + dir);
    process.exit(1);
}

const packageJsonFile = fs.readFileSync(path.join(dir, 'package.json'));
if (!packageJsonFile) {
    console.error("Can't find package.json: " + dir);
    process.exit(1);
}

const packageContents = glob.sync('**/*', { cwd: dir, nodir: true });

const expectedVersion = JSON.parse(fs.readFileSync('./package.json').toString()).version;
const packageJson = JSON.parse(packageJsonFile.toString());

let exitStatus = 0;

async function check(type, field, filename) {
    if (!(typeof filename === 'string')) return;

    let success = true;
    if (type === 'types' && !filename.endsWith('.d.ts')) {
        console.warn(`[${packageJson.name}] ${filename}: Field '${field}' has reference to non '.d.ts' file.`);
        success = false;
    }

    if (type === 'cjs') {
        if (
            (!filename.endsWith('.cjs') && !filename.endsWith('.cjs.js') && !filename.endsWith('.js')) ||
            filename.includes('.esm')
        ) {
            console.warn(
                `[${packageJson.name}] ${filename}: Field '${field}' has reference to non CJS file: ${filename}`
            );
            success = false;
        }
    }

    if (type === 'esm' && !filename.endsWith('.esm.js') && !filename.endsWith('.mjs')) {
        console.warn(`[${packageJson.name}] ${filename}: Field '${field}' has reference to non ESM file: ${filename}`);
        success = false;
    }

    if (type === 'js' && !filename.endsWith('.js') && !filename.endsWith('.mjs') && !filename.endsWith('.cjs')) {
        console.warn(`[${packageJson.name}] ${filename}: Field '${field}' has reference to non JS file: ${filename}`);
        success = false;
    }

    let fileCount = 0;
    if (filename.indexOf('*') >= 0) {
        const matches = glob.sync(path.join(dir, filename));
        fileCount += matches.length;
        if (matches.length === 0) {
            console.warn(
                `[${packageJson.name}] ${filename}: Field '${field}' has invalid file reference glob: ${filename}`
            );
            success = false;
        }
    } else if (fs.existsSync(path.join(dir, filename))) {
        fileCount++;
    } else {
        console.warn(`[${packageJson.name}] ${filename}: Field '${field}' has invalid file reference: ${filename}`);
        success = false;
    }

    // try {
    //     if (type === 'esm') {
    //         const tmp = await import('../' + fullFilename);
    //     } else if (type === 'cjs') {
    //         require('../' + fullFilename);
    //     } else if (type === 'types') {
    //         const tmp = await import('../' + fullFilename);
    //     }
    // } catch (e) {
    //     console.warn(`[${packageJson.name}] ${filename} check failure`, e);
    //     success = false;
    // }

    if (success) {
        console.log(`[${packageJson.name}] ${filename} check success. [${fileCount} matches]`);
    } else {
        exitStatus = 1;
    }
}

function checkOneExists(...filenames) {
    if (!filenames.some((f) => fs.existsSync(path.join(dir, f)))) {
        console.log(`[${packageJson.name}]: Didn't find any files with name(s): ${filenames.join(' / ')}`);
        exitStatus = 1;
    }
}

const exportMap = {
    require: 'cjs',
    import: 'esm',
    default: 'js',
    types: 'types',
};

async function checkExports(exports) {
    for (const key in exports) {
        if (key === './package.json') {
            // Generated by Angular build tool
            await check('json', key, exports[key]);
            continue;
        }

        if (typeof exports[key] === 'object') {
            await checkExports(exports[key]);
            continue;
        }

        const type = exportMap[key] ?? 'unknown';
        await check(type, key, exports[key]);
    }
}

const allowedExtensions = ['.md', '.js', '.mjs', '.d.ts', '.txt', '.json'];
function checkAllowedExtension(filename) {
    if (!allowedExtensions.some((ext) => filename.endsWith(ext))) {
        console.log(`[${packageJson.name}]: Unexpected file extension: ${filename}`);
        exitStatus = 1;
    }
}

async function run() {
    if (packageJson.version !== expectedVersion) {
        console.log(
            `[${packageJson.name}]: Version field mismatch, expected [${expectedVersion}] but found [${packageJson.version}]`
        );
        exitStatus = 1;
    }

    for (const field of ['types', 'typing']) {
        const filename = packageJson[field];
        await check('types', field, filename);
    }
    for (const field of ['main']) {
        const filename = packageJson[field];
        await check('cjs', field, filename);
    }
    for (const field of ['module']) {
        const filename = packageJson[field];
        await check('esm', field, filename);
    }

    if (packageJson.exports != null) {
        await checkExports(packageJson.exports);
    }

    checkOneExists('README.md');
    checkOneExists('LICENSE.txt', 'LICENSE.html');

    for (const file of packageContents) {
        checkAllowedExtension(file);
    }

    if (exitStatus === 0) {
        console.log(`[${packageJson.name}]: No problems found with package in ${dir}`);
    }
}

run()
    .then(() => {
        process.exitStatus = exitStatus;
    })
    .catch((e) => {
        console.error(e);
        process.exit(1);
    });
