{"version":3,"sources":["webpack://ag-charts-vue3/webpack/universalModuleDefinition","webpack://ag-charts-vue3/webpack/bootstrap","webpack://ag-charts-vue3/external \"agCharts\"","webpack://ag-charts-vue3/external {\"commonjs\":\"vue\",\"commonjs2\":\"vue\",\"root\":\"Vue\"}","webpack://ag-charts-vue3/./node_modules/@vue/shared/dist/shared.esm-bundler.js","webpack://ag-charts-vue3/(webpack)/buildin/global.js","webpack://ag-charts-vue3/./node_modules/current-script-polyfill/currentScript.js","webpack://ag-charts-vue3/./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js","webpack://ag-charts-vue3/./node_modules/tslib/tslib.es6.js","webpack://ag-charts-vue3/./node_modules/vue-class-component/dist/vue-class-component.esm-bundler.js","webpack://ag-charts-vue3/./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","webpack://ag-charts-vue3/./src/AgChartsVue.ts"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__4d8b__","__WEBPACK_EXTERNAL_MODULE__8bbf__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","EMPTY_OBJ","NOOP","extend","assign","hasOwn","val","isArray","Array","isMap","toTypeString","isFunction","isString","isSymbol","isObject","objectToString","toString","toRawType","slice","isIntegerKey","parseInt","cacheStringFunction","fn","cache","str","hit","camelizeRE","hyphenateRE","replace","_","toUpperCase","hasChanged","toLowerCase","charAt","oldValue","def","obj","configurable","g","Function","e","window","document","currentScript","scripts","getElementsByTagName","Error","err","res","exec","stack","src","readyState","match","__decorate","decorators","target","desc","arguments","length","getOwnPropertyDescriptor","Reflect","decorate","_classCallCheck","instance","Constructor","TypeError","_defineProperties","props","descriptor","writable","_createClass","protoProps","staticProps","_defineProperty","ownKeys","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","push","apply","_objectSpread2","source","forEach","getOwnPropertyDescriptors","defineProperties","_inherits","subClass","superClass","constructor","_setPrototypeOf","_getPrototypeOf","setPrototypeOf","getPrototypeOf","__proto__","_isNativeReflectConstruct","construct","sham","Proxy","Date","_assertThisInitialized","ReferenceError","_possibleConstructorReturn","_createSuper","Derived","hasNativeReflectConstruct","result","Super","NewTarget","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","_arrayLikeToArray","iter","iterator","from","minLen","test","len","arr2","defineGetter","defineProxy","proxy","set","getSuper","Ctor","superProto","getOwn","undefined","VueImpl","ctx","_this","attrs","slots","emit","_this$__h","__h","Props","propsMeta","meta","PropsMixin","_this2","_super","__b","Vue","options","__c","__vccOpts","base","mixins","unshift","methods","computed","proto","getOwnPropertyNames","indexOf","setup","_promise","data","dataKeys","plainData","promise","__s","setupState","Promise","resolve","then","injections","Options","Component","__o","targetMap","WeakMap","activeEffect","ITERATE_KEY","MAP_KEY_ITERATE_KEY","shouldTrack","trackStack","pauseTracking","enableTracking","track","type","depsMap","Map","dep","Set","has","add","deps","trigger","newValue","oldTarget","effects","effectsToAdd","effect","allowRecurse","run","scheduler","builtInSymbols","map","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","isReadonly","shallow","receiver","readonlyMap","reactiveMap","targetIsArray","keyIsSymbol","isRef","shouldUnwrap","readonly","reactive","method","args","toRaw","createSetter","shallowSet","hadKey","Number","deleteProperty","mutableHandlers","readonlyHandlers","toReactive","toReadonly","toShallow","getProto","v","get$1","isShallow","rawTarget","rawKey","wrap","has$1","size","set$1","deleteEntry","delete","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","targetIsMap","isPair","isKeyOnly","innerIterator","done","next","createReadonlyMethod","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","iteratorMethods","createInstrumentationGetter","instrumentations","mutableCollectionHandlers","readonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","Boolean","__v_isRef","isCreated","isDestroyed","style","height","ref","applyContainerIfNotSet","chart","$watch","processChanges","deep","waitForUpdate","$emit","destroy","destroyed","currentValue","previousValue","update","propsOptions","container","$refs","agChartRef","emits"],"mappings":"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","file":"ag-charts-vue3.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"agCharts\"), require(\"vue\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"agCharts\", ], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ag-charts-vue3\"] = factory(require(\"agCharts\"), require(\"vue\"));\n\telse\n\t\troot[\"ag-charts-vue3\"] = factory(root[\"agCharts\"], root[\"Vue\"]);\n})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__4d8b__, __WEBPACK_EXTERNAL_MODULE__8bbf__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"fae3\");\n","module.exports = __WEBPACK_EXTERNAL_MODULE__4d8b__;","module.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;","/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\n// Patch flags are optimization hints generated by the compiler.\r\n// when a block with dynamicChildren is encountered during diff, the algorithm\r\n// enters \"optimized mode\". In this mode, we know that the vdom is produced by\r\n// a render function generated by the compiler, so the algorithm only needs to\r\n// handle updates explicitly marked by these patch flags.\r\n// dev only flag -> name mapping\r\nconst PatchFlagNames = {\r\n    [1 /* TEXT */]: `TEXT`,\r\n    [2 /* CLASS */]: `CLASS`,\r\n    [4 /* STYLE */]: `STYLE`,\r\n    [8 /* PROPS */]: `PROPS`,\r\n    [16 /* FULL_PROPS */]: `FULL_PROPS`,\r\n    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n    [512 /* NEED_PATCH */]: `NEED_PATCH`,\r\n    [-1 /* HOISTED */]: `HOISTED`,\r\n    [-2 /* BAIL */]: `BAIL`\r\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\r\nfunction generateCodeFrame(source, start = 0, end = source.length) {\r\n    const lines = source.split(/\\r?\\n/);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count += lines[i].length + 1;\r\n        if (count >= start) {\r\n            for (let j = i - range; j <= i + range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - lineLength) + 1;\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + 1;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`);\r\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\r\nconst attrValidationCache = {};\r\nfunction isSSRSafeAttrName(name) {\r\n    if (attrValidationCache.hasOwnProperty(name)) {\r\n        return attrValidationCache[name];\r\n    }\r\n    const isUnsafe = unsafeAttrCharRE.test(name);\r\n    if (isUnsafe) {\r\n        console.error(`unsafe attribute name: ${name}`);\r\n    }\r\n    return (attrValidationCache[name] = !isUnsafe);\r\n}\r\nconst propsToAttrMap = {\r\n    acceptCharset: 'accept-charset',\r\n    className: 'class',\r\n    htmlFor: 'for',\r\n    httpEquiv: 'http-equiv'\r\n};\r\n/**\r\n * CSS properties that accept plain numbers\r\n */\r\nconst isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +\r\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\r\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\r\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\r\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\r\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\r\n    // SVG\r\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width`);\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nconst isKnownAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`);\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction stringifyStyle(styles) {\r\n    let ret = '';\r\n    if (!styles) {\r\n        return ret;\r\n    }\r\n    for (const key in styles) {\r\n        const value = styles[key];\r\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\r\n        if (isString(value) ||\r\n            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {\r\n            // only render valid values\r\n            ret += `${normalizedKey}:${value};`;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            res += normalizeClass(value[i]) + ' ';\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot';\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n    'text,textPath,title,tspan,unknown,use,view';\r\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\r\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\r\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\nconst escapeRE = /[\"'&<>]/;\r\nfunction escapeHtml(string) {\r\n    const str = '' + string;\r\n    const match = escapeRE.exec(str);\r\n    if (!match) {\r\n        return str;\r\n    }\r\n    let html = '';\r\n    let escaped;\r\n    let index;\r\n    let lastIndex = 0;\r\n    for (index = match.index; index < str.length; index++) {\r\n        switch (str.charCodeAt(index)) {\r\n            case 34: // \"\r\n                escaped = '&quot;';\r\n                break;\r\n            case 38: // &\r\n                escaped = '&amp;';\r\n                break;\r\n            case 39: // '\r\n                escaped = '&#39;';\r\n                break;\r\n            case 60: // <\r\n                escaped = '&lt;';\r\n                break;\r\n            case 62: // >\r\n                escaped = '&gt;';\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        if (lastIndex !== index) {\r\n            html += str.substring(lastIndex, index);\r\n        }\r\n        lastIndex = index + 1;\r\n        html += escaped;\r\n    }\r\n    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\r\n}\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\r\nfunction escapeHtmlComment(src) {\r\n    return src.replace(commentStripRE, '');\r\n}\n\nfunction looseCompareArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    let equal = true;\r\n    for (let i = 0; equal && i < a.length; i++) {\r\n        equal = looseEqual(a[i], b[i]);\r\n    }\r\n    return equal;\r\n}\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    let aValidType = isDate(a);\r\n    let bValidType = isDate(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n    }\r\n    aValidType = isArray(a);\r\n    bValidType = isArray(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\r\n    }\r\n    aValidType = isObject(a);\r\n    bValidType = isObject(b);\r\n    if (aValidType || bValidType) {\r\n        /* istanbul ignore if: this if will probably never be called */\r\n        if (!aValidType || !bValidType) {\r\n            return false;\r\n        }\r\n        const aKeysCount = Object.keys(a).length;\r\n        const bKeysCount = Object.keys(b).length;\r\n        if (aKeysCount !== bKeysCount) {\r\n            return false;\r\n        }\r\n        for (const key in a) {\r\n            const aHasKey = a.hasOwnProperty(key);\r\n            const bHasKey = b.hasOwnProperty(key);\r\n            if ((aHasKey && !bHasKey) ||\r\n                (!aHasKey && bHasKey) ||\r\n                !looseEqual(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return String(a) === String(b);\r\n}\r\nfunction looseIndexOf(arr, val) {\r\n    return arr.findIndex(item => looseEqual(item, val));\r\n}\r\nfunction looseHas(set, val) {\r\n    for (let item of set) {\r\n        if (looseEqual(item, val))\r\n            return true;\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nconst toDisplayString = (val) => {\r\n    return val == null\r\n        ? ''\r\n        : isObject(val)\r\n            ? JSON.stringify(val, replacer, 2)\r\n            : String(val);\r\n};\r\nconst replacer = (_key, val) => {\r\n    if (isMap(val)) {\r\n        return {\r\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                entries[`${key} =>`] = val;\r\n                return entries;\r\n            }, {})\r\n        };\r\n    }\r\n    else if (isSet(val)) {\r\n        return {\r\n            [`Set(${val.size})`]: [...val.values()]\r\n        };\r\n    }\r\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\r\n        return String(val);\r\n    }\r\n    return val;\r\n};\n\n/**\r\n * List of @babel/parser plugins that are used for template expression\r\n * transforms and SFC script transforms. By default we enable proposals slated\r\n * for ES2020. This will need to be updated as the spec moves forward.\r\n * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins\r\n */\r\nconst babelParserDefaultPlugins = [\r\n    'bigInt',\r\n    'optionalChaining',\r\n    'nullishCoalescingOperator'\r\n];\r\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = [];\r\nconst NOOP = () => { };\r\n/**\r\n * Always return false.\r\n */\r\nconst NO = () => false;\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isDate = (val) => val instanceof Date;\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst isReservedProp = /*#__PURE__*/ makeMap('key,ref,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) => {\r\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\r\n});\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n});\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nconst invokeArrayFns = (fns, arg) => {\r\n    for (let i = 0; i < fns.length; i++) {\r\n        fns[i](arg);\r\n    }\r\n};\r\nconst def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\r\nconst toNumber = (val) => {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n};\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, babelParserDefaultPlugins, camelize, capitalize, def, escapeHtml, escapeHtmlComment, extend, generateCodeFrame, getGlobalThis, hasChanged, hasOwn, hyphenate, invokeArrayFns, isArray, isBooleanAttr, isDate, isFunction, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownAttr, isMap, isModelListener, isNoUnitNumericStyleProp, isObject, isOn, isPlainObject, isPromise, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseHas, looseIndexOf, makeMap, normalizeClass, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, stringifyStyle, toDisplayString, toNumber, toRawType, toTypeString };\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// document.currentScript polyfill by Adam Miller\n\n// MIT license\n\n(function(document){\n  var currentScript = \"currentScript\",\n      scripts = document.getElementsByTagName('script'); // Live NodeList collection\n\n  // If browser needs currentScript polyfill, add get currentScript() to the document object\n  if (!(currentScript in document)) {\n    Object.defineProperty(document, currentScript, {\n      get: function(){\n\n        // IE 6-10 supports script readyState\n        // IE 10+ support stack trace\n        try { throw new Error(); }\n        catch (err) {\n\n          // Find the second match for the \"at\" string to get file src url from stack.\n          // Specifically works with the format of stack traces in IE.\n          var i, res = ((/.*at [^\\(]*\\((.*):.+:.+\\)$/ig).exec(err.stack) || [false])[1];\n\n          // For all scripts on the page, if src matches or if ready state is interactive, return the script tag\n          for(i in scripts){\n            if(scripts[i].src == res || scripts[i].readyState == \"interactive\"){\n              return scripts[i];\n            }\n          }\n\n          // If no match, return null\n          return null;\n        }\n      }\n    });\n  }\n})(document);\n","// This file is imported into lib/wc client bundles.\n\nif (typeof window !== 'undefined') {\n  if (process.env.NEED_CURRENTSCRIPT_POLYFILL) {\n    require('current-script-polyfill')\n  }\n\n  var i\n  if ((i = window.document.currentScript) && (i = i.src.match(/(.+\\/)[^/]+\\.js(\\?.*)?$/))) {\n    __webpack_public_path__ = i[1] // eslint-disable-line\n  }\n}\n\n// Indicate to webpack that this file can be concatenated\nexport default null\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\n  * vue-class-component v8.0.0-rc.1\n  * (c) 2015-present Evan You\n  * @license MIT\n  */\nimport { ref, proxyRefs } from 'vue';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction defineGetter(obj, key, getter) {\n  Object.defineProperty(obj, key, {\n    get: getter,\n    enumerable: false,\n    configurable: true\n  });\n}\n\nfunction defineProxy(proxy, key, target) {\n  Object.defineProperty(proxy, key, {\n    get: function get() {\n      return target[key].value;\n    },\n    set: function set(value) {\n      target[key].value = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n}\n\nfunction getSuper(Ctor) {\n  var superProto = Object.getPrototypeOf(Ctor.prototype);\n\n  if (!superProto) {\n    return undefined;\n  }\n\n  return superProto.constructor;\n}\n\nfunction getOwn(value, key) {\n  return value.hasOwnProperty(key) ? value[key] : undefined;\n}\n\nvar VueImpl = /*#__PURE__*/function () {\n  function VueImpl(props, ctx) {\n    var _this = this;\n\n    _classCallCheck(this, VueImpl);\n\n    defineGetter(this, '$props', function () {\n      return props;\n    });\n    defineGetter(this, '$attrs', function () {\n      return ctx.attrs;\n    });\n    defineGetter(this, '$slots', function () {\n      return ctx.slots;\n    });\n    defineGetter(this, '$emit', function () {\n      return ctx.emit;\n    });\n    Object.keys(props).forEach(function (key) {\n      Object.defineProperty(_this, key, {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: props[key]\n      });\n    });\n  }\n\n  _createClass(VueImpl, null, [{\n    key: \"registerHooks\",\n    value: function registerHooks(keys) {\n      var _this$__h;\n\n      (_this$__h = this.__h).push.apply(_this$__h, _toConsumableArray(keys));\n    }\n  }, {\n    key: \"with\",\n    value: function _with(Props) {\n      var propsMeta = new Props();\n      var props = {};\n      Object.keys(propsMeta).forEach(function (key) {\n        var meta = propsMeta[key];\n        props[key] = meta !== null && meta !== void 0 ? meta : null;\n      });\n\n      var PropsMixin = /*#__PURE__*/function (_this2) {\n        _inherits(PropsMixin, _this2);\n\n        var _super = _createSuper(PropsMixin);\n\n        function PropsMixin() {\n          _classCallCheck(this, PropsMixin);\n\n          return _super.apply(this, arguments);\n        }\n\n        return PropsMixin;\n      }(this);\n\n      PropsMixin.__b = {\n        props: props\n      };\n      return PropsMixin;\n    }\n  }, {\n    key: \"__vccOpts\",\n    get: function get() {\n      // Early return if `this` is base class as it does not have any options\n      if (this === Vue) {\n        return {};\n      }\n\n      var Ctor = this;\n      var cache = getOwn(Ctor, '__c');\n\n      if (cache) {\n        return cache;\n      } // If the options are provided via decorator use it as a base\n\n\n      var options = _objectSpread2({}, getOwn(Ctor, '__o'));\n\n      Ctor.__c = options; // Handle super class options\n\n      var Super = getSuper(Ctor);\n\n      if (Super) {\n        options[\"extends\"] = Super.__vccOpts;\n      } // Inject base options as a mixin\n\n\n      var base = getOwn(Ctor, '__b');\n\n      if (base) {\n        options.mixins = options.mixins || [];\n        options.mixins.unshift(base);\n      }\n\n      options.methods = _objectSpread2({}, options.methods);\n      options.computed = _objectSpread2({}, options.computed);\n      var proto = Ctor.prototype;\n      Object.getOwnPropertyNames(proto).forEach(function (key) {\n        if (key === 'constructor') {\n          return;\n        } // hooks\n\n\n        if (Ctor.__h.indexOf(key) > -1) {\n          options[key] = proto[key];\n          return;\n        }\n\n        var descriptor = Object.getOwnPropertyDescriptor(proto, key); // methods\n\n        if (typeof descriptor.value === 'function') {\n          options.methods[key] = descriptor.value;\n          return;\n        } // computed properties\n\n\n        if (descriptor.get || descriptor.set) {\n          options.computed[key] = {\n            get: descriptor.get,\n            set: descriptor.set\n          };\n          return;\n        }\n      });\n\n      options.setup = function (props, ctx) {\n        var _promise;\n\n        var data = new Ctor(props, ctx);\n        var dataKeys = Object.keys(data);\n        var plainData = {};\n        var promise = null; // Initialize reactive data and convert constructor `this` to a proxy\n\n        dataKeys.forEach(function (key) {\n          // Skip if the value is undefined not to make it reactive.\n          // If the value has `__s`, it's a value from `setup` helper, proceed it later.\n          if (data[key] === undefined || data[key] && data[key].__s) {\n            return;\n          }\n\n          plainData[key] = ref(data[key]);\n          defineProxy(data, key, plainData);\n        }); // Invoke composition functions\n\n        dataKeys.forEach(function (key) {\n          if (data[key] && data[key].__s) {\n            var setupState = data[key].__s();\n\n            if (setupState instanceof Promise) {\n              if (!promise) {\n                promise = Promise.resolve(plainData);\n              }\n\n              promise = promise.then(function () {\n                return setupState.then(function (value) {\n                  plainData[key] = proxyRefs(value);\n                  return plainData;\n                });\n              });\n            } else {\n              plainData[key] = proxyRefs(setupState);\n            }\n          }\n        });\n        return (_promise = promise) !== null && _promise !== void 0 ? _promise : plainData;\n      };\n\n      var decorators = getOwn(Ctor, '__d');\n\n      if (decorators) {\n        decorators.forEach(function (fn) {\n          return fn(options);\n        });\n      } // from Vue Loader\n\n\n      var injections = ['render', 'ssrRender', '__file', '__cssModules', '__scopeId', '__hmrId'];\n      injections.forEach(function (key) {\n        if (Ctor[key]) {\n          options[key] = Ctor[key];\n        }\n      });\n      return options;\n    }\n  }]);\n\n  return VueImpl;\n}();\n\nVueImpl.__h = ['data', 'beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUnmount', 'unmounted', 'beforeUpdate', 'updated', 'activated', 'deactivated', 'render', 'errorCaptured', 'serverPrefetch'];\nvar Vue = VueImpl;\n\nfunction Options(options) {\n  return function (Component) {\n    Component.__o = options;\n    return Component;\n  };\n}\nfunction createDecorator(factory) {\n  return function (target, key, index) {\n    var Ctor = typeof target === 'function' ? target : target.constructor;\n\n    if (!Ctor.__d) {\n      Ctor.__d = [];\n    }\n\n    if (typeof index !== 'number') {\n      index = undefined;\n    }\n\n    Ctor.__d.push(function (options) {\n      return factory(options, key, index);\n    });\n  };\n}\nfunction mixins() {\n  for (var _len = arguments.length, Ctors = new Array(_len), _key = 0; _key < _len; _key++) {\n    Ctors[_key] = arguments[_key];\n  }\n\n  var _a;\n\n  return _a = /*#__PURE__*/function (_Vue) {\n    _inherits(MixedVue, _Vue);\n\n    var _super = _createSuper(MixedVue);\n\n    function MixedVue() {\n      var _this;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _classCallCheck(this, MixedVue);\n\n      _this = _super.call.apply(_super, [this].concat(args));\n      Ctors.forEach(function (Ctor) {\n        var data = _construct(Ctor, args);\n\n        Object.keys(data).forEach(function (key) {\n          _this[key] = data[key];\n        });\n      });\n      return _this;\n    }\n\n    return MixedVue;\n  }(Vue), _a.__b = {\n    mixins: Ctors.map(function (Ctor) {\n      return Ctor.__vccOpts;\n    })\n  }, _a;\n}\nfunction setup(setupFn) {\n  // Hack to delay the invocation of setup function.\n  // Will be called after dealing with class properties.\n  return {\n    __s: setupFn\n  };\n}\n\n// Actual implementation\nfunction prop(options) {\n  return options;\n}\n\nexport { Options, Vue, createDecorator, mixins, prop, setup };\n","import { EMPTY_OBJ, isArray, isMap, isIntegerKey, isSymbol, extend, hasOwn, isObject, hasChanged, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.options.onTrack) {\r\n            activeEffect.options.onTrack({\r\n                effect: activeEffect,\r\n                target,\r\n                type,\r\n                key\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.options.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if ((process.env.NODE_ENV !== 'production') && effect.options.onTrigger) {\r\n            effect.options.onTrigger({\r\n                effect,\r\n                target,\r\n                key,\r\n                type,\r\n                newValue,\r\n                oldValue,\r\n                oldTarget\r\n            });\r\n        }\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, \"get\" /* GET */, i + '');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn't work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        enableTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        const keyIsSymbol = isSymbol(key);\r\n        if (keyIsSymbol\r\n            ? builtInSymbols.has(key)\r\n            : key === `__proto__` || key === `__v_isRef`) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    const result = target.add(value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return result;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    const result = target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? `as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\r\n}\r\n// Return a reactive-copy of the original object, where only the root level\r\n// properties are reactive, and does NOT unwrap refs nor recursively convert\r\n// returned properties.\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers);\r\n}\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);\r\n}\r\n// Return a reactive-copy of the original object, where only the root level\r\n// properties are readonly, and does NOT unwrap refs nor recursively convert\r\n// returned properties.\r\n// This is used for creating the props proxy object for stateful components.\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction markRaw(value) {\r\n    def(value, \"__v_skip\" /* SKIP */, true);\r\n    return value;\r\n}\n\nconst convert = (val) => isObject(val) ? reactive(val) : val;\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\r\nfunction ref(value) {\r\n    return createRef(value);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nclass RefImpl {\r\n    constructor(_rawValue, _shallow = false) {\r\n        this._rawValue = _rawValue;\r\n        this._shallow = _shallow;\r\n        this.__v_isRef = true;\r\n        this._value = _shallow ? _rawValue : convert(_rawValue);\r\n    }\r\n    get value() {\r\n        track(toRaw(this), \"get\" /* GET */, 'value');\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        if (hasChanged(toRaw(newVal), this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this._shallow ? newVal : convert(newVal);\r\n            trigger(toRaw(this), \"set\" /* SET */, 'value', newVal);\r\n        }\r\n    }\r\n}\r\nfunction createRef(rawValue, shallow = false) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new RefImpl(rawValue, shallow);\r\n}\r\nfunction triggerRef(ref) {\r\n    trigger(ref, \"set\" /* SET */, 'value', (process.env.NODE_ENV !== 'production') ? ref.value : void 0);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => track(this, \"get\" /* GET */, 'value'), () => trigger(this, \"set\" /* SET */, 'value'));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if ((process.env.NODE_ENV !== 'production') && !isProxy(object)) {\r\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\r\n    }\r\n    const ret = isArray(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        return this._object[this._key];\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key) {\r\n    return isRef(object[key])\r\n        ? object[key]\r\n        : new ObjectRefImpl(object, key);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly) {\r\n        this._setter = _setter;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this.effect = effect(getter, {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                if (!this._dirty) {\r\n                    this._dirty = true;\r\n                    trigger(toRaw(this), \"set\" /* SET */, 'value');\r\n                }\r\n            }\r\n        });\r\n        this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        if (this._dirty) {\r\n            this._value = this.effect();\r\n            this._dirty = false;\r\n        }\r\n        track(toRaw(this), \"get\" /* GET */, 'value');\r\n        return this._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction computed(getterOrOptions) {\r\n    let getter;\r\n    let setter;\r\n    if (isFunction(getterOrOptions)) {\r\n        getter = getterOrOptions;\r\n        setter = (process.env.NODE_ENV !== 'production')\r\n            ? () => {\r\n                console.warn('Write operation failed: computed value is readonly');\r\n            }\r\n            : NOOP;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set);\r\n}\n\nexport { ITERATE_KEY, computed, customRef, effect, enableTracking, isProxy, isReactive, isReadonly, isRef, markRaw, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };\n","import {h} from 'vue';\nimport {Options, Vue} from 'vue-class-component';\nimport {AgChart, AgChartOptions, AgChartInstance} from 'ag-charts-community';\nimport {toRaw} from '@vue/reactivity';\n\n@Options({\n    props: {\n        options: {},\n    },\n    emits: ['onChartReady'],\n    // watch: {\n    //     options: {\n    //         handler(currentValue, previousValue) {\n    //             this.processChanges( currentValue, previousValue);\n    //         },\n    //         deep: true,\n    //     },\n    // },\n})\nexport class AgChartsVue extends Vue {\n    public chart?: AgChartInstance;\n\n    private isCreated = false;\n    private isDestroyed = false;\n\n    private options!: AgChartOptions;\n\n    // noinspection JSUnusedGlobalSymbols, JSMethodCanBeStatic\n    public render() {\n        return h('div', {style: {height: '100%'}, ref: 'agChartRef'});\n    }\n\n    public mounted() {\n        const options = this.applyContainerIfNotSet(this.options);\n\n        this.chart = AgChart.create(options);\n\n        this.$watch('options', (newValue: any, oldValue: any) => {\n            this.processChanges(newValue, oldValue);\n        }, {\n            deep: true,\n        });\n\n        this.isCreated = true;\n\n        (this.chart as any).chart.waitForUpdate()\n            .then(() => this.$emit('onChartReady', this.chart!));\n    }\n\n    public destroyed() {\n        if (this.isCreated) {\n            if (this.chart) {\n                this.chart.destroy();\n            }\n\n            this.isDestroyed = true;\n        }\n    }\n\n    public unmounted() {\n        this.destroyed();\n    }\n\n    public processChanges(currentValue: any, previousValue: any) {\n        if (this.isCreated && this.chart) {\n            AgChart.update(this.chart, toRaw(this.applyContainerIfNotSet(toRaw(this.options))));\n        }\n    }\n\n    private applyContainerIfNotSet(propsOptions: AgChartOptions): AgChartOptions {\n        if (propsOptions.container) {\n            return propsOptions;\n        }\n\n        return {...propsOptions, container: this.$refs.agChartRef as HTMLElement};\n    }\n}\n"],"sourceRoot":""}