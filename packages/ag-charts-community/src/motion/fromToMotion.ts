import type { ProcessedOutputDiff } from '../chart/data/dataModel';
import type { AnimationManager } from '../chart/interaction/animationManager';
import type { Node } from '../scene/node';
import type { Selection } from '../scene/selection';
import { zipObject } from '../util/zip';
import { ADD_PHASE, INITIAL_LOAD, REMOVE_PHASE, UPDATE_PHASE, isNodeArray } from './animation';
import type { AnimationTiming, AnimationValue } from './animation';
import * as easing from './easing';

export type NodeUpdateState = 'unknown' | 'added' | 'removed' | 'updated';

export type FromToMotionPropFnContext<T> = {
    last: boolean;
    lastLive: boolean;
    prev?: T;
    prevFromProps?: Partial<T>;
    next?: T;
    prevLive?: T;
    nextLive?: T;
};
type ExtraOpts = { animationDelay?: number; animationDuration?: number };
export type FromToMotionPropFn<N extends Node, T extends Record<string, string | number> & Partial<N>, D> = (
    node: N,
    datum: D,
    state: NodeUpdateState,
    ctx: FromToMotionPropFnContext<N>
) => T & ExtraOpts;
type IntermediateFn<N extends Node, D> = (
    node: N,
    datum: D,
    state: NodeUpdateState,
    ctx: FromToMotionPropFnContext<N>
) => Partial<N>;

export const FROM_TO_MIXINS: Record<NodeUpdateState, AnimationTiming> = {
    added: ADD_PHASE,
    updated: UPDATE_PHASE,
    removed: REMOVE_PHASE,
    unknown: INITIAL_LOAD,
};

export type FromToDiff = Pick<ProcessedOutputDiff, 'added' | 'removed'>;

/**
 * Implements a per-node "to/from" animation, with support for detection of added/moved/removed
 * nodes.
 *
 * @param id prefix for all animation ids generated by this call
 * @param animationManager used to schedule generated animations
 * @param selections contains nodes to be animated
 * @param fromFn callback to determine per-node starting properties
 * @param toFn callback to determine per-node final properties
 * @param extraOpts optional additional animation properties to pass to AnimationManager#animate.
 * @param getDatumId optional per-datum 'id' generation function for diff calculation - must be
 *                   specified iff diff is specified
 * @param diff optional diff from a DataModel to use to detect added/moved/removed cases
 */
export function fromToMotion<N extends Node, T extends Record<string, string | number> & Partial<N>, D>(
    id: string,
    animationManager: AnimationManager,
    selections: Selection<N, D>[],
    fns: {
        fromFn: FromToMotionPropFn<N, T, D>;
        toFn: FromToMotionPropFn<N, T, D>;
        intermediateFn?: IntermediateFn<N, D>;
    },
    getDatumId?: (node: N, datum: D) => string,
    diff?: FromToDiff
) {
    const { defaultDuration } = animationManager;
    const { fromFn, toFn, intermediateFn } = fns;

    // Dynamic case with varying add/update/remove behavior.
    const ids = { added: {}, removed: {} };
    if (getDatumId && diff) {
        ids.added = zipObject(diff.added, true);
        ids.removed = zipObject(diff.removed, true);
    }

    let selectionIndex = 0;
    for (const selection of selections) {
        let cleanup = false;
        let prevFromProps: T | undefined;

        let nodeIndex = 0;
        const nodes = selection.nodes();
        let liveNodeIndex = 0;
        const liveNodes = nodes.filter((n) => !selection.isGarbage(n));
        for (const node of nodes) {
            const isLive = liveNodes[liveNodeIndex] === node;
            const ctx: FromToMotionPropFnContext<N> = {
                last: nodeIndex >= nodes.length - 1,
                lastLive: liveNodeIndex >= liveNodes.length - 1,
                prev: nodes[nodeIndex - 1],
                prevFromProps,
                prevLive: liveNodes[liveNodeIndex - 1],
                next: nodes[nodeIndex + 1],
                nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)],
            };

            let status: NodeUpdateState = 'unknown';
            if (!isLive) {
                status = 'removed';
            } else if (getDatumId && diff) {
                status = calculateStatus(node, node.datum, getDatumId, ids);
            }

            cleanup ||= status === 'removed';

            const {
                animationDelay: delay,
                animationDuration: duration,
                ...from
            } = fromFn(node, node.datum, status, ctx);
            const {
                animationDelay: toDelay,
                animationDuration: toDuration,
                ...to
            } = toFn(node, node.datum, status, ctx);

            animationManager.animate({
                id: `${id}_${node.id}`,
                from: from as T,
                to: to as T,
                ease: easing.easeOut,
                onUpdate(props) {
                    node.setProperties(props);
                    if (intermediateFn) {
                        node.setProperties(intermediateFn(node, node.datum, status, ctx));
                    }
                },
                onStop() {
                    node.setProperties(to as T);
                },
                duration: (duration ?? toDuration ?? 1) * defaultDuration,
                delay: (delay ?? toDelay ?? 0) * defaultDuration,
            });

            if (isLive) {
                liveNodeIndex++;
            }
            nodeIndex++;
            prevFromProps = from as T;
        }

        // Only perform selection cleanup once.
        if (cleanup) {
            animationManager.animate({
                id: `${id}_selection_${selectionIndex}`,
                from: 0,
                to: 1,
                ease: easing.easeOut,
                onComplete() {
                    selection.cleanup();
                },
            });
        }
        selectionIndex++;
    }
}

/**
 * Implements a batch "to/from" animation.
 *
 * @param id prefix for all animation ids generated by this call
 * @param animationManager used to schedule generated animations
 * @param selectionsOrNodes contains nodes to be animated
 * @param from node starting properties
 * @param to node final properties
 * @param extraOpts optional additional animation properties to pass to AnimationManager#animate.
 */
export function staticFromToMotion<N extends Node, T extends AnimationValue & Partial<N>, D>(
    id: string,
    animationManager: AnimationManager,
    selectionsOrNodes: Selection<N, D>[] | N[],
    from: T,
    to: T,
    extraOpts: ExtraOpts = {}
) {
    const isNodes = isNodeArray(selectionsOrNodes);
    const nodes = isNodes ? selectionsOrNodes : [];
    const selections = !isNodes ? selectionsOrNodes : [];
    const { animationDelay = 0, animationDuration = 1 } = extraOpts;
    const { defaultDuration } = animationManager;

    // Simple static to/from case, we can batch updates.
    animationManager.animate({
        id: `${id}_batch`,
        from,
        to,
        ease: easing.easeOut,
        onUpdate(props) {
            for (const node of nodes) {
                node.setProperties(props);
            }
            for (const selection of selections) {
                for (const node of selection.nodes()) {
                    node.setProperties(props);
                }
            }
        },
        onStop() {
            for (const node of nodes) {
                node.setProperties(to);
            }
            for (const selection of selections) {
                for (const node of selection.nodes()) {
                    node.setProperties(to);
                }
            }
        },
        duration: animationDuration * defaultDuration,
        delay: animationDelay * defaultDuration,
    });
}

function calculateStatus<N extends Node, D>(
    node: N,
    datum: D,
    getDatumId: (node: N, datum: D) => string,
    ids: {
        added: Record<string, true>;
        removed: Record<string, true>;
    }
): NodeUpdateState {
    const id = getDatumId(node, datum);

    if (ids.added[id]) {
        return 'added';
    } else if (ids.removed[id]) {
        return 'removed';
    }

    return 'updated';
}
