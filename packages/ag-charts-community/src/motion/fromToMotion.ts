import type { ProcessedOutputDiff } from '../chart/data/processors';
import type { AnimationManager } from '../chart/interaction/animationManager';
import type { Selection } from '../scene/selection';
import type { Shape } from '../scene/shape/shape';
import { zipObject } from '../util/zip';
import type { AdditionalAnimationOptions, AnimationOptions, AnimationValue } from './animation';
import * as easing from './easing';

export type NodeUpdateState = 'added' | 'removed' | 'updated' | 'moved';

/**
 * Implements a per-node "to/from" animation, with support for detection of added/moved/removed
 * nodes.
 *
 * @param id prefix for all animation ids generated by this call
 * @param animationManager used to schedule generated animations
 * @param selections contains nodes to be animated
 * @param fromFn callback to determine per-node starting properties
 * @param toFn callback to determine per-node final properties
 * @param extraOpts optional additional animation properties to pass to AnimationManager#animate.
 * @param idFn optional per-datum 'id' generation function for diff calculation - must be specified
 *             iff diff is specified
 * @param diff optional diff from a DataModel to use to detect added/moved/removed cases
 */
export function fromToMotion<N extends Shape, T extends AnimationValue & Partial<N>, D>(
    id: string,
    animationManager: AnimationManager,
    selections: Selection<N, D>[],
    fromFn: (node: N, datum: D, state: NodeUpdateState) => T,
    toFn: (node: N, datum: D, state: NodeUpdateState) => T,
    extraOpts: Partial<AnimationOptions<T> & AdditionalAnimationOptions> = {},
    idFn?: (node: N, datum: D) => string,
    diff?: ProcessedOutputDiff
) {
    // Dynamic case with varying add/update/remove behavior.
    const ids = { added: {}, removed: {} };
    if (idFn && diff) {
        ids.added = zipObject(diff.added, true);
        ids.removed = zipObject(diff.removed, true);
    }

    let selectionIndex = 0;
    for (const selection of selections) {
        let cleanup = false;

        for (const node of selection.nodes()) {
            let status: NodeUpdateState = 'added';
            if (idFn && diff) {
                status = calculateStatus(node, node.datum, idFn, ids);
            }

            cleanup ||= status === 'removed';

            const from = typeof fromFn === 'function' ? fromFn(node, node.datum, status) : fromFn;
            const to = typeof toFn === 'function' ? toFn(node, node.datum, status) : toFn;

            animationManager.animate({
                id: `${id}_${node.id}`,
                from: from,
                to: to,
                ease: easing.easeOut,
                onUpdate(props) {
                    node.setProperties(props);
                },
                ...extraOpts,
            });
        }

        // Only perform selection cleanup once.
        if (cleanup) {
            animationManager.animate({
                id: `${id}_selection_${selectionIndex}`,
                from: 0 as T,
                to: 1 as T,
                ease: easing.easeOut,
                onComplete() {
                    selection.cleanup();
                },
                ...extraOpts,
            });
        }
        selectionIndex++;
    }
}

/**
 * Implements a batch "to/from" animation.
 *
 * @param id prefix for all animation ids generated by this call
 * @param animationManager used to schedule generated animations
 * @param selections contains nodes to be animated
 * @param from node starting properties
 * @param to node final properties
 * @param extraOpts optional additional animation properties to pass to AnimationManager#animate.
 */
export function staticFromToMotion<N extends Shape, T extends AnimationValue & Partial<N>, D>(
    id: string,
    animationManager: AnimationManager,
    selections: Selection<N, D>[],
    from: T,
    to: T,
    extraOpts: Partial<AnimationOptions<T> & AdditionalAnimationOptions> = {}
) {
    // Simple static to/from case, we can batch updates.
    animationManager.animate({
        id: `${id}_batch`,
        from,
        to,
        ease: easing.easeOut,
        onUpdate(props) {
            for (const selection of selections) {
                for (const node of selection.nodes()) {
                    node.setProperties(props);
                }
            }
        },
        ...extraOpts,
    });
}

function calculateStatus<N extends Shape, D>(
    node: N,
    datum: D,
    idFn: (node: N, datum: D) => string,
    ids: {
        added: Record<string, true>;
        removed: Record<string, true>;
    }
): NodeUpdateState {
    const id = idFn(node, datum);

    if (ids.added[id]) {
        return 'added';
    } else if (ids.removed[id]) {
        return 'removed';
    }

    return 'updated';
}
