import type { AstroUserConfig } from 'astro';

import { urlWithBaseUrl } from '../urlWithBaseUrl';
import { SITE_301_REDIRECTS, type SimpleRedirectRule } from './redirects';

export function getHtaccessContent() {
    return `### AUTOGENERATED DO NOT EDIT
ErrorDocument 404 /404.html

# add MIME types for serving example files
AddType text/javascript ts jsx

${getRedirectRules()}

# CORS settings
Header add Access-Control-Allow-Origin "*"
Header add Access-Control-Allow-Methods: "GET,POST,OPTIONS,DELETE,PUT"

Options -Indexes
`;
}

export function getRedirectRules() {
    return `${SITE_301_REDIRECTS.map((redirect) => {
        const { from, fromPattern, to } = redirect as any;
        if (!to) {
            // eslint-disable-next-line no-console
            console.warn('Missing `to` in redirect', redirect);
            return;
        } else if (!from && !fromPattern) {
            // eslint-disable-next-line no-console
            console.warn('Missing `from` in redirect', redirect);
            return;
        }
        return from
            ? `Redirect 301 ${urlWithBaseUrl(from)} ${urlWithBaseUrl(to)}`
            : // NOTE: Redirect matches might not have the base url
              `RedirectMatch 301 "${fromPattern}" "${urlWithBaseUrl(to)}"`;
    })
        .filter(Boolean)
        .join('\n')}`;
}

export function getAstroRedirectRules(): AstroUserConfig['redirects'] {
    // Only for simple redirects, not pattern matches
    const simpleRedirects = SITE_301_REDIRECTS.filter((redirect) =>
        Boolean((redirect as SimpleRedirectRule).from)
    ) as SimpleRedirectRule[];

    return Object.fromEntries(
        simpleRedirects.map(({ from, to }) => {
            // NOTE: Don't need to add base to the `from` side, as Astro handles that
            return [from, urlWithBaseUrl(to)];
        })
    );
}
