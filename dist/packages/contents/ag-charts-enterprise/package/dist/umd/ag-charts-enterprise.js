(function (g, f) {
    if ("object" == typeof exports && "object" == typeof module) {
      module.exports = f();
    } else if ("function" == typeof define && define.amd) {
      define("agCharts", [], f);
    } else if ("object" == typeof exports) {
      exports["agCharts"] = f();
    } else {
      g["agCharts"] = f();
    }
  }(this, () => {
var exports = {};
var module = { exports };
if (typeof require === 'undefined') {
    function require(name) {
        
        throw new Error('Unknown module: ' + name);
    }
}
        
"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __knownSymbol = (name, symbol) => {
  return (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
};
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")];
  var isAwait = false;
  var method;
  var it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw")
          throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object))
            throw TypeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};

// packages/ag-charts-community/src/options/chart/axisOptions.ts
var init_axisOptions = __esm({
  "packages/ag-charts-community/src/options/chart/axisOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/chart/crosshairOptions.ts
var init_crosshairOptions = __esm({
  "packages/ag-charts-community/src/options/chart/crosshairOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/chart/chartOptions.ts
var init_chartOptions = __esm({
  "packages/ag-charts-community/src/options/chart/chartOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/chart/chartBuilderOptions.ts
var init_chartBuilderOptions = __esm({
  "packages/ag-charts-community/src/options/chart/chartBuilderOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/chart/crossLineOptions.ts
var init_crossLineOptions = __esm({
  "packages/ag-charts-community/src/options/chart/crossLineOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/chart/dropShadowOptions.ts
var init_dropShadowOptions = __esm({
  "packages/ag-charts-community/src/options/chart/dropShadowOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/chart/errorBarOptions.ts
var AgErrorBarSupportedSeriesTypes;
var init_errorBarOptions = __esm({
  "packages/ag-charts-community/src/options/chart/errorBarOptions.ts"() {
    "use strict";
    AgErrorBarSupportedSeriesTypes = ["bar", "line", "scatter"];
  }
});

// packages/ag-charts-community/src/options/chart/eventOptions.ts
var init_eventOptions = __esm({
  "packages/ag-charts-community/src/options/chart/eventOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/chart/gradientLegendOptions.ts
var init_gradientLegendOptions = __esm({
  "packages/ag-charts-community/src/options/chart/gradientLegendOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/chart/labelOptions.ts
var init_labelOptions = __esm({
  "packages/ag-charts-community/src/options/chart/labelOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/chart/legendOptions.ts
var init_legendOptions = __esm({
  "packages/ag-charts-community/src/options/chart/legendOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/chart/navigatorOptions.ts
var __MINI_CHART_SERIES_OPTIONS, __VERIFY_MINI_CHART_SERIES_OPTIONS;
var init_navigatorOptions = __esm({
  "packages/ag-charts-community/src/options/chart/navigatorOptions.ts"() {
    "use strict";
    __MINI_CHART_SERIES_OPTIONS = {};
    __VERIFY_MINI_CHART_SERIES_OPTIONS = void 0;
    __VERIFY_MINI_CHART_SERIES_OPTIONS = __MINI_CHART_SERIES_OPTIONS;
  }
});

// packages/ag-charts-community/src/options/chart/polarAxisOptions.ts
var init_polarAxisOptions = __esm({
  "packages/ag-charts-community/src/options/chart/polarAxisOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/chart/toolbarOptions.ts
var init_toolbarOptions = __esm({
  "packages/ag-charts-community/src/options/chart/toolbarOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/chart/tooltipOptions.ts
var AgTooltipPositionType;
var init_tooltipOptions = __esm({
  "packages/ag-charts-community/src/options/chart/tooltipOptions.ts"() {
    "use strict";
    AgTooltipPositionType = /* @__PURE__ */ ((AgTooltipPositionType2) => {
      AgTooltipPositionType2["POINTER"] = "pointer";
      AgTooltipPositionType2["NODE"] = "node";
      AgTooltipPositionType2["TOP"] = "top";
      AgTooltipPositionType2["RIGHT"] = "right";
      AgTooltipPositionType2["BOTTOM"] = "bottom";
      AgTooltipPositionType2["LEFT"] = "left";
      AgTooltipPositionType2["TOP_LEFT"] = "top-left";
      AgTooltipPositionType2["TOP_RIGHT"] = "top-right";
      AgTooltipPositionType2["BOTTOM_RIGHT"] = "bottom-right";
      AgTooltipPositionType2["BOTTOM_LEFT"] = "bottom-left";
      return AgTooltipPositionType2;
    })(AgTooltipPositionType || {});
  }
});

// packages/ag-charts-community/src/options/chart/themeOptions.ts
var __THEME_OVERRIDES, __VERIFY_THEME_OVERRIDES;
var init_themeOptions = __esm({
  "packages/ag-charts-community/src/options/chart/themeOptions.ts"() {
    "use strict";
    __THEME_OVERRIDES = {};
    __VERIFY_THEME_OVERRIDES = void 0;
    __VERIFY_THEME_OVERRIDES = __THEME_OVERRIDES;
  }
});

// packages/ag-charts-community/src/options/chart/types.ts
var init_types = __esm({
  "packages/ag-charts-community/src/options/chart/types.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/chart/zoomOptions.ts
var init_zoomOptions = __esm({
  "packages/ag-charts-community/src/options/chart/zoomOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/seriesOptions.ts
var init_seriesOptions = __esm({
  "packages/ag-charts-community/src/options/series/seriesOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/cartesianOptions.ts
var init_cartesianOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/cartesianOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/cartesianSeriesTooltipOptions.ts
var init_cartesianSeriesTooltipOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/cartesianSeriesTooltipOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/cartesianSeriesTypes.ts
var init_cartesianSeriesTypes = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/cartesianSeriesTypes.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/areaOptions.ts
var init_areaOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/areaOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/barOptions.ts
var init_barOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/barOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/boxPlotOptions.ts
var init_boxPlotOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/boxPlotOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/candlestickBaseOptions.ts
var init_candlestickBaseOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/candlestickBaseOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/candlestickOptions.ts
var init_candlestickOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/candlestickOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/ohlcOptions.ts
var init_ohlcOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/ohlcOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/bubbleOptions.ts
var init_bubbleOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/bubbleOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/bulletOptions.ts
var init_bulletOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/bulletOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/commonOptions.ts
var init_commonOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/commonOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/lineOptions.ts
var init_lineOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/lineOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/heatmapOptions.ts
var init_heatmapOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/heatmapOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/histogramOptions.ts
var init_histogramOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/histogramOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/rangeBarOptions.ts
var init_rangeBarOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/rangeBarOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/rangeAreaOptions.ts
var init_rangeAreaOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/rangeAreaOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/scatterOptions.ts
var init_scatterOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/scatterOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/cartesian/waterfallOptions.ts
var init_waterfallOptions = __esm({
  "packages/ag-charts-community/src/options/series/cartesian/waterfallOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/hierarchy/hierarchyOptions.ts
var init_hierarchyOptions = __esm({
  "packages/ag-charts-community/src/options/series/hierarchy/hierarchyOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/hierarchy/sunburstOptions.ts
var init_sunburstOptions = __esm({
  "packages/ag-charts-community/src/options/series/hierarchy/sunburstOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/hierarchy/treemapOptions.ts
var init_treemapOptions = __esm({
  "packages/ag-charts-community/src/options/series/hierarchy/treemapOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/polar/nightingaleOptions.ts
var init_nightingaleOptions = __esm({
  "packages/ag-charts-community/src/options/series/polar/nightingaleOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/polar/donutOptions.ts
var init_donutOptions = __esm({
  "packages/ag-charts-community/src/options/series/polar/donutOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/polar/pieOptions.ts
var init_pieOptions = __esm({
  "packages/ag-charts-community/src/options/series/polar/pieOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/polar/polarOptions.ts
var init_polarOptions = __esm({
  "packages/ag-charts-community/src/options/series/polar/polarOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/polar/radarOptions.ts
var init_radarOptions = __esm({
  "packages/ag-charts-community/src/options/series/polar/radarOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/polar/radarLineOptions.ts
var init_radarLineOptions = __esm({
  "packages/ag-charts-community/src/options/series/polar/radarLineOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/polar/radarAreaOptions.ts
var init_radarAreaOptions = __esm({
  "packages/ag-charts-community/src/options/series/polar/radarAreaOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/polar/radialBarOptions.ts
var init_radialBarOptions = __esm({
  "packages/ag-charts-community/src/options/series/polar/radialBarOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/polar/radialColumnOptions.ts
var init_radialColumnOptions = __esm({
  "packages/ag-charts-community/src/options/series/polar/radialColumnOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/polar/radialOptions.ts
var init_radialOptions = __esm({
  "packages/ag-charts-community/src/options/series/polar/radialOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/topology/mapShapeOptions.ts
var init_mapShapeOptions = __esm({
  "packages/ag-charts-community/src/options/series/topology/mapShapeOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/topology/mapLineOptions.ts
var init_mapLineOptions = __esm({
  "packages/ag-charts-community/src/options/series/topology/mapLineOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/topology/mapMarkerOptions.ts
var init_mapMarkerOptions = __esm({
  "packages/ag-charts-community/src/options/series/topology/mapMarkerOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/topology/mapShapeBackgroundOptions.ts
var init_mapShapeBackgroundOptions = __esm({
  "packages/ag-charts-community/src/options/series/topology/mapShapeBackgroundOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/topology/mapLineBackgroundOptions.ts
var init_mapLineBackgroundOptions = __esm({
  "packages/ag-charts-community/src/options/series/topology/mapLineBackgroundOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/series/markerOptions.ts
var init_markerOptions = __esm({
  "packages/ag-charts-community/src/options/series/markerOptions.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/options/agChartOptions.ts
var __FORCE_MODULE_DETECTION;
var init_agChartOptions = __esm({
  "packages/ag-charts-community/src/options/agChartOptions.ts"() {
    "use strict";
    init_axisOptions();
    init_crosshairOptions();
    init_chartOptions();
    init_chartBuilderOptions();
    init_crossLineOptions();
    init_dropShadowOptions();
    init_errorBarOptions();
    init_eventOptions();
    init_gradientLegendOptions();
    init_labelOptions();
    init_legendOptions();
    init_navigatorOptions();
    init_polarAxisOptions();
    init_toolbarOptions();
    init_tooltipOptions();
    init_themeOptions();
    init_types();
    init_zoomOptions();
    init_seriesOptions();
    init_cartesianOptions();
    init_cartesianSeriesTooltipOptions();
    init_cartesianSeriesTypes();
    init_areaOptions();
    init_barOptions();
    init_boxPlotOptions();
    init_candlestickBaseOptions();
    init_candlestickOptions();
    init_ohlcOptions();
    init_bubbleOptions();
    init_bulletOptions();
    init_commonOptions();
    init_lineOptions();
    init_heatmapOptions();
    init_histogramOptions();
    init_rangeBarOptions();
    init_rangeAreaOptions();
    init_scatterOptions();
    init_waterfallOptions();
    init_hierarchyOptions();
    init_sunburstOptions();
    init_treemapOptions();
    init_nightingaleOptions();
    init_donutOptions();
    init_pieOptions();
    init_polarOptions();
    init_radarOptions();
    init_radarLineOptions();
    init_radarAreaOptions();
    init_radialBarOptions();
    init_radialColumnOptions();
    init_radialOptions();
    init_mapShapeOptions();
    init_mapLineOptions();
    init_mapMarkerOptions();
    init_mapShapeBackgroundOptions();
    init_mapLineBackgroundOptions();
    init_markerOptions();
    __FORCE_MODULE_DETECTION = 0;
  }
});

// packages/ag-charts-community/src/util/function.ts
function doOnce(func, key) {
  if (doOnceState.has(key))
    return;
  doOnceState.set(key, true);
  func();
}
function identity(x) {
  return x;
}
function* iterate(...iterators) {
  for (const iterator of iterators) {
    yield* __yieldStar(iterator);
  }
}
function* iterateReverseArray(array) {
  for (let j = array.length - 1; j >= 0; j--) {
    yield array[j];
  }
}
function throttle(callback, waitMs = 0, options) {
  const { leading = true, trailing = true } = options != null ? options : {};
  let timerId;
  let lastArgs;
  let shouldWait = false;
  function timeoutHandler() {
    if (trailing && lastArgs) {
      timerId = setTimeout(timeoutHandler, waitMs);
      callback(...lastArgs);
    } else {
      shouldWait = false;
    }
    lastArgs = null;
  }
  function throttleCallback(...args) {
    if (shouldWait) {
      lastArgs = args;
    } else {
      shouldWait = true;
      timerId = setTimeout(timeoutHandler, waitMs);
      if (leading) {
        callback(...args);
      } else {
        lastArgs = args;
      }
    }
  }
  return Object.assign(throttleCallback, {
    cancel() {
      clearTimeout(timerId);
      shouldWait = false;
      lastArgs = null;
    }
  });
}
function joinFunctions(...fns) {
  return () => {
    for (const fn of fns) {
      fn();
    }
  };
}
var doOnceState;
var init_function = __esm({
  "packages/ag-charts-community/src/util/function.ts"() {
    "use strict";
    doOnceState = /* @__PURE__ */ new Map();
    doOnce.clear = () => doOnceState.clear();
  }
});

// packages/ag-charts-community/src/util/logger.ts
var Logger;
var init_logger = __esm({
  "packages/ag-charts-community/src/util/logger.ts"() {
    "use strict";
    init_function();
    Logger = {
      log(...logContent) {
        console.log(...logContent);
      },
      warn(message, ...logContent) {
        console.warn(`AG Charts - ${message}`, ...logContent);
      },
      error(message, ...logContent) {
        if (typeof message === "object") {
          console.error(`AG Charts error`, message, ...logContent);
        } else {
          console.error(`AG Charts - ${message}`, ...logContent);
        }
      },
      table(...logContent) {
        console.table(...logContent);
      },
      warnOnce(message, ...logContent) {
        doOnce(() => Logger.warn(message, ...logContent), `Logger.warn: ${message}`);
      },
      errorOnce(message, ...logContent) {
        doOnce(() => Logger.error(message, ...logContent), `Logger.error: ${message}`);
      }
    };
  }
});

// packages/ag-charts-community/src/util/time/interval.ts
var TimeInterval, CountableTimeInterval;
var init_interval = __esm({
  "packages/ag-charts-community/src/util/time/interval.ts"() {
    "use strict";
    init_logger();
    TimeInterval = class {
      constructor(_encode, _decode, _rangeCallback) {
        this._encode = _encode;
        this._decode = _decode;
        this._rangeCallback = _rangeCallback;
      }
      /**
       * Returns a new date representing the latest interval boundary date before or equal to date.
       * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.
       * @param date
       */
      floor(date) {
        const d = new Date(date);
        const e = this._encode(d);
        return this._decode(e);
      }
      /**
       * Returns a new date representing the earliest interval boundary date after or equal to date.
       * @param date
       */
      ceil(date) {
        const d = new Date(Number(date) - 1);
        const e = this._encode(d);
        return this._decode(e + 1);
      }
      /**
       * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).
       * @param start Range start.
       * @param stop Range end.
       * @param extend If specified, the requested range will be extended to the closest "nice" values.
       */
      range(start, stop, extend) {
        var _a2;
        const rangeCallback = (_a2 = this._rangeCallback) == null ? void 0 : _a2.call(this, start, stop);
        const e0 = this._encode(extend ? this.floor(start) : this.ceil(start));
        const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));
        if (e1 < e0) {
          return [];
        }
        const range4 = [];
        for (let e = e0; e <= e1; e++) {
          const d = this._decode(e);
          range4.push(d);
        }
        rangeCallback == null ? void 0 : rangeCallback();
        return range4;
      }
    };
    CountableTimeInterval = class extends TimeInterval {
      getOffset(snapTo, step) {
        const s = typeof snapTo === "number" || snapTo instanceof Date ? this._encode(new Date(snapTo)) : 0;
        return Math.floor(s) % step;
      }
      /**
       * Returns a filtered view of this interval representing every step'th date.
       * It can be a number of minutes, hours, days etc.
       * Must be a positive integer.
       * @param step
       */
      every(step, options) {
        let offset4 = 0;
        let rangeCallback;
        const unsafeStep = step;
        step = Math.max(1, Math.round(step));
        if (unsafeStep !== step) {
          Logger.warnOnce(`interval step of [${unsafeStep}] rounded to [${step}].`);
        }
        const { snapTo = "start" } = options != null ? options : {};
        if (typeof snapTo === "string") {
          const initialOffset = offset4;
          rangeCallback = (start, stop) => {
            const s = snapTo === "start" ? start : stop;
            offset4 = this.getOffset(s, step);
            return () => offset4 = initialOffset;
          };
        } else if (typeof snapTo === "number") {
          offset4 = this.getOffset(new Date(snapTo), step);
        } else if (snapTo instanceof Date) {
          offset4 = this.getOffset(snapTo, step);
        }
        const encode13 = (date) => {
          const e = this._encode(date);
          return Math.floor((e - offset4) / step);
        };
        const decode13 = (encoded) => {
          return this._decode(encoded * step + offset4);
        };
        return new TimeInterval(encode13, decode13, rangeCallback);
      }
    };
  }
});

// packages/ag-charts-community/src/util/time/millisecond.ts
function encode(date) {
  return date.getTime();
}
function decode(encoded) {
  return new Date(encoded);
}
var millisecond, millisecond_default;
var init_millisecond = __esm({
  "packages/ag-charts-community/src/util/time/millisecond.ts"() {
    "use strict";
    init_interval();
    millisecond = new CountableTimeInterval(encode, decode);
    millisecond_default = millisecond;
  }
});

// packages/ag-charts-community/src/util/time/duration.ts
var epochYear, durationSecond, durationMinute, durationHour, durationDay, durationWeek, durationMonth, durationYear;
var init_duration = __esm({
  "packages/ag-charts-community/src/util/time/duration.ts"() {
    "use strict";
    epochYear = (/* @__PURE__ */ new Date(0)).getFullYear();
    durationSecond = 1e3;
    durationMinute = durationSecond * 60;
    durationHour = durationMinute * 60;
    durationDay = durationHour * 24;
    durationWeek = durationDay * 7;
    durationMonth = durationDay * 30;
    durationYear = durationDay * 365;
  }
});

// packages/ag-charts-community/src/util/time/second.ts
function encode2(date) {
  return Math.floor((date.getTime() - offset) / durationSecond);
}
function decode2(encoded) {
  return new Date(offset + encoded * durationSecond);
}
var offset, second, second_default;
var init_second = __esm({
  "packages/ag-charts-community/src/util/time/second.ts"() {
    "use strict";
    init_duration();
    init_interval();
    offset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
    second = new CountableTimeInterval(encode2, decode2);
    second_default = second;
  }
});

// packages/ag-charts-community/src/util/time/minute.ts
function encode3(date) {
  return Math.floor((date.getTime() - offset2) / durationMinute);
}
function decode3(encoded) {
  return new Date(offset2 + encoded * durationMinute);
}
var offset2, minute, minute_default;
var init_minute = __esm({
  "packages/ag-charts-community/src/util/time/minute.ts"() {
    "use strict";
    init_duration();
    init_interval();
    offset2 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
    minute = new CountableTimeInterval(encode3, decode3);
    minute_default = minute;
  }
});

// packages/ag-charts-community/src/util/time/hour.ts
function encode4(date) {
  return Math.floor((date.getTime() - offset3) / durationHour);
}
function decode4(encoded) {
  return new Date(offset3 + encoded * durationHour);
}
var offset3, hour, hour_default;
var init_hour = __esm({
  "packages/ag-charts-community/src/util/time/hour.ts"() {
    "use strict";
    init_duration();
    init_interval();
    offset3 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;
    hour = new CountableTimeInterval(encode4, decode4);
    hour_default = hour;
  }
});

// packages/ag-charts-community/src/util/time/day.ts
function encode5(date) {
  const tzOffsetMs = date.getTimezoneOffset() * durationMinute;
  return Math.floor((date.getTime() - tzOffsetMs) / durationDay);
}
function decode5(encoded) {
  const d = new Date(1970, 0, 1);
  d.setDate(d.getDate() + encoded);
  return d;
}
var day, day_default;
var init_day = __esm({
  "packages/ag-charts-community/src/util/time/day.ts"() {
    "use strict";
    init_duration();
    init_interval();
    day = new CountableTimeInterval(encode5, decode5);
    day_default = day;
  }
});

// packages/ag-charts-community/src/util/time/week.ts
function weekday(weekStart) {
  const thursday2 = 4;
  const dayShift = (7 + weekStart - thursday2) % 7;
  function encode13(date) {
    const tzOffsetMs = date.getTimezoneOffset() * durationMinute;
    return Math.floor((date.getTime() - tzOffsetMs) / durationWeek - dayShift / 7);
  }
  function decode13(encoded) {
    const d = new Date(1970, 0, 1);
    d.setDate(d.getDate() + encoded * 7 + dayShift);
    return d;
  }
  return new CountableTimeInterval(encode13, decode13);
}
var sunday, monday, tuesday, wednesday, thursday, friday, saturday, week_default;
var init_week = __esm({
  "packages/ag-charts-community/src/util/time/week.ts"() {
    "use strict";
    init_duration();
    init_interval();
    sunday = weekday(0);
    monday = weekday(1);
    tuesday = weekday(2);
    wednesday = weekday(3);
    thursday = weekday(4);
    friday = weekday(5);
    saturday = weekday(6);
    week_default = sunday;
  }
});

// packages/ag-charts-community/src/util/time/month.ts
function encode6(date) {
  return date.getFullYear() * 12 + date.getMonth();
}
function decode6(encoded) {
  const year2 = Math.floor(encoded / 12);
  const month2 = encoded - year2 * 12;
  return new Date(year2, month2, 1);
}
var month, month_default;
var init_month = __esm({
  "packages/ag-charts-community/src/util/time/month.ts"() {
    "use strict";
    init_interval();
    month = new CountableTimeInterval(encode6, decode6);
    month_default = month;
  }
});

// packages/ag-charts-community/src/util/time/year.ts
function encode7(date) {
  return date.getFullYear();
}
function decode7(encoded) {
  const d = /* @__PURE__ */ new Date();
  d.setFullYear(encoded);
  d.setMonth(0, 1);
  d.setHours(0, 0, 0, 0);
  return d;
}
var year, year_default;
var init_year = __esm({
  "packages/ag-charts-community/src/util/time/year.ts"() {
    "use strict";
    init_interval();
    year = new CountableTimeInterval(encode7, decode7);
    year_default = year;
  }
});

// packages/ag-charts-community/src/util/time/utcMinute.ts
function encode8(date) {
  return Math.floor(date.getTime() / durationMinute);
}
function decode8(encoded) {
  return new Date(encoded * durationMinute);
}
var utcMinute;
var init_utcMinute = __esm({
  "packages/ag-charts-community/src/util/time/utcMinute.ts"() {
    "use strict";
    init_duration();
    init_interval();
    utcMinute = new CountableTimeInterval(encode8, decode8);
  }
});

// packages/ag-charts-community/src/util/time/utcHour.ts
function encode9(date) {
  return Math.floor(date.getTime() / durationHour);
}
function decode9(encoded) {
  return new Date(encoded * durationHour);
}
var utcHour;
var init_utcHour = __esm({
  "packages/ag-charts-community/src/util/time/utcHour.ts"() {
    "use strict";
    init_duration();
    init_interval();
    utcHour = new CountableTimeInterval(encode9, decode9);
  }
});

// packages/ag-charts-community/src/util/time/utcDay.ts
function encode10(date) {
  return Math.floor(date.getTime() / durationDay);
}
function decode10(encoded) {
  const d = /* @__PURE__ */ new Date(0);
  d.setUTCDate(d.getUTCDate() + encoded);
  d.setUTCHours(0, 0, 0, 0);
  return d;
}
var utcDay;
var init_utcDay = __esm({
  "packages/ag-charts-community/src/util/time/utcDay.ts"() {
    "use strict";
    init_duration();
    init_interval();
    utcDay = new CountableTimeInterval(encode10, decode10);
  }
});

// packages/ag-charts-community/src/util/time/utcMonth.ts
function encode11(date) {
  return date.getUTCFullYear() * 12 + date.getUTCMonth();
}
function decode11(encoded) {
  const year2 = Math.floor(encoded / 12);
  const month2 = encoded - year2 * 12;
  return new Date(Date.UTC(year2, month2, 1));
}
var utcMonth;
var init_utcMonth = __esm({
  "packages/ag-charts-community/src/util/time/utcMonth.ts"() {
    "use strict";
    init_interval();
    utcMonth = new CountableTimeInterval(encode11, decode11);
  }
});

// packages/ag-charts-community/src/util/time/utcYear.ts
function encode12(date) {
  return date.getUTCFullYear();
}
function decode12(encoded) {
  const d = /* @__PURE__ */ new Date();
  d.setUTCFullYear(encoded);
  d.setUTCMonth(0, 1);
  d.setUTCHours(0, 0, 0, 0);
  return d;
}
var utcYear;
var init_utcYear = __esm({
  "packages/ag-charts-community/src/util/time/utcYear.ts"() {
    "use strict";
    init_interval();
    utcYear = new CountableTimeInterval(encode12, decode12);
  }
});

// packages/ag-charts-community/src/util/time/index.ts
var time_exports = {};
__export(time_exports, {
  day: () => day,
  friday: () => friday,
  hour: () => hour,
  millisecond: () => millisecond,
  minute: () => minute,
  monday: () => monday,
  month: () => month,
  saturday: () => saturday,
  second: () => second,
  sunday: () => sunday,
  thursday: () => thursday,
  tuesday: () => tuesday,
  utcDay: () => utcDay,
  utcHour: () => utcHour,
  utcMinute: () => utcMinute,
  utcMonth: () => utcMonth,
  utcYear: () => utcYear,
  wednesday: () => wednesday,
  year: () => year
});
var init_time = __esm({
  "packages/ag-charts-community/src/util/time/index.ts"() {
    "use strict";
    init_millisecond();
    init_second();
    init_minute();
    init_hour();
    init_day();
    init_week();
    init_month();
    init_year();
    init_utcMinute();
    init_utcHour();
    init_utcDay();
    init_utcMonth();
    init_utcYear();
  }
});

// packages/ag-charts-community/src/module/enterpriseModule.ts
var enterpriseModule;
var init_enterpriseModule = __esm({
  "packages/ag-charts-community/src/module/enterpriseModule.ts"() {
    "use strict";
    enterpriseModule = {
      isEnterprise: false
    };
  }
});

// packages/ag-charts-community/src/module/module.ts
var BaseModuleInstance, ModuleRegistry, moduleRegistry;
var init_module = __esm({
  "packages/ag-charts-community/src/module/module.ts"() {
    "use strict";
    BaseModuleInstance = class {
      constructor() {
        this.destroyFns = [];
      }
      destroy() {
        for (const destroyFn of this.destroyFns) {
          destroyFn();
        }
      }
    };
    ModuleRegistry = class {
      constructor() {
        this.modules = [];
        this.dependencies = /* @__PURE__ */ new Set();
        this.dependents = /* @__PURE__ */ new Set();
      }
      register(...modules) {
        for (const module2 of modules) {
          this.registerDependencies(module2);
          const otherModule = this.modules.find(
            (other) => module2.type === other.type && module2.optionsKey === other.optionsKey && module2.identifier === other.identifier
          );
          if (otherModule) {
            if (module2.packageType === "enterprise" && otherModule.packageType === "community") {
              const index = this.modules.indexOf(otherModule);
              this.modules.splice(index, 1, module2);
            }
          } else {
            this.modules.push(module2);
          }
        }
      }
      hasEnterpriseModules() {
        return this.modules.some((m) => m.packageType === "enterprise");
      }
      *byType(...types) {
        for (const module2 of this.modules) {
          if (types.includes(module2.type) && this.dependencies.has(module2.optionsKey)) {
            yield module2;
          }
        }
        for (const module2 of this.modules) {
          if (types.includes(module2.type) && !this.dependencies.has(module2.optionsKey) && !this.dependents.has(module2.optionsKey)) {
            yield module2;
          }
        }
        for (const module2 of this.modules) {
          if (types.includes(module2.type) && this.dependents.has(module2.optionsKey)) {
            yield module2;
          }
        }
      }
      registerDependencies(module2) {
        if (module2.dependencies == null || module2.dependencies.length === 0)
          return;
        if (this.dependencies.has(module2.optionsKey)) {
          throw new Error(
            `Module [${module2.optionsKey}] can not both be depended upon by any module and have dependencies of [${module2.dependencies}].`
          );
        }
        for (const dep of module2.dependencies) {
          if (this.dependents.has(dep)) {
            throw new Error(
              `Module [${dep}] can not both be depended upon by any module and have dependencies of [${module2.optionsKey}].`
            );
          }
          this.dependencies.add(dep);
        }
        this.dependents.add(module2.optionsKey);
      }
    };
    moduleRegistry = new ModuleRegistry();
  }
});

// packages/ag-charts-community/src/chart/factory/axisRegistry.ts
var AxisRegistry, axisRegistry;
var init_axisRegistry = __esm({
  "packages/ag-charts-community/src/chart/factory/axisRegistry.ts"() {
    "use strict";
    AxisRegistry = class {
      constructor() {
        this.axesMap = /* @__PURE__ */ new Map();
        this.hidden = /* @__PURE__ */ new Set();
        this.themeTemplates = /* @__PURE__ */ new Map();
      }
      register(axisType, module2) {
        this.axesMap.set(axisType, module2.instanceConstructor);
        if (module2.themeTemplate) {
          this.setThemeTemplate(axisType, module2.themeTemplate);
        }
        if (module2.hidden) {
          this.hidden.add(axisType);
        }
      }
      create(axisType, moduleContext) {
        const AxisConstructor = this.axesMap.get(axisType);
        if (AxisConstructor) {
          return new AxisConstructor(moduleContext);
        }
        throw new Error(`AG Charts - unknown axis type: ${axisType}`);
      }
      has(axisType) {
        return this.axesMap.has(axisType);
      }
      keys() {
        return this.axesMap.keys();
      }
      publicKeys() {
        return [...this.keys()].filter((k) => !this.hidden.has(k));
      }
      setThemeTemplate(axisType, themeTemplate) {
        this.themeTemplates.set(axisType, themeTemplate);
        return this;
      }
      getThemeTemplate(axisType) {
        return this.themeTemplates.get(axisType);
      }
    };
    axisRegistry = new AxisRegistry();
  }
});

// packages/ag-charts-community/src/util/decorator.ts
function initialiseConfig(target, propertyKeyOrSymbol) {
  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {
    Object.defineProperty(target, CONFIG_KEY, { value: {} });
  }
  const config = target[CONFIG_KEY];
  const propertyKey = propertyKeyOrSymbol.toString();
  if (typeof config[propertyKey] !== "undefined") {
    return config[propertyKey];
  }
  const valuesMap = /* @__PURE__ */ new WeakMap();
  config[propertyKey] = { setters: [], getters: [], observers: [], valuesMap };
  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);
  const prevSet = descriptor == null ? void 0 : descriptor.set;
  const prevGet = descriptor == null ? void 0 : descriptor.get;
  const getter = function() {
    let value = prevGet ? prevGet.call(this) : valuesMap.get(this);
    for (const transformFn of config[propertyKey].getters) {
      value = transformFn(this, propertyKeyOrSymbol, value);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return;
      }
    }
    return value;
  };
  const setter = function(value) {
    const { setters, observers } = config[propertyKey];
    let oldValue;
    if (setters.some((f) => f.length > 2)) {
      oldValue = prevGet ? prevGet.call(this) : valuesMap.get(this);
    }
    for (const transformFn of setters) {
      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);
      if (value === BREAK_TRANSFORM_CHAIN) {
        return;
      }
    }
    if (prevSet) {
      prevSet.call(this, value);
    } else {
      valuesMap.set(this, value);
    }
    for (const observerFn of observers) {
      observerFn(this, value, oldValue);
    }
  };
  Object.defineProperty(target, propertyKeyOrSymbol, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: false
  });
  return config[propertyKey];
}
function addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {
  return (target, propertyKeyOrSymbol) => {
    const config = initialiseConfig(target, propertyKeyOrSymbol);
    config.setters.push(setTransform);
    if (getTransform) {
      config.getters.unshift(getTransform);
    }
    if (configMetadata) {
      Object.assign(config, configMetadata);
    }
  };
}
function addObserverToInstanceProperty(setObserver) {
  return (target, propertyKeyOrSymbol) => {
    initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);
  };
}
function isDecoratedObject(target) {
  return typeof target !== "undefined" && CONFIG_KEY in target;
}
function listDecoratedProperties(target) {
  const targets = /* @__PURE__ */ new Set();
  while (isDecoratedObject(target)) {
    targets.add(target == null ? void 0 : target[CONFIG_KEY]);
    target = Object.getPrototypeOf(target);
  }
  return Array.from(targets).flatMap((configMap) => Object.keys(configMap));
}
function extractDecoratedProperties(target) {
  return listDecoratedProperties(target).reduce((result, key) => {
    var _a2;
    result[key] = (_a2 = target[key]) != null ? _a2 : null;
    return result;
  }, {});
}
function extractDecoratedPropertyMetadata(target, propertyKeyOrSymbol) {
  const propertyKey = propertyKeyOrSymbol.toString();
  while (isDecoratedObject(target)) {
    const config = target[CONFIG_KEY];
    if (Object.hasOwn(config, propertyKey)) {
      return config[propertyKey];
    }
    target = Object.getPrototypeOf(target);
  }
}
var BREAK_TRANSFORM_CHAIN, CONFIG_KEY;
var init_decorator = __esm({
  "packages/ag-charts-community/src/util/decorator.ts"() {
    "use strict";
    BREAK_TRANSFORM_CHAIN = Symbol("BREAK");
    CONFIG_KEY = "__decorator_config";
  }
});

// packages/ag-charts-community/src/util/type-guards.ts
function isDefined(val) {
  return val != null;
}
function isArray(value) {
  return Array.isArray(value);
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isDate(value) {
  return value instanceof Date;
}
function isValidDate(value) {
  return isDate(value) && !isNaN(Number(value));
}
function isRegExp(value) {
  return value instanceof RegExp;
}
function isFunction(value) {
  return typeof value === "function";
}
function isObject(value) {
  return typeof value === "object" && value !== null && !isArray(value);
}
function isObjectLike(value) {
  return isArray(value) || isPlainObject(value);
}
function isPlainObject(value) {
  return typeof value === "object" && value !== null && value.constructor === Object;
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isFiniteNumber(value) {
  return isNumber(value) && Number.isFinite(value);
}
function isHtmlElement(value) {
  return typeof window !== "undefined" && value instanceof HTMLElement;
}
function isEnumKey(enumObject, enumKey) {
  return isString(enumKey) && Object.keys(enumObject).includes(enumKey);
}
function isEnumValue(enumObject, enumValue) {
  return Object.values(enumObject).includes(enumValue);
}
function isSymbol(value) {
  return typeof value === "symbol";
}
var init_type_guards = __esm({
  "packages/ag-charts-community/src/util/type-guards.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/util/object.ts
function deepMerge(...sources) {
  return mergeDefaults(...sources.reverse());
}
function mergeDefaults(...sources) {
  var _a2;
  const target = {};
  for (const source of sources) {
    if (!isObject(source))
      continue;
    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);
    for (const key of keys) {
      if (isPlainObject(target[key]) && isPlainObject(source[key])) {
        target[key] = mergeDefaults(target[key], source[key]);
      } else {
        (_a2 = target[key]) != null ? _a2 : target[key] = source[key];
      }
    }
  }
  return target;
}
function mergeArrayDefaults(dataArray, ...itemDefaults) {
  if (itemDefaults && isArray(dataArray)) {
    return dataArray.map((item) => mergeDefaults(item, ...itemDefaults));
  }
  return dataArray;
}
function mapValues(object, mapper) {
  return Object.entries(object).reduce(
    (result, [key, value]) => {
      result[key] = mapper(value, key, object);
      return result;
    },
    {}
  );
}
function without(object, keys) {
  const clone = __spreadValues({}, object);
  for (const key of keys) {
    delete clone[key];
  }
  return clone;
}
function getPath(object, path) {
  const pathArray = isArray(path) ? path : path.split(".");
  return pathArray.reduce((value, pathKey) => value[pathKey], object);
}
function setPath(object, path, newValue) {
  const pathArray = isArray(path) ? path.slice() : path.split(".");
  const lastKey = pathArray.pop();
  if (pathArray.some((p) => SKIP_JS_BUILTINS.has(p)))
    return;
  const lastObject = pathArray.reduce((value, pathKey) => value[pathKey], object);
  lastObject[lastKey] = newValue;
}
function partialAssign(keysToCopy, target, source) {
  if (source === void 0) {
    return target;
  }
  for (const key of keysToCopy) {
    const value = source[key];
    if (value !== void 0) {
      target[key] = value;
    }
  }
  return target;
}
var SKIP_JS_BUILTINS;
var init_object = __esm({
  "packages/ag-charts-community/src/util/object.ts"() {
    "use strict";
    init_decorator();
    init_type_guards();
    SKIP_JS_BUILTINS = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
  }
});

// packages/ag-charts-community/src/chart/factory/chartTypes.ts
var ChartTypes, ChartDefaults, chartTypes, publicChartTypes, chartDefaults;
var init_chartTypes = __esm({
  "packages/ag-charts-community/src/chart/factory/chartTypes.ts"() {
    "use strict";
    init_object();
    ChartTypes = class extends Map {
      get(seriesType) {
        var _a2;
        return (_a2 = super.get(seriesType)) != null ? _a2 : "unknown";
      }
      isCartesian(seriesType) {
        return this.get(seriesType) === "cartesian";
      }
      isPolar(seriesType) {
        return this.get(seriesType) === "polar";
      }
      isHierarchy(seriesType) {
        return this.get(seriesType) === "hierarchy";
      }
      isTopology(seriesType) {
        return this.get(seriesType) === "topology";
      }
      get seriesTypes() {
        return Array.from(this.keys());
      }
      get cartesianTypes() {
        return this.seriesTypes.filter((t) => this.isCartesian(t));
      }
      get polarTypes() {
        return this.seriesTypes.filter((t) => this.isPolar(t));
      }
      get hierarchyTypes() {
        return this.seriesTypes.filter((t) => this.isHierarchy(t));
      }
      get topologyTypes() {
        return this.seriesTypes.filter((t) => this.isTopology(t));
      }
    };
    ChartDefaults = class extends Map {
      set(chartType2, defaults) {
        return super.set(chartType2, mergeDefaults(defaults, this.get(chartType2)));
      }
    };
    chartTypes = new ChartTypes();
    publicChartTypes = new ChartTypes();
    chartDefaults = new ChartDefaults();
  }
});

// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts
function isEnterpriseSeriesType(type) {
  return EXPECTED_ENTERPRISE_MODULES.some((s) => s.type === "series" && s.identifier === type);
}
function getEnterpriseSeriesChartTypes(type) {
  var _a2;
  return (_a2 = EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === "series" && s.identifier === type)) == null ? void 0 : _a2.chartTypes;
}
function isEnterpriseCartesian(seriesType) {
  var _a2;
  const type = (_a2 = getEnterpriseSeriesChartTypes(seriesType)) == null ? void 0 : _a2.find((v) => v === "cartesian");
  return type === "cartesian";
}
function isEnterprisePolar(seriesType) {
  var _a2;
  const type = (_a2 = getEnterpriseSeriesChartTypes(seriesType)) == null ? void 0 : _a2.find((v) => v === "polar");
  return type === "polar";
}
function isEnterpriseHierarchy(seriesType) {
  var _a2;
  const type = (_a2 = getEnterpriseSeriesChartTypes(seriesType)) == null ? void 0 : _a2.find((v) => v === "hierarchy");
  return type === "hierarchy";
}
function isEnterpriseTopology(seriesType) {
  var _a2;
  const type = (_a2 = getEnterpriseSeriesChartTypes(seriesType)) == null ? void 0 : _a2.find((v) => v === "topology");
  return type === "topology";
}
function isEnterpriseModule(module2) {
  return module2.packageType === "enterprise";
}
function verifyIfModuleExpected(module2) {
  var _a2;
  if (!isEnterpriseModule(module2)) {
    throw new Error("AG Charts - internal configuration error, only enterprise modules need verification.");
  }
  const stub = EXPECTED_ENTERPRISE_MODULES.find((s) => {
    return s.type === module2.type && s.optionsKey === module2.optionsKey && s.identifier === module2.identifier && module2.chartTypes.every((t) => s.chartTypes.includes(t));
  });
  if (stub) {
    (_a2 = stub.useCount) != null ? _a2 : stub.useCount = 0;
    stub.useCount++;
  }
  return stub != null;
}
function getUnusedExpectedModules() {
  return EXPECTED_ENTERPRISE_MODULES.filter(({ useCount }) => useCount == null || useCount === 0);
}
var EXPECTED_ENTERPRISE_MODULES;
var init_expectedEnterpriseModules = __esm({
  "packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts"() {
    "use strict";
    EXPECTED_ENTERPRISE_MODULES = [
      { type: "root", optionsKey: "animation", chartTypes: ["cartesian", "polar", "hierarchy", "topology"] },
      { type: "root", optionsKey: "annotations", chartTypes: ["cartesian"] },
      {
        type: "root",
        optionsKey: "background",
        chartTypes: ["cartesian", "polar", "hierarchy", "topology"],
        optionsInnerKey: "image"
      },
      { type: "root", optionsKey: "contextMenu", chartTypes: ["cartesian", "polar", "hierarchy", "topology"] },
      { type: "root", optionsKey: "dataSource", chartTypes: ["cartesian", "polar", "hierarchy", "topology"] },
      { type: "root", optionsKey: "sync", chartTypes: ["cartesian"] },
      { type: "root", optionsKey: "zoom", chartTypes: ["cartesian", "topology"] },
      {
        type: "legend",
        optionsKey: "gradientLegend",
        chartTypes: ["cartesian", "polar", "hierarchy", "topology"],
        identifier: "gradient"
      },
      { type: "root", optionsKey: "navigator", chartTypes: ["cartesian"], optionsInnerKey: "miniChart" },
      { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "angle-category" },
      { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "angle-number" },
      { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "radius-category" },
      { type: "axis", optionsKey: "axes[]", chartTypes: ["polar"], identifier: "radius-number" },
      { type: "axis", optionsKey: "axes[]", chartTypes: ["cartesian"], identifier: "ordinal-time" },
      { type: "axis-option", optionsKey: "crosshair", chartTypes: ["cartesian"] },
      { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "box-plot" },
      { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "candlestick" },
      { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "ohlc" },
      { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "bullet" },
      { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "heatmap" },
      { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "range-area" },
      { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "range-bar" },
      { type: "series", optionsKey: "series[]", chartTypes: ["cartesian"], identifier: "waterfall" },
      { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "nightingale" },
      { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radar-area" },
      { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radar-line" },
      { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radial-bar" },
      { type: "series", optionsKey: "series[]", chartTypes: ["polar"], identifier: "radial-column" },
      { type: "series", optionsKey: "series[]", chartTypes: ["hierarchy"], identifier: "sunburst" },
      { type: "series", optionsKey: "series[]", chartTypes: ["hierarchy"], identifier: "treemap" },
      { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-shape" },
      { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-line" },
      { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-marker" },
      { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-shape-background" },
      { type: "series", optionsKey: "series[]", chartTypes: ["topology"], identifier: "map-line-background" },
      { type: "series-option", optionsKey: "errorBar", chartTypes: ["cartesian"], identifier: "error-bars" }
    ];
  }
});

// packages/ag-charts-community/src/chart/mapping/types.ts
function optionsType(input) {
  var _a2, _b, _c;
  return (_c = (_b = (_a2 = input.series) == null ? void 0 : _a2[0]) == null ? void 0 : _b.type) != null ? _c : "line";
}
function isAgCartesianChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return true;
  }
  if (specifiedType === "cartesian") {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return chartTypes.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);
}
function isAgPolarChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  if (specifiedType === "polar") {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return chartTypes.isPolar(specifiedType) || isEnterprisePolar(specifiedType);
}
function isAgHierarchyChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  if (specifiedType === "hierarchy") {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return chartTypes.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);
}
function isAgTopologyChartOptions(input) {
  const specifiedType = optionsType(input);
  if (specifiedType == null) {
    return false;
  }
  if (specifiedType === "topology") {
    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);
    return true;
  }
  return chartTypes.isTopology(specifiedType) || isEnterpriseTopology(specifiedType);
}
function isAgPolarChartOptionsWithSeriesBasedLegend(input) {
  const specifiedType = optionsType(input);
  return isAgPolarChartOptions(input) && specifiedType !== "pie" && specifiedType !== "donut";
}
function isSeriesOptionType(input) {
  if (input == null) {
    return false;
  }
  return chartTypes.has(input);
}
function isAxisOptionType(input) {
  if (input == null) {
    return false;
  }
  return axisRegistry.has(input);
}
var init_types2 = __esm({
  "packages/ag-charts-community/src/chart/mapping/types.ts"() {
    "use strict";
    init_logger();
    init_axisRegistry();
    init_chartTypes();
    init_expectedEnterpriseModules();
  }
});

// packages/ag-charts-community/src/chart/factory/processEnterpriseOptions.ts
function removeUsedEnterpriseOptions(options) {
  var _a2, _b, _c, _d;
  const usedOptions = [];
  const optionsChartType = chartTypes.get(optionsType(options));
  for (const {
    type,
    chartTypes: moduleChartTypes,
    optionsKey,
    optionsInnerKey,
    identifier
  } of EXPECTED_ENTERPRISE_MODULES) {
    if (optionsChartType !== "unknown" && !moduleChartTypes.includes(optionsChartType))
      continue;
    if (type === "root" || type === "legend") {
      const optionValue = options[optionsKey];
      if (optionValue == null)
        continue;
      if (!optionsInnerKey) {
        usedOptions.push(optionsKey);
        delete options[optionsKey];
      } else if (optionValue[optionsInnerKey]) {
        usedOptions.push(`${optionsKey}.${optionsInnerKey}`);
        delete optionValue[optionsInnerKey];
      }
    } else if (type === "axis") {
      if (!("axes" in options) || !((_a2 = options.axes) == null ? void 0 : _a2.some((axis) => axis.type === identifier)))
        continue;
      usedOptions.push(`axis[type=${identifier}]`);
      options.axes = options.axes.filter((axis) => axis.type !== identifier);
    } else if (type === "axis-option") {
      if (!("axes" in options) || !((_b = options.axes) == null ? void 0 : _b.some((axis) => axis[optionsKey])))
        continue;
      usedOptions.push(`axis.${optionsKey}`);
      options.axes.forEach((axis) => {
        if (axis[optionsKey]) {
          delete axis[optionsKey];
        }
      });
    } else if (type === "series") {
      if (!((_c = options.series) == null ? void 0 : _c.some((series) => series.type === identifier)))
        continue;
      usedOptions.push(`series[type=${identifier}]`);
      options.series = options.series.filter((series) => series.type !== identifier);
    } else if (type === "series-option") {
      if (!((_d = options.series) == null ? void 0 : _d.some((series) => series[optionsKey])))
        continue;
      usedOptions.push(`series.${optionsKey}`);
      options.series.forEach((series) => {
        if (series[optionsKey]) {
          delete series[optionsKey];
        }
      });
    }
  }
  if (usedOptions.length) {
    let enterprisePackageName = "ag-charts-enterprise";
    let enterpriseReferenceUrl = "https://charts.ag-grid.com/javascript/installation/";
    if (options.mode === "integrated") {
      enterprisePackageName = "ag-grid-charts-enterprise' or 'ag-grid-enterprise/charts-enterprise";
      enterpriseReferenceUrl = "https://www.ag-grid.com/javascript-data-grid/integrated-charts-installation/";
    }
    Logger.warnOnce(
      [
        `unable to use these enterprise features as '${enterprisePackageName}' has not been loaded:`,
        "",
        ...usedOptions,
        "",
        `See: ${enterpriseReferenceUrl}`
      ].join("\n")
    );
  }
}
var init_processEnterpriseOptions = __esm({
  "packages/ag-charts-community/src/chart/factory/processEnterpriseOptions.ts"() {
    "use strict";
    init_logger();
    init_types2();
    init_chartTypes();
    init_expectedEnterpriseModules();
  }
});

// packages/ag-charts-community/src/util/properties.ts
function isProperties(value) {
  return value instanceof BaseProperties || value instanceof PropertiesArray;
}
var BaseProperties, PropertiesArray;
var init_properties = __esm({
  "packages/ag-charts-community/src/util/properties.ts"() {
    "use strict";
    init_decorator();
    init_logger();
    init_type_guards();
    BaseProperties = class {
      set(properties) {
        const { className = this.constructor.name } = this.constructor;
        if (typeof properties !== "object") {
          Logger.warn(`unable to set ${className} - expecting a properties object`);
          return this;
        }
        const keys = new Set(Object.keys(properties));
        for (const propertyKey of listDecoratedProperties(this)) {
          if (keys.has(propertyKey)) {
            const value = properties[propertyKey];
            const self = this;
            if (isProperties(self[propertyKey])) {
              self[propertyKey] = self[propertyKey] instanceof PropertiesArray ? self[propertyKey].reset(value) : self[propertyKey].set(value);
            } else {
              self[propertyKey] = value;
            }
            keys.delete(propertyKey);
          }
        }
        for (const unknownKey of keys) {
          Logger.warn(`unable to set [${unknownKey}] in ${className} - property is unknown`);
        }
        return this;
      }
      isValid() {
        return listDecoratedProperties(this).every((propertyKey) => {
          const { optional } = extractDecoratedPropertyMetadata(this, propertyKey);
          const valid = optional || typeof this[propertyKey] !== "undefined";
          if (!valid) {
            Logger.warnOnce(`[${propertyKey}] is required.`);
          }
          return valid;
        });
      }
      toJson() {
        return listDecoratedProperties(this).reduce((object, propertyKey) => {
          const propertyValue = this[propertyKey];
          object[propertyKey] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;
          return object;
        }, {});
      }
    };
    PropertiesArray = class _PropertiesArray extends Array {
      constructor(itemFactory, ...properties) {
        super(properties.length);
        Object.defineProperty(this, "itemFactory", { value: itemFactory, enumerable: false, configurable: false });
        this.set(properties);
      }
      set(properties) {
        if (isArray(properties)) {
          this.length = properties.length;
          for (let i = 0; i < properties.length; i++) {
            this[i] = new this.itemFactory().set(properties[i]);
          }
        }
        return this;
      }
      reset(properties) {
        return new _PropertiesArray(this.itemFactory, ...properties);
      }
      toJson() {
        return this.map((value) => {
          var _a2, _b;
          return (_b = (_a2 = value == null ? void 0 : value.toJson) == null ? void 0 : _a2.call(value)) != null ? _b : value;
        });
      }
    };
  }
});

// packages/ag-charts-community/src/util/json.ts
function jsonDiff(source, target, skip) {
  if (isArray(target)) {
    if (!isArray(source) || source.length !== target.length || target.some((v, i) => jsonDiff(source[i], v) != null)) {
      return target;
    }
  } else if (isPlainObject(target)) {
    if (!isPlainObject(source)) {
      return target;
    }
    const result = {};
    const allKeys = /* @__PURE__ */ new Set([
      ...Object.keys(source),
      ...Object.keys(target)
    ]);
    for (const key of allKeys) {
      if (source[key] === target[key] || (skip == null ? void 0 : skip.includes(key))) {
        continue;
      }
      if (typeof source[key] === typeof target[key]) {
        const diff8 = jsonDiff(source[key], target[key]);
        if (diff8 !== null) {
          result[key] = diff8;
        }
      } else {
        result[key] = target[key];
      }
    }
    return Object.keys(result).length ? result : null;
  } else if (source !== target) {
    return target;
  }
  return null;
}
function deepClone(source, options) {
  if (isArray(source)) {
    return source.map((item) => deepClone(item, options));
  }
  if (isPlainObject(source)) {
    return mapValues(
      source,
      (value, key) => {
        var _a2;
        return ((_a2 = options == null ? void 0 : options.shallow) == null ? void 0 : _a2.includes(key)) ? shallowClone(value) : deepClone(value, options);
      }
    );
  }
  return shallowClone(source);
}
function shallowClone(source) {
  if (isArray(source)) {
    return [...source];
  }
  if (isPlainObject(source)) {
    return __spreadValues({}, source);
  }
  if (isDate(source)) {
    return new Date(source);
  }
  if (isRegExp(source)) {
    return new RegExp(source.source, source.flags);
  }
  return source;
}
function jsonWalk(json, visit, opts, ...jsons) {
  var _a2;
  if (isArray(json)) {
    visit(json, ...jsons);
    json.forEach((node, index) => {
      jsonWalk(node, visit, opts, ...keyMapper(jsons, index));
    });
  } else if (isPlainObject(json)) {
    visit(json, ...jsons);
    for (const key of Object.keys(json)) {
      if ((_a2 = opts == null ? void 0 : opts.skip) == null ? void 0 : _a2.includes(key)) {
        continue;
      }
      const value = json[key];
      if (isArray(value) || isPlainObject(value)) {
        jsonWalk(value, visit, opts, ...keyMapper(jsons, key));
      }
    }
  }
}
function jsonApply(target, source, params = {}) {
  const { path, constructedArrays, matcherPath = path == null ? void 0 : path.replace(/(\[[0-9+]+])/i, "[]"), skip = [] } = params;
  if (target == null) {
    throw new Error(`AG Charts - target is uninitialised: ${path != null ? path : "<root>"}`);
  }
  if (source == null) {
    return target;
  }
  if (isProperties(target)) {
    return target.set(source);
  }
  const targetAny = target;
  const targetType = classify(target);
  for (const property in source) {
    if (SKIP_JS_BUILTINS.has(property))
      continue;
    const propertyMatcherPath = `${matcherPath ? matcherPath + "." : ""}${property}`;
    if (skip.includes(propertyMatcherPath))
      continue;
    const newValue = source[property];
    const propertyPath = `${path ? path + "." : ""}${property}`;
    const targetClass = targetAny.constructor;
    const currentValue = targetAny[property];
    let ctr;
    try {
      const currentValueType = classify(currentValue);
      const newValueType = classify(newValue);
      if (targetType === CLASS_INSTANCE_TYPE && !(property in target)) {
        Logger.warn(`unable to set [${propertyPath}] in ${targetClass == null ? void 0 : targetClass.name} - property is unknown`);
        continue;
      }
      if (currentValueType != null && newValueType != null && newValueType !== currentValueType && (currentValueType !== CLASS_INSTANCE_TYPE || newValueType !== "object")) {
        Logger.warn(
          `unable to set [${propertyPath}] in ${targetClass == null ? void 0 : targetClass.name} - can't apply type of [${newValueType}], allowed types are: [${currentValueType}]`
        );
        continue;
      }
      if (isProperties(currentValue)) {
        targetAny[property].set(newValue);
      } else if (newValueType === "array") {
        ctr != null ? ctr : ctr = constructedArrays == null ? void 0 : constructedArrays.get(currentValue);
        if (ctr == null) {
          targetAny[property] = newValue;
        } else {
          const newValueArray = newValue;
          targetAny[property] = newValueArray.map(
            (v) => jsonApply(new ctr(), v, __spreadProps(__spreadValues({}, params), {
              path: propertyPath,
              matcherPath: propertyMatcherPath + "[]"
            }))
          );
        }
      } else if (newValueType === CLASS_INSTANCE_TYPE) {
        targetAny[property] = newValue;
      } else if (newValueType === "object") {
        if (currentValue != null) {
          jsonApply(currentValue, newValue, __spreadProps(__spreadValues({}, params), {
            path: propertyPath,
            matcherPath: propertyMatcherPath
          }));
        } else if (ctr == null) {
          targetAny[property] = {};
          jsonApply(targetAny[property], newValue, __spreadProps(__spreadValues({}, params), {
            path: propertyPath,
            matcherPath: propertyMatcherPath
          }));
        } else {
          targetAny[property] = jsonApply(new ctr(), newValue, __spreadProps(__spreadValues({}, params), {
            path: propertyPath,
            matcherPath: propertyMatcherPath
          }));
        }
      } else {
        targetAny[property] = newValue;
      }
    } catch (error) {
      Logger.warn(`unable to set [${propertyPath}] in [${targetClass == null ? void 0 : targetClass.name}]; nested error is: ${error.message}`);
    }
  }
  return target;
}
function keyMapper(data, key) {
  return data.map((dataObject) => dataObject == null ? void 0 : dataObject[key]);
}
function classify(value) {
  if (value == null) {
    return null;
  }
  if (isHtmlElement(value) || isDate(value)) {
    return "primitive";
  }
  if (isArray(value)) {
    return "array";
  }
  if (isObject(value)) {
    return isPlainObject(value) ? "object" : CLASS_INSTANCE_TYPE;
  }
  if (isFunction(value)) {
    return "function";
  }
  return "primitive";
}
var CLASS_INSTANCE_TYPE;
var init_json = __esm({
  "packages/ag-charts-community/src/util/json.ts"() {
    "use strict";
    init_logger();
    init_object();
    init_properties();
    init_type_guards();
    CLASS_INSTANCE_TYPE = "class-instance";
  }
});

// packages/ag-charts-community/src/chart/factory/seriesRegistry.ts
var SeriesRegistry, seriesRegistry;
var init_seriesRegistry = __esm({
  "packages/ag-charts-community/src/chart/factory/seriesRegistry.ts"() {
    "use strict";
    init_enterpriseModule();
    init_json();
    init_object();
    init_chartTypes();
    SeriesRegistry = class {
      constructor() {
        this.seriesMap = /* @__PURE__ */ new Map();
        this.themeTemplates = /* @__PURE__ */ new Map();
      }
      register(seriesType, {
        chartTypes: [chartType2],
        instanceConstructor,
        defaultAxes,
        themeTemplate,
        enterpriseThemeTemplate,
        paletteFactory,
        solo,
        stackable,
        groupable,
        stackedByDefault,
        swapDefaultAxesCondition,
        hidden
      }) {
        this.setThemeTemplate(seriesType, themeTemplate, enterpriseThemeTemplate);
        this.seriesMap.set(seriesType, {
          instanceConstructor,
          defaultAxes,
          paletteFactory,
          solo,
          stackable,
          groupable,
          stackedByDefault,
          swapDefaultAxesCondition
        });
        chartTypes.set(seriesType, chartType2);
        if (!hidden) {
          publicChartTypes.set(seriesType, chartType2);
        }
      }
      create(seriesType, moduleContext) {
        var _a2;
        const SeriesConstructor = (_a2 = this.seriesMap.get(seriesType)) == null ? void 0 : _a2.instanceConstructor;
        if (SeriesConstructor) {
          return new SeriesConstructor(moduleContext);
        }
        throw new Error(`AG Charts - unknown series type: ${seriesType}`);
      }
      cloneDefaultAxes(seriesType) {
        var _a2;
        const defaultAxes = (_a2 = this.seriesMap.get(seriesType)) == null ? void 0 : _a2.defaultAxes;
        return defaultAxes ? { axes: deepClone(defaultAxes) } : null;
      }
      setThemeTemplate(seriesType, themeTemplate, enterpriseThemeTemplate = {}) {
        const currentTemplate = this.themeTemplates.get(seriesType);
        this.themeTemplates.set(seriesType, {
          community: mergeDefaults(themeTemplate, currentTemplate == null ? void 0 : currentTemplate.community),
          enterprise: mergeDefaults(enterpriseThemeTemplate, themeTemplate, currentTemplate == null ? void 0 : currentTemplate.community)
        });
      }
      getThemeTemplate(seriesType) {
        const themeTemplate = this.themeTemplates.get(seriesType);
        return enterpriseModule.isEnterprise ? themeTemplate == null ? void 0 : themeTemplate.enterprise : themeTemplate == null ? void 0 : themeTemplate.community;
      }
      getPaletteFactory(seriesType) {
        var _a2;
        return (_a2 = this.seriesMap.get(seriesType)) == null ? void 0 : _a2.paletteFactory;
      }
      isSolo(seriesType) {
        var _a2, _b;
        return (_b = (_a2 = this.seriesMap.get(seriesType)) == null ? void 0 : _a2.solo) != null ? _b : false;
      }
      isGroupable(seriesType) {
        var _a2, _b;
        return (_b = (_a2 = this.seriesMap.get(seriesType)) == null ? void 0 : _a2.groupable) != null ? _b : false;
      }
      isStackable(seriesType) {
        var _a2, _b;
        return (_b = (_a2 = this.seriesMap.get(seriesType)) == null ? void 0 : _a2.stackable) != null ? _b : false;
      }
      isStackedByDefault(seriesType) {
        var _a2, _b;
        return (_b = (_a2 = this.seriesMap.get(seriesType)) == null ? void 0 : _a2.stackedByDefault) != null ? _b : false;
      }
      isDefaultAxisSwapNeeded(options) {
        var _a2, _b, _c;
        let result;
        for (const series of (_a2 = options.series) != null ? _a2 : []) {
          const { type = "line" } = series;
          const isDefaultAxisSwapped = (_c = (_b = this.seriesMap.get(type)) == null ? void 0 : _b.swapDefaultAxesCondition) == null ? void 0 : _c.call(_b, series);
          if (isDefaultAxisSwapped != null) {
            if (result != null && result != isDefaultAxisSwapped) {
              throw new Error("AG Charts - The provided series have incompatible directions");
            }
            result = isDefaultAxisSwapped;
          }
        }
        return result;
      }
    };
    seriesRegistry = new SeriesRegistry();
  }
});

// packages/ag-charts-community/src/chart/factory/legendRegistry.ts
var LegendRegistry, legendRegistry;
var init_legendRegistry = __esm({
  "packages/ag-charts-community/src/chart/factory/legendRegistry.ts"() {
    "use strict";
    LegendRegistry = class {
      constructor() {
        this.legendMap = /* @__PURE__ */ new Map();
        this.themeTemplates = /* @__PURE__ */ new Map();
      }
      register(legendType, { optionsKey, instanceConstructor, themeTemplate }) {
        this.legendMap.set(legendType, { optionsKey, instanceConstructor });
        this.themeTemplates.set(optionsKey, themeTemplate);
      }
      create(legendType, moduleContext) {
        var _a2;
        const LegendConstructor = (_a2 = this.legendMap.get(legendType)) == null ? void 0 : _a2.instanceConstructor;
        if (LegendConstructor) {
          return new LegendConstructor(moduleContext);
        }
        throw new Error(`AG Charts - unknown legend type: ${legendType}`);
      }
      getThemeTemplates() {
        return Object.fromEntries(this.themeTemplates);
      }
      getKeys() {
        return Array.from(this.legendMap.entries()).reduce(
          (result, [legendType, record]) => {
            result[legendType] = record.optionsKey;
            return result;
          },
          {}
        );
      }
    };
    legendRegistry = new LegendRegistry();
  }
});

// packages/ag-charts-community/src/chart/themes/constants.ts
var FONT_SIZE, FONT_WEIGHT, POSITION, CARTESIAN_AXIS_TYPE, POLAR_AXIS_TYPE, POLAR_AXIS_SHAPE;
var init_constants = __esm({
  "packages/ag-charts-community/src/chart/themes/constants.ts"() {
    "use strict";
    FONT_SIZE = /* @__PURE__ */ ((FONT_SIZE2) => {
      FONT_SIZE2[FONT_SIZE2["SMALL"] = 12] = "SMALL";
      FONT_SIZE2[FONT_SIZE2["MEDIUM"] = 13] = "MEDIUM";
      FONT_SIZE2[FONT_SIZE2["LARGE"] = 17] = "LARGE";
      return FONT_SIZE2;
    })(FONT_SIZE || {});
    FONT_WEIGHT = /* @__PURE__ */ ((FONT_WEIGHT4) => {
      FONT_WEIGHT4["NORMAL"] = "normal";
      FONT_WEIGHT4["BOLD"] = "bold";
      FONT_WEIGHT4["BOLDER"] = "bolder";
      FONT_WEIGHT4["LIGHTER"] = "lighter";
      return FONT_WEIGHT4;
    })(FONT_WEIGHT || {});
    POSITION = /* @__PURE__ */ ((POSITION4) => {
      POSITION4["TOP"] = "top";
      POSITION4["RIGHT"] = "right";
      POSITION4["BOTTOM"] = "bottom";
      POSITION4["LEFT"] = "left";
      return POSITION4;
    })(POSITION || {});
    CARTESIAN_AXIS_TYPE = /* @__PURE__ */ ((CARTESIAN_AXIS_TYPE2) => {
      CARTESIAN_AXIS_TYPE2["CATEGORY"] = "category";
      CARTESIAN_AXIS_TYPE2["ORDINAL_TIME"] = "ordinal-time";
      CARTESIAN_AXIS_TYPE2["NUMBER"] = "number";
      CARTESIAN_AXIS_TYPE2["TIME"] = "time";
      CARTESIAN_AXIS_TYPE2["LOG"] = "log";
      return CARTESIAN_AXIS_TYPE2;
    })(CARTESIAN_AXIS_TYPE || {});
    POLAR_AXIS_TYPE = /* @__PURE__ */ ((POLAR_AXIS_TYPE2) => {
      POLAR_AXIS_TYPE2["ANGLE_CATEGORY"] = "angle-category";
      POLAR_AXIS_TYPE2["ANGLE_NUMBER"] = "angle-number";
      POLAR_AXIS_TYPE2["RADIUS_CATEGORY"] = "radius-category";
      POLAR_AXIS_TYPE2["RADIUS_NUMBER"] = "radius-number";
      return POLAR_AXIS_TYPE2;
    })(POLAR_AXIS_TYPE || {});
    POLAR_AXIS_SHAPE = /* @__PURE__ */ ((POLAR_AXIS_SHAPE2) => {
      POLAR_AXIS_SHAPE2["CIRCLE"] = "circle";
      POLAR_AXIS_SHAPE2["POLYGON"] = "polygon";
      return POLAR_AXIS_SHAPE2;
    })(POLAR_AXIS_SHAPE || {});
  }
});

// packages/ag-charts-community/src/chart/themes/defaultColors.ts
var DEFAULT_FILLS, DEFAULT_STROKES;
var init_defaultColors = __esm({
  "packages/ag-charts-community/src/chart/themes/defaultColors.ts"() {
    "use strict";
    DEFAULT_FILLS = {
      BLUE: "#5090dc",
      ORANGE: "#ffa03a",
      GREEN: "#459d55",
      CYAN: "#34bfe1",
      YELLOW: "#e1cc00",
      VIOLET: "#9669cb",
      GRAY: "#b5b5b5",
      MAGENTA: "#bd5aa7",
      BROWN: "#8a6224",
      RED: "#ef5452"
    };
    DEFAULT_STROKES = {
      BLUE: "#2b5c95",
      ORANGE: "#cc6f10",
      GREEN: "#1e652e",
      CYAN: "#18859e",
      YELLOW: "#a69400",
      VIOLET: "#603c88",
      GRAY: "#575757",
      MAGENTA: "#7d2f6d",
      BROWN: "#4f3508",
      RED: "#a82529"
    };
  }
});

// packages/ag-charts-community/src/chart/themes/symbols.ts
var IS_DARK_THEME, EXTENDS_AXES_DEFAULTS, EXTENDS_AXES_LINE_DEFAULTS, EXTENDS_AXES_TICK_DEFAULTS, EXTENDS_AXES_GRID_LINE_DEFAULTS, EXTENDS_SERIES_DEFAULTS, EXTENDS_CARTESIAN_MARKER_DEFAULTS, DEFAULT_FONT_FAMILY, DEFAULT_LABEL_COLOUR, DEFAULT_INVERTED_LABEL_COLOUR, DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_MUTED_LABEL_COLOUR, DEFAULT_AXIS_GRID_COLOUR, DEFAULT_AXIS_LINE_COLOUR, DEFAULT_CROSS_LINES_COLOUR, DEFAULT_BACKGROUND_COLOUR, DEFAULT_SHADOW_COLOUR, DEFAULT_COLOURS, DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, DEFAULT_HIERARCHY_FILLS, DEFAULT_HIERARCHY_STROKES, DEFAULT_ANNOTATION_STROKE, DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_ANNOTATION_HANDLE_FILL;
var init_symbols = __esm({
  "packages/ag-charts-community/src/chart/themes/symbols.ts"() {
    "use strict";
    IS_DARK_THEME = Symbol("is-dark-theme");
    EXTENDS_AXES_DEFAULTS = Symbol("extends-axes-defaults");
    EXTENDS_AXES_LINE_DEFAULTS = Symbol("extends-axes-line-defaults");
    EXTENDS_AXES_TICK_DEFAULTS = Symbol("extends-axes-tick-defaults");
    EXTENDS_AXES_GRID_LINE_DEFAULTS = Symbol("extends-axes-grid-line-defaults");
    EXTENDS_SERIES_DEFAULTS = Symbol("extends-series-defaults");
    EXTENDS_CARTESIAN_MARKER_DEFAULTS = Symbol("extends-cartesian-marker-defaults");
    DEFAULT_FONT_FAMILY = Symbol("default-font");
    DEFAULT_LABEL_COLOUR = Symbol("default-label-colour");
    DEFAULT_INVERTED_LABEL_COLOUR = Symbol("default-inverted-label-colour");
    DEFAULT_INSIDE_SERIES_LABEL_COLOUR = Symbol("default-inside-series-label-colour");
    DEFAULT_MUTED_LABEL_COLOUR = Symbol("default-muted-label-colour");
    DEFAULT_AXIS_GRID_COLOUR = Symbol("default-axis-grid-colour");
    DEFAULT_AXIS_LINE_COLOUR = Symbol("default-axis-line-colour");
    DEFAULT_CROSS_LINES_COLOUR = Symbol("default-cross-lines-colour");
    DEFAULT_BACKGROUND_COLOUR = Symbol("default-background-colour");
    DEFAULT_SHADOW_COLOUR = Symbol("default-shadow-colour");
    DEFAULT_COLOURS = Symbol("default-colours");
    DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS = Symbol(
      "default-waterfall-series-positive-colors"
    );
    DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS = Symbol(
      "default-waterfall-series-negative-colors"
    );
    DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS = Symbol(
      "default-waterfall-series-total-colors"
    );
    DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE = Symbol(
      "default-waterfall-series-connector-line-stroke"
    );
    DEFAULT_POLAR_SERIES_STROKE = Symbol("default-polar-series-stroke");
    DEFAULT_DIVERGING_SERIES_COLOUR_RANGE = Symbol(
      "default-diverging-series-colour-range"
    );
    DEFAULT_HIERARCHY_FILLS = Symbol("default-hierarchy-fills");
    DEFAULT_HIERARCHY_STROKES = Symbol("default-hierarchy-strokes");
    DEFAULT_ANNOTATION_STROKE = Symbol("default-annotation-stroke");
    DEFAULT_ANNOTATION_BACKGROUND_FILL = Symbol("default-annotation-background-fill");
    DEFAULT_ANNOTATION_HANDLE_FILL = Symbol("default-annotation-handle-fill");
  }
});

// packages/ag-charts-community/src/chart/themes/chartTheme.ts
var DEFAULT_BACKGROUND_FILL, DEFAULT_PALETTE, CHART_TYPE_CONFIG, CHART_TYPE_SPECIFIC_COMMON_OPTIONS, _ChartTheme, ChartTheme;
var init_chartTheme = __esm({
  "packages/ag-charts-community/src/chart/themes/chartTheme.ts"() {
    "use strict";
    init_json();
    init_object();
    init_type_guards();
    init_axisRegistry();
    init_chartTypes();
    init_legendRegistry();
    init_seriesRegistry();
    init_constants();
    init_defaultColors();
    init_symbols();
    DEFAULT_BACKGROUND_FILL = "white";
    DEFAULT_PALETTE = {
      fills: Object.values(DEFAULT_FILLS),
      strokes: Object.values(DEFAULT_STROKES)
    };
    CHART_TYPE_CONFIG = {
      get cartesian() {
        return { seriesTypes: chartTypes.cartesianTypes, commonOptions: ["zoom", "navigator"] };
      },
      get polar() {
        return { seriesTypes: chartTypes.polarTypes, commonOptions: [] };
      },
      get hierarchy() {
        return { seriesTypes: chartTypes.hierarchyTypes, commonOptions: [] };
      },
      get topology() {
        return { seriesTypes: chartTypes.topologyTypes, commonOptions: [] };
      }
    };
    CHART_TYPE_SPECIFIC_COMMON_OPTIONS = Object.values(CHART_TYPE_CONFIG).reduce((r, { commonOptions }) => r.concat(commonOptions), []);
    _ChartTheme = class _ChartTheme {
      getPalette() {
        return DEFAULT_PALETTE;
      }
      static getAxisDefaults(overrideDefaults) {
        return mergeDefaults(overrideDefaults, {
          title: {
            enabled: false,
            text: "Axis Title",
            spacing: 25,
            fontWeight: "normal" /* NORMAL */,
            fontSize: 13 /* MEDIUM */,
            fontFamily: DEFAULT_FONT_FAMILY,
            color: DEFAULT_LABEL_COLOUR
          },
          label: {
            fontSize: 12 /* SMALL */,
            fontFamily: DEFAULT_FONT_FAMILY,
            padding: 5,
            color: DEFAULT_LABEL_COLOUR,
            avoidCollisions: true
          },
          line: {
            enabled: true,
            width: 1,
            color: DEFAULT_AXIS_LINE_COLOUR
          },
          tick: {
            enabled: false,
            width: 1,
            color: DEFAULT_AXIS_LINE_COLOUR
          },
          gridLine: {
            enabled: true,
            style: [{ stroke: DEFAULT_AXIS_GRID_COLOUR, lineDash: [] }]
          },
          crossLines: {
            enabled: false,
            fill: DEFAULT_CROSS_LINES_COLOUR,
            stroke: DEFAULT_CROSS_LINES_COLOUR,
            fillOpacity: 0.1,
            strokeWidth: 1,
            label: {
              enabled: false,
              fontSize: 12 /* SMALL */,
              fontFamily: DEFAULT_FONT_FAMILY,
              padding: 5,
              color: DEFAULT_LABEL_COLOUR
            }
          }
        });
      }
      static getSeriesDefaults() {
        return {
          visible: true,
          showInLegend: true,
          highlightStyle: {
            item: { fill: "#ffffff54", stroke: `#0006`, strokeWidth: 2 },
            series: { dimOpacity: 1 }
          },
          nodeClickRange: "exact",
          tooltip: { enabled: true }
        };
      }
      static getCartesianSeriesMarkerDefaults() {
        return { enabled: true, shape: "circle", size: 7, strokeWidth: 1 };
      }
      static getChartDefaults() {
        return {
          background: { visible: true, fill: DEFAULT_BACKGROUND_COLOUR },
          padding: { top: 20, right: 20, bottom: 20, left: 20 },
          keyboard: { enabled: true },
          title: {
            enabled: false,
            text: "Title",
            fontWeight: "normal" /* NORMAL */,
            fontSize: 17 /* LARGE */,
            fontFamily: DEFAULT_FONT_FAMILY,
            color: DEFAULT_LABEL_COLOUR,
            wrapping: "hyphenate"
          },
          subtitle: {
            enabled: false,
            text: "Subtitle",
            spacing: 20,
            fontSize: 13 /* MEDIUM */,
            fontFamily: DEFAULT_FONT_FAMILY,
            color: DEFAULT_MUTED_LABEL_COLOUR,
            wrapping: "hyphenate"
          },
          footnote: {
            enabled: false,
            text: "Footnote",
            spacing: 20,
            fontSize: 13 /* MEDIUM */,
            fontFamily: DEFAULT_FONT_FAMILY,
            color: "rgb(140, 140, 140)",
            wrapping: "hyphenate"
          },
          legend: {
            position: "bottom" /* BOTTOM */,
            spacing: 30,
            listeners: {},
            item: {
              paddingX: 16,
              paddingY: 8,
              marker: { size: 15, padding: 8 },
              toggleSeriesVisible: true,
              label: {
                color: DEFAULT_LABEL_COLOUR,
                fontSize: 12 /* SMALL */,
                fontFamily: DEFAULT_FONT_FAMILY
              }
            },
            reverseOrder: false,
            pagination: {
              marker: { size: 12 },
              activeStyle: { fill: DEFAULT_LABEL_COLOUR },
              inactiveStyle: { fill: DEFAULT_MUTED_LABEL_COLOUR },
              highlightStyle: { fill: DEFAULT_LABEL_COLOUR },
              label: { color: DEFAULT_LABEL_COLOUR }
            }
          },
          tooltip: {
            enabled: true,
            darkTheme: IS_DARK_THEME,
            range: "nearest",
            delay: 0
          },
          overlays: {
            loading: { darkTheme: IS_DARK_THEME },
            noData: { darkTheme: IS_DARK_THEME },
            noVisibleSeries: { darkTheme: IS_DARK_THEME }
          },
          listeners: {}
        };
      }
      constructor(options = {}) {
        const { overrides, palette: palette10 } = deepClone(options);
        const defaults = this.createChartConfigPerChartType(this.getDefaults());
        if (overrides) {
          this.mergeOverrides(defaults, overrides);
        }
        this.config = Object.freeze(this.templateTheme(defaults));
        this.palette = mergeDefaults(palette10, this.getPalette());
      }
      mergeOverrides(defaults, overrides) {
        for (const { seriesTypes, commonOptions } of Object.values(CHART_TYPE_CONFIG)) {
          const cleanedCommon = __spreadValues({}, overrides.common);
          for (const commonKey of CHART_TYPE_SPECIFIC_COMMON_OPTIONS) {
            if (!commonOptions.includes(commonKey)) {
              delete cleanedCommon[commonKey];
            }
          }
          if (!cleanedCommon)
            continue;
          for (const s of seriesTypes) {
            const seriesType = s;
            defaults[seriesType] = mergeDefaults(cleanedCommon, defaults[seriesType]);
          }
        }
        chartTypes.seriesTypes.forEach((s) => {
          const seriesType = s;
          if (overrides[seriesType]) {
            defaults[seriesType] = mergeDefaults(overrides[seriesType], defaults[seriesType]);
          }
        });
      }
      createChartConfigPerChartType(config) {
        for (const [nextType, { seriesTypes }] of Object.entries(CHART_TYPE_CONFIG)) {
          const typeDefaults = chartDefaults.get(nextType);
          for (const seriesType of seriesTypes) {
            config[seriesType] || (config[seriesType] = deepClone(typeDefaults));
          }
        }
        return config;
      }
      getDefaults() {
        const getOverridesByType = (chartType2, seriesTypes) => {
          var _a2;
          const result = {};
          const chartTypeDefaults = __spreadValues(__spreadValues(__spreadValues({
            axes: {}
          }, legendRegistry.getThemeTemplates()), _ChartTheme.getChartDefaults()), chartDefaults.get(chartType2));
          for (const seriesType of seriesTypes) {
            result[seriesType] = mergeDefaults(
              seriesRegistry.getThemeTemplate(seriesType),
              (_a2 = result[seriesType]) != null ? _a2 : deepClone(chartTypeDefaults)
            );
            const { axes } = result[seriesType];
            for (const axisType of axisRegistry.keys()) {
              axes[axisType] = mergeDefaults(
                axes[axisType],
                axisRegistry.getThemeTemplate(axisType),
                chartType2 === "cartesian" && _ChartTheme.cartesianAxisDefault[axisType]
              );
            }
          }
          return result;
        };
        return mergeDefaults(
          getOverridesByType("cartesian", chartTypes.cartesianTypes),
          getOverridesByType("polar", chartTypes.polarTypes),
          getOverridesByType("hierarchy", chartTypes.hierarchyTypes),
          getOverridesByType("topology", chartTypes.topologyTypes)
        );
      }
      templateTheme(themeTemplate) {
        const themeInstance = deepClone(themeTemplate);
        const { extensions, properties } = this.getTemplateParameters();
        jsonWalk(themeInstance, (node) => {
          if (node["__extends__"]) {
            const extendsValue = node["__extends__"];
            const source = extensions.get(extendsValue);
            if (source == null) {
              throw new Error(`AG Charts - no template variable provided for: ${extendsValue}`);
            }
            Object.keys(source).forEach((key) => {
              if (!(key in node)) {
                node[key] = source[key];
              } else if (isObject(node[key])) {
                node[key] = mergeDefaults(node[key], source[key]);
              }
            });
            delete node["__extends__"];
          }
          if (isArray(node)) {
            for (let i = 0; i < node.length; i++) {
              const symbol = node[i];
              if (properties.has(symbol)) {
                node[i] = properties.get(symbol);
              }
            }
          } else {
            for (const [name, value] of Object.entries(node)) {
              if (properties.has(value)) {
                node[name] = properties.get(value);
              }
            }
          }
        });
        return deepClone(themeInstance);
      }
      static getDefaultColors() {
        return {
          fills: DEFAULT_FILLS,
          strokes: DEFAULT_STROKES
        };
      }
      static getWaterfallSeriesDefaultPositiveColors() {
        return {
          fill: DEFAULT_FILLS.BLUE,
          stroke: DEFAULT_STROKES.BLUE,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      static getWaterfallSeriesDefaultNegativeColors() {
        return {
          fill: DEFAULT_FILLS.ORANGE,
          stroke: DEFAULT_STROKES.ORANGE,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      static getWaterfallSeriesDefaultTotalColors() {
        return {
          fill: DEFAULT_FILLS.GRAY,
          stroke: DEFAULT_STROKES.GRAY,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      getTemplateParameters() {
        const extensions = /* @__PURE__ */ new Map();
        extensions.set(EXTENDS_AXES_DEFAULTS, _ChartTheme.getAxisDefaults());
        extensions.set(EXTENDS_AXES_LINE_DEFAULTS, _ChartTheme.getAxisDefaults().line);
        extensions.set(EXTENDS_AXES_TICK_DEFAULTS, _ChartTheme.getAxisDefaults().tick);
        extensions.set(EXTENDS_AXES_GRID_LINE_DEFAULTS, _ChartTheme.getAxisDefaults().gridLine);
        extensions.set(EXTENDS_SERIES_DEFAULTS, _ChartTheme.getSeriesDefaults());
        extensions.set(EXTENDS_CARTESIAN_MARKER_DEFAULTS, _ChartTheme.getCartesianSeriesMarkerDefaults());
        const properties = /* @__PURE__ */ new Map();
        properties.set(IS_DARK_THEME, false);
        properties.set(DEFAULT_FONT_FAMILY, "Verdana, sans-serif");
        properties.set(DEFAULT_LABEL_COLOUR, "rgb(70, 70, 70)");
        properties.set(DEFAULT_INVERTED_LABEL_COLOUR, "white");
        properties.set(DEFAULT_MUTED_LABEL_COLOUR, "rgb(140, 140, 140)");
        properties.set(DEFAULT_AXIS_GRID_COLOUR, "rgb(224,234,241)");
        properties.set(DEFAULT_AXIS_LINE_COLOUR, "rgb(195, 195, 195)");
        properties.set(DEFAULT_CROSS_LINES_COLOUR, "rgb(70, 70, 70)");
        properties.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_BACKGROUND_FILL);
        properties.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_BACKGROUND_FILL);
        properties.set(DEFAULT_SHADOW_COLOUR, "rgba(0, 0, 0, 0.5)");
        properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
          DEFAULT_FILLS.ORANGE,
          DEFAULT_FILLS.YELLOW,
          DEFAULT_FILLS.GREEN
        ]);
        properties.set(DEFAULT_HIERARCHY_FILLS, ["#ffffff", "#e0e5ea", "#c1ccd5", "#a3b4c1", "#859cad"]);
        properties.set(DEFAULT_HIERARCHY_STROKES, ["#ffffff", "#c5cbd1", "#a4b1bd", "#8498a9", "#648096"]);
        properties.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);
        properties.set(DEFAULT_COLOURS, _ChartTheme.getDefaultColors());
        properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, _ChartTheme.getWaterfallSeriesDefaultPositiveColors());
        properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, _ChartTheme.getWaterfallSeriesDefaultNegativeColors());
        properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, _ChartTheme.getWaterfallSeriesDefaultTotalColors());
        properties.set(
          DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
          _ChartTheme.getWaterfallSeriesDefaultTotalColors().stroke
        );
        properties.set(DEFAULT_ANNOTATION_STROKE, DEFAULT_STROKES.BLUE);
        properties.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_FILLS.BLUE);
        properties.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_BACKGROUND_FILL);
        return {
          extensions,
          properties
        };
      }
    };
    _ChartTheme.cartesianAxisDefault = {
      ["number" /* NUMBER */]: _ChartTheme.getAxisDefaults({ line: { enabled: false } }),
      ["log" /* LOG */]: _ChartTheme.getAxisDefaults({ base: 10, line: { enabled: false } }),
      ["category" /* CATEGORY */]: _ChartTheme.getAxisDefaults({
        groupPaddingInner: 0.1,
        label: { autoRotate: true },
        gridLine: { enabled: false }
      }),
      ["time" /* TIME */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: false } }),
      "grouped-category": _ChartTheme.getAxisDefaults()
    };
    ChartTheme = _ChartTheme;
  }
});

// packages/ag-charts-community/src/chart/themes/darkTheme.ts
var DEFAULT_DARK_BACKGROUND_FILL, DEFAULT_DARK_FILLS, DEFAULT_DARK_STROKES, palette, DarkTheme;
var init_darkTheme = __esm({
  "packages/ag-charts-community/src/chart/themes/darkTheme.ts"() {
    "use strict";
    init_chartTheme();
    init_symbols();
    DEFAULT_DARK_BACKGROUND_FILL = "#192232";
    DEFAULT_DARK_FILLS = {
      BLUE: "#5090dc",
      ORANGE: "#ffa03a",
      GREEN: "#459d55",
      CYAN: "#34bfe1",
      YELLOW: "#e1cc00",
      VIOLET: "#9669cb",
      GRAY: "#b5b5b5",
      MAGENTA: "#bd5aa7",
      BROWN: "#8a6224",
      RED: "#ef5452"
    };
    DEFAULT_DARK_STROKES = {
      BLUE: "#74a8e6",
      ORANGE: "#ffbe70",
      GREEN: "#6cb176",
      CYAN: "#75d4ef",
      YELLOW: "#f6e559",
      VIOLET: "#aa86d8",
      GRAY: "#a1a1a1",
      MAGENTA: "#ce7ab9",
      BROWN: "#997b52",
      RED: "#ff7872"
    };
    palette = {
      fills: Object.values(DEFAULT_DARK_FILLS),
      strokes: Object.values(DEFAULT_DARK_STROKES)
    };
    DarkTheme = class _DarkTheme extends ChartTheme {
      static getDefaultColors() {
        return {
          fills: DEFAULT_DARK_FILLS,
          strokes: DEFAULT_DARK_STROKES
        };
      }
      static getWaterfallSeriesDefaultPositiveColors() {
        return {
          fill: DEFAULT_DARK_FILLS.BLUE,
          stroke: DEFAULT_DARK_STROKES.BLUE,
          label: {
            color: "white"
          }
        };
      }
      static getWaterfallSeriesDefaultNegativeColors() {
        return {
          fill: DEFAULT_DARK_FILLS.ORANGE,
          stroke: DEFAULT_DARK_STROKES.ORANGE,
          label: {
            color: "white"
          }
        };
      }
      static getWaterfallSeriesDefaultTotalColors() {
        return {
          fill: DEFAULT_DARK_FILLS.GRAY,
          stroke: DEFAULT_DARK_STROKES.GRAY,
          label: {
            color: "white"
          }
        };
      }
      getTemplateParameters() {
        const result = super.getTemplateParameters();
        result.properties.set(IS_DARK_THEME, true);
        result.properties.set(DEFAULT_COLOURS, _DarkTheme.getDefaultColors());
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
          _DarkTheme.getWaterfallSeriesDefaultPositiveColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
          _DarkTheme.getWaterfallSeriesDefaultNegativeColors()
        );
        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, _DarkTheme.getWaterfallSeriesDefaultTotalColors());
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
          _DarkTheme.getWaterfallSeriesDefaultTotalColors().stroke
        );
        result.properties.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);
        result.properties.set(DEFAULT_LABEL_COLOUR, "white");
        result.properties.set(DEFAULT_MUTED_LABEL_COLOUR, "#7D91A0");
        result.properties.set(DEFAULT_AXIS_GRID_COLOUR, "#545A6E");
        result.properties.set(DEFAULT_CROSS_LINES_COLOUR, "white");
        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
          DEFAULT_DARK_FILLS.ORANGE,
          DEFAULT_DARK_FILLS.YELLOW,
          DEFAULT_DARK_FILLS.GREEN
        ]);
        result.properties.set(DEFAULT_HIERARCHY_FILLS, ["#192834", "#253746", "#324859", "#3f596c", "#4d6a80"]);
        result.properties.set(DEFAULT_HIERARCHY_STROKES, ["#192834", "#3b5164", "#496275", "#577287", "#668399"]);
        result.properties.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);
        result.properties.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);
        result.properties.set(DEFAULT_ANNOTATION_STROKE, DEFAULT_DARK_STROKES.BLUE);
        result.properties.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_DARK_FILLS.BLUE);
        result.properties.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_DARK_BACKGROUND_FILL);
        return result;
      }
      getPalette() {
        return palette;
      }
      constructor(options) {
        super(options);
      }
    };
  }
});

// packages/ag-charts-community/src/chart/themes/materialDark.ts
var MATERIAL_DARK_FILLS, MATERIAL_DARK_STROKES, palette2, MaterialDark;
var init_materialDark = __esm({
  "packages/ag-charts-community/src/chart/themes/materialDark.ts"() {
    "use strict";
    init_darkTheme();
    init_symbols();
    MATERIAL_DARK_FILLS = {
      BLUE: "#2196F3",
      ORANGE: "#FF9800",
      GREEN: "#4CAF50",
      CYAN: "#00BCD4",
      YELLOW: "#FFEB3B",
      VIOLET: "#7E57C2",
      GRAY: "#9E9E9E",
      MAGENTA: "#F06292",
      BROWN: "#795548",
      RED: "#F44336"
    };
    MATERIAL_DARK_STROKES = {
      BLUE: "#90CAF9",
      ORANGE: "#FFCC80",
      GREEN: "#A5D6A7",
      CYAN: "#80DEEA",
      YELLOW: "#FFF9C4",
      VIOLET: "#B39DDB",
      GRAY: "#E0E0E0",
      MAGENTA: "#F48FB1",
      BROWN: "#A1887F",
      RED: "#EF9A9A"
    };
    palette2 = {
      fills: Object.values(MATERIAL_DARK_FILLS),
      strokes: Object.values(MATERIAL_DARK_STROKES)
    };
    MaterialDark = class _MaterialDark extends DarkTheme {
      static getDefaultColors() {
        return {
          fills: MATERIAL_DARK_FILLS,
          strokes: MATERIAL_DARK_STROKES
        };
      }
      static getWaterfallSeriesDefaultPositiveColors() {
        return {
          fill: MATERIAL_DARK_FILLS.BLUE,
          stroke: MATERIAL_DARK_STROKES.BLUE,
          label: {
            color: "white"
          }
        };
      }
      static getWaterfallSeriesDefaultNegativeColors() {
        return {
          fill: MATERIAL_DARK_FILLS.RED,
          stroke: MATERIAL_DARK_STROKES.RED,
          label: {
            color: "white"
          }
        };
      }
      static getWaterfallSeriesDefaultTotalColors() {
        return {
          fill: MATERIAL_DARK_FILLS.GRAY,
          stroke: MATERIAL_DARK_STROKES.GRAY,
          label: {
            color: "white"
          }
        };
      }
      getTemplateParameters() {
        const result = super.getTemplateParameters();
        result.properties.set(DEFAULT_COLOURS, _MaterialDark.getDefaultColors());
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
          _MaterialDark.getWaterfallSeriesDefaultPositiveColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
          _MaterialDark.getWaterfallSeriesDefaultNegativeColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
          _MaterialDark.getWaterfallSeriesDefaultTotalColors()
        );
        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
          MATERIAL_DARK_FILLS.ORANGE,
          MATERIAL_DARK_FILLS.YELLOW,
          MATERIAL_DARK_FILLS.GREEN
        ]);
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
          _MaterialDark.getWaterfallSeriesDefaultTotalColors().stroke
        );
        result.properties.set(DEFAULT_ANNOTATION_STROKE, MATERIAL_DARK_STROKES.BLUE);
        result.properties.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_DARK_FILLS.BLUE);
        return result;
      }
      getPalette() {
        return palette2;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/themes/materialLight.ts
var MATERIAL_LIGHT_FILLS, MATERIAL_LIGHT_STROKES, palette3, MaterialLight;
var init_materialLight = __esm({
  "packages/ag-charts-community/src/chart/themes/materialLight.ts"() {
    "use strict";
    init_chartTheme();
    init_symbols();
    MATERIAL_LIGHT_FILLS = {
      BLUE: "#2196F3",
      ORANGE: "#FF9800",
      GREEN: "#4CAF50",
      CYAN: "#00BCD4",
      YELLOW: "#FFEB3B",
      VIOLET: "#7E57C2",
      GRAY: "#9E9E9E",
      MAGENTA: "#F06292",
      BROWN: "#795548",
      RED: "#F44336"
    };
    MATERIAL_LIGHT_STROKES = {
      BLUE: "#1565C0",
      ORANGE: "#E65100",
      GREEN: "#2E7D32",
      CYAN: "#00838F",
      YELLOW: "#F9A825",
      VIOLET: "#4527A0",
      GRAY: "#616161",
      MAGENTA: "#C2185B",
      BROWN: "#4E342E",
      RED: "#B71C1C"
    };
    palette3 = {
      fills: Object.values(MATERIAL_LIGHT_FILLS),
      strokes: Object.values(MATERIAL_LIGHT_STROKES)
    };
    MaterialLight = class _MaterialLight extends ChartTheme {
      static getDefaultColors() {
        return {
          fills: MATERIAL_LIGHT_FILLS,
          strokes: MATERIAL_LIGHT_STROKES
        };
      }
      static getWaterfallSeriesDefaultPositiveColors() {
        return {
          fill: MATERIAL_LIGHT_FILLS.BLUE,
          stroke: MATERIAL_LIGHT_STROKES.BLUE,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      static getWaterfallSeriesDefaultNegativeColors() {
        return {
          fill: MATERIAL_LIGHT_FILLS.RED,
          stroke: MATERIAL_LIGHT_STROKES.RED,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      static getWaterfallSeriesDefaultTotalColors() {
        return {
          fill: MATERIAL_LIGHT_FILLS.GRAY,
          stroke: MATERIAL_LIGHT_STROKES.GRAY,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      getTemplateParameters() {
        const result = super.getTemplateParameters();
        result.properties.set(DEFAULT_COLOURS, _MaterialLight.getDefaultColors());
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
          _MaterialLight.getWaterfallSeriesDefaultPositiveColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
          _MaterialLight.getWaterfallSeriesDefaultNegativeColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
          _MaterialLight.getWaterfallSeriesDefaultTotalColors()
        );
        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
          MATERIAL_LIGHT_FILLS.ORANGE,
          MATERIAL_LIGHT_FILLS.YELLOW,
          MATERIAL_LIGHT_FILLS.GREEN
        ]);
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
          _MaterialLight.getWaterfallSeriesDefaultTotalColors().stroke
        );
        result.properties.set(DEFAULT_ANNOTATION_STROKE, MATERIAL_LIGHT_STROKES.BLUE);
        result.properties.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_LIGHT_FILLS.BLUE);
        return result;
      }
      getPalette() {
        return palette3;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/themes/polychromaDark.ts
var POLYCHROMA_DARK_FILLS, POLYCHROMA_DARK_STROKES, POLYCHROMA_DARK_FILL_GRAY, POLYCHROMA_DARK_STROKE_GRAY, palette4, PolychromaDark;
var init_polychromaDark = __esm({
  "packages/ag-charts-community/src/chart/themes/polychromaDark.ts"() {
    "use strict";
    init_darkTheme();
    init_symbols();
    POLYCHROMA_DARK_FILLS = {
      BLUE: "#436ff4",
      PURPLE: "#9a7bff",
      MAGENTA: "#d165d2",
      PINK: "#f0598b",
      RED: "#f47348",
      ORANGE: "#f2a602",
      YELLOW: "#e9e201",
      GREEN: "#21b448",
      CYAN: "#00b9a2",
      MODERATE_BLUE: "#00aee4"
    };
    POLYCHROMA_DARK_STROKES = {
      BLUE: "#6698ff",
      PURPLE: "#c0a3ff",
      MAGENTA: "#fc8dfc",
      PINK: "#ff82b1",
      RED: "#ff9b70",
      ORANGE: "#ffcf4e",
      YELLOW: "#ffff58",
      GREEN: "#58dd70",
      CYAN: "#51e2c9",
      MODERATE_BLUE: "#4fd7ff"
    };
    POLYCHROMA_DARK_FILL_GRAY = "#bbbbbb";
    POLYCHROMA_DARK_STROKE_GRAY = "#eeeeee";
    palette4 = {
      fills: Object.values(POLYCHROMA_DARK_FILLS),
      strokes: Object.values(POLYCHROMA_DARK_STROKES)
    };
    PolychromaDark = class _PolychromaDark extends DarkTheme {
      static getDefaultColors() {
        return {
          fills: POLYCHROMA_DARK_FILLS,
          strokes: POLYCHROMA_DARK_STROKES
        };
      }
      static getWaterfallSeriesDefaultPositiveColors() {
        return {
          fill: POLYCHROMA_DARK_FILLS.BLUE,
          stroke: POLYCHROMA_DARK_STROKES.BLUE,
          label: {
            color: "white"
          }
        };
      }
      static getWaterfallSeriesDefaultNegativeColors() {
        return {
          fill: POLYCHROMA_DARK_FILLS.RED,
          stroke: POLYCHROMA_DARK_STROKES.RED,
          label: {
            color: "white"
          }
        };
      }
      static getWaterfallSeriesDefaultTotalColors() {
        return {
          fill: POLYCHROMA_DARK_FILL_GRAY,
          stroke: POLYCHROMA_DARK_STROKE_GRAY,
          label: {
            color: "white"
          }
        };
      }
      getTemplateParameters() {
        const result = super.getTemplateParameters();
        result.properties.set(DEFAULT_COLOURS, _PolychromaDark.getDefaultColors());
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
          _PolychromaDark.getWaterfallSeriesDefaultPositiveColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
          _PolychromaDark.getWaterfallSeriesDefaultNegativeColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
          _PolychromaDark.getWaterfallSeriesDefaultTotalColors()
        );
        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
          POLYCHROMA_DARK_FILLS.BLUE,
          POLYCHROMA_DARK_FILLS.RED
        ]);
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
          _PolychromaDark.getWaterfallSeriesDefaultTotalColors().stroke
        );
        result.properties.set(DEFAULT_ANNOTATION_STROKE, POLYCHROMA_DARK_STROKES.BLUE);
        result.properties.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_DARK_FILLS.BLUE);
        return result;
      }
      getPalette() {
        return palette4;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/themes/polychromaLight.ts
var POLYCHROMA_LIGHT_FILLS, POLYCHROMA_LIGHT_STROKES, POLYCHROMA_LIGHT_FILL_GRAY, POLYCHROMA_LIGHT_STROKE_GRAY, palette5, PolychromaLight;
var init_polychromaLight = __esm({
  "packages/ag-charts-community/src/chart/themes/polychromaLight.ts"() {
    "use strict";
    init_chartTheme();
    init_symbols();
    POLYCHROMA_LIGHT_FILLS = {
      BLUE: "#436ff4",
      PURPLE: "#9a7bff",
      MAGENTA: "#d165d2",
      PINK: "#f0598b",
      RED: "#f47348",
      ORANGE: "#f2a602",
      YELLOW: "#e9e201",
      GREEN: "#21b448",
      CYAN: "#00b9a2",
      MODERATE_BLUE: "#00aee4"
    };
    POLYCHROMA_LIGHT_STROKES = {
      BLUE: "#2346c9",
      PURPLE: "#7653d4",
      MAGENTA: "#a73da9",
      PINK: "#c32d66",
      RED: "#c84b1c",
      ORANGE: "#c87f00",
      YELLOW: "#c1b900",
      GREEN: "#008c1c",
      CYAN: "#00927c",
      MODERATE_BLUE: "#0087bb"
    };
    POLYCHROMA_LIGHT_FILL_GRAY = "#bbbbbb";
    POLYCHROMA_LIGHT_STROKE_GRAY = "#888888";
    palette5 = {
      fills: Object.values(POLYCHROMA_LIGHT_FILLS),
      strokes: Object.values(POLYCHROMA_LIGHT_STROKES)
    };
    PolychromaLight = class _PolychromaLight extends ChartTheme {
      static getDefaultColors() {
        return {
          fills: POLYCHROMA_LIGHT_FILLS,
          strokes: POLYCHROMA_LIGHT_STROKES
        };
      }
      static getWaterfallSeriesDefaultPositiveColors() {
        return {
          fill: POLYCHROMA_LIGHT_FILLS.BLUE,
          stroke: POLYCHROMA_LIGHT_STROKES.BLUE,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      static getWaterfallSeriesDefaultNegativeColors() {
        return {
          fill: POLYCHROMA_LIGHT_FILLS.RED,
          stroke: POLYCHROMA_LIGHT_STROKES.RED,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      static getWaterfallSeriesDefaultTotalColors() {
        return {
          fill: POLYCHROMA_LIGHT_FILL_GRAY,
          stroke: POLYCHROMA_LIGHT_STROKE_GRAY,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      getTemplateParameters() {
        const result = super.getTemplateParameters();
        result.properties.set(DEFAULT_COLOURS, _PolychromaLight.getDefaultColors());
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
          _PolychromaLight.getWaterfallSeriesDefaultPositiveColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
          _PolychromaLight.getWaterfallSeriesDefaultNegativeColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
          _PolychromaLight.getWaterfallSeriesDefaultTotalColors()
        );
        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
          POLYCHROMA_LIGHT_FILLS.BLUE,
          POLYCHROMA_LIGHT_FILLS.RED
        ]);
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
          _PolychromaLight.getWaterfallSeriesDefaultTotalColors().stroke
        );
        result.properties.set(DEFAULT_ANNOTATION_STROKE, POLYCHROMA_LIGHT_STROKES.BLUE);
        result.properties.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_LIGHT_FILLS.BLUE);
        return result;
      }
      getPalette() {
        return palette5;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/themes/sheetsDark.ts
var SHEETS_DARK_FILLS, SHEETS_DARK_STROKES, palette6, SheetsDark;
var init_sheetsDark = __esm({
  "packages/ag-charts-community/src/chart/themes/sheetsDark.ts"() {
    "use strict";
    init_darkTheme();
    init_symbols();
    SHEETS_DARK_FILLS = {
      BLUE: "#4472C4",
      ORANGE: "#ED7D31",
      GRAY: "#A5A5A5",
      YELLOW: "#FFC000",
      MODERATE_BLUE: "#5B9BD5",
      GREEN: "#70AD47",
      DARK_GRAY: "#7B7B7B",
      DARK_BLUE: "#264478",
      VERY_DARK_GRAY: "#636363",
      DARK_YELLOW: "#997300"
    };
    SHEETS_DARK_STROKES = {
      BLUE: "#6899ee",
      ORANGE: "#ffa55d",
      GRAY: "#cdcdcd",
      YELLOW: "#ffea53",
      MODERATE_BLUE: "#82c3ff",
      GREEN: "#96d56f",
      DARK_GRAY: "#a1a1a1",
      DARK_BLUE: "#47689f",
      VERY_DARK_GRAY: "#878787",
      DARK_YELLOW: "#c0993d"
    };
    palette6 = {
      fills: Object.values(SHEETS_DARK_FILLS),
      strokes: Object.values(SHEETS_DARK_STROKES)
    };
    SheetsDark = class _SheetsDark extends DarkTheme {
      static getDefaultColors() {
        return {
          fills: __spreadProps(__spreadValues({}, SHEETS_DARK_FILLS), { RED: SHEETS_DARK_FILLS.ORANGE }),
          strokes: __spreadProps(__spreadValues({}, SHEETS_DARK_STROKES), { RED: SHEETS_DARK_STROKES.ORANGE })
        };
      }
      static getWaterfallSeriesDefaultPositiveColors() {
        return {
          fill: SHEETS_DARK_FILLS.BLUE,
          stroke: SHEETS_DARK_STROKES.BLUE,
          label: {
            color: "white"
          }
        };
      }
      static getWaterfallSeriesDefaultNegativeColors() {
        return {
          fill: SHEETS_DARK_FILLS.ORANGE,
          stroke: SHEETS_DARK_STROKES.ORANGE,
          label: {
            color: "white"
          }
        };
      }
      static getWaterfallSeriesDefaultTotalColors() {
        return {
          fill: SHEETS_DARK_FILLS.GRAY,
          stroke: SHEETS_DARK_STROKES.GRAY,
          label: {
            color: "white"
          }
        };
      }
      getTemplateParameters() {
        const result = super.getTemplateParameters();
        result.properties.set(DEFAULT_COLOURS, _SheetsDark.getDefaultColors());
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
          _SheetsDark.getWaterfallSeriesDefaultPositiveColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
          _SheetsDark.getWaterfallSeriesDefaultNegativeColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
          _SheetsDark.getWaterfallSeriesDefaultTotalColors()
        );
        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
          SHEETS_DARK_FILLS.ORANGE,
          SHEETS_DARK_FILLS.YELLOW,
          SHEETS_DARK_FILLS.GREEN
        ]);
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
          _SheetsDark.getWaterfallSeriesDefaultTotalColors().stroke
        );
        result.properties.set(DEFAULT_ANNOTATION_STROKE, SHEETS_DARK_STROKES.BLUE);
        result.properties.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_DARK_FILLS.BLUE);
        return result;
      }
      getPalette() {
        return palette6;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/themes/sheetsLight.ts
var SHEETS_LIGHT_FILLS, SHEETS_LIGHT_STROKES, palette7, SheetsLight;
var init_sheetsLight = __esm({
  "packages/ag-charts-community/src/chart/themes/sheetsLight.ts"() {
    "use strict";
    init_chartTheme();
    init_symbols();
    SHEETS_LIGHT_FILLS = {
      BLUE: "#5281d5",
      ORANGE: "#ff8d44",
      GRAY: "#b5b5b5",
      YELLOW: "#ffd02f",
      MODERATE_BLUE: "#6aabe6",
      GREEN: "#7fbd57",
      DARK_GRAY: "#8a8a8a",
      DARK_BLUE: "#335287",
      VERY_DARK_GRAY: "#717171",
      DARK_YELLOW: "#a98220"
    };
    SHEETS_LIGHT_STROKES = {
      BLUE: "#214d9b",
      ORANGE: "#c25600",
      GRAY: "#7f7f7f",
      YELLOW: "#d59800",
      MODERATE_BLUE: "#3575ac",
      GREEN: "#4b861a",
      DARK_GRAY: "#575757",
      DARK_BLUE: "#062253",
      VERY_DARK_GRAY: "#414141",
      DARK_YELLOW: "#734f00"
    };
    palette7 = {
      fills: Object.values(SHEETS_LIGHT_FILLS),
      strokes: Object.values(SHEETS_LIGHT_STROKES)
    };
    SheetsLight = class _SheetsLight extends ChartTheme {
      static getDefaultColors() {
        return {
          fills: __spreadProps(__spreadValues({}, SHEETS_LIGHT_FILLS), { RED: SHEETS_LIGHT_FILLS.ORANGE }),
          strokes: __spreadProps(__spreadValues({}, SHEETS_LIGHT_STROKES), { RED: SHEETS_LIGHT_STROKES.ORANGE })
        };
      }
      static getWaterfallSeriesDefaultPositiveColors() {
        return {
          fill: SHEETS_LIGHT_FILLS.BLUE,
          stroke: SHEETS_LIGHT_STROKES.BLUE,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      static getWaterfallSeriesDefaultNegativeColors() {
        return {
          fill: SHEETS_LIGHT_FILLS.ORANGE,
          stroke: SHEETS_LIGHT_STROKES.ORANGE,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      static getWaterfallSeriesDefaultTotalColors() {
        return {
          fill: SHEETS_LIGHT_FILLS.GRAY,
          stroke: SHEETS_LIGHT_STROKES.GRAY,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      getTemplateParameters() {
        const result = super.getTemplateParameters();
        result.properties.set(DEFAULT_COLOURS, _SheetsLight.getDefaultColors());
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
          _SheetsLight.getWaterfallSeriesDefaultPositiveColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
          _SheetsLight.getWaterfallSeriesDefaultNegativeColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
          _SheetsLight.getWaterfallSeriesDefaultTotalColors()
        );
        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
          SHEETS_LIGHT_FILLS.ORANGE,
          SHEETS_LIGHT_FILLS.YELLOW,
          SHEETS_LIGHT_FILLS.GREEN
        ]);
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
          _SheetsLight.getWaterfallSeriesDefaultTotalColors().stroke
        );
        result.properties.set(DEFAULT_ANNOTATION_STROKE, SHEETS_LIGHT_STROKES.BLUE);
        result.properties.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_LIGHT_FILLS.BLUE);
        return result;
      }
      getPalette() {
        return palette7;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/themes/vividDark.ts
var VIVID_DARK_FILLS, VIVID_DARK_STROKES, palette8, VividDark;
var init_vividDark = __esm({
  "packages/ag-charts-community/src/chart/themes/vividDark.ts"() {
    "use strict";
    init_darkTheme();
    init_symbols();
    VIVID_DARK_FILLS = {
      BLUE: "#0083ff",
      ORANGE: "#ff6600",
      GREEN: "#00af00",
      CYAN: "#00ccff",
      YELLOW: "#f7c700",
      VIOLET: "#ac26ff",
      GRAY: "#a7a7b7",
      MAGENTA: "#e800c5",
      BROWN: "#b54300",
      RED: "#ff0000"
    };
    VIVID_DARK_STROKES = {
      BLUE: "#67b7ff",
      ORANGE: "#ffc24d",
      GREEN: "#5cc86f",
      CYAN: "#54ebff",
      VIOLET: "#c18aff",
      YELLOW: "#fff653",
      GRAY: "#aeaeae",
      MAGENTA: "#f078d4",
      BROWN: "#ba8438",
      RED: "#ff726e"
    };
    palette8 = {
      fills: Object.values(VIVID_DARK_FILLS),
      strokes: Object.values(VIVID_DARK_STROKES)
    };
    VividDark = class _VividDark extends DarkTheme {
      static getDefaultColors() {
        return {
          fills: VIVID_DARK_FILLS,
          strokes: VIVID_DARK_STROKES
        };
      }
      static getWaterfallSeriesDefaultPositiveColors() {
        return {
          fill: VIVID_DARK_FILLS.BLUE,
          stroke: VIVID_DARK_STROKES.BLUE,
          label: {
            color: "white"
          }
        };
      }
      static getWaterfallSeriesDefaultNegativeColors() {
        return {
          fill: VIVID_DARK_FILLS.ORANGE,
          stroke: VIVID_DARK_STROKES.ORANGE,
          label: {
            color: "white"
          }
        };
      }
      static getWaterfallSeriesDefaultTotalColors() {
        return {
          fill: VIVID_DARK_FILLS.GRAY,
          stroke: VIVID_DARK_STROKES.GRAY,
          label: {
            color: "white"
          }
        };
      }
      getTemplateParameters() {
        const result = super.getTemplateParameters();
        result.properties.set(DEFAULT_COLOURS, _VividDark.getDefaultColors());
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
          _VividDark.getWaterfallSeriesDefaultPositiveColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
          _VividDark.getWaterfallSeriesDefaultNegativeColors()
        );
        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, _VividDark.getWaterfallSeriesDefaultTotalColors());
        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
          VIVID_DARK_FILLS.ORANGE,
          VIVID_DARK_FILLS.YELLOW,
          VIVID_DARK_FILLS.GREEN
        ]);
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
          _VividDark.getWaterfallSeriesDefaultTotalColors().stroke
        );
        result.properties.set(DEFAULT_ANNOTATION_STROKE, VIVID_DARK_STROKES.BLUE);
        result.properties.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_DARK_FILLS.BLUE);
        return result;
      }
      getPalette() {
        return palette8;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/themes/vividLight.ts
var VIVID_FILLS, VIVID_STROKES, palette9, VividLight;
var init_vividLight = __esm({
  "packages/ag-charts-community/src/chart/themes/vividLight.ts"() {
    "use strict";
    init_chartTheme();
    init_symbols();
    VIVID_FILLS = {
      BLUE: "#0083ff",
      ORANGE: "#ff6600",
      GREEN: "#00af00",
      CYAN: "#00ccff",
      YELLOW: "#f7c700",
      VIOLET: "#ac26ff",
      GRAY: "#a7a7b7",
      MAGENTA: "#e800c5",
      BROWN: "#b54300",
      RED: "#ff0000"
    };
    VIVID_STROKES = {
      BLUE: "#0f68c0",
      ORANGE: "#d47100",
      GREEN: "#007922",
      CYAN: "#009ac2",
      VIOLET: "#bca400",
      YELLOW: "#753cac",
      GRAY: "#646464",
      MAGENTA: "#9b2685",
      BROWN: "#6c3b00",
      RED: "#cb0021"
    };
    palette9 = {
      fills: Object.values(VIVID_FILLS),
      strokes: Object.values(VIVID_STROKES)
    };
    VividLight = class _VividLight extends ChartTheme {
      static getDefaultColors() {
        return {
          fills: VIVID_FILLS,
          strokes: VIVID_STROKES
        };
      }
      static getWaterfallSeriesDefaultPositiveColors() {
        return {
          fill: VIVID_FILLS.BLUE,
          stroke: VIVID_STROKES.BLUE,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      static getWaterfallSeriesDefaultNegativeColors() {
        return {
          fill: VIVID_FILLS.ORANGE,
          stroke: VIVID_STROKES.ORANGE,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      static getWaterfallSeriesDefaultTotalColors() {
        return {
          fill: VIVID_FILLS.GRAY,
          stroke: VIVID_STROKES.GRAY,
          label: {
            color: DEFAULT_LABEL_COLOUR
          }
        };
      }
      getTemplateParameters() {
        const result = super.getTemplateParameters();
        result.properties.set(DEFAULT_COLOURS, _VividLight.getDefaultColors());
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
          _VividLight.getWaterfallSeriesDefaultPositiveColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
          _VividLight.getWaterfallSeriesDefaultNegativeColors()
        );
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
          _VividLight.getWaterfallSeriesDefaultTotalColors()
        );
        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [
          VIVID_FILLS.ORANGE,
          VIVID_FILLS.YELLOW,
          VIVID_FILLS.GREEN
        ]);
        result.properties.set(
          DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
          _VividLight.getWaterfallSeriesDefaultTotalColors().stroke
        );
        result.properties.set(DEFAULT_ANNOTATION_STROKE, VIVID_STROKES.BLUE);
        result.properties.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_FILLS.BLUE);
        return result;
      }
      getPalette() {
        return palette9;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/mapping/themes.ts
function validateChartThemeObject(unknownObject) {
  if (unknownObject === null) {
    return;
  }
  let valid = true;
  const { baseTheme, palette: palette10, overrides } = unknownObject;
  if (baseTheme !== void 0 && typeof baseTheme !== "string" && typeof baseTheme !== "object") {
    Logger.warn(`invalid theme.baseTheme type ${typeof baseTheme}, expected (string | object).`);
    valid = false;
  }
  if (overrides !== void 0 && typeof overrides !== "object") {
    Logger.warn(`invalid theme.overrides type ${typeof overrides}, expected object.`);
    valid = false;
  }
  if (typeof palette10 === "object") {
    if (palette10 !== null) {
      const { fills, strokes } = palette10;
      if (fills !== void 0 && !Array.isArray(fills)) {
        Logger.warn(`theme.overrides.fills must be undefined or an array`);
        valid = false;
      }
      if (strokes !== void 0 && !Array.isArray(strokes)) {
        Logger.warn(`theme.overrides.strokes must be undefined or an array`);
        valid = false;
      }
    }
  } else if (palette10 !== void 0) {
    Logger.warn(`invalid theme.palette type ${typeof palette10}, expected object.`);
    valid = false;
  }
  if (valid) {
    return unknownObject;
  }
}
function validateChartTheme(value) {
  if (value === void 0 || typeof value === "string" || value instanceof ChartTheme) {
    return value;
  }
  if (typeof value === "object") {
    return validateChartThemeObject(value);
  }
  Logger.warn(`invalid theme value type ${typeof value}, expected object or string.`);
}
function getChartTheme(unvalidatedValue) {
  let value = validateChartTheme(unvalidatedValue);
  if (value instanceof ChartTheme) {
    return value;
  }
  if (value == null || typeof value === "string") {
    const stockTheme = themes[value];
    if (stockTheme) {
      return stockTheme();
    }
    Logger.warnOnce(`the theme [${value}] is invalid, using [ag-default] instead.`);
    return lightTheme();
  }
  const overrides = [];
  let palette10;
  while (typeof value === "object") {
    overrides.push(value.overrides);
    palette10 != null ? palette10 : palette10 = value.palette;
    value = value.baseTheme;
  }
  const flattenedTheme = {
    baseTheme: value,
    overrides: mergeDefaults(...overrides),
    palette: palette10
  };
  const baseTheme = flattenedTheme.baseTheme ? getChartTheme(flattenedTheme.baseTheme) : lightTheme();
  return new baseTheme.constructor(flattenedTheme);
}
var lightTheme, darkTheme, lightThemes, darkThemes, themes;
var init_themes = __esm({
  "packages/ag-charts-community/src/chart/mapping/themes.ts"() {
    "use strict";
    init_logger();
    init_object();
    init_chartTheme();
    init_darkTheme();
    init_materialDark();
    init_materialLight();
    init_polychromaDark();
    init_polychromaLight();
    init_sheetsDark();
    init_sheetsLight();
    init_vividDark();
    init_vividLight();
    lightTheme = () => new ChartTheme();
    darkTheme = () => new DarkTheme();
    lightThemes = {
      undefined: lightTheme,
      null: lightTheme,
      "ag-default": lightTheme,
      "ag-sheets": () => new SheetsLight(),
      "ag-polychroma": () => new PolychromaLight(),
      "ag-vivid": () => new VividLight(),
      "ag-material": () => new MaterialLight()
    };
    darkThemes = {
      undefined: darkTheme,
      null: darkTheme,
      "ag-default-dark": darkTheme,
      "ag-sheets-dark": () => new SheetsDark(),
      "ag-polychroma-dark": () => new PolychromaDark(),
      "ag-vivid-dark": () => new VividDark(),
      "ag-material-dark": () => new MaterialDark()
    };
    themes = __spreadValues(__spreadValues({}, darkThemes), lightThemes);
  }
});

// packages/ag-charts-community/src/util/array.ts
function extent(values) {
  if (values.length === 0) {
    return;
  }
  let min = Infinity;
  let max = -Infinity;
  for (let n of values) {
    if (n instanceof Date) {
      n = n.getTime();
    }
    if (typeof n !== "number") {
      continue;
    }
    if (n < min) {
      min = n;
    }
    if (n > max) {
      max = n;
    }
  }
  const result = [min, max];
  if (result.every(isFinite)) {
    return result;
  }
}
function normalisedExtent(d, min, max) {
  return normalisedExtentWithMetadata(d, min, max).extent;
}
function normalisedExtentWithMetadata(d, min, max) {
  var _a2;
  let clipped = false;
  if (d.length > 2) {
    d = (_a2 = extent(d)) != null ? _a2 : [NaN, NaN];
  }
  if (!isNaN(min)) {
    clipped || (clipped = min > d[0]);
    d = [min, d[1]];
  }
  if (!isNaN(max)) {
    clipped || (clipped = max < d[1]);
    d = [d[0], max];
  }
  if (d[0] > d[1]) {
    d = [];
  }
  return { extent: d, clipped };
}
function arraysEqual(a, b) {
  if (a == null || b == null || a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (Array.isArray(a[i]) && Array.isArray(b[i])) {
      if (!arraysEqual(a[i], b[i])) {
        return false;
      }
    } else if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function toArray(value) {
  if (typeof value === "undefined") {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function unique(array) {
  return Array.from(new Set(array));
}
function groupBy(array, iteratee) {
  return array.reduce((result, item) => {
    var _a2;
    const groupKey = iteratee(item);
    (_a2 = result[groupKey]) != null ? _a2 : result[groupKey] = [];
    result[groupKey].push(item);
    return result;
  }, {});
}
function circularSliceArray(data, size, offset4 = 0) {
  if (data.length === 0) {
    return [];
  }
  const result = [];
  for (let i = 0; i < size; i++) {
    result.push(data.at((i + offset4) % data.length));
  }
  return result;
}
function bifurcate(isLeft, array) {
  return array.reduce(
    ([left, right], value) => isLeft(value) ? [[...left, value], right] : [left, [...right, value]],
    [[], []]
  );
}
function* mapIterable(src, predicate) {
  for (const e of src) {
    yield predicate(e);
  }
}
function constStringsIncludes(array, value) {
  const casting = array;
  return casting.includes(value);
}
function isInStringUnion(unionValues, value) {
  return constStringsIncludes(unionValues, value);
}
function allInStringUnion(unionValues, values) {
  return !values.some((v) => !isInStringUnion(unionValues, v));
}
var init_array = __esm({
  "packages/ag-charts-community/src/util/array.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/util/dom.ts
function getDocument(propertyName) {
  var _a2;
  return propertyName ? (_a2 = verifiedGlobals.document) == null ? void 0 : _a2[propertyName] : verifiedGlobals.document;
}
function getWindow(propertyName) {
  var _a2;
  return propertyName ? (_a2 = verifiedGlobals.window) == null ? void 0 : _a2[propertyName] : verifiedGlobals.window;
}
function createElement(tagName, className, style) {
  const element2 = getDocument().createElement(tagName);
  if (typeof className === "object") {
    style = className;
    className = void 0;
  }
  if (className) {
    element2.classList.add(className);
  }
  if (style) {
    Object.assign(element2.style, style);
  }
  return element2;
}
function downloadUrl(dataUrl, fileName) {
  const { body } = getDocument();
  const element2 = createElement("a", { display: "none" });
  element2.href = dataUrl;
  element2.download = fileName;
  body.appendChild(element2);
  element2.click();
  setTimeout(() => body.removeChild(element2));
}
function injectStyle(cssStyle, uniqueId) {
  var _a2, _b;
  const document2 = getDocument();
  if (uniqueId && ((_a2 = injectCache.get(document2)) == null ? void 0 : _a2.has(uniqueId)))
    return;
  const styleElement = createElement("style");
  styleElement.innerHTML = cssStyle;
  document2.head.insertBefore(styleElement, document2.head.querySelector("style"));
  if (uniqueId && !injectCache.has(document2)) {
    injectCache.set(document2, /* @__PURE__ */ new Set([uniqueId]));
  } else if (uniqueId) {
    (_b = injectCache.get(document2)) == null ? void 0 : _b.add(uniqueId);
  }
}
function setDocument(document2) {
  verifiedGlobals.document = document2;
}
function setWindow(window2) {
  verifiedGlobals.window = window2;
}
var verifiedGlobals, injectCache;
var init_dom = __esm({
  "packages/ag-charts-community/src/util/dom.ts"() {
    "use strict";
    verifiedGlobals = {};
    injectCache = /* @__PURE__ */ new WeakMap();
    if (typeof window !== "undefined") {
      verifiedGlobals.window = window;
    } else if (typeof global !== "undefined") {
      verifiedGlobals.window = global.window;
    }
    if (typeof document !== "undefined") {
      verifiedGlobals.document = document;
    } else if (typeof global !== "undefined") {
      verifiedGlobals.document = global.document;
    }
  }
});

// packages/ag-charts-community/src/util/debug.ts
var LONG_TIME_PERIOD_THRESHOLD, timeOfLastLog, logTimeGap, Debug;
var init_debug = __esm({
  "packages/ag-charts-community/src/util/debug.ts"() {
    "use strict";
    init_array();
    init_dom();
    init_logger();
    LONG_TIME_PERIOD_THRESHOLD = 2e3;
    timeOfLastLog = Date.now();
    logTimeGap = () => {
      const timeSinceLastLog = Date.now() - timeOfLastLog;
      if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {
        const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);
        Logger.log(`**** ${prettyDuration}s since last log message ****`);
      }
      timeOfLastLog = Date.now();
    };
    Debug = {
      create(...debugSelectors) {
        const resultFn = (...logContent) => {
          if (Debug.check(...debugSelectors)) {
            if (typeof logContent[0] === "function") {
              logContent = toArray(logContent[0]());
            }
            logTimeGap();
            Logger.log(...logContent);
          }
        };
        return Object.assign(resultFn, { check: () => Debug.check(...debugSelectors) });
      },
      check(...debugSelectors) {
        if (debugSelectors.length === 0) {
          debugSelectors.push(true);
        }
        const chartDebug = toArray(getWindow("agChartsDebug"));
        return chartDebug.some((selector) => debugSelectors.includes(selector));
      }
    };
  }
});

// packages/ag-charts-community/src/module/optionsModule.ts
var unthemedSeries, ChartOptions;
var init_optionsModule = __esm({
  "packages/ag-charts-community/src/module/optionsModule.ts"() {
    "use strict";
    init_axisRegistry();
    init_chartTypes();
    init_expectedEnterpriseModules();
    init_processEnterpriseOptions();
    init_seriesRegistry();
    init_themes();
    init_types2();
    init_tooltipOptions();
    init_array();
    init_debug();
    init_dom();
    init_json();
    init_logger();
    init_object();
    init_type_guards();
    init_enterpriseModule();
    unthemedSeries = /* @__PURE__ */ new Set(["map-shape-background", "map-line-background"]);
    ChartOptions = class {
      constructor(userOptions, specialOverrides) {
        var _b, _c, _d;
        const cloneOptions = { shallow: ["data"] };
        const options = deepClone(userOptions, cloneOptions);
        const chartType2 = this.optionsType(options);
        this.sanityCheckAndCleanup(options);
        this.userOptions = options;
        this.activeTheme = getChartTheme(options.theme);
        this.defaultAxes = this.getDefaultAxes(options);
        this.specialOverrides = this.specialOverridesDefaults(__spreadValues({}, specialOverrides));
        const _a2 = this.getSeriesThemeConfig(chartType2), {
          axes: axesThemes = {},
          annotations: annotationsThemes = {},
          series: _
        } = _a2, themeDefaults = __objRest(_a2, [
          "axes",
          "annotations",
          "series"
        ]);
        this.processedOptions = deepClone(
          mergeDefaults(this.userOptions, themeDefaults, this.defaultAxes),
          cloneOptions
        );
        this.processAxesOptions(this.processedOptions, axesThemes);
        this.processSeriesOptions(this.processedOptions);
        this.processMiniChartSeriesOptions(this.processedOptions);
        this.processAnnotationsOptions(this.processedOptions, annotationsThemes);
        if ((isAgCartesianChartOptions(this.processedOptions) || isAgPolarChartOptionsWithSeriesBasedLegend(this.processedOptions)) && ((_b = this.processedOptions.legend) == null ? void 0 : _b.enabled) == null) {
          (_d = (_c = this.processedOptions).legend) != null ? _d : _c.legend = {};
          this.processedOptions.legend.enabled = this.processedOptions.series.length > 1;
        }
        this.enableConfiguredOptions(this.processedOptions);
        if (!enterpriseModule.isEnterprise) {
          removeUsedEnterpriseOptions(this.processedOptions);
        }
      }
      getOptions() {
        var _a2;
        return (_a2 = this.processedOptions) != null ? _a2 : {};
      }
      diffOptions(options) {
        return jsonDiff(options, this.processedOptions);
      }
      getSeriesThemeConfig(seriesType) {
        var _a2, _b;
        return deepClone((_b = (_a2 = this.activeTheme) == null ? void 0 : _a2.config[seriesType]) != null ? _b : {});
      }
      getDefaultAxes(options) {
        const optionsType2 = this.optionsType(options);
        const axesDefaults = seriesRegistry.cloneDefaultAxes(optionsType2);
        if (seriesRegistry.isDefaultAxisSwapNeeded(options)) {
          this.swapAxesPosition(axesDefaults);
        }
        return axesDefaults;
      }
      optionsType(options) {
        var _a2, _b, _c;
        return (_c = (_b = (_a2 = options.series) == null ? void 0 : _a2[0]) == null ? void 0 : _b.type) != null ? _c : "line";
      }
      sanityCheckAndCleanup(options) {
        var _a2;
        this.deprecationWarnings(options);
        this.axesTypeIntegrity(options);
        this.seriesTypeIntegrity(options);
        this.soloSeriesIntegrity(options);
        this.removeDisabledOptions(options);
        this.removeLeftoverSymbols(options);
        if (((_a2 = options.series) == null ? void 0 : _a2.some((s) => s.type === "bullet")) && options.sync != null && options.sync.enabled !== false) {
          Logger.warnOnce("bullet series cannot be synced, disabling synchronization.");
          delete options.sync;
        }
      }
      swapAxesPosition(options) {
        var _a2;
        if (isAgCartesianChartOptions(options)) {
          const [axis0, axis1] = (_a2 = options.axes) != null ? _a2 : [];
          options.axes = [
            __spreadProps(__spreadValues({}, axis0), { position: axis1.position }),
            __spreadProps(__spreadValues({}, axis1), { position: axis0.position })
          ];
        }
      }
      processAxesOptions(options, axesThemes) {
        if (!("axes" in options))
          return;
        options.axes = options.axes.map((axis) => {
          var _a2, _c, _d;
          const _b = mergeDefaults(
            (_a2 = axesThemes[axis.type]) == null ? void 0 : _a2[axis.position],
            axesThemes[axis.type]
          ), { crossLines: crossLinesTheme } = _b, axisTheme = __objRest(_b, ["crossLines"]);
          if (axis.crossLines) {
            axis.crossLines = mergeArrayDefaults(axis.crossLines, crossLinesTheme);
          }
          const gridLineStyle = (_c = axisTheme.gridLine) == null ? void 0 : _c.style;
          if (((_d = axis.gridLine) == null ? void 0 : _d.style) && (gridLineStyle == null ? void 0 : gridLineStyle.length)) {
            axis.gridLine.style = axis.gridLine.style.map(
              (style, index) => style.stroke != null || style.lineDash != null ? mergeDefaults(style, gridLineStyle.at(index % gridLineStyle.length)) : style
            );
          }
          const _e = mergeDefaults(axis, axisTheme), { top: _1, right: _2, bottom: _3, left: _4 } = _e, axisOptions = __objRest(_e, ["top", "right", "bottom", "left"]);
          return axisOptions;
        });
      }
      processSeriesOptions(options) {
        const defaultSeriesType = this.getDefaultSeriesType(options);
        const defaultTooltipPosition = this.getTooltipPositionDefaults(options);
        const userPalette = Boolean(isObject(options.theme) && options.theme.palette);
        const paletteOptions = {
          colourIndex: 0,
          userPalette
        };
        const processedSeries = options.series.map((series) => {
          var _a2, _b;
          (_a2 = series.type) != null ? _a2 : series.type = defaultSeriesType;
          const _c = (_b = this.getSeriesThemeConfig(series.type).series) != null ? _b : {}, { innerLabels: innerLabelsTheme } = _c, seriesTheme = __objRest(_c, ["innerLabels"]);
          const seriesPaletteOptions = unthemedSeries.has(series.type) ? { colourIndex: 0, userPalette } : paletteOptions;
          const palette10 = this.getSeriesPalette(series.type, seriesPaletteOptions);
          const seriesOptions = mergeDefaults(
            this.getSeriesGroupingOptions(series),
            series,
            defaultTooltipPosition,
            seriesTheme,
            palette10
          );
          if (seriesOptions.innerLabels) {
            seriesOptions.innerLabels = mergeArrayDefaults(seriesOptions.innerLabels, innerLabelsTheme);
          }
          return this.activeTheme.templateTheme(seriesOptions);
        });
        options.series = this.setSeriesGroupingOptions(processedSeries);
      }
      processMiniChartSeriesOptions(options) {
        var _a2, _b;
        let miniChartSeries = (_b = (_a2 = options.navigator) == null ? void 0 : _a2.miniChart) == null ? void 0 : _b.series;
        if (miniChartSeries == null)
          return;
        const paletteOptions = {
          colourIndex: 0,
          userPalette: Boolean(isObject(options.theme) && options.theme.palette)
        };
        miniChartSeries = miniChartSeries.map((series) => {
          var _a3, _b2;
          (_a3 = series.type) != null ? _a3 : series.type = "line";
          const _c = (_b2 = this.getSeriesThemeConfig(series.type).series) != null ? _b2 : {}, { innerLabels: _ } = _c, seriesTheme = __objRest(_c, ["innerLabels"]);
          const seriesOptions = mergeDefaults(
            this.getSeriesGroupingOptions(series),
            series,
            seriesTheme,
            this.getSeriesPalette(series.type, paletteOptions)
          );
          return this.activeTheme.templateTheme(seriesOptions);
        });
        options.navigator.miniChart.series = this.setSeriesGroupingOptions(miniChartSeries);
      }
      processAnnotationsOptions(options, _annotationsThemes) {
        if (!isAgCartesianChartOptions(options))
          return;
      }
      getSeriesPalette(seriesType, options) {
        const paletteFactory = seriesRegistry.getPaletteFactory(seriesType);
        const { colourIndex: colourOffset, userPalette } = options;
        const { fills = [], strokes = [] } = this.activeTheme.palette;
        return paletteFactory == null ? void 0 : paletteFactory({
          userPalette,
          colorsCount: Math.max(fills.length, strokes.length),
          themeTemplateParameters: this.activeTheme.getTemplateParameters(),
          takeColors(count) {
            options.colourIndex += count;
            return {
              fills: circularSliceArray(fills, count, colourOffset),
              strokes: circularSliceArray(strokes, count, colourOffset)
            };
          }
        });
      }
      getSeriesGroupingOptions(series) {
        const groupable = seriesRegistry.isGroupable(series.type);
        const stackable = seriesRegistry.isStackable(series.type);
        const stackedByDefault = seriesRegistry.isStackedByDefault(series.type);
        if (series.grouped && !groupable) {
          Logger.warnOnce(`unsupported grouping of series type "${series.type}".`);
        }
        if ((series.stacked || series.stackGroup) && !stackable) {
          Logger.warnOnce(`unsupported stacking of series type "${series.type}".`);
        }
        let { grouped, stacked } = series;
        stacked != null ? stacked : stacked = (stackedByDefault || series.stackGroup != null) && !(groupable && grouped);
        grouped != null ? grouped : grouped = true;
        return {
          stacked: stackable && stacked,
          grouped: groupable && grouped && !(stackable && stacked)
        };
      }
      setSeriesGroupingOptions(allSeries) {
        const seriesGroups = this.getSeriesGrouping(allSeries);
        Debug.create(true, "opts")("setSeriesGroupingOptions() - series grouping: ", seriesGroups);
        const groupIdx = {};
        const groupCount2 = seriesGroups.reduce((countMap, seriesGroup) => {
          var _a2, _b;
          if (seriesGroup.groupType === "default" /* DEFAULT */) {
            return countMap;
          }
          (_b = countMap[_a2 = seriesGroup.seriesType]) != null ? _b : countMap[_a2] = 0;
          countMap[seriesGroup.seriesType] += seriesGroup.groupType === "stack" /* STACK */ ? 1 : seriesGroup.series.length;
          return countMap;
        }, {});
        return seriesGroups.flatMap((seriesGroup) => {
          var _a2, _b;
          (_b = groupIdx[_a2 = seriesGroup.seriesType]) != null ? _b : groupIdx[_a2] = 0;
          switch (seriesGroup.groupType) {
            case "stack" /* STACK */:
              const groupIndex = groupIdx[seriesGroup.seriesType]++;
              return seriesGroup.series.map(
                (series, stackIndex) => Object.assign(series, {
                  seriesGrouping: {
                    groupIndex,
                    groupCount: groupCount2[seriesGroup.seriesType],
                    stackIndex,
                    stackCount: seriesGroup.series.length
                  }
                })
              );
            case "group" /* GROUP */:
              return seriesGroup.series.map(
                (series) => Object.assign(series, {
                  seriesGrouping: {
                    groupIndex: groupIdx[seriesGroup.seriesType]++,
                    groupCount: groupCount2[seriesGroup.seriesType],
                    stackIndex: 0,
                    stackCount: 0
                  }
                })
              );
          }
          return seriesGroup.series;
        }).map((_a2) => {
          var _b = _a2, { stacked: _, grouped: __ } = _b, seriesOptions = __objRest(_b, ["stacked", "grouped"]);
          return seriesOptions;
        });
      }
      getSeriesGroupId(series) {
        var _a2;
        return [series.type, series.xKey, series.stacked ? (_a2 = series.stackGroup) != null ? _a2 : "stacked" : "grouped"].filter(Boolean).join("-");
      }
      getSeriesGrouping(allSeries) {
        const groupMap = /* @__PURE__ */ new Map();
        return allSeries.reduce((result, series) => {
          const seriesType = series.type;
          if (!series.stacked && !series.grouped) {
            result.push({ groupType: "default" /* DEFAULT */, seriesType, series: [series] });
          } else {
            const groupId = this.getSeriesGroupId(series);
            if (!groupMap.has(groupId)) {
              const groupType = series.stacked ? "stack" /* STACK */ : "group" /* GROUP */;
              const record = { groupType, seriesType, series: [] };
              groupMap.set(groupId, record);
              result.push(record);
            }
            groupMap.get(groupId).series.push(series);
          }
          return result;
        }, []);
      }
      getDefaultSeriesType(options) {
        if (isAgCartesianChartOptions(options)) {
          return "line";
        } else if (isAgPolarChartOptions(options)) {
          return "pie";
        } else if (isAgHierarchyChartOptions(options)) {
          return "treemap";
        } else if (isAgTopologyChartOptions(options)) {
          return "map-shape";
        }
        throw new Error("Invalid chart options type detected.");
      }
      getTooltipPositionDefaults(options) {
        var _a2;
        const position = (_a2 = options.tooltip) == null ? void 0 : _a2.position;
        if (!isPlainObject(position)) {
          return;
        }
        const { type, xOffset, yOffset } = position;
        const result = {};
        if (isString(type) && isEnumValue(AgTooltipPositionType, type)) {
          result.type = type;
        }
        if (isFiniteNumber(xOffset)) {
          result.xOffset = xOffset;
        }
        if (isFiniteNumber(yOffset)) {
          result.yOffset = yOffset;
        }
        return { tooltip: { position: result } };
      }
      deprecationWarnings(options) {
        const deprecatedArrayProps = { yKeys: "yKey", yNames: "yName" };
        Object.entries(deprecatedArrayProps).forEach(([oldProp, newProp]) => {
          var _a2;
          if ((_a2 = options.series) == null ? void 0 : _a2.some((s) => s[oldProp] != null)) {
            Logger.warnOnce(
              `Property [series.${oldProp}] is deprecated, please use [series.${newProp}] and multiple series instead.`
            );
          }
        });
      }
      axesTypeIntegrity(options) {
        var _a2;
        if ("axes" in options) {
          const axes = (_a2 = options.axes) != null ? _a2 : [];
          for (const { type } of axes) {
            if (!isAxisOptionType(type)) {
              delete options.axes;
              const expectedTypes = Array.from(axisRegistry.publicKeys()).join(", ");
              Logger.warnOnce(`unknown axis type: ${type}; expected one of: ${expectedTypes}`);
            }
          }
        }
      }
      seriesTypeIntegrity(options) {
        var _a2;
        const series = (_a2 = options.series) != null ? _a2 : [];
        options.series = series.filter(({ type }) => {
          if (type == null || isSeriesOptionType(type) || isEnterpriseSeriesType(type)) {
            return true;
          }
          Logger.warnOnce(
            `unknown series type: ${type}; expected one of: ${publicChartTypes.seriesTypes.join(", ")}`
          );
        });
      }
      soloSeriesIntegrity(options) {
        const allSeries = options.series;
        if (allSeries && allSeries.length > 1 && allSeries.some((series) => seriesRegistry.isSolo(series.type))) {
          const mainSeriesType = this.optionsType(options);
          if (seriesRegistry.isSolo(mainSeriesType)) {
            Logger.warn(
              `series[0] of type '${mainSeriesType}' is incompatible with other series types. Only processing series[0]`
            );
            options.series = allSeries.slice(0, 1);
          } else {
            const { solo, nonSolo } = groupBy(
              allSeries,
              (s) => seriesRegistry.isSolo(s.type) ? "solo" : "nonSolo"
            );
            const rejects = unique(solo.map((s) => s.type)).join(", ");
            Logger.warn(`Unable to mix these series types with the lead series type: ${rejects}`);
            options.series = nonSolo;
          }
        }
      }
      enableConfiguredOptions(options) {
        jsonWalk(
          this.userOptions,
          (visitingUserOpts, visitingMergedOpts) => {
            if (visitingMergedOpts && "enabled" in visitingMergedOpts && !visitingMergedOpts._enabledFromTheme && visitingUserOpts.enabled == null) {
              visitingMergedOpts.enabled = true;
            }
          },
          { skip: ["data", "theme"] },
          options
        );
        jsonWalk(
          options,
          (visitingMergedOpts) => {
            if (visitingMergedOpts._enabledFromTheme != null) {
              delete visitingMergedOpts._enabledFromTheme;
            }
          },
          { skip: ["data", "theme"] }
        );
      }
      removeDisabledOptions(options) {
        jsonWalk(
          options,
          (optionsNode) => {
            if ("enabled" in optionsNode && optionsNode.enabled === false) {
              Object.keys(optionsNode).forEach((key) => {
                if (key === "enabled")
                  return;
                delete optionsNode[key];
              });
            }
          },
          { skip: ["data", "theme"] }
        );
      }
      removeLeftoverSymbols(options) {
        jsonWalk(
          options,
          (optionsNode) => {
            if (!optionsNode || !isObject(optionsNode))
              return;
            for (const [key, value] of Object.entries(optionsNode)) {
              if (isSymbol(value)) {
                delete optionsNode[key];
              }
            }
          },
          { skip: ["data"] }
        );
      }
      specialOverridesDefaults(options) {
        if (options.window != null) {
          setWindow(options.window);
        } else if (typeof window !== "undefined") {
          options.window = window;
        } else if (typeof global !== "undefined") {
          options.window = global.window;
        }
        if (options.document != null) {
          setDocument(options.document);
        } else if (typeof document !== "undefined") {
          options.document = document;
        } else if (typeof global !== "undefined") {
          options.document = global.document;
        }
        if (options.window == null) {
          throw new Error("AG Charts - unable to resolve global window");
        }
        if (options.document == null) {
          throw new Error("AG Charts - unable to resolve global document");
        }
        return options;
      }
    };
  }
});

// packages/ag-charts-community/src/util/deprecation.ts
function createDeprecationWarning() {
  return (key, message) => {
    const msg = [`Property [${key}] is deprecated.`, message].filter(Boolean).join(" ");
    Logger.warnOnce(msg);
  };
}
function Deprecated(message, opts) {
  const warnDeprecated = createDeprecationWarning();
  const def = opts == null ? void 0 : opts.default;
  return addTransformToInstanceProperty((_, key, value) => {
    if (value !== def) {
      warnDeprecated(key.toString(), message);
    }
    return value;
  });
}
function DeprecatedAndRenamedTo(newPropName, mapValue) {
  const warnDeprecated = createDeprecationWarning();
  return addTransformToInstanceProperty(
    (target, key, value) => {
      if (value !== target[newPropName]) {
        warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);
        setPath(target, newPropName, mapValue ? mapValue(value) : value);
      }
      return BREAK_TRANSFORM_CHAIN;
    },
    (target, key) => {
      warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);
      return getPath(target, newPropName);
    }
  );
}
var init_deprecation = __esm({
  "packages/ag-charts-community/src/util/deprecation.ts"() {
    "use strict";
    init_decorator();
    init_logger();
    init_object();
  }
});

// packages/ag-charts-community/src/util/id.ts
function resetIds() {
  ID_MAP.clear();
}
function createId(instance) {
  var _a2;
  const constructor = instance.constructor;
  const className = Object.hasOwn(constructor, "className") ? constructor.className : constructor.name;
  if (!className) {
    throw new Error(`The ${constructor} is missing the 'className' property.`);
  }
  const nextId = ((_a2 = ID_MAP.get(className)) != null ? _a2 : 0) + 1;
  ID_MAP.set(className, nextId);
  return `${className}-${nextId}`;
}
var ID_MAP;
var init_id = __esm({
  "packages/ag-charts-community/src/util/id.ts"() {
    "use strict";
    ID_MAP = /* @__PURE__ */ new Map();
  }
});

// packages/ag-charts-community/src/util/interpolating.ts
var interpolate, isInterpolating;
var init_interpolating = __esm({
  "packages/ag-charts-community/src/util/interpolating.ts"() {
    "use strict";
    interpolate = "$interpolate";
    isInterpolating = (x) => x[interpolate] != null;
  }
});

// packages/ag-charts-community/src/util/number.ts
function clamp(min, value, max) {
  return Math.min(max, Math.max(min, value));
}
function clampArray(value, array) {
  const [min, max] = findMinMax(array);
  return clamp(min, value, max);
}
function findMinMax(array) {
  return array.length ? [Math.min(...array), Math.max(...array)] : [];
}
function findRangeExtent(array) {
  const [min, max] = findMinMax(array);
  return max - min;
}
function isEqual(a, b, epsilon2 = 1e-10) {
  return Math.abs(a - b) < epsilon2;
}
function isNegative(value) {
  return Math.sign(value) === -1 || Object.is(value, -0);
}
function round(value, decimals = 2) {
  const base = __pow(10, decimals);
  return Math.round(value * base) / base;
}
function toFixed(value, fractionOrSignificantDigits = 2) {
  const power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);
  if (power >= 0 || !isFinite(power)) {
    return value.toFixed(fractionOrSignificantDigits);
  }
  return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits);
}
function mod(n, m) {
  return Math.floor(n % m + (n < 0 ? m : 0));
}
function countFractionDigits(value, maximumFractionDigits = 10) {
  const [, decimal = ""] = (Math.abs(value) % 1).toLocaleString("en-GB", { minimumFractionDigits: 0, maximumFractionDigits }).split(".");
  return decimal.length;
}
var init_number = __esm({
  "packages/ag-charts-community/src/util/number.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/scene/nearest.ts
function nearestSquared(x, y, objects, maxDistanceSquared = Infinity) {
  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };
  for (const obj of objects) {
    const thisDistance = obj.distanceSquared(x, y);
    if (thisDistance === 0) {
      return { nearest: obj, distanceSquared: 0 };
    } else if (thisDistance < result.distanceSquared) {
      result.nearest = obj;
      result.distanceSquared = thisDistance;
    }
  }
  return result;
}
function nearestSquaredInContainer(x, y, container, maxDistanceSquared = Infinity) {
  const { x: tx, y: ty } = container.transformPoint(x, y);
  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };
  for (const child of container.children) {
    const { nearest, distanceSquared: distanceSquared2 } = child.nearestSquared(tx, ty, result.distanceSquared);
    if (distanceSquared2 === 0) {
      return { nearest, distanceSquared: distanceSquared2 };
    } else if (distanceSquared2 < result.distanceSquared) {
      result.nearest = nearest;
      result.distanceSquared = distanceSquared2;
    }
  }
  return result;
}
var init_nearest = __esm({
  "packages/ag-charts-community/src/scene/nearest.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/scene/bbox.ts
var _BBox, BBox;
var init_bbox = __esm({
  "packages/ag-charts-community/src/scene/bbox.ts"() {
    "use strict";
    init_interpolating();
    init_number();
    init_nearest();
    _BBox = class _BBox {
      constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
      clone() {
        const { x, y, width, height } = this;
        return new _BBox(x, y, width, height);
      }
      equals(other) {
        return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;
      }
      containsPoint(x, y) {
        return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;
      }
      collidesBBox(other) {
        return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;
      }
      computeCenter() {
        return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
      }
      isFinite() {
        return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.width) && Number.isFinite(this.height);
      }
      distanceSquared(x, y) {
        if (this.containsPoint(x, y)) {
          return 0;
        }
        const dx2 = x - clamp(this.x, x, this.x + this.width);
        const dy2 = y - clamp(this.y, y, this.y + this.height);
        return dx2 * dx2 + dy2 * dy2;
      }
      static nearestBox(x, y, boxes) {
        return nearestSquared(x, y, boxes);
      }
      clip(clipRect) {
        if (clipRect === void 0)
          return this;
        const x1 = Math.max(this.x, clipRect.x);
        const y1 = Math.max(this.y, clipRect.y);
        const x2 = Math.min(this.x + this.width, clipRect.x + clipRect.width);
        const y2 = Math.min(this.y + this.height, clipRect.y + clipRect.height);
        this.x = x1;
        this.y = y1;
        this.width = Math.max(0, x2 - x1);
        this.height = Math.max(0, y2 - y1);
        return this;
      }
      shrink(amount, position) {
        const apply = (pos, amt) => {
          switch (pos) {
            case "top":
              this.y += amt;
            case "bottom":
              this.height -= amt;
              break;
            case "left":
              this.x += amt;
            case "right":
              this.width -= amt;
              break;
            case "vertical":
              this.y += amt;
              this.height -= amt * 2;
              break;
            case "horizontal":
              this.x += amt;
              this.width -= amt * 2;
              break;
            case void 0:
              this.x += amt;
              this.width -= amt * 2;
              this.y += amt;
              this.height -= amt * 2;
              break;
            default:
          }
        };
        if (typeof amount === "number") {
          apply(position, amount);
        } else if (typeof amount === "object") {
          Object.entries(amount).forEach(([pos, amt]) => apply(pos, amt));
        }
        return this;
      }
      grow(amount, position) {
        if (typeof amount === "number") {
          this.shrink(-amount, position);
        } else {
          const paddingCopy = __spreadValues({}, amount);
          for (const key in paddingCopy) {
            paddingCopy[key] *= -1;
          }
          this.shrink(paddingCopy);
        }
        return this;
      }
      combine(other) {
        const { x, y, width, height } = this;
        this.x = Math.min(x, other.x);
        this.y = Math.min(y, other.y);
        this.width = Math.max(x + width, other.x + other.width) - this.x;
        this.height = Math.max(y + height, other.y + other.height) - this.y;
      }
      static merge(boxes) {
        let left = Infinity;
        let top = Infinity;
        let right = -Infinity;
        let bottom = -Infinity;
        for (const box of boxes) {
          if (box.x < left) {
            left = box.x;
          }
          if (box.y < top) {
            top = box.y;
          }
          if (box.x + box.width > right) {
            right = box.x + box.width;
          }
          if (box.y + box.height > bottom) {
            bottom = box.y + box.height;
          }
        }
        return new _BBox(left, top, right - left, bottom - top);
      }
      [interpolate](other, d) {
        return new _BBox(
          this.x * (1 - d) + other.x * d,
          this.y * (1 - d) + other.y * d,
          this.width * (1 - d) + other.width * d,
          this.height * (1 - d) + other.height * d
        );
      }
    };
    _BBox.zero = new _BBox(0, 0, 0, 0);
    _BBox.NaN = new _BBox(NaN, NaN, NaN, NaN);
    BBox = _BBox;
  }
});

// packages/ag-charts-community/src/scene/changeDetectable.ts
function functionConstructorAvailable() {
  try {
    new Function("return true");
    return true;
  } catch (e) {
    return false;
  }
}
function SceneChangeDetection(opts) {
  const { changeCb, convertor } = opts != null ? opts : {};
  return function(target, key) {
    const privateKey = `__${key}`;
    if (target[key]) {
      return;
    }
    if (STRING_FUNCTION_USEABLE && changeCb == null && convertor == null) {
      prepareFastGetSet(target, key, privateKey, opts);
    } else {
      prepareSlowGetSet(target, key, privateKey, opts);
    }
  };
}
function prepareFastGetSet(target, key, privateKey, opts) {
  const { redraw = 1 /* TRIVIAL */, type = "normal", checkDirtyOnAssignment = false } = opts != null ? opts : {};
  const setterJs = new Function(
    "value",
    `
        const oldValue = this.${privateKey};
        if (value !== oldValue) {
            this.${privateKey} = value;
            ${type === "normal" ? `this.markDirty(this, ${redraw});` : ""}
            ${type === "transform" ? `this.markDirtyTransform(${redraw});` : ""}
            ${type === "path" ? `if (!this._dirtyPath) { this._dirtyPath = true; this.markDirty(this, ${redraw}); }` : ""}
            ${type === "font" ? `if (!this._dirtyFont) { this._dirtyFont = true; this.markDirty(this, ${redraw}); }` : ""}
        }
        ${checkDirtyOnAssignment ? `if (value != null && value._dirty > ${0 /* NONE */}) { this.markDirty(value, value._dirty); }` : ""}
`
  );
  const getterJs = new Function(`return this.${privateKey};`);
  Object.defineProperty(target, key, {
    set: setterJs,
    get: getterJs,
    enumerable: true,
    configurable: true
  });
}
function prepareSlowGetSet(target, key, privateKey, opts) {
  const {
    redraw = 1 /* TRIVIAL */,
    type = "normal",
    changeCb,
    convertor,
    checkDirtyOnAssignment = false
  } = opts != null ? opts : {};
  const setter = function(value) {
    const oldValue = this[privateKey];
    value = convertor ? convertor(value) : value;
    if (value !== oldValue) {
      this[privateKey] = value;
      if (type === "normal")
        this.markDirty(this, redraw);
      if (type === "transform")
        this.markDirtyTransform(redraw);
      if (type === "path" && !this._dirtyPath) {
        this._dirtyPath = true;
        this.markDirty(this, redraw);
      }
      if (type === "font" && !this._dirtyFont) {
        this._dirtyFont = true;
        this.markDirty(this, redraw);
      }
      changeCb == null ? void 0 : changeCb(this);
    }
    if (checkDirtyOnAssignment && value != null && value._dirty > 0 /* NONE */)
      this.markDirty(value, value._dirty);
  };
  const getter = function() {
    return this[privateKey];
  };
  Object.defineProperty(target, key, {
    set: setter,
    get: getter,
    enumerable: true,
    configurable: true
  });
}
var RedrawType, STRING_FUNCTION_USEABLE, ChangeDetectable;
var init_changeDetectable = __esm({
  "packages/ag-charts-community/src/scene/changeDetectable.ts"() {
    "use strict";
    RedrawType = /* @__PURE__ */ ((RedrawType3) => {
      RedrawType3[RedrawType3["NONE"] = 0] = "NONE";
      RedrawType3[RedrawType3["TRIVIAL"] = 1] = "TRIVIAL";
      RedrawType3[RedrawType3["MINOR"] = 2] = "MINOR";
      RedrawType3[RedrawType3["MAJOR"] = 3] = "MAJOR";
      return RedrawType3;
    })(RedrawType || {});
    STRING_FUNCTION_USEABLE = functionConstructorAvailable();
    ChangeDetectable = class {
      constructor() {
        this._dirty = 3 /* MAJOR */;
      }
      markDirty(_source, type = 1 /* TRIVIAL */) {
        if (this._dirty < type) {
          this._dirty = type;
        }
      }
      markClean(_opts) {
        this._dirty = 0 /* NONE */;
      }
      isDirty() {
        return this._dirty > 0 /* NONE */;
      }
    };
  }
});

// packages/ag-charts-community/src/scene/matrix.ts
var _Matrix, Matrix;
var init_matrix = __esm({
  "packages/ag-charts-community/src/scene/matrix.ts"() {
    "use strict";
    init_bbox();
    _Matrix = class _Matrix {
      get e() {
        return [...this.elements];
      }
      constructor(elements3 = [1, 0, 0, 1, 0, 0]) {
        this.elements = elements3;
      }
      setElements(elements3) {
        const e = this.elements;
        e[0] = elements3[0];
        e[1] = elements3[1];
        e[2] = elements3[2];
        e[3] = elements3[3];
        e[4] = elements3[4];
        e[5] = elements3[5];
        return this;
      }
      get identity() {
        const e = this.elements;
        return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;
      }
      /**
       * Performs the AxB matrix multiplication and saves the result
       * to `C`, if given, or to `A` otherwise.
       */
      AxB(A, B, C) {
        const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];
        C = C != null ? C : A;
        C[0] = a;
        C[1] = b;
        C[2] = c;
        C[3] = d;
        C[4] = e;
        C[5] = f;
      }
      /**
       * The `other` matrix gets post-multiplied to the current matrix.
       * Returns the current matrix.
       * @param other
       */
      multiplySelf(other) {
        this.AxB(this.elements, other.elements);
        return this;
      }
      /**
       * The `other` matrix gets post-multiplied to the current matrix.
       * Returns a new matrix.
       * @param other
       */
      multiply(other) {
        const elements3 = new Array(6);
        this.AxB(this.elements, other.elements, elements3);
        return new _Matrix(elements3);
      }
      preMultiplySelf(other) {
        this.AxB(other.elements, this.elements, this.elements);
        return this;
      }
      /**
       * Returns the inverse of this matrix as a new matrix.
       */
      inverse() {
        const el = this.elements;
        let a = el[0], b = el[1], c = el[2], d = el[3];
        const e = el[4], f = el[5];
        const rD = 1 / (a * d - b * c);
        a *= rD;
        b *= rD;
        c *= rD;
        d *= rD;
        return new _Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);
      }
      /**
       * Save the inverse of this matrix to the given matrix.
       */
      inverseTo(other) {
        const el = this.elements;
        let a = el[0], b = el[1], c = el[2], d = el[3];
        const e = el[4], f = el[5];
        const rD = 1 / (a * d - b * c);
        a *= rD;
        b *= rD;
        c *= rD;
        d *= rD;
        other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);
        return this;
      }
      invertSelf() {
        const el = this.elements;
        let a = el[0], b = el[1], c = el[2], d = el[3];
        const e = el[4], f = el[5];
        const rD = 1 / (a * d - b * c);
        a *= rD;
        b *= rD;
        c *= rD;
        d *= rD;
        el[0] = d;
        el[1] = -b;
        el[2] = -c;
        el[3] = a;
        el[4] = c * f - d * e;
        el[5] = b * e - a * f;
        return this;
      }
      transformPoint(x, y) {
        const e = this.elements;
        return {
          x: x * e[0] + y * e[2] + e[4],
          y: x * e[1] + y * e[3] + e[5]
        };
      }
      transformBBox(bbox, target) {
        const elements3 = this.elements;
        const xx = elements3[0];
        const xy = elements3[1];
        const yx = elements3[2];
        const yy = elements3[3];
        const h_w = bbox.width * 0.5;
        const h_h = bbox.height * 0.5;
        const cx = bbox.x + h_w;
        const cy = bbox.y + h_h;
        const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);
        const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);
        if (!target) {
          target = new BBox(0, 0, 0, 0);
        }
        target.x = cx * xx + cy * yx + elements3[4] - w;
        target.y = cx * xy + cy * yy + elements3[5] - h;
        target.width = w + w;
        target.height = h + h;
        return target;
      }
      toContext(ctx) {
        if (this.identity) {
          return;
        }
        const e = this.elements;
        ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);
      }
      static flyweight(sourceMatrix) {
        return _Matrix.instance.setElements(sourceMatrix.elements);
      }
      static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {
        const [bbcx, bbcy] = [0, 0];
        const sx = scalingX;
        const sy = scalingY;
        let scx;
        let scy;
        if (sx === 1 && sy === 1) {
          scx = 0;
          scy = 0;
        } else {
          scx = (opts == null ? void 0 : opts.scalingCenterX) == null ? bbcx : opts == null ? void 0 : opts.scalingCenterX;
          scy = (opts == null ? void 0 : opts.scalingCenterY) == null ? bbcy : opts == null ? void 0 : opts.scalingCenterY;
        }
        const r = rotation;
        const cos = Math.cos(r);
        const sin = Math.sin(r);
        let rcx;
        let rcy;
        if (r === 0) {
          rcx = 0;
          rcy = 0;
        } else {
          rcx = (opts == null ? void 0 : opts.rotationCenterX) == null ? bbcx : opts == null ? void 0 : opts.rotationCenterX;
          rcy = (opts == null ? void 0 : opts.rotationCenterY) == null ? bbcy : opts == null ? void 0 : opts.rotationCenterY;
        }
        const tx = translationX;
        const ty = translationY;
        const tx4 = scx * (1 - sx) - rcx;
        const ty4 = scy * (1 - sy) - rcy;
        matrix.setElements([
          cos * sx,
          sin * sx,
          -sin * sy,
          cos * sy,
          cos * tx4 - sin * ty4 + rcx + tx,
          sin * tx4 + cos * ty4 + rcy + ty
        ]);
        return matrix;
      }
      static fromContext(ctx) {
        const domMatrix = ctx.getTransform();
        return new _Matrix([domMatrix.a, domMatrix.b, domMatrix.c, domMatrix.d, domMatrix.e, domMatrix.f]);
      }
    };
    _Matrix.instance = new _Matrix();
    Matrix = _Matrix;
  }
});

// packages/ag-charts-community/src/scene/node.ts
var PointerEvents, _Node, Node;
var init_node = __esm({
  "packages/ag-charts-community/src/scene/node.ts"() {
    "use strict";
    init_id();
    init_bbox();
    init_changeDetectable();
    init_matrix();
    PointerEvents = /* @__PURE__ */ ((PointerEvents9) => {
      PointerEvents9[PointerEvents9["All"] = 0] = "All";
      PointerEvents9[PointerEvents9["None"] = 1] = "None";
      return PointerEvents9;
    })(PointerEvents || {});
    _Node = class _Node extends ChangeDetectable {
      constructor({ isVirtual, tag, zIndex } = {}) {
        super();
        /** Unique number to allow creation order to be easily determined. */
        this.serialNumber = _Node._nextSerialNumber++;
        /**
         * Unique node ID in the form `ClassName-NaturalNumber`.
         */
        this.id = createId(this);
        /**
         * To simplify the type system (especially in Selections) we don't have the `Parent` node
         * (one that has children). Instead, we mimic HTML DOM, where any node can have children.
         * But we still need to distinguish regular leaf nodes from container leafs somehow.
         */
        this.isContainerNode = false;
        this._virtualChildren = [];
        this._children = [];
        // Used to check for duplicate nodes.
        this.childSet = {};
        // These matrices may need to have package level visibility
        // for performance optimization purposes.
        this.matrix = new Matrix();
        this.dirtyTransform = false;
        this.scalingX = 1;
        this.scalingY = 1;
        this.scalingCenterX = null;
        this.scalingCenterY = null;
        this.rotationCenterX = null;
        this.rotationCenterY = null;
        this.rotation = 0;
        this.translationX = 0;
        this.translationY = 0;
        this._childNodeCounts = {
          groups: 0,
          nonGroups: 0
        };
        this.visible = true;
        this.dirtyZIndex = false;
        this.zIndex = 0;
        /** Discriminators for render order within a zIndex. */
        this.zIndexSubOrder = void 0;
        this.pointerEvents = 0 /* All */;
        this.isVirtual = isVirtual != null ? isVirtual : false;
        this.tag = tag != null ? tag : NaN;
        this.zIndex = zIndex != null ? zIndex : 0;
      }
      /**
       * Some arbitrary data bound to the node.
       */
      get datum() {
        var _a2, _b;
        return (_b = this._datum) != null ? _b : (_a2 = this._parent) == null ? void 0 : _a2.datum;
      }
      get previousDatum() {
        return this._previousDatum;
      }
      set datum(datum) {
        if (this._datum !== datum) {
          this._previousDatum = this._datum;
        }
        this._datum = datum;
      }
      _setLayerManager(value) {
        this._layerManager = value;
        this._debug = value == null ? void 0 : value.debug;
        for (const child of this._children) {
          child._setLayerManager(value);
        }
        for (const child of this._virtualChildren) {
          child._setLayerManager(value);
        }
      }
      get layerManager() {
        return this._layerManager;
      }
      *ancestors() {
        let node = this;
        while (node = node.parent) {
          yield node;
        }
      }
      *traverseUp() {
        yield this;
        yield* __yieldStar(this.ancestors());
      }
      get parent() {
        return this._parent;
      }
      get children() {
        return this._virtualChildren.length ? this._children.concat(this._virtualChildren.flatMap((next) => next.children)) : this._children;
      }
      get virtualChildren() {
        return this._virtualChildren;
      }
      hasVirtualChildren() {
        return this._virtualChildren.length > 0;
      }
      // new Set<Node>()
      setProperties(styles, pickKeys) {
        const keys = pickKeys != null ? pickKeys : Object.keys(styles);
        for (const key of keys) {
          this[key] = styles[key];
        }
        return this;
      }
      /**
       * Appends one or more new node instances to this parent.
       * If one needs to:
       * - move a child to the end of the list of children
       * - move a child from one parent to another (including parents in other scenes)
       * one should use the {@link insertBefore} method instead.
       * @param nodes A node or nodes to append.
       */
      append(nodes) {
        if (!Array.isArray(nodes)) {
          nodes = [nodes];
        }
        for (const node of nodes) {
          if (node.parent) {
            throw new Error(`${node} already belongs to another parent: ${node.parent}.`);
          }
          if (node.layerManager) {
            throw new Error(`${node} already belongs to a scene: ${node.layerManager}.`);
          }
          if (this.childSet[node.id]) {
            throw new Error(`Duplicate ${node.constructor.name} node: ${node}`);
          }
          if (node.isVirtual) {
            this._virtualChildren.push(node);
          } else {
            this._children.push(node);
          }
          this.childSet[node.id] = true;
          node._parent = this;
          node._setLayerManager(this.layerManager);
        }
        this.dirtyZIndex = true;
        this.markDirty(this, 3 /* MAJOR */);
      }
      appendChild(node) {
        this.append(node);
        return node;
      }
      removeChild(node) {
        const error = () => {
          throw new Error(`The node to be removed is not a child of this node.`);
        };
        if (node.parent !== this) {
          error();
        }
        if (node.isVirtual) {
          const i = this._virtualChildren.indexOf(node);
          if (i < 0)
            error();
          this._virtualChildren.splice(i, 1);
        } else {
          const i = this._children.indexOf(node);
          if (i < 0)
            error();
          this._children.splice(i, 1);
        }
        delete this.childSet[node.id];
        node._parent = void 0;
        node._setLayerManager();
        this.dirtyZIndex = true;
        this.markDirty(node, 3 /* MAJOR */);
        return node;
      }
      calculateCumulativeMatrix() {
        this.computeTransformMatrix();
        const matrix = Matrix.flyweight(this.matrix);
        for (const parent of this.ancestors()) {
          parent.computeTransformMatrix();
          matrix.preMultiplySelf(parent.matrix);
        }
        return matrix;
      }
      transformPoint(x, y) {
        const matrix = this.calculateCumulativeMatrix();
        return matrix.invertSelf().transformPoint(x, y);
      }
      inverseTransformPoint(x, y) {
        const matrix = this.calculateCumulativeMatrix();
        return matrix.transformPoint(x, y);
      }
      transformBBox(bbox) {
        const matrix = this.calculateCumulativeMatrix();
        return matrix.invertSelf().transformBBox(bbox);
      }
      inverseTransformBBox(bbox) {
        const matrix = this.calculateCumulativeMatrix();
        return matrix.transformBBox(bbox);
      }
      markDirtyTransform() {
        this.dirtyTransform = true;
        this.markDirty(this, 3 /* MAJOR */);
      }
      containsPoint(_x, _y) {
        return false;
      }
      /**
       * Hit testing method.
       * Recursively checks if the given point is inside this node or any of its children.
       * Returns the first matching node or `undefined`.
       * Nodes that render later (show on top) are hit tested first.
       */
      pickNode(x, y) {
        var _a2;
        if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {
          return;
        }
        const { children } = this;
        if (children.length > 1e3) {
          for (let i = children.length - 1; i >= 0; i--) {
            const child = children[i];
            const containsPoint = (_a2 = child.computeTransformedBBox()) == null ? void 0 : _a2.containsPoint(x, y);
            const hit = containsPoint ? child.pickNode(x, y) : void 0;
            if (hit) {
              return hit;
            }
          }
        } else if (children.length) {
          for (let i = children.length - 1; i >= 0; i--) {
            const hit = children[i].pickNode(x, y);
            if (hit) {
              return hit;
            }
          }
        } else if (!this.isContainerNode) {
          return this;
        }
      }
      getCachedBBox() {
        var _a2;
        return (_a2 = this.cachedBBox) != null ? _a2 : BBox.zero;
      }
      computeBBox() {
        return;
      }
      computeTransformedBBox() {
        const bbox = this.computeBBox();
        if (!bbox) {
          return;
        }
        this.computeTransformMatrix();
        const matrix = Matrix.flyweight(this.matrix);
        for (const parent of this.ancestors()) {
          parent.computeTransformMatrix();
          matrix.preMultiplySelf(parent.matrix);
        }
        matrix.transformBBox(bbox, bbox);
        return bbox;
      }
      computeTransformMatrix() {
        if (!this.dirtyTransform) {
          return;
        }
        const {
          matrix,
          scalingX,
          scalingY,
          rotation,
          translationX,
          translationY,
          scalingCenterX,
          scalingCenterY,
          rotationCenterX,
          rotationCenterY
        } = this;
        Matrix.updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, {
          scalingCenterX,
          scalingCenterY,
          rotationCenterX,
          rotationCenterY
        });
        this.dirtyTransform = false;
      }
      /** Perform any pre-rendering initialization. */
      preRender() {
        this._childNodeCounts.groups = 0;
        this._childNodeCounts.nonGroups = 1;
        for (const child of this.children) {
          const childCounts = child.preRender();
          this._childNodeCounts.groups += childCounts.groups;
          this._childNodeCounts.nonGroups += childCounts.nonGroups;
        }
        return this._childNodeCounts;
      }
      render(renderCtx) {
        const { stats } = renderCtx;
        this._dirty = 0 /* NONE */;
        this.cachedBBox = this.computeBBox();
        if (stats) {
          stats.nodesRendered++;
        }
      }
      markDirty(_source, type = 1 /* TRIVIAL */, parentType = type) {
        if (this._dirty > type || this._dirty === type && type === parentType) {
          return;
        }
        this._dirty = type;
        if (this.parent) {
          this.parent.markDirty(this, parentType);
        } else if (this.layerManager) {
          this.layerManager.markDirty();
        }
      }
      get dirty() {
        return this._dirty;
      }
      markClean(opts) {
        const { force = false, recursive = true } = opts != null ? opts : {};
        if (this._dirty === 0 /* NONE */ && !force) {
          return;
        }
        this._dirty = 0 /* NONE */;
        if (recursive !== false) {
          for (const child of this._virtualChildren) {
            child.markClean({ force });
          }
        }
        if (recursive === true) {
          for (const child of this._children) {
            child.markClean({ force });
          }
        }
      }
      onVisibleChange() {
      }
      get nodeCount() {
        let count = 1;
        let dirtyCount = this._dirty >= 0 /* NONE */ || this.dirtyTransform ? 1 : 0;
        let visibleCount = this.visible ? 1 : 0;
        const countChild = (child) => {
          const { count: childCount, visibleCount: childVisibleCount, dirtyCount: childDirtyCount } = child.nodeCount;
          count += childCount;
          visibleCount += childVisibleCount;
          dirtyCount += childDirtyCount;
        };
        for (const child of this._children) {
          countChild(child);
        }
        for (const child of this._virtualChildren) {
          countChild(child);
        }
        return { count, visibleCount, dirtyCount };
      }
      onZIndexChange() {
        if (this.parent) {
          this.parent.dirtyZIndex = true;
        }
      }
    };
    _Node._nextSerialNumber = 0;
    __decorateClass([
      SceneChangeDetection({ type: "transform" })
    ], _Node.prototype, "scalingX", 2);
    __decorateClass([
      SceneChangeDetection({ type: "transform" })
    ], _Node.prototype, "scalingY", 2);
    __decorateClass([
      SceneChangeDetection({ type: "transform" })
    ], _Node.prototype, "scalingCenterX", 2);
    __decorateClass([
      SceneChangeDetection({ type: "transform" })
    ], _Node.prototype, "scalingCenterY", 2);
    __decorateClass([
      SceneChangeDetection({ type: "transform" })
    ], _Node.prototype, "rotationCenterX", 2);
    __decorateClass([
      SceneChangeDetection({ type: "transform" })
    ], _Node.prototype, "rotationCenterY", 2);
    __decorateClass([
      SceneChangeDetection({ type: "transform" })
    ], _Node.prototype, "rotation", 2);
    __decorateClass([
      SceneChangeDetection({ type: "transform" })
    ], _Node.prototype, "translationX", 2);
    __decorateClass([
      SceneChangeDetection({ type: "transform" })
    ], _Node.prototype, "translationY", 2);
    __decorateClass([
      SceneChangeDetection({
        redraw: 3 /* MAJOR */,
        changeCb: (target) => target.onVisibleChange()
      })
    ], _Node.prototype, "visible", 2);
    __decorateClass([
      SceneChangeDetection({
        redraw: 1 /* TRIVIAL */,
        changeCb: (target) => target.onZIndexChange()
      })
    ], _Node.prototype, "zIndex", 2);
    __decorateClass([
      SceneChangeDetection({
        redraw: 1 /* TRIVIAL */,
        changeCb: (target) => target.onZIndexChange()
      })
    ], _Node.prototype, "zIndexSubOrder", 2);
    Node = _Node;
  }
});

// packages/ag-charts-community/src/util/color.ts
var srgbToLinear, srgbFromLinear, _Color, Color;
var init_color = __esm({
  "packages/ag-charts-community/src/util/color.ts"() {
    "use strict";
    init_logger();
    init_number();
    srgbToLinear = (value) => {
      const sign = value < 0 ? -1 : 1;
      const abs = Math.abs(value);
      if (abs <= 0.04045)
        return value / 12.92;
      return sign * __pow((abs + 0.055) / 1.055, 2.4);
    };
    srgbFromLinear = (value) => {
      const sign = value < 0 ? -1 : 1;
      const abs = Math.abs(value);
      if (abs > 31308e-7) {
        return sign * (1.055 * __pow(abs, 1 / 2.4) - 0.055);
      }
      return 12.92 * value;
    };
    _Color = class _Color {
      /**
       * Every color component should be in the [0, 1] range.
       * Some easing functions (such as elastic easing) can overshoot the target value by some amount.
       * So, when animating colors, if the source or target color components are already near
       * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color
       * component value to end up outside of that range mid-animation. For this reason the constructor
       * performs range checking/constraining.
       * @param r Red component.
       * @param g Green component.
       * @param b Blue component.
       * @param a Alpha (opacity) component.
       */
      constructor(r, g, b, a = 1) {
        this.r = clamp(0, r || 0, 1);
        this.g = clamp(0, g || 0, 1);
        this.b = clamp(0, b || 0, 1);
        this.a = clamp(0, a || 0, 1);
      }
      /**
       * A color string can be in one of the following formats to be valid:
       * - #rgb
       * - #rrggbb
       * - rgb(r, g, b)
       * - rgba(r, g, b, a)
       * - CSS color name such as 'white', 'orange', 'cyan', etc.
       */
      static validColorString(str) {
        if (str.indexOf("#") >= 0) {
          return !!_Color.parseHex(str);
        }
        if (str.indexOf("rgb") >= 0) {
          return !!_Color.stringToRgba(str);
        }
        return !!_Color.nameToHex[str.toLowerCase()];
      }
      /**
       * The given string can be in one of the following formats:
       * - #rgb
       * - #rrggbb
       * - rgb(r, g, b)
       * - rgba(r, g, b, a)
       * - CSS color name such as 'white', 'orange', 'cyan', etc.
       * @param str
       */
      static fromString(str) {
        if (str.indexOf("#") >= 0) {
          return _Color.fromHexString(str);
        }
        const hex = _Color.nameToHex[str.toLowerCase()];
        if (hex) {
          return _Color.fromHexString(hex);
        }
        if (str.indexOf("rgb") >= 0) {
          return _Color.fromRgbaString(str);
        }
        throw new Error(`Invalid color string: '${str}'`);
      }
      static tryParseFromString(str) {
        try {
          return _Color.fromString(str);
        } catch (e) {
          Logger.warnOnce(`invalid color string: '${str}'.`);
          return _Color.fromArray([0, 0, 0]);
        }
      }
      // See https://drafts.csswg.org/css-color/#hex-notation
      static parseHex(input) {
        input = input.replace(/ /g, "").slice(1);
        let parts;
        switch (input.length) {
          case 6:
          case 8:
            parts = [];
            for (let i = 0; i < input.length; i += 2) {
              parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));
            }
            break;
          case 3:
          case 4:
            parts = input.split("").map((p) => parseInt(p, 16)).map((p) => p + p * 16);
            break;
        }
        if ((parts == null ? void 0 : parts.length) >= 3 && parts.every((p) => p >= 0)) {
          if (parts.length === 3) {
            parts.push(255);
          }
          return parts;
        }
      }
      static fromHexString(str) {
        const values = _Color.parseHex(str);
        if (values) {
          const [r, g, b, a] = values;
          return new _Color(r / 255, g / 255, b / 255, a / 255);
        }
        throw new Error(`Malformed hexadecimal color string: '${str}'`);
      }
      static stringToRgba(str) {
        let [po, pc] = [NaN, NaN];
        for (let i = 0; i < str.length; i++) {
          const c = str[i];
          if (!po && c === "(") {
            po = i;
          } else if (c === ")") {
            pc = i;
            break;
          }
        }
        const contents = po && pc && str.substring(po + 1, pc);
        if (!contents) {
          return;
        }
        const parts = contents.split(",");
        const rgba = [];
        for (let i = 0; i < parts.length; i++) {
          const part = parts[i];
          let value = parseFloat(part);
          if (isNaN(value)) {
            return;
          }
          if (part.indexOf("%") >= 0) {
            value = clamp(0, value, 100);
            value /= 100;
          } else if (i === 3) {
            value = clamp(0, value, 1);
          } else {
            value = clamp(0, value, 255);
            value /= 255;
          }
          rgba.push(value);
        }
        return rgba;
      }
      static fromRgbaString(str) {
        const rgba = _Color.stringToRgba(str);
        if (rgba) {
          if (rgba.length === 3) {
            return new _Color(rgba[0], rgba[1], rgba[2]);
          } else if (rgba.length === 4) {
            return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);
          }
        }
        throw new Error(`Malformed rgb/rgba color string: '${str}'`);
      }
      static fromArray(arr) {
        if (arr.length === 4) {
          return new _Color(arr[0], arr[1], arr[2], arr[3]);
        }
        if (arr.length === 3) {
          return new _Color(arr[0], arr[1], arr[2]);
        }
        throw new Error("The given array should contain 3 or 4 color components (numbers).");
      }
      static fromHSB(h, s, b, alpha = 1) {
        const rgb = _Color.HSBtoRGB(h, s, b);
        return new _Color(rgb[0], rgb[1], rgb[2], alpha);
      }
      static fromHSL(h, s, l, alpha = 1) {
        const rgb = _Color.HSLtoRGB(h, s, l);
        return new _Color(rgb[0], rgb[1], rgb[2], alpha);
      }
      static fromOKLCH(l, c, h, alpha = 1) {
        const rgb = _Color.OKLCHtoRGB(l, c, h);
        return new _Color(rgb[0], rgb[1], rgb[2], alpha);
      }
      static padHex(str) {
        return str.length === 1 ? "0" + str : str;
      }
      toHexString() {
        let hex = "#" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));
        if (this.a < 1) {
          hex += _Color.padHex(Math.round(this.a * 255).toString(16));
        }
        return hex;
      }
      toRgbaString(fractionDigits = 3) {
        const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];
        const k = Math.pow(10, fractionDigits);
        if (this.a !== 1) {
          components.push(Math.round(this.a * k) / k);
          return `rgba(${components.join(", ")})`;
        }
        return `rgb(${components.join(", ")})`;
      }
      toString() {
        if (this.a === 1) {
          return this.toHexString();
        }
        return this.toRgbaString();
      }
      toHSB() {
        return _Color.RGBtoHSB(this.r, this.g, this.b);
      }
      static RGBtoOKLCH(r, g, b) {
        const LSRGB0 = srgbToLinear(r);
        const LSRGB1 = srgbToLinear(g);
        const LSRGB2 = srgbToLinear(b);
        const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);
        const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);
        const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);
        const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;
        const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;
        const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;
        const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;
        const OKLCH0 = OKLAB0;
        const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);
        const OKLCH2 = hue >= 0 ? hue : hue + 360;
        return [OKLCH0, OKLCH1, OKLCH2];
      }
      static OKLCHtoRGB(l, c, h) {
        const OKLAB0 = l;
        const OKLAB1 = c * Math.cos(h * Math.PI / 180);
        const OKLAB2 = c * Math.sin(h * Math.PI / 180);
        const LMS0 = __pow(OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2, 3);
        const LMS1 = __pow(OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2, 3);
        const LMS2 = __pow(OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2, 3);
        const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;
        const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;
        const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;
        const SRGB0 = srgbFromLinear(LSRGB0);
        const SRGB1 = srgbFromLinear(LSRGB1);
        const SRGB2 = srgbFromLinear(LSRGB2);
        return [SRGB0, SRGB1, SRGB2];
      }
      static RGBtoHSL(r, g, b) {
        const min = Math.min(r, g, b);
        const max = Math.max(r, g, b);
        const l = (max + min) / 2;
        let h;
        let s;
        if (max === min) {
          h = NaN;
          s = 0;
        } else {
          const delta3 = max - min;
          s = l > 0.5 ? delta3 / (2 - max - min) : delta3 / (max + min);
          if (max === r) {
            h = (g - b) / delta3 + (g < b ? 6 : 0);
          } else if (max === g) {
            h = (b - r) / delta3 + 2;
          } else {
            h = (r - g) / delta3 + 4;
          }
          h *= 360 / 6;
        }
        return [h, s, l];
      }
      static HSLtoRGB(h, s, l) {
        if (s === 0) {
          return [l, l, l];
        }
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        function hueToRgb(t) {
          if (t < 0)
            t += 1;
          if (t > 1)
            t -= 1;
          if (t < 1 / 6)
            return p + (q - p) * 6 * t;
          if (t < 1 / 2)
            return q;
          if (t < 2 / 3)
            return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        }
        const r = hueToRgb(h / 360 + 1 / 3);
        const g = hueToRgb(h / 360);
        const b = hueToRgb(h / 360 - 1 / 3);
        return [r, g, b];
      }
      /**
       * Converts the given RGB triple to an array of HSB (HSV) components.
       * The hue component will be `NaN` for achromatic colors.
       */
      static RGBtoHSB(r, g, b) {
        const min = Math.min(r, g, b);
        const max = Math.max(r, g, b);
        const S = max === 0 ? 0 : (max - min) / max;
        let H = NaN;
        if (min !== max) {
          const delta3 = max - min;
          const rc = (max - r) / delta3;
          const gc = (max - g) / delta3;
          const bc = (max - b) / delta3;
          if (r === max) {
            H = bc - gc;
          } else if (g === max) {
            H = 2 + rc - bc;
          } else {
            H = 4 + gc - rc;
          }
          H /= 6;
          if (H < 0) {
            H = H + 1;
          }
        }
        return [H * 360, S, max];
      }
      /**
       * Converts the given HSB (HSV) triple to an array of RGB components.
       */
      static HSBtoRGB(H, S, B) {
        if (isNaN(H)) {
          H = 0;
        }
        H = (H % 360 + 360) % 360 / 360;
        let r = 0;
        let g = 0;
        let b = 0;
        if (S === 0) {
          r = g = b = B;
        } else {
          const h = (H - Math.floor(H)) * 6;
          const f = h - Math.floor(h);
          const p = B * (1 - S);
          const q = B * (1 - S * f);
          const t = B * (1 - S * (1 - f));
          switch (h >> 0) {
            case 0:
              r = B;
              g = t;
              b = p;
              break;
            case 1:
              r = q;
              g = B;
              b = p;
              break;
            case 2:
              r = p;
              g = B;
              b = t;
              break;
            case 3:
              r = p;
              g = q;
              b = B;
              break;
            case 4:
              r = t;
              g = p;
              b = B;
              break;
            case 5:
              r = B;
              g = p;
              b = q;
              break;
          }
        }
        return [r, g, b];
      }
      derive(hueShift, saturationFactor, brightnessFactor, opacityFactor) {
        const hsb = _Color.RGBtoHSB(this.r, this.g, this.b);
        let b = hsb[2];
        if (b == 0 && brightnessFactor > 1) {
          b = 0.05;
        }
        const h = ((hsb[0] + hueShift) % 360 + 360) % 360;
        const s = clamp(0, hsb[1] * saturationFactor, 1);
        b = clamp(0, b * brightnessFactor, 1);
        const a = clamp(0, this.a * opacityFactor, 1);
        const rgba = _Color.HSBtoRGB(h, s, b);
        rgba.push(a);
        return _Color.fromArray(rgba);
      }
      brighter() {
        return this.derive(0, 1, 1 / 0.7, 1);
      }
      darker() {
        return this.derive(0, 1, 0.7, 1);
      }
      static interpolate(color, other) {
        const c0 = _Color.tryParseFromString(color);
        const c1 = _Color.tryParseFromString(other);
        return (t) => {
          const i = (x, y) => x * (1 - t) + y * t;
          const c = new _Color(i(c0.r, c1.r), i(c0.g, c1.g), i(c0.b, c1.b), i(c0.a, c1.a));
          return c.toString();
        };
      }
    };
    _Color.didDebug = false;
    /**
     * CSS Color Module Level 4:
     * https://drafts.csswg.org/css-color/#named-colors
     */
    _Color.nameToHex = Object.freeze({
      aliceblue: "#F0F8FF",
      antiquewhite: "#FAEBD7",
      aqua: "#00FFFF",
      aquamarine: "#7FFFD4",
      azure: "#F0FFFF",
      beige: "#F5F5DC",
      bisque: "#FFE4C4",
      black: "#000000",
      blanchedalmond: "#FFEBCD",
      blue: "#0000FF",
      blueviolet: "#8A2BE2",
      brown: "#A52A2A",
      burlywood: "#DEB887",
      cadetblue: "#5F9EA0",
      chartreuse: "#7FFF00",
      chocolate: "#D2691E",
      coral: "#FF7F50",
      cornflowerblue: "#6495ED",
      cornsilk: "#FFF8DC",
      crimson: "#DC143C",
      cyan: "#00FFFF",
      darkblue: "#00008B",
      darkcyan: "#008B8B",
      darkgoldenrod: "#B8860B",
      darkgray: "#A9A9A9",
      darkgreen: "#006400",
      darkgrey: "#A9A9A9",
      darkkhaki: "#BDB76B",
      darkmagenta: "#8B008B",
      darkolivegreen: "#556B2F",
      darkorange: "#FF8C00",
      darkorchid: "#9932CC",
      darkred: "#8B0000",
      darksalmon: "#E9967A",
      darkseagreen: "#8FBC8F",
      darkslateblue: "#483D8B",
      darkslategray: "#2F4F4F",
      darkslategrey: "#2F4F4F",
      darkturquoise: "#00CED1",
      darkviolet: "#9400D3",
      deeppink: "#FF1493",
      deepskyblue: "#00BFFF",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1E90FF",
      firebrick: "#B22222",
      floralwhite: "#FFFAF0",
      forestgreen: "#228B22",
      fuchsia: "#FF00FF",
      gainsboro: "#DCDCDC",
      ghostwhite: "#F8F8FF",
      gold: "#FFD700",
      goldenrod: "#DAA520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#ADFF2F",
      grey: "#808080",
      honeydew: "#F0FFF0",
      hotpink: "#FF69B4",
      indianred: "#CD5C5C",
      indigo: "#4B0082",
      ivory: "#FFFFF0",
      khaki: "#F0E68C",
      lavender: "#E6E6FA",
      lavenderblush: "#FFF0F5",
      lawngreen: "#7CFC00",
      lemonchiffon: "#FFFACD",
      lightblue: "#ADD8E6",
      lightcoral: "#F08080",
      lightcyan: "#E0FFFF",
      lightgoldenrodyellow: "#FAFAD2",
      lightgray: "#D3D3D3",
      lightgreen: "#90EE90",
      lightgrey: "#D3D3D3",
      lightpink: "#FFB6C1",
      lightsalmon: "#FFA07A",
      lightseagreen: "#20B2AA",
      lightskyblue: "#87CEFA",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#B0C4DE",
      lightyellow: "#FFFFE0",
      lime: "#00FF00",
      limegreen: "#32CD32",
      linen: "#FAF0E6",
      magenta: "#FF00FF",
      maroon: "#800000",
      mediumaquamarine: "#66CDAA",
      mediumblue: "#0000CD",
      mediumorchid: "#BA55D3",
      mediumpurple: "#9370DB",
      mediumseagreen: "#3CB371",
      mediumslateblue: "#7B68EE",
      mediumspringgreen: "#00FA9A",
      mediumturquoise: "#48D1CC",
      mediumvioletred: "#C71585",
      midnightblue: "#191970",
      mintcream: "#F5FFFA",
      mistyrose: "#FFE4E1",
      moccasin: "#FFE4B5",
      navajowhite: "#FFDEAD",
      navy: "#000080",
      oldlace: "#FDF5E6",
      olive: "#808000",
      olivedrab: "#6B8E23",
      orange: "#FFA500",
      orangered: "#FF4500",
      orchid: "#DA70D6",
      palegoldenrod: "#EEE8AA",
      palegreen: "#98FB98",
      paleturquoise: "#AFEEEE",
      palevioletred: "#DB7093",
      papayawhip: "#FFEFD5",
      peachpuff: "#FFDAB9",
      peru: "#CD853F",
      pink: "#FFC0CB",
      plum: "#DDA0DD",
      powderblue: "#B0E0E6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#FF0000",
      rosybrown: "#BC8F8F",
      royalblue: "#4169E1",
      saddlebrown: "#8B4513",
      salmon: "#FA8072",
      sandybrown: "#F4A460",
      seagreen: "#2E8B57",
      seashell: "#FFF5EE",
      sienna: "#A0522D",
      silver: "#C0C0C0",
      skyblue: "#87CEEB",
      slateblue: "#6A5ACD",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#FFFAFA",
      springgreen: "#00FF7F",
      steelblue: "#4682B4",
      tan: "#D2B48C",
      teal: "#008080",
      thistle: "#D8BFD8",
      tomato: "#FF6347",
      transparent: "#00000000",
      turquoise: "#40E0D0",
      violet: "#EE82EE",
      wheat: "#F5DEB3",
      white: "#FFFFFF",
      whitesmoke: "#F5F5F5",
      yellow: "#FFFF00",
      yellowgreen: "#9ACD32"
    });
    Color = _Color;
  }
});

// packages/ag-charts-community/src/util/interpolate.ts
function interpolateNumber(a, b) {
  return (d) => Number(a) * (1 - d) + Number(b) * d;
}
function interpolateColor(a, b) {
  if (typeof a === "string") {
    try {
      a = Color.fromString(a);
    } catch (e) {
      a = Color.fromArray([0, 0, 0]);
    }
  }
  if (typeof b === "string") {
    try {
      b = Color.fromString(b);
    } catch (e) {
      b = Color.fromArray([0, 0, 0]);
    }
  }
  const red = interpolateNumber(a.r, b.r);
  const green = interpolateNumber(a.g, b.g);
  const blue = interpolateNumber(a.b, b.b);
  const alpha = interpolateNumber(a.a, b.a);
  return (d) => Color.fromArray([red(d), green(d), blue(d), alpha(d)]).toRgbaString();
}
var init_interpolate = __esm({
  "packages/ag-charts-community/src/util/interpolate.ts"() {
    "use strict";
    init_color();
  }
});

// packages/ag-charts-community/src/motion/easing.ts
var easing_exports = {};
__export(easing_exports, {
  easeIn: () => easeIn,
  easeInOut: () => easeInOut,
  easeInOutQuad: () => easeInOutQuad,
  easeInQuad: () => easeInQuad,
  easeOut: () => easeOut,
  easeOutQuad: () => easeOutQuad,
  inverseEaseOut: () => inverseEaseOut,
  linear: () => linear
});
var linear, easeIn, easeOut, easeInOut, easeInQuad, easeOutQuad, easeInOutQuad, inverseEaseOut;
var init_easing = __esm({
  "packages/ag-charts-community/src/motion/easing.ts"() {
    "use strict";
    linear = (n) => n;
    easeIn = (n) => 1 - Math.cos(n * Math.PI / 2);
    easeOut = (n) => Math.sin(n * Math.PI / 2);
    easeInOut = (n) => -(Math.cos(n * Math.PI) - 1) / 2;
    easeInQuad = (n) => n * n;
    easeOutQuad = (n) => 1 - __pow(1 - n, 2);
    easeInOutQuad = (n) => n < 0.5 ? 2 * n * n : 1 - __pow(-2 * n + 2, 2) / 2;
    inverseEaseOut = (x) => 2 * Math.asin(x) / Math.PI;
  }
});

// packages/ag-charts-community/src/motion/animation.ts
function isNodeArray(array) {
  return array.every((n) => n instanceof Node);
}
function deconstructSelectionsOrNodes(selectionsOrNodes) {
  return isNodeArray(selectionsOrNodes) ? { nodes: selectionsOrNodes, selections: [] } : { nodes: [], selections: selectionsOrNodes };
}
var QUICK_TRANSITION, PHASE_ORDER, PHASE_METADATA, RepeatType, Animation;
var init_animation = __esm({
  "packages/ag-charts-community/src/motion/animation.ts"() {
    "use strict";
    init_node();
    init_interpolate();
    init_interpolating();
    init_json();
    init_number();
    init_easing();
    QUICK_TRANSITION = 0.2;
    PHASE_ORDER = ["initial", "remove", "update", "add", "trailing", "end", "none"];
    PHASE_METADATA = {
      initial: {
        animationDuration: 1,
        animationDelay: 0
      },
      add: {
        animationDuration: 0.25,
        animationDelay: 0.75
      },
      remove: {
        animationDuration: 0.25,
        animationDelay: 0
      },
      update: {
        animationDuration: 0.5,
        animationDelay: 0.25
      },
      trailing: {
        animationDuration: QUICK_TRANSITION,
        animationDelay: 1,
        skipIfNoEarlierAnimations: true
      },
      end: {
        animationDelay: 1 + QUICK_TRANSITION,
        animationDuration: 0,
        skipIfNoEarlierAnimations: true
      },
      none: {
        animationDuration: 0,
        animationDelay: 0
      }
    };
    RepeatType = /* @__PURE__ */ ((RepeatType2) => {
      RepeatType2["Loop"] = "loop";
      RepeatType2["Reverse"] = "reverse";
      return RepeatType2;
    })(RepeatType || {});
    Animation = class {
      constructor(opts) {
        this.isComplete = false;
        this.elapsed = 0;
        this.iteration = 0;
        this.isPlaying = false;
        this.isReverse = false;
        var _a2, _b, _c, _d, _e, _f, _g;
        this.id = opts.id;
        this.groupId = opts.groupId;
        this.autoplay = (_a2 = opts.autoplay) != null ? _a2 : true;
        this.ease = (_b = opts.ease) != null ? _b : linear;
        this.phase = opts.phase;
        const durationProportion = (_c = opts.duration) != null ? _c : PHASE_METADATA[this.phase].animationDuration;
        this.duration = durationProportion * opts.defaultDuration;
        this.delay = ((_d = opts.delay) != null ? _d : 0) * opts.defaultDuration;
        this.onComplete = opts.onComplete;
        this.onPlay = opts.onPlay;
        this.onStop = opts.onStop;
        this.onUpdate = opts.onUpdate;
        this.interpolate = this.createInterpolator(opts.from, opts.to);
        this.from = opts.from;
        if (opts.skip === true) {
          (_e = this.onUpdate) == null ? void 0 : _e.call(this, opts.to, false, this);
          (_f = this.onStop) == null ? void 0 : _f.call(this, this);
          (_g = this.onComplete) == null ? void 0 : _g.call(this, this);
          this.isComplete = true;
        }
        if (opts.collapsable !== false) {
          this.duration = this.checkCollapse(opts, this.duration);
        }
      }
      checkCollapse(opts, calculatedDuration) {
        if (opts.from === opts.to)
          return 0;
        const diff8 = typeof opts.from === "object" ? jsonDiff(opts.from, opts.to) : null;
        if (diff8) {
          return calculatedDuration;
        }
        return 0;
      }
      play(initialUpdate = false) {
        var _a2, _b;
        if (this.isPlaying || this.isComplete)
          return;
        this.isPlaying = true;
        (_a2 = this.onPlay) == null ? void 0 : _a2.call(this, this);
        if (!this.autoplay)
          return;
        this.autoplay = false;
        if (!initialUpdate)
          return;
        (_b = this.onUpdate) == null ? void 0 : _b.call(this, this.from, true, this);
      }
      pause() {
        this.isPlaying = false;
      }
      stop() {
        var _a2;
        this.isPlaying = false;
        if (!this.isComplete) {
          this.isComplete = true;
          (_a2 = this.onStop) == null ? void 0 : _a2.call(this, this);
        }
      }
      update(time2) {
        var _a2, _b;
        if (this.isComplete)
          return time2;
        if (!this.isPlaying && this.autoplay) {
          this.play(true);
        }
        const previousElapsed = this.elapsed;
        this.elapsed += time2;
        if (this.delay > this.elapsed)
          return 0;
        const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);
        (_a2 = this.onUpdate) == null ? void 0 : _a2.call(this, value, false, this);
        const totalDuration = this.delay + this.duration;
        if (this.elapsed >= totalDuration) {
          this.stop();
          this.isComplete = true;
          (_b = this.onComplete) == null ? void 0 : _b.call(this, this);
          return time2 - (totalDuration - previousElapsed);
        }
        return 0;
      }
      get delta() {
        return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));
      }
      createInterpolator(from, to) {
        if (typeof to !== "object" || isInterpolating(to)) {
          return this.interpolateValue(from, to);
        }
        const interpolatorEntries = [];
        for (const key in to) {
          const interpolator = this.interpolateValue(from[key], to[key]);
          if (interpolator != null) {
            interpolatorEntries.push([key, interpolator]);
          }
        }
        return (d) => {
          const result = {};
          for (const [key, interpolator] of interpolatorEntries) {
            result[key] = interpolator(d);
          }
          return result;
        };
      }
      interpolateValue(a, b) {
        if (a === void 0 || b === void 0) {
          return;
        } else if (isInterpolating(a)) {
          return (d) => a[interpolate](b, d);
        }
        try {
          switch (typeof a) {
            case "number":
              return interpolateNumber(a, b);
            case "string":
              return interpolateColor(a, b);
            case "boolean":
              if (a === b)
                return () => a;
              break;
          }
        } catch (e) {
        }
        throw new Error(`Unable to interpolate values: ${a}, ${b}`);
      }
    };
  }
});

// packages/ag-charts-community/src/motion/fromToMotion.ts
var fromToMotion_exports = {};
__export(fromToMotion_exports, {
  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,
  fromToMotion: () => fromToMotion,
  staticFromToMotion: () => staticFromToMotion
});
function fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff8) {
  const { fromFn, toFn, intermediateFn } = fns;
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  const processNodes = (liveNodes, subNodes) => {
    var _c;
    let prevFromProps;
    let liveNodeIndex = 0;
    let nodeIndex = 0;
    for (const node of subNodes) {
      const isLive = liveNodes[liveNodeIndex] === node;
      const ctx = {
        last: nodeIndex >= subNodes.length - 1,
        lastLive: liveNodeIndex >= liveNodes.length - 1,
        prev: subNodes[nodeIndex - 1],
        prevFromProps,
        prevLive: liveNodes[liveNodeIndex - 1],
        next: subNodes[nodeIndex + 1],
        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]
      };
      const animationId = `${groupId}_${subId}_${node.id}`;
      animationManager.stopByAnimationId(animationId);
      let status = "unknown";
      if (!isLive) {
        status = "removed";
      } else if (getDatumId && diff8) {
        status = calculateStatus(node, node.datum, getDatumId, diff8);
      }
      const _a2 = fromFn(node, node.datum, status, ctx), { phase, start, finish, delay, duration } = _a2, from = __objRest(_a2, ["phase", "start", "finish", "delay", "duration"]);
      const _b = toFn(node, node.datum, status, ctx), {
        phase: toPhase,
        start: toStart,
        finish: toFinish,
        delay: toDelay,
        duration: toDuration
      } = _b, to = __objRest(_b, [
        "phase",
        "start",
        "finish",
        "delay",
        "duration"
      ]);
      const collapsable = finish == null && toFinish == null;
      animationManager.animate({
        id: animationId,
        groupId,
        phase: (_c = phase != null ? phase : toPhase) != null ? _c : "update",
        duration: duration != null ? duration : toDuration,
        delay: delay != null ? delay : toDelay,
        from,
        to,
        ease: easeOut,
        collapsable,
        onPlay: () => {
          node.setProperties(__spreadValues(__spreadValues({}, start), toStart));
        },
        onUpdate(props) {
          node.setProperties(props);
          if (intermediateFn) {
            node.setProperties(intermediateFn(node, node.datum, status, ctx));
          }
        },
        onStop: () => {
          node.setProperties(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, start), toStart), from), to), finish), toFinish));
        }
      });
      if (isLive) {
        liveNodeIndex++;
      }
      nodeIndex++;
      prevFromProps = from;
    }
  };
  let selectionIndex = 0;
  for (const selection of selections) {
    const selectionNodes = selection.nodes();
    const liveNodes = selectionNodes.filter((n) => !selection.isGarbage(n));
    processNodes(liveNodes, selectionNodes);
    animationManager.animate({
      id: `${groupId}_${subId}_selection_${selectionIndex}`,
      groupId,
      phase: "end",
      from: 0,
      to: 1,
      ease: easeOut,
      onStop() {
        selection.cleanup();
      }
    });
    selectionIndex++;
  }
  processNodes(nodes, nodes);
}
function staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from, to, extraOpts) {
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  const { start, finish, phase } = extraOpts;
  const collapsable = finish == null;
  animationManager.animate({
    id: `${groupId}_${subId}`,
    groupId,
    phase: phase != null ? phase : "update",
    from,
    to,
    ease: easeOut,
    collapsable,
    onPlay: () => {
      if (!start)
        return;
      for (const node of nodes) {
        node.setProperties(start);
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(start);
        }
      }
    },
    onUpdate(props) {
      for (const node of nodes) {
        node.setProperties(props);
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(props);
        }
      }
    },
    onStop: () => {
      for (const node of nodes) {
        node.setProperties(__spreadValues(__spreadValues({}, to), finish));
      }
      for (const selection of selections) {
        for (const node of selection.nodes()) {
          node.setProperties(__spreadValues(__spreadValues({}, to), finish));
        }
      }
    }
  });
}
function calculateStatus(node, datum, getDatumId, diff8) {
  const id = getDatumId(node, datum);
  if (diff8.added.has(id)) {
    return "added";
  }
  if (diff8.removed.has(id)) {
    return "removed";
  }
  return "updated";
}
var NODE_UPDATE_STATE_TO_PHASE_MAPPING;
var init_fromToMotion = __esm({
  "packages/ag-charts-community/src/motion/fromToMotion.ts"() {
    "use strict";
    init_animation();
    init_easing();
    NODE_UPDATE_STATE_TO_PHASE_MAPPING = {
      added: "add",
      updated: "update",
      removed: "remove",
      unknown: "initial",
      "no-op": "none"
    };
  }
});

// packages/ag-charts-community/src/util/angle.ts
function normalizeAngle360(radians) {
  radians %= twoPi;
  radians += twoPi;
  radians %= twoPi;
  return radians;
}
function normalizeAngle360Inclusive(radians) {
  radians %= twoPi;
  radians += twoPi;
  if (radians !== twoPi) {
    radians %= twoPi;
  }
  return radians;
}
function normalizeAngle180(radians) {
  radians %= twoPi;
  if (radians < -Math.PI) {
    radians += twoPi;
  } else if (radians >= Math.PI) {
    radians -= twoPi;
  }
  return radians;
}
function isBetweenAngles(targetAngle, startAngle, endAngle) {
  const t = normalizeAngle360(targetAngle);
  const a0 = normalizeAngle360(startAngle);
  const a1 = normalizeAngle360Inclusive(endAngle);
  if (a0 <= a1) {
    return a0 <= t && t <= a1;
  } else {
    return a0 <= t || t <= a1;
  }
}
function toRadians(degrees) {
  return degrees / 180 * Math.PI;
}
function toDegrees(radians) {
  return radians / Math.PI * 180;
}
function angleBetween(angle0, angle1) {
  angle0 = normalizeAngle360(angle0);
  angle1 = normalizeAngle360(angle1);
  return angle1 - angle0 + (angle0 > angle1 ? 2 * Math.PI : 0);
}
function displacePointFromVector(centerX, centerY, radius, angle) {
  const x = centerX + radius * Math.cos(angle);
  const y = centerY + radius * Math.sin(angle);
  return { x, y };
}
var twoPi;
var init_angle = __esm({
  "packages/ag-charts-community/src/util/angle.ts"() {
    "use strict";
    twoPi = Math.PI * 2;
  }
});

// packages/ag-charts-community/src/scale/invalidating.ts
var Invalidating;
var init_invalidating = __esm({
  "packages/ag-charts-community/src/scale/invalidating.ts"() {
    "use strict";
    Invalidating = (target, propertyKey) => {
      const mappedProperty = Symbol(String(propertyKey));
      target[mappedProperty] = void 0;
      Object.defineProperty(target, propertyKey, {
        get() {
          return this[mappedProperty];
        },
        set(newValue) {
          const oldValue = this[mappedProperty];
          if (oldValue !== newValue) {
            this[mappedProperty] = newValue;
            this.invalid = true;
          }
        },
        enumerable: true,
        configurable: false
      });
    };
  }
});

// packages/ag-charts-community/src/scale/bandScale.ts
var _BandScale, BandScale;
var init_bandScale = __esm({
  "packages/ag-charts-community/src/scale/bandScale.ts"() {
    "use strict";
    init_logger();
    init_number();
    init_invalidating();
    _BandScale = class _BandScale {
      constructor() {
        this.type = "band";
        this.invalid = true;
        this.interval = void 0;
        /**
         * Maps datum to its index in the {@link domain} array.
         * Used to check for duplicate datums (not allowed).
         */
        this.index = /* @__PURE__ */ new Map();
        /**
         * The output range values for datum at each index.
         */
        this.ordinalRange = [];
        /**
         * Contains unique datums only. Since `{}` is used in place of `Map`
         * for IE11 compatibility, the datums are converted `toString` before
         * the uniqueness check.
         */
        this._domain = [];
        this.range = [0, 1];
        this._bandwidth = 1;
        this._step = 1;
        this._rawBandwidth = 1;
        /**
         * The ratio of the range that is reserved for space between bands.
         */
        this._paddingInner = 0;
        /**
         * The ratio of the range that is reserved for space before the first
         * and after the last band.
         */
        this._paddingOuter = 0;
        this.round = false;
      }
      static is(value) {
        return value instanceof _BandScale;
      }
      refresh() {
        if (!this.invalid)
          return;
        this.invalid = false;
        this.update();
        if (this.invalid) {
          Logger.warnOnce("Expected update to not invalidate scale");
        }
      }
      set domain(values) {
        this.invalid = true;
        const domain = [];
        this.index = /* @__PURE__ */ new Map();
        const index = this.index;
        values.forEach((value) => {
          if (this.getIndex(value) === void 0) {
            index.set(value, domain.push(value) - 1);
          }
        });
        this._domain = domain;
      }
      get domain() {
        return this._domain;
      }
      ticks() {
        this.refresh();
        let { interval = 1 } = this;
        if (typeof interval !== "number") {
          interval = Number(interval);
        }
        const step = Math.abs(Math.round(interval));
        return this._domain.filter((_, i) => i % step === 0);
      }
      convert(d) {
        this.refresh();
        const i = this.getIndex(d);
        if (i === void 0) {
          return NaN;
        }
        const r = this.ordinalRange[i];
        if (r === void 0) {
          return NaN;
        }
        return r;
      }
      invert(position) {
        this.refresh();
        const index = this.ordinalRange.findIndex((p) => p === position);
        return this.domain[index];
      }
      invertNearest(position) {
        var _a2;
        this.refresh();
        let nearest = -1;
        let minDistance = Infinity;
        const index = this.ordinalRange.findIndex((p, i) => {
          if (p === position)
            return true;
          const distance2 = Math.abs(position - p);
          if (distance2 < minDistance) {
            minDistance = distance2;
            nearest = i;
          }
          return false;
        });
        return (_a2 = this.domain[index]) != null ? _a2 : this.domain[nearest];
      }
      get bandwidth() {
        this.refresh();
        return this._bandwidth;
      }
      get step() {
        this.refresh();
        return this._step;
      }
      get rawBandwidth() {
        this.refresh();
        return this._rawBandwidth;
      }
      set padding(value) {
        value = clamp(0, value, 1);
        this._paddingInner = value;
        this._paddingOuter = value;
      }
      get padding() {
        return this._paddingInner;
      }
      set paddingInner(value) {
        this._paddingInner = clamp(0, value, 1);
      }
      get paddingInner() {
        return this._paddingInner;
      }
      set paddingOuter(value) {
        this._paddingOuter = clamp(0, value, 1);
      }
      get paddingOuter() {
        return this._paddingOuter;
      }
      update() {
        const count = this._domain.length;
        if (count === 0) {
          return;
        }
        const round4 = this.round;
        const paddingInner = this._paddingInner;
        const paddingOuter = this._paddingOuter;
        const [r0, r1] = this.range;
        const width = r1 - r0;
        const rawStep = width / Math.max(1, count + 2 * paddingOuter - paddingInner);
        const step = round4 ? Math.floor(rawStep) : rawStep;
        const fullBandWidth = step * (count - paddingInner);
        const x0 = r0 + (width - fullBandWidth) / 2;
        const start = round4 ? Math.round(x0) : x0;
        const bw = step * (1 - paddingInner);
        const bandwidth = round4 ? Math.round(bw) : bw;
        const rawBandwidth = rawStep * (1 - paddingInner);
        const values = [];
        for (let i = 0; i < count; i++) {
          values.push(start + step * i);
        }
        this._bandwidth = bandwidth;
        this._rawBandwidth = rawBandwidth;
        this._step = step;
        this.ordinalRange = values;
      }
      getIndex(value) {
        if (!(value instanceof Date)) {
          return this.index.get(value);
        }
        const valueOf = value.valueOf();
        let index = 0;
        for (const key of this.index.keys()) {
          if (key instanceof Date && key.valueOf() === valueOf) {
            return index;
          }
          index++;
        }
      }
    };
    __decorateClass([
      Invalidating
    ], _BandScale.prototype, "interval", 2);
    __decorateClass([
      Invalidating
    ], _BandScale.prototype, "range", 2);
    __decorateClass([
      Invalidating
    ], _BandScale.prototype, "round", 2);
    BandScale = _BandScale;
  }
});

// packages/ag-charts-community/src/util/default.ts
function Default(defaultValue, replaces = [void 0]) {
  return addTransformToInstanceProperty((_, __, v) => {
    if (replaces.includes(v)) {
      return isFunction(defaultValue) ? defaultValue(v) : defaultValue;
    }
    return v;
  });
}
var init_default = __esm({
  "packages/ag-charts-community/src/util/default.ts"() {
    "use strict";
    init_decorator();
    init_type_guards();
  }
});

// packages/ag-charts-community/src/util/validation.ts
function Validate(predicate, options = {}) {
  const { optional = false, property: overrideProperty } = options;
  return addTransformToInstanceProperty(
    (target, property, value) => {
      var _a2;
      const context = __spreadProps(__spreadValues({}, options), { target, property });
      if (optional && typeof value === "undefined" || predicate(value, context)) {
        if (isProperties(target[property]) && !isProperties(value)) {
          target[property].set(value);
          return target[property];
        }
        return value;
      }
      const cleanKey = overrideProperty != null ? overrideProperty : String(property).replace(/^_*/, "");
      const targetName = (_a2 = target.constructor.className) != null ? _a2 : target.constructor.name.replace(/Properties$/, "");
      let valueString = stringify(value);
      const maxLength = 50;
      if (valueString != null && valueString.length > maxLength) {
        const excessCharacters = valueString.length - maxLength;
        valueString = valueString.slice(0, maxLength) + `... (+${excessCharacters} characters)`;
      }
      Logger.warn(
        `Property [${cleanKey}] of [${targetName}] cannot be set to [${valueString}]${predicate.message ? `; expecting ${getPredicateMessage(predicate, context)}` : ""}, ignoring.`
      );
      return BREAK_TRANSFORM_CHAIN;
    },
    void 0,
    { optional }
  );
}
function UNION(options, message = "a") {
  return predicateWithMessage(
    (v) => options.includes(v),
    `${message} keyword such as ${joinUnionOptions(options)}`
  );
}
function predicateWithMessage(predicate, message) {
  predicate.message = message;
  return predicate;
}
function joinUnionOptions(options) {
  const values = options.map((option) => `'${option}'`);
  if (values.length === 1) {
    return values[0];
  }
  const lastValue = values.pop();
  return `${values.join(", ")} or ${lastValue}`;
}
function getPredicateMessage(predicate, ctx) {
  return isFunction(predicate.message) ? predicate.message(ctx) : predicate.message;
}
function getPredicateMessageMapper(ctx) {
  return (predicate) => getPredicateMessage(predicate, ctx);
}
function attachArrayRestrictions(predicate) {
  return Object.assign(predicate, {
    restrict({ length, minLength } = {}) {
      let message = "an array";
      if (isNumber(minLength) && minLength > 0) {
        message = "a non-empty array";
      } else if (isNumber(length)) {
        message = `an array of length ${length}`;
      }
      return predicateWithMessage(
        (value) => isArray(value) && (isNumber(length) ? value.length === length : true) && (isNumber(minLength) ? value.length >= minLength : true),
        message
      );
    }
  });
}
function attachNumberRestrictions(predicate) {
  return Object.assign(predicate, {
    restrict({ min, max } = {}) {
      const message = ["a number"];
      const hasMin = isNumber(min);
      const hasMax = isNumber(max);
      if (hasMin && hasMax) {
        message.push(`between ${min} and ${max} inclusive`);
      } else if (hasMin) {
        message.push(`greater than or equal to ${min}`);
      } else if (hasMax) {
        message.push(`less than or equal to ${max}`);
      }
      return predicateWithMessage(
        (value) => isFiniteNumber(value) && (hasMin ? value >= min : true) && (hasMax ? value <= max : true),
        message.join(" ")
      );
    }
  });
}
function attachObjectRestrictions(predicate) {
  return Object.assign(predicate, {
    restrict(objectType) {
      return predicateWithMessage(
        (value) => value instanceof objectType,
        (ctx) => {
          var _a2;
          return (_a2 = getPredicateMessage(predicate, ctx)) != null ? _a2 : `an instance of ${objectType.name}`;
        }
      );
    }
  });
}
function stringify(value) {
  if (typeof value === "number") {
    if (isNaN(value))
      return "NaN";
    if (value === Infinity)
      return "Infinity";
    if (value === -Infinity)
      return "-Infinity";
  }
  return JSON.stringify(value);
}
var AND, OR, OBJECT, PLAIN_OBJECT, BOOLEAN, FUNCTION, STRING, NUMBER, NAN, POSITIVE_NUMBER, RATIO, DEGREE, NUMBER_OR_NAN, ARRAY, ARRAY_OF, isComparable, LESS_THAN, GREATER_THAN, DATE, DATE_OR_DATETIME_MS, colorMessage, COLOR_STRING, COLOR_STRING_ARRAY, BOOLEAN_ARRAY, NUMBER_ARRAY, STRING_ARRAY, DATE_ARRAY, OBJECT_ARRAY, LINE_CAP, LINE_JOIN, LINE_DASH, POSITION2, FONT_STYLE, FONT_WEIGHT2, TEXT_WRAP, TEXT_ALIGN, VERTICAL_ALIGN, OVERFLOW_STRATEGY, DIRECTION, PLACEMENT, INTERACTION_RANGE, LABEL_PLACEMENT, MIN_SPACING, MAX_SPACING;
var init_validation = __esm({
  "packages/ag-charts-community/src/util/validation.ts"() {
    "use strict";
    init_color();
    init_decorator();
    init_logger();
    init_properties();
    init_type_guards();
    AND = (...predicates) => {
      const messages = [];
      return predicateWithMessage(
        (value, ctx) => {
          messages.length = 0;
          return predicates.every((predicate) => {
            const isValid = predicate(value, ctx);
            if (!isValid) {
              messages.push(getPredicateMessage(predicate, ctx));
            }
            return isValid;
          });
        },
        () => messages.filter(Boolean).join(" AND ")
      );
    };
    OR = (...predicates) => predicateWithMessage(
      (value, ctx) => predicates.some((predicate) => predicate(value, ctx)),
      (ctx) => predicates.map(getPredicateMessageMapper(ctx)).filter(Boolean).join(" OR ")
    );
    OBJECT = attachObjectRestrictions(
      predicateWithMessage(
        (value, ctx) => isProperties(value) || isObject(value) && isProperties(ctx.target[ctx.property]),
        "a properties object"
      )
    );
    PLAIN_OBJECT = attachObjectRestrictions(predicateWithMessage((value) => isObject(value), "an object"));
    BOOLEAN = predicateWithMessage(isBoolean, "a boolean");
    FUNCTION = predicateWithMessage(isFunction, "a function");
    STRING = predicateWithMessage(isString, "a string");
    NUMBER = attachNumberRestrictions(predicateWithMessage(isFiniteNumber, "a number"));
    NAN = predicateWithMessage((value) => isNumber(value) && isNaN(value), "NaN");
    POSITIVE_NUMBER = NUMBER.restrict({ min: 0 });
    RATIO = NUMBER.restrict({ min: 0, max: 1 });
    DEGREE = NUMBER.restrict({ min: -360, max: 360 });
    NUMBER_OR_NAN = OR(NUMBER, NAN);
    ARRAY = attachArrayRestrictions(predicateWithMessage(isArray, "an array"));
    ARRAY_OF = (predicate, message) => predicateWithMessage(
      (value, ctx) => isArray(value) && value.every((item) => predicate(item, ctx)),
      (ctx) => {
        var _a2;
        const arrayMessage = (_a2 = getPredicateMessage(ARRAY, ctx)) != null ? _a2 : "";
        return message ? `${arrayMessage} of ${message}` : arrayMessage;
      }
    );
    isComparable = (value) => isFiniteNumber(value) || isValidDate(value);
    LESS_THAN = (otherField) => predicateWithMessage(
      (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v < ctx.target[otherField],
      `to be less than ${otherField}`
    );
    GREATER_THAN = (otherField) => predicateWithMessage(
      (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v > ctx.target[otherField],
      `to be greater than ${otherField}`
    );
    DATE = predicateWithMessage(isValidDate, "Date object");
    DATE_OR_DATETIME_MS = OR(DATE, POSITIVE_NUMBER);
    colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;
    COLOR_STRING = predicateWithMessage(
      (v) => isString(v) && Color.validColorString(v),
      `color String. ${colorMessage}`
    );
    COLOR_STRING_ARRAY = predicateWithMessage(ARRAY_OF(COLOR_STRING), `color strings. ${colorMessage}`);
    BOOLEAN_ARRAY = ARRAY_OF(BOOLEAN, "boolean values");
    NUMBER_ARRAY = ARRAY_OF(NUMBER, "numbers");
    STRING_ARRAY = ARRAY_OF(STRING, "strings");
    DATE_ARRAY = predicateWithMessage(ARRAY_OF(DATE), "Date objects");
    OBJECT_ARRAY = predicateWithMessage(ARRAY_OF(OBJECT), "objects");
    LINE_CAP = UNION(["butt", "round", "square"], "a line cap");
    LINE_JOIN = UNION(["round", "bevel", "miter"], "a line join");
    LINE_DASH = predicateWithMessage(
      ARRAY_OF(POSITIVE_NUMBER),
      "numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels."
    );
    POSITION2 = UNION(["top", "right", "bottom", "left"], "a position");
    FONT_STYLE = UNION(["normal", "italic", "oblique"], "a font style");
    FONT_WEIGHT2 = OR(
      UNION(["normal", "bold", "bolder", "lighter"], "a font weight"),
      NUMBER.restrict({ min: 1, max: 1e3 })
    );
    TEXT_WRAP = UNION(["never", "always", "hyphenate", "on-space"], "a text wrap strategy");
    TEXT_ALIGN = UNION(["left", "center", "right"], "a text align");
    VERTICAL_ALIGN = UNION(["top", "middle", "bottom"], "a vertical align");
    OVERFLOW_STRATEGY = UNION(["ellipsis", "hide"], "an overflow strategy");
    DIRECTION = UNION(["horizontal", "vertical"], "a direction");
    PLACEMENT = UNION(["inside", "outside"], "a placement");
    INTERACTION_RANGE = OR(UNION(["exact", "nearest"], "interaction range"), NUMBER);
    LABEL_PLACEMENT = UNION(["top", "bottom", "left", "right"]);
    MIN_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), LESS_THAN("maxSpacing")), NAN);
    MAX_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), GREATER_THAN("minSpacing")), NAN);
  }
});

// packages/ag-charts-community/src/chart/axis/axisTick.ts
var TICK_INTERVAL, AxisTick;
var init_axisTick = __esm({
  "packages/ag-charts-community/src/chart/axis/axisTick.ts"() {
    "use strict";
    init_properties();
    init_interval();
    init_type_guards();
    init_validation();
    TICK_INTERVAL = predicateWithMessage(
      (value) => isFiniteNumber(value) && value > 0 || value instanceof TimeInterval,
      `a non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`
    );
    AxisTick = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.enabled = true;
        this.width = 1;
        this.size = 6;
        this.color = void 0;
        this.interval = void 0;
        this.values = void 0;
      }
    };
    __decorateClass([
      Validate(BOOLEAN)
    ], AxisTick.prototype, "enabled", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], AxisTick.prototype, "width", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], AxisTick.prototype, "size", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], AxisTick.prototype, "color", 2);
    __decorateClass([
      Validate(TICK_INTERVAL, { optional: true })
    ], AxisTick.prototype, "interval", 2);
    __decorateClass([
      Validate(ARRAY, { optional: true })
    ], AxisTick.prototype, "values", 2);
  }
});

// packages/ag-charts-community/src/chart/chartAxisDirection.ts
var ChartAxisDirection;
var init_chartAxisDirection = __esm({
  "packages/ag-charts-community/src/chart/chartAxisDirection.ts"() {
    "use strict";
    ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection17) => {
      ChartAxisDirection17["X"] = "x";
      ChartAxisDirection17["Y"] = "y";
      return ChartAxisDirection17;
    })(ChartAxisDirection || {});
  }
});

// packages/ag-charts-community/src/chart/chartOptions.ts
function assignJsonApplyConstructedArray(array, ctor) {
  var _a2;
  (_a2 = JSON_APPLY_PLUGINS.constructedArrays) == null ? void 0 : _a2.set(array, ctor);
}
var JSON_APPLY_PLUGINS;
var init_chartOptions2 = __esm({
  "packages/ag-charts-community/src/chart/chartOptions.ts"() {
    "use strict";
    JSON_APPLY_PLUGINS = {
      constructedArrays: /* @__PURE__ */ new WeakMap()
    };
  }
});

// packages/ag-charts-community/src/scale/continuousScale.ts
var _ContinuousScale, ContinuousScale;
var init_continuousScale = __esm({
  "packages/ag-charts-community/src/scale/continuousScale.ts"() {
    "use strict";
    init_logger();
    init_number();
    init_invalidating();
    _ContinuousScale = class _ContinuousScale {
      constructor(domain, range4) {
        this.invalid = true;
        this.nice = false;
        this.interval = void 0;
        this.tickCount = _ContinuousScale.defaultTickCount;
        this.minTickCount = 0;
        this.maxTickCount = Infinity;
        this.niceDomain = [];
        this.defaultClampMode = "raw";
        this.domain = domain;
        this.range = range4;
      }
      static is(value) {
        return value instanceof _ContinuousScale;
      }
      transform(x) {
        return x;
      }
      transformInvert(x) {
        return x;
      }
      calcBandwidth(smallestInterval = 1) {
        const { range: range4 } = this;
        const domain = this.getDomain();
        const rangeDistance = Math.abs(range4[1] - range4[0]);
        const intervals = Math.abs(domain[1] - domain[0]) / smallestInterval + 1;
        const maxBands = Math.floor(rangeDistance);
        const bands = Math.min(intervals, maxBands);
        return rangeDistance / Math.max(1, bands);
      }
      getDomain() {
        if (this.nice) {
          this.refresh();
          if (this.niceDomain.length) {
            return this.niceDomain;
          }
        }
        return this.domain;
      }
      convert(x, opts) {
        var _a2;
        const clampMode = (_a2 = opts == null ? void 0 : opts.clampMode) != null ? _a2 : this.defaultClampMode;
        if (!this.domain || this.domain.length < 2) {
          return NaN;
        }
        this.refresh();
        const domain = this.getDomain().map((d) => this.transform(d));
        const [d0, d1] = domain;
        const { range: range4 } = this;
        const [r0, r1] = range4;
        x = this.transform(x);
        if (clampMode === "clamped") {
          const [start, stop] = findMinMax(domain.map(Number));
          if (Number(x) < start) {
            return r0;
          } else if (Number(x) > stop) {
            return r1;
          }
        }
        if (d0 === d1) {
          return (r0 + r1) / 2;
        } else if (x === d0) {
          return r0;
        } else if (x === d1) {
          return r1;
        }
        return r0 + (Number(x) - Number(d0)) / (Number(d1) - Number(d0)) * (r1 - r0);
      }
      invert(x) {
        this.refresh();
        const domain = this.getDomain().map((d2) => this.transform(d2));
        const [d0, d1] = domain;
        const { range: range4 } = this;
        const [r0, r1] = range4;
        const isReversed = r0 > r1;
        const rMin = isReversed ? r1 : r0;
        const rMax = isReversed ? r0 : r1;
        let d;
        if (x < rMin) {
          return isReversed ? d1 : d0;
        } else if (x > rMax) {
          return isReversed ? d0 : d1;
        } else if (r0 === r1) {
          d = this.toDomain((Number(d0) + Number(d1)) / 2);
        } else {
          d = this.toDomain(Number(d0) + (x - r0) / (r1 - r0) * (Number(d1) - Number(d0)));
        }
        return this.transformInvert(d);
      }
      refresh() {
        if (!this.invalid)
          return;
        this.invalid = false;
        this.update();
        if (this.invalid) {
          Logger.warnOnce("Expected update to not invalidate scale");
        }
      }
      getPixelRange() {
        const [a, b] = this.range;
        return Math.abs(b - a);
      }
    };
    _ContinuousScale.defaultTickCount = 5;
    _ContinuousScale.defaultMaxTickCount = 6;
    __decorateClass([
      Invalidating
    ], _ContinuousScale.prototype, "domain", 2);
    __decorateClass([
      Invalidating
    ], _ContinuousScale.prototype, "range", 2);
    __decorateClass([
      Invalidating
    ], _ContinuousScale.prototype, "nice", 2);
    __decorateClass([
      Invalidating
    ], _ContinuousScale.prototype, "interval", 2);
    __decorateClass([
      Invalidating
    ], _ContinuousScale.prototype, "tickCount", 2);
    __decorateClass([
      Invalidating
    ], _ContinuousScale.prototype, "minTickCount", 2);
    __decorateClass([
      Invalidating
    ], _ContinuousScale.prototype, "maxTickCount", 2);
    ContinuousScale = _ContinuousScale;
  }
});

// packages/ag-charts-community/src/util/timeFormat.ts
function dayOfYear(date, startOfYear = new Date(date.getFullYear(), 0, 1)) {
  const startOffset = date.getTimezoneOffset() - startOfYear.getTimezoneOffset();
  const timeDiff = date.getTime() - startOfYear.getTime() + startOffset * 6e4;
  const timeOneDay = 36e5 * 24;
  return Math.floor(timeDiff / timeOneDay);
}
function weekOfYear(date, startDay) {
  const startOfYear = new Date(date.getFullYear(), 0, 1);
  const startOfYearDay = startOfYear.getDay();
  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;
  const startOffset = new Date(date.getFullYear(), 0, firstWeekStartOffset + 1);
  if (startOffset <= date) {
    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;
  }
  return 0;
}
function isoWeekOfYear(date, year2 = date.getFullYear()) {
  const firstOfYear = new Date(year2, 0, 1);
  const firstOfYearDay = firstOfYear.getDay();
  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;
  const startOffset = new Date(year2, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);
  if (startOffset <= date) {
    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;
  }
  return isoWeekOfYear(date, year2 - 1);
}
function timezone(date) {
  const offset4 = date.getTimezoneOffset();
  const unsignedOffset = Math.abs(offset4);
  const sign = offset4 > 0 ? "-" : "+";
  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, "0")}${pad(Math.floor(unsignedOffset % 60), 2, "0")}`;
}
function pad(value, size, padChar) {
  const output = String(Math.floor(value));
  if (output.length >= size) {
    return output;
  }
  return `${padChar.repeat(size - output.length)}${output}`;
}
function buildFormatter(formatString) {
  const formatParts = [];
  while (formatString.length > 0) {
    let nextEscapeIdx = formatString.indexOf("%");
    if (nextEscapeIdx !== 0) {
      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;
      formatParts.push(literalPart);
    }
    if (nextEscapeIdx < 0)
      break;
    const maybePadSpecifier = formatString[nextEscapeIdx + 1];
    const maybePad = PADS[maybePadSpecifier];
    if (maybePad != null) {
      nextEscapeIdx++;
    }
    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];
    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];
    if (typeof maybeFormatter === "function") {
      formatParts.push([maybeFormatter, maybePad]);
    } else if (typeof maybeFormatter === "string") {
      const formatter = buildFormatter(maybeFormatter);
      formatParts.push([formatter, maybePad]);
    } else {
      formatParts.push(`${maybePad != null ? maybePad : ""}${maybeFormatterSpecifier}`);
    }
    formatString = formatString.substring(nextEscapeIdx + 2);
  }
  return (dateTime) => {
    const dateTimeAsDate = typeof dateTime === "number" ? new Date(dateTime) : dateTime;
    return formatParts.map((c) => typeof c === "string" ? c : c[0](dateTimeAsDate, c[1])).join("");
  };
}
var CONSTANTS, SUNDAY, MONDAY, THURSDAY, FORMATTERS, PADS;
var init_timeFormat = __esm({
  "packages/ag-charts-community/src/util/timeFormat.ts"() {
    "use strict";
    CONSTANTS = {
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    };
    SUNDAY = 0;
    MONDAY = 1;
    THURSDAY = 4;
    FORMATTERS = {
      a: (d) => CONSTANTS.shortDays[d.getDay()],
      A: (d) => CONSTANTS.days[d.getDay()],
      b: (d) => CONSTANTS.shortMonths[d.getMonth()],
      B: (d) => CONSTANTS.months[d.getMonth()],
      c: "%x, %X",
      d: (d, p) => pad(d.getDate(), 2, p != null ? p : "0"),
      e: "%_d",
      f: (d, p) => pad(d.getMilliseconds() * 1e3, 6, p != null ? p : "0"),
      H: (d, p) => pad(d.getHours(), 2, p != null ? p : "0"),
      I: (d, p) => {
        const hours = d.getHours() % 12;
        return hours === 0 ? "12" : pad(hours, 2, p != null ? p : "0");
      },
      j: (d, p) => pad(dayOfYear(d) + 1, 3, p != null ? p : "0"),
      m: (d, p) => pad(d.getMonth() + 1, 2, p != null ? p : "0"),
      M: (d, p) => pad(d.getMinutes(), 2, p != null ? p : "0"),
      L: (d, p) => pad(d.getMilliseconds(), 3, p != null ? p : "0"),
      p: (d) => d.getHours() < 12 ? "AM" : "PM",
      Q: (d) => String(d.getTime()),
      s: (d) => String(Math.floor(d.getTime() / 1e3)),
      S: (d, p) => pad(d.getSeconds(), 2, p != null ? p : "0"),
      u: (d) => {
        let day2 = d.getDay();
        if (day2 < 1)
          day2 += 7;
        return String(day2 % 7);
      },
      U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p != null ? p : "0"),
      V: (d, p) => pad(isoWeekOfYear(d), 2, p != null ? p : "0"),
      w: (d, p) => pad(d.getDay(), 2, p != null ? p : "0"),
      W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p != null ? p : "0"),
      x: "%-m/%-d/%Y",
      X: "%-I:%M:%S %p",
      y: (d, p) => pad(d.getFullYear() % 100, 2, p != null ? p : "0"),
      Y: (d, p) => pad(d.getFullYear(), 4, p != null ? p : "0"),
      Z: (d) => timezone(d),
      "%": () => "%"
    };
    PADS = {
      _: " ",
      "0": "0",
      "-": ""
    };
  }
});

// packages/ag-charts-community/src/util/timeFormatDefaults.ts
function dateToNumber(x) {
  return x instanceof Date ? x.getTime() : x;
}
function defaultTimeTickFormat(ticks, domain) {
  const formatString = calculateDefaultTimeTickFormat(ticks, domain);
  return (date) => buildFormatter(formatString)(date);
}
function calculateDefaultTimeTickFormat(ticks = [], domain = ticks) {
  let defaultTimeFormat = 8 /* YEAR */;
  const updateFormat = (format2) => {
    if (format2 < defaultTimeFormat) {
      defaultTimeFormat = format2;
    }
  };
  for (const value of ticks) {
    const format2 = getLowestGranularityFormat(value);
    updateFormat(format2);
  }
  const startDomain = dateToNumber(domain[0]);
  const endDomain = dateToNumber(domain.at(-1));
  const startYear = new Date(startDomain).getFullYear();
  const stopYear = new Date(endDomain).getFullYear();
  const yearChange = stopYear - startYear > 0;
  return formatStringBuilder(defaultTimeFormat, yearChange, ticks);
}
function getLowestGranularityFormat(value) {
  if (second_default.floor(value) < value) {
    return 0 /* MILLISECOND */;
  } else if (minute_default.floor(value) < value) {
    return 1 /* SECOND */;
  } else if (hour_default.floor(value) < value) {
    return 2 /* MINUTE */;
  } else if (day_default.floor(value) < value) {
    return 3 /* HOUR */;
  } else if (month_default.floor(value) < value) {
    if (week_default.floor(value) < value) {
      return 4 /* WEEK_DAY */;
    }
    return 5 /* SHORT_MONTH */;
  } else if (year_default.floor(value) < value) {
    return 6 /* MONTH */;
  }
  return 8 /* YEAR */;
}
function formatStringBuilder(defaultTimeFormat, yearChange, ticks) {
  const firstTick = dateToNumber(ticks[0]);
  const lastTick = dateToNumber(ticks.at(-1));
  const extent6 = Math.abs(lastTick - firstTick);
  const activeYear = yearChange || defaultTimeFormat === 8 /* YEAR */;
  const activeDate = extent6 === 0;
  const parts = [
    ["hour", 6 * durationHour, 14 * durationDay, 3 /* HOUR */, "%I %p"],
    ["hour", durationMinute, 6 * durationHour, 3 /* HOUR */, "%I:%M"],
    ["second", 1e3, 6 * durationHour, 1 /* SECOND */, ":%S"],
    ["ms", 0, 6 * durationHour, 0 /* MILLISECOND */, ".%L"],
    ["am/pm", durationMinute, 6 * durationHour, 3 /* HOUR */, "%p"],
    " ",
    ["day", durationDay, 1 * durationWeek, 4 /* WEEK_DAY */, "%a"],
    ["month", activeDate ? 0 : durationWeek, 52 * durationWeek, 5 /* SHORT_MONTH */, "%b %d"],
    ["month", 5 * durationWeek, 10 * durationYear, 6 /* MONTH */, "%B"],
    " ",
    ["year", activeYear ? 0 : durationYear, Infinity, 8 /* YEAR */, "%Y"]
  ];
  const formatParts = parts.filter((v) => {
    if (typeof v === "string")
      return true;
    const [_, min, max, format2] = v;
    return format2 >= defaultTimeFormat && min <= extent6 && extent6 < max;
  }).reduce(
    (r, next) => {
      if (typeof next === "string") {
        r.result.push(next);
      } else if (!r.used.has(next[0])) {
        r.result.push(next);
        r.used.add(next[0]);
      }
      return r;
    },
    { result: [], used: /* @__PURE__ */ new Set() }
  ).result;
  const firstFormat = formatParts.findIndex((v) => typeof v !== "string");
  const lastFormat = formatParts.length - [...formatParts].reverse().findIndex((v) => typeof v !== "string");
  return formatParts.slice(firstFormat, lastFormat).map((v) => typeof v === "string" ? v : v[4]).join("").replaceAll(/\s+/g, " ").trim();
}
var init_timeFormatDefaults = __esm({
  "packages/ag-charts-community/src/util/timeFormatDefaults.ts"() {
    "use strict";
    init_day();
    init_hour();
    init_minute();
    init_month();
    init_second();
    init_week();
    init_year();
    init_duration();
    init_timeFormat();
  }
});

// packages/ag-charts-community/src/util/ticks.ts
function ticks_default(start, stop, count, minCount, maxCount) {
  if (count < 2) {
    return range(start, stop, stop - start);
  }
  const step = tickStep(start, stop, count, minCount, maxCount);
  if (isNaN(step)) {
    return createNumericTicks(0);
  }
  start = Math.ceil(start / step) * step;
  stop = Math.floor(stop / step) * step;
  return range(start, stop, step);
}
function tickStep(a, b, count, minCount = 0, maxCount = Infinity) {
  const extent6 = Math.abs(b - a);
  const rawStep = extent6 / count;
  const power = Math.floor(Math.log10(rawStep));
  const step = Math.pow(10, power);
  const m = tickMultipliers.map((multiplier) => {
    const s = multiplier * step;
    const c = Math.ceil(extent6 / s);
    const isWithinBounds = c >= minCount && c <= maxCount;
    const diffCount = Math.abs(c - count);
    return { multiplier, isWithinBounds, diffCount };
  }).sort((a2, b2) => {
    if (a2.isWithinBounds !== b2.isWithinBounds) {
      return a2.isWithinBounds ? -1 : 1;
    }
    return a2.diffCount - b2.diffCount;
  })[0].multiplier;
  if (!m || isNaN(m)) {
    return NaN;
  }
  return m * step;
}
function singleTickDomain(a, b) {
  const extent6 = Math.abs(b - a);
  const power = Math.floor(Math.log10(extent6));
  const step = Math.pow(10, power);
  const roundStart = a > b ? Math.ceil : Math.floor;
  const roundStop = b < a ? Math.floor : Math.ceil;
  return tickMultipliers.map((multiplier) => {
    const s = multiplier * step;
    const start = roundStart(a / s) * s;
    const end = roundStop(b / s) * s;
    const error = 1 - extent6 / Math.abs(end - start);
    const domain = [start, end];
    return { error, domain };
  }).sort((a2, b2) => a2.error - b2.error)[0].domain;
}
function range(start, stop, step) {
  const d0 = Math.min(start, stop);
  const d1 = Math.max(start, stop);
  const fractionalDigits = countFractionDigits(step);
  const f = Math.pow(10, fractionalDigits);
  const n = Math.ceil((d1 - d0) / step);
  const values = createNumericTicks(fractionalDigits);
  for (let i = 0; i <= n; i++) {
    const value = d0 + step * i;
    values.push(Math.round(value * f) / f);
  }
  return values;
}
function isDenseInterval({
  start,
  stop,
  interval,
  count,
  availableRange
}) {
  const domain = stop - start;
  const step = typeof interval === "number" ? interval : 1;
  count != null ? count : count = domain / step;
  if (count >= availableRange) {
    Logger.warnOnce(
      `the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration`
    );
    return true;
  }
  return false;
}
var createNumericTicks, tickMultipliers;
var init_ticks = __esm({
  "packages/ag-charts-community/src/util/ticks.ts"() {
    "use strict";
    init_logger();
    init_number();
    createNumericTicks = (fractionDigits, takingValues = []) => Object.assign(takingValues, { fractionDigits });
    tickMultipliers = [1, 2, 5, 10];
  }
});

// packages/ag-charts-community/src/scale/timeScale.ts
var _TimeScale, TimeScale;
var init_timeScale = __esm({
  "packages/ag-charts-community/src/scale/timeScale.ts"() {
    "use strict";
    init_ticks();
    init_day();
    init_duration();
    init_hour();
    init_interval();
    init_millisecond();
    init_minute();
    init_month();
    init_second();
    init_week();
    init_year();
    init_timeFormat();
    init_timeFormatDefaults();
    init_continuousScale();
    _TimeScale = class _TimeScale extends ContinuousScale {
      constructor() {
        super([], [0, 1]);
        this.type = "time";
      }
      toDomain(d) {
        return new Date(d);
      }
      /**
       * @param options Tick interval options.
       * @param options.start The start time (timestamp).
       * @param options.stop The end time (timestamp).
       * @param options.count Number of intervals between ticks.
       */
      static getTickInterval({
        start,
        stop,
        count,
        minCount,
        maxCount,
        target
      }) {
        let countableTimeInterval;
        let step;
        const tickCount = count != null ? count : ContinuousScale.defaultTickCount;
        const targetInterval = target != null ? target : Math.abs(stop - start) / Math.max(tickCount, 1);
        const i = _TimeScale.getIntervalIndex(targetInterval);
        if (i === 0) {
          step = Math.max(tickStep(start, stop, tickCount, minCount, maxCount), 1);
          countableTimeInterval = millisecond_default;
        } else if (i === _TimeScale.tickIntervals.length) {
          const y0 = start / durationYear;
          const y1 = stop / durationYear;
          step = target === void 0 ? tickStep(y0, y1, tickCount, minCount, maxCount) : 1;
          countableTimeInterval = year_default;
        } else {
          const diff0 = targetInterval - _TimeScale.tickIntervals[i - 1][2];
          const diff1 = _TimeScale.tickIntervals[i][2] - targetInterval;
          const index = diff0 < diff1 ? i - 1 : i;
          [countableTimeInterval, step] = _TimeScale.tickIntervals[index];
        }
        return countableTimeInterval.every(step);
      }
      static getIntervalIndex(target) {
        let i = 0;
        while (i < _TimeScale.tickIntervals.length && target > _TimeScale.tickIntervals[i][2]) {
          i++;
        }
        return i;
      }
      invert(y) {
        return new Date(super.invert(y));
      }
      /**
       * Returns uniformly-spaced dates that represent the scale's domain.
       */
      ticks() {
        if (!this.domain || this.domain.length < 2) {
          return [];
        }
        this.refresh();
        const [t0, t1] = this.getDomain().map(dateToNumber);
        const start = Math.min(t0, t1);
        const stop = Math.max(t0, t1);
        const { interval, nice, tickCount, minTickCount, maxTickCount } = this;
        if (interval !== void 0) {
          const availableRange = this.getPixelRange();
          const ticks = _TimeScale.getTicksForInterval({ start, stop, interval, availableRange });
          return ticks != null ? ticks : _TimeScale.getDefaultTicks({ start, stop, tickCount, minTickCount, maxTickCount });
        }
        if (nice) {
          if (tickCount === 2) {
            return this.niceDomain;
          }
          if (tickCount === 1) {
            return this.niceDomain.slice(0, 1);
          }
        }
        return _TimeScale.getDefaultTicks({ start, stop, tickCount, minTickCount, maxTickCount });
      }
      static getDefaultTicks({
        start,
        stop,
        tickCount,
        minTickCount,
        maxTickCount
      }) {
        const t = _TimeScale.getTickInterval({
          start,
          stop,
          count: tickCount,
          minCount: minTickCount,
          maxCount: maxTickCount
        });
        return t ? t.range(new Date(start), new Date(stop)) : [];
      }
      static getTicksForInterval({
        start,
        stop,
        interval,
        availableRange
      }) {
        if (!interval) {
          return [];
        }
        if (interval instanceof TimeInterval) {
          const ticks2 = interval.range(new Date(start), new Date(stop));
          if (isDenseInterval({ start, stop, interval, count: ticks2.length, availableRange })) {
            return;
          }
          return ticks2;
        }
        const absInterval = Math.abs(interval);
        if (isDenseInterval({ start, stop, interval: absInterval, availableRange })) {
          return;
        }
        const reversedInterval = [..._TimeScale.tickIntervals];
        reversedInterval.reverse();
        const timeInterval = reversedInterval.find((tickInterval) => absInterval % tickInterval[2] === 0);
        if (timeInterval) {
          const i = timeInterval[0].every(absInterval / (timeInterval[2] / timeInterval[1]));
          return i.range(new Date(start), new Date(stop));
        }
        let date = new Date(start);
        const stopDate = new Date(stop);
        const ticks = [];
        while (date <= stopDate) {
          ticks.push(date);
          date = new Date(date);
          date.setMilliseconds(date.getMilliseconds() + absInterval);
        }
        return ticks;
      }
      /**
       * Returns a time format function suitable for displaying tick values.
       * @param specifier If the specifier string is provided, this method is equivalent to
       * the {@link TimeLocaleObject.format} method.
       * If no specifier is provided, this method returns the default time format function.
       */
      tickFormat({
        ticks,
        domain,
        specifier
      }) {
        return specifier == null ? defaultTimeTickFormat(ticks, domain) : buildFormatter(specifier);
      }
      update() {
        if (!this.domain || this.domain.length < 2) {
          return;
        }
        if (this.nice) {
          this.updateNiceDomain();
        }
      }
      /**
       * Extends the domain so that it starts and ends on nice round values.
       * This method typically modifies the scales domain, and may only extend the bounds to the nearest round value.
       */
      updateNiceDomain() {
        const maxAttempts = 4;
        let [d0, d1] = this.domain;
        for (let i = 0; i < maxAttempts; i++) {
          this.updateNiceDomainIteration(d0, d1);
          const [n0, n1] = this.niceDomain;
          if (dateToNumber(d0) === dateToNumber(n0) && dateToNumber(d1) === dateToNumber(n1)) {
            break;
          }
          d0 = n0;
          d1 = n1;
        }
      }
      updateNiceDomainIteration(d0, d1) {
        const start = Math.min(dateToNumber(d0), dateToNumber(d1));
        const stop = Math.max(dateToNumber(d0), dateToNumber(d1));
        const isReversed = d0 > d1;
        const { interval } = this;
        let i;
        if (interval instanceof TimeInterval) {
          i = interval;
        } else {
          const tickCount = typeof interval === "number" ? (stop - start) / Math.max(interval, 1) : this.tickCount;
          i = _TimeScale.getTickInterval({
            start,
            stop,
            count: tickCount,
            minCount: this.minTickCount,
            maxCount: this.maxTickCount
          });
        }
        if (i) {
          const intervalRange = i.range(new Date(start), new Date(stop), true);
          const domain = isReversed ? [...intervalRange].reverse() : intervalRange;
          const n0 = domain[0];
          const n1 = domain.at(-1);
          this.niceDomain = [n0, n1];
        }
      }
    };
    /**
     * Array of default tick intervals in the following format:
     *
     *     [
     *         interval (unit of time),
     *         number of units (step),
     *         the length of that number of units in milliseconds
     *     ]
     */
    _TimeScale.tickIntervals = [
      [second_default, 1, durationSecond],
      [second_default, 5, 5 * durationSecond],
      [second_default, 15, 15 * durationSecond],
      [second_default, 30, 30 * durationSecond],
      [minute_default, 1, durationMinute],
      [minute_default, 5, 5 * durationMinute],
      [minute_default, 15, 15 * durationMinute],
      [minute_default, 30, 30 * durationMinute],
      [hour_default, 1, durationHour],
      [hour_default, 3, 3 * durationHour],
      [hour_default, 6, 6 * durationHour],
      [hour_default, 12, 12 * durationHour],
      [day_default, 1, durationDay],
      [day_default, 2, 2 * durationDay],
      [week_default, 1, durationWeek],
      [week_default, 2, 2 * durationWeek],
      [week_default, 3, 3 * durationWeek],
      [month_default, 1, durationMonth],
      [month_default, 2, 2 * durationMonth],
      [month_default, 3, 3 * durationMonth],
      [month_default, 4, 4 * durationMonth],
      [month_default, 6, 6 * durationMonth],
      [year_default, 1, durationYear]
    ];
    TimeScale = _TimeScale;
  }
});

// packages/ag-charts-community/src/scale/ordinalTimeScale.ts
var _OrdinalTimeScale, OrdinalTimeScale;
var init_ordinalTimeScale = __esm({
  "packages/ag-charts-community/src/scale/ordinalTimeScale.ts"() {
    "use strict";
    init_timeFormat();
    init_timeFormatDefaults();
    init_bandScale();
    init_continuousScale();
    init_invalidating();
    init_timeScale();
    _OrdinalTimeScale = class _OrdinalTimeScale extends BandScale {
      constructor() {
        super(...arguments);
        this.type = "ordinal-time";
        this.tickCount = ContinuousScale.defaultTickCount;
        this.minTickCount = 0;
        this.maxTickCount = Infinity;
        this.interval = void 0;
        this.index = /* @__PURE__ */ new Map();
        /**
         * Contains unique datums only. Since `{}` is used in place of `Map`
         * for IE11 compatibility, the datums are converted `toString` before
         * the uniqueness check.
         */
        this._domain = [];
      }
      static is(value) {
        return value instanceof _OrdinalTimeScale;
      }
      toDomain(d) {
        return new Date(d);
      }
      set domain(values) {
        this.invalid = true;
        if (values.length === 0) {
          this._domain = [];
          return;
        }
        const domain = this.updateIndex(values);
        this._domain = domain;
      }
      get domain() {
        return this._domain;
      }
      updateIndex(values) {
        this.index = /* @__PURE__ */ new Map();
        const { index } = this;
        const domain = [];
        const extents = [];
        const isReversed = values[0] > values.at(-1);
        const indexShift = isReversed ? 0 : 1;
        values.forEach((value, i2) => {
          const nextValue = values[i2 + 1];
          const e02 = isReversed ? value : this.toDomain(dateToNumber(value) + 1);
          const e12 = isReversed ? this.toDomain(dateToNumber(nextValue) + 1) : nextValue;
          const dateRange2 = isReversed ? [e12, e02] : [e02, e12];
          domain.push(value);
          if (nextValue !== void 0 && index.get(dateRange2) === void 0) {
            extents.push(Math.abs(dateToNumber(e12) - dateToNumber(e02)));
            index.set(dateRange2, i2 + indexShift);
          }
        });
        extents.sort((a, b) => a - b);
        const bands = extents.length;
        const middleIndex = Math.floor(bands / 2);
        this.medianInterval = bands > 2 && bands % 2 === 0 ? (extents[middleIndex - 1] + extents[middleIndex + 1]) / 2 : extents[middleIndex];
        const intervalIndex = Math.max(0, TimeScale.getIntervalIndex(this.medianInterval) - 1);
        const [countableTimeInterval, step] = TimeScale.tickIntervals[intervalIndex];
        const interval = countableTimeInterval.every(step);
        const i = isReversed ? values.length - 1 : 0;
        const e1 = values[i];
        const e0 = interval.floor(values[i]);
        const dateRange = [e0, e1];
        index.set(dateRange, i);
        return domain;
      }
      ticks() {
        if (!this.domain) {
          return [];
        }
        this.refresh();
        const [t0, t1] = [dateToNumber(this.domain[0]), dateToNumber(this.domain.at(-1))];
        const start = Math.min(t0, t1);
        const stop = Math.max(t0, t1);
        const isReversed = t0 > t1;
        let ticks;
        if (this.interval !== void 0) {
          ticks = this.getTicksForInterval({ start, stop, interval: this.interval });
        }
        const n = this.domain.length;
        const { maxTickCount, tickCount } = this;
        let { minTickCount } = this;
        let medianInterval;
        if (isFinite(maxTickCount) && n <= maxTickCount) {
          minTickCount = Math.max(1, n);
          medianInterval = this.medianInterval;
        }
        ticks != null ? ticks : ticks = this.getDefaultTicks({
          start,
          stop,
          tickCount,
          minTickCount,
          maxTickCount,
          isReversed,
          interval: medianInterval
        });
        const tickPositions = /* @__PURE__ */ new Set();
        return ticks.filter((tick) => {
          const position = this.convert(tick);
          if (isNaN(position) || tickPositions.has(position)) {
            return false;
          }
          tickPositions.add(position);
          return true;
        });
      }
      getDefaultTicks({
        start,
        stop,
        tickCount,
        minTickCount,
        maxTickCount,
        isReversed,
        interval
      }) {
        const tickInterval = TimeScale.getTickInterval({
          start,
          stop,
          count: tickCount,
          minCount: minTickCount,
          maxCount: maxTickCount,
          target: interval
        });
        if (!tickInterval) {
          return [];
        }
        const tickEvery = Math.ceil(this.domain.length / maxTickCount);
        const ticks = [];
        for (const [dateRange, index] of this.index.entries()) {
          if (index % tickEvery > 0) {
            continue;
          }
          const tick = isReversed ? tickInterval.ceil(dateRange[0]) : tickInterval.floor(dateRange[1]);
          ticks.splice(index, 0, tick);
        }
        return ticks;
      }
      getTicksForInterval({
        start,
        stop,
        interval
      }) {
        var _a2;
        const [r0, r1] = this.range;
        const availableRange = Math.abs(r1 - r0);
        return (_a2 = TimeScale.getTicksForInterval({ start, stop, interval, availableRange })) != null ? _a2 : [];
      }
      convert(d) {
        if (typeof d === "number") {
          d = new Date(d);
        }
        if (!(d instanceof Date)) {
          return NaN;
        }
        this.refresh();
        let i;
        for (const [dateRange, index] of this.index.entries()) {
          if (d >= dateRange[0] && d <= dateRange[1]) {
            i = index;
            break;
          }
        }
        if (i === void 0) {
          return NaN;
        }
        const r = this.ordinalRange[i];
        if (r === void 0) {
          return NaN;
        }
        return r;
      }
      /**
       * Returns a time format function suitable for displaying tick values.
       * @param specifier If the specifier string is provided, this method is equivalent to
       * the {@link TimeLocaleObject.format} method.
       * If no specifier is provided, this method returns the default time format function.
       */
      tickFormat({
        ticks,
        domain,
        specifier
      }) {
        return specifier == null ? defaultTimeTickFormat(ticks, domain) : buildFormatter(specifier);
      }
      invert(y) {
        return new Date(super.invert(y));
      }
      invertNearest(y) {
        return new Date(super.invertNearest(y));
      }
    };
    __decorateClass([
      Invalidating
    ], _OrdinalTimeScale.prototype, "tickCount", 2);
    __decorateClass([
      Invalidating
    ], _OrdinalTimeScale.prototype, "minTickCount", 2);
    __decorateClass([
      Invalidating
    ], _OrdinalTimeScale.prototype, "maxTickCount", 2);
    __decorateClass([
      Invalidating
    ], _OrdinalTimeScale.prototype, "interval", 2);
    OrdinalTimeScale = _OrdinalTimeScale;
  }
});

// packages/ag-charts-community/src/util/compare.ts
function ascendingStringNumberUndefined(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return a - b;
  } else if (typeof a === "string" && typeof b === "string") {
    return a.localeCompare(b);
  } else if (a == null && b == null) {
    return 0;
  } else if (a == null) {
    return -1;
  } else if (b == null) {
    return 1;
  }
  return String(a).localeCompare(String(b));
}
function toLiteral(v) {
  return typeof v === "function" ? v() : v;
}
function compoundAscending(a, b, comparator) {
  for (const idx in a) {
    const diff8 = comparator(toLiteral(a[idx]), toLiteral(b[idx]));
    if (diff8 !== 0) {
      return diff8;
    }
  }
  return 0;
}
var init_compare = __esm({
  "packages/ag-charts-community/src/util/compare.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/scene/group.ts
var _Group, Group;
var init_group = __esm({
  "packages/ag-charts-community/src/scene/group.ts"() {
    "use strict";
    init_compare();
    init_number();
    init_bbox();
    init_node();
    _Group = class _Group extends Node {
      constructor(opts) {
        var _a2;
        super({ isVirtual: opts == null ? void 0 : opts.isVirtual });
        this.opts = opts;
        this.opacity = 1;
        this.lastBBox = void 0;
        const { zIndex, zIndexSubOrder } = opts != null ? opts : {};
        this.isContainerNode = true;
        if (zIndex !== void 0) {
          this.zIndex = zIndex;
        }
        if (zIndexSubOrder !== void 0) {
          this.zIndexSubOrder = zIndexSubOrder;
        }
        this.name = (_a2 = this.opts) == null ? void 0 : _a2.name;
      }
      static is(value) {
        return value instanceof _Group;
      }
      onZIndexChange() {
        var _a2;
        super.onZIndexChange();
        if (this.layer) {
          (_a2 = this._layerManager) == null ? void 0 : _a2.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);
        }
      }
      isLayer() {
        return this.layer != null;
      }
      _setLayerManager(layersManager) {
        if (this._layerManager && this.layer) {
          this._layerManager.removeLayer(this.layer);
          this.layer = void 0;
        }
        if (this.layer) {
          throw new Error("AG Charts - unable to deregister scene rendering layer!");
        }
        super._setLayerManager(layersManager);
      }
      initialiseLayer() {
        var _a2;
        if (this.layer)
          return;
        if (!this._layerManager || ((_a2 = this.opts) == null ? void 0 : _a2.layer) !== true)
          return;
        this.layer = this._layerManager.addLayer({
          name: this.name,
          zIndex: this.zIndex,
          zIndexSubOrder: this.zIndexSubOrder,
          getComputedOpacity: () => this.getComputedOpacity(),
          getVisibility: () => this.getVisibility()
        });
      }
      getComputedOpacity() {
        let opacity = 1;
        for (const node of this.traverseUp()) {
          if (node instanceof _Group) {
            opacity *= node.opacity;
          }
        }
        return opacity;
      }
      getVisibility() {
        for (const node of this.traverseUp()) {
          if (!node.visible) {
            return false;
          }
        }
        return true;
      }
      onVisibleChange() {
        if (this.layer) {
          this.layer.enabled = this.visible;
        }
      }
      markDirty(source, type = 1 /* TRIVIAL */) {
        if (this.isVirtual) {
          super.markDirty(source, type);
          return;
        }
        let parentType = type;
        if (type < 2 /* MINOR */ || this.layer != null) {
          parentType = 1 /* TRIVIAL */;
        }
        super.markDirty(source, type, parentType);
      }
      // We consider a group to be boundless, thus any point belongs to it.
      containsPoint(_x, _y) {
        return true;
      }
      computeBBox() {
        this.computeTransformMatrix();
        return _Group.computeBBox(this.children);
      }
      computeTransformedBBox() {
        return this.computeBBox();
      }
      preRender() {
        var _a2, _b;
        const counts = super.preRender();
        counts.groups += 1;
        counts.nonGroups -= 1;
        if (((_a2 = this.opts) == null ? void 0 : _a2.layer) !== true || this.layer != null)
          return counts;
        if (counts.nonGroups > 0) {
          this.initialiseLayer();
        }
        if (((_b = this.opts) == null ? void 0 : _b.nonEmptyChildDerivedZIndex) && counts.nonGroups > 0) {
          this.deriveZIndexFromChildren();
        }
        return counts;
      }
      deriveZIndexFromChildren() {
        var _a2;
        const children = this.children.filter((c) => c._childNodeCounts.nonGroups > 0);
        this.sortChildren(children);
        const lastChild = children.at(-1);
        this.zIndex = (_a2 = lastChild == null ? void 0 : lastChild.zIndex) != null ? _a2 : -Infinity;
        this.zIndexSubOrder = lastChild == null ? void 0 : lastChild.zIndexSubOrder;
      }
      render(renderCtx) {
        var _a2, _b;
        const { opts: { name = void 0 } = {}, _debug: debug3 } = this;
        const { dirty, dirtyZIndex, layer, children, clipRect, dirtyTransform } = this;
        let { ctx, forceRender, clipBBox } = renderCtx;
        const { resized, stats } = renderCtx;
        const canvasCtxTransform = ctx.getTransform();
        const isDirty = dirty >= 2 /* MINOR */ || dirtyZIndex || resized;
        let isChildDirty = isDirty;
        let isChildLayerDirty = false;
        for (const child of children) {
          isChildDirty || (isChildDirty = child.layerManager == null && child.dirty >= 1 /* TRIVIAL */);
          isChildLayerDirty || (isChildLayerDirty = child.layerManager != null && child.dirty >= 1 /* TRIVIAL */);
          if (isChildDirty) {
            break;
          }
        }
        if (name) {
          debug3 == null ? void 0 : debug3({ name, group: this, isDirty, isChildDirty, dirtyTransform, renderCtx, forceRender });
        }
        if (dirtyTransform) {
          forceRender = "dirtyTransform";
        } else if (layer) {
          const currentBBox = this.computeBBox();
          if (this.lastBBox === void 0 || !this.lastBBox.equals(currentBBox)) {
            forceRender = "dirtyTransform";
            this.lastBBox = currentBBox;
          }
        }
        if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {
          if (name && stats) {
            debug3 == null ? void 0 : debug3({ name, result: "skipping", renderCtx, counts: this.nodeCount, group: this });
          }
          if (layer && stats) {
            stats.layersSkipped++;
            stats.nodesSkipped += this.nodeCount.count;
          }
          this.markClean({ recursive: false });
          return;
        }
        const groupVisible = this.visible;
        if (layer) {
          ctx = layer.context;
          ctx.save();
          ctx.setTransform(layer.pixelRatio, 0, 0, layer.pixelRatio, 0, 0);
          if (forceRender !== "dirtyTransform") {
            forceRender = isChildDirty || dirtyZIndex;
          }
          if (forceRender)
            layer.clear();
          if (clipBBox) {
            const { width, height, x, y } = clipBBox;
            debug3 == null ? void 0 : debug3(() => ({
              name,
              clipBBox,
              ctxTransform: ctx.getTransform(),
              renderCtx,
              group: this
            }));
            ctx.beginPath();
            ctx.rect(x, y, width, height);
            ctx.clip();
          }
          ctx.setTransform(canvasCtxTransform);
        } else {
          ctx.globalAlpha *= this.opacity;
        }
        this.computeTransformMatrix();
        this.matrix.toContext(ctx);
        if (clipRect) {
          const { x, y, width, height } = clipRect;
          ctx.save();
          debug3 == null ? void 0 : debug3(() => ({ name, clipRect, ctxTransform: ctx.getTransform(), renderCtx, group: this }));
          ctx.beginPath();
          ctx.rect(x, y, width, height);
          ctx.clip();
          clipBBox = this.matrix.transformBBox(clipRect);
        }
        const hasVirtualChildren = this.hasVirtualChildren();
        if (dirtyZIndex) {
          this.sortChildren(children);
          if (forceRender !== "dirtyTransform")
            forceRender = true;
        } else if (hasVirtualChildren) {
          this.sortChildren(children);
        }
        const renderContextChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;
        const childRenderContext = renderContextChanged ? __spreadProps(__spreadValues({}, renderCtx), { ctx, forceRender, clipBBox }) : renderCtx;
        let skipped = 0;
        for (const child of children) {
          if (!child.visible || !groupVisible) {
            child.markClean();
            if (stats)
              skipped += child.nodeCount.count;
            continue;
          }
          if (!forceRender && child.dirty === 0 /* NONE */) {
            if (stats)
              skipped += child.nodeCount.count;
            continue;
          }
          ctx.save();
          child.render(childRenderContext);
          ctx.restore();
        }
        if (stats)
          stats.nodesSkipped += skipped;
        super.render(renderCtx);
        if (clipRect) {
          ctx.restore();
        }
        if (hasVirtualChildren) {
          for (const child of this.virtualChildren) {
            child.markClean({ recursive: "virtual" });
          }
        }
        if (layer) {
          if (stats)
            stats.layersRendered++;
          ctx.restore();
          if (forceRender)
            layer.snapshot();
          (_b = (_a2 = layer.context).verifyDepthZero) == null ? void 0 : _b.call(_a2);
        }
        if (name && stats) {
          debug3 == null ? void 0 : debug3({ name, result: "rendered", skipped, renderCtx, counts: this.nodeCount, group: this });
        }
      }
      sortChildren(children) {
        this.dirtyZIndex = false;
        children.sort(
          (a, b) => {
            var _a2, _b;
            return compoundAscending(
              [a.zIndex, ...(_a2 = a.zIndexSubOrder) != null ? _a2 : [void 0, void 0], a.serialNumber],
              [b.zIndex, ...(_b = b.zIndexSubOrder) != null ? _b : [void 0, void 0], b.serialNumber],
              ascendingStringNumberUndefined
            );
          }
        );
      }
      static computeBBox(nodes) {
        let left = Infinity;
        let right = -Infinity;
        let top = Infinity;
        let bottom = -Infinity;
        for (const n of nodes) {
          if (!n.visible)
            continue;
          const bbox = n.computeTransformedBBox();
          if (!bbox)
            continue;
          const { x, y, width, height } = bbox;
          if (x < left) {
            left = x;
          }
          if (y < top) {
            top = y;
          }
          if (x + width > right) {
            right = x + width;
          }
          if (y + height > bottom) {
            bottom = y + height;
          }
        }
        return new BBox(left, top, right - left, bottom - top);
      }
      /**
       * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and
       * sets this group's clipRect to the transformed bbox.
       * @param bbox clipRect bbox in the canvas coordinate space.
       */
      setClipRectInGroupCoordinateSpace(bbox) {
        this.clipRect = bbox ? this.transformBBox(bbox) : void 0;
      }
    };
    _Group.className = "Group";
    __decorateClass([
      SceneChangeDetection({
        redraw: 3 /* MAJOR */,
        convertor: (v) => clamp(0, v, 1)
      })
    ], _Group.prototype, "opacity", 2);
    Group = _Group;
  }
});

// packages/ag-charts-community/src/scene/gradient/gradient.ts
var Gradient;
var init_gradient = __esm({
  "packages/ag-charts-community/src/scene/gradient/gradient.ts"() {
    "use strict";
    Gradient = class {
      constructor(stops = []) {
        this.stops = stops;
      }
    };
  }
});

// packages/ag-charts-community/src/scene/gradient/linearGradient.ts
var LinearGradient;
var init_linearGradient = __esm({
  "packages/ag-charts-community/src/scene/gradient/linearGradient.ts"() {
    "use strict";
    init_angle();
    init_gradient();
    LinearGradient = class extends Gradient {
      constructor(stops, angle = 0) {
        super(stops);
        this.angle = angle;
      }
      createGradient(ctx, bbox) {
        const angleOffset = 90;
        const { stops, angle } = this;
        const radians = normalizeAngle360(toRadians(angle + angleOffset));
        const cos = Math.cos(radians);
        const sin = Math.sin(radians);
        const w = bbox.width;
        const h = bbox.height;
        const cx = bbox.x + w * 0.5;
        const cy = bbox.y + h * 0.5;
        if (w > 0 && h > 0) {
          const diagonal = Math.sqrt(h * h + w * w) / 2;
          const diagonalAngle = Math.atan2(h, w);
          let quarteredAngle;
          if (radians < Math.PI / 2) {
            quarteredAngle = radians;
          } else if (radians < Math.PI) {
            quarteredAngle = Math.PI - radians;
          } else if (radians < 1.5 * Math.PI) {
            quarteredAngle = radians - Math.PI;
          } else {
            quarteredAngle = 2 * Math.PI - radians;
          }
          const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));
          const gradient = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);
          for (const stop of stops) {
            gradient.addColorStop(stop.offset, stop.color);
          }
          return gradient;
        }
        return "black";
      }
    };
  }
});

// packages/ag-charts-community/src/scene/shape/shape.ts
var LINEAR_GRADIENT_REGEXP, _Shape, Shape;
var init_shape = __esm({
  "packages/ag-charts-community/src/scene/shape/shape.ts"() {
    "use strict";
    init_number();
    init_linearGradient();
    init_node();
    LINEAR_GRADIENT_REGEXP = /^linear-gradient\((.*?)deg,\s*(.*?)\s*\)$/i;
    _Shape = class _Shape extends Node {
      constructor() {
        super(...arguments);
        this.fillOpacity = 1;
        this.strokeOpacity = 1;
        this.fill = _Shape.defaultStyles.fill;
        this.stroke = _Shape.defaultStyles.stroke;
        this.strokeWidth = _Shape.defaultStyles.strokeWidth;
        this.lineDash = _Shape.defaultStyles.lineDash;
        this.lineDashOffset = _Shape.defaultStyles.lineDashOffset;
        this.lineCap = _Shape.defaultStyles.lineCap;
        this.lineJoin = _Shape.defaultStyles.lineJoin;
        this.opacity = _Shape.defaultStyles.opacity;
        this.fillShadow = _Shape.defaultStyles.fillShadow;
      }
      /**
       * Restores the default styles introduced by this subclass.
       */
      restoreOwnStyles() {
        const { defaultStyles } = this.constructor;
        Object.assign(this, defaultStyles);
      }
      onFillChange() {
        const { fill } = this;
        let linearGradientMatch;
        if ((fill == null ? void 0 : fill.startsWith("linear-gradient")) && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(fill))) {
          const angle = parseFloat(linearGradientMatch[1]);
          const colors = [];
          const colorsPart = linearGradientMatch[2];
          const colorRegex = /(#[0-9a-f]+)|(rgba?\(.+?\))|([a-z]+)/gi;
          let c;
          while (c = colorRegex.exec(colorsPart)) {
            colors.push(c[0]);
          }
          this.gradient = new LinearGradient(
            colors.map((color, index) => ({ color, offset: index / (colors.length - 1) })),
            angle
          );
        } else {
          this.gradient = void 0;
        }
      }
      /**
       * Returns a device-pixel aligned coordinate (or length if length is supplied).
       *
       * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle
       * of a device pixel.
       */
      align(start, length) {
        var _a2, _b, _c;
        const pixelRatio = (_c = (_b = (_a2 = this.layerManager) == null ? void 0 : _a2.canvas) == null ? void 0 : _b.pixelRatio) != null ? _c : 1;
        const alignedStart = Math.round(start * pixelRatio) / pixelRatio;
        if (length == null) {
          return alignedStart;
        } else if (length === 0) {
          return 0;
        } else if (length < 1) {
          return Math.ceil(length * pixelRatio) / pixelRatio;
        }
        return Math.round((length + start) * pixelRatio) / pixelRatio - alignedStart;
      }
      fillStroke(ctx, path) {
        this.renderFill(ctx, path);
        this.renderStroke(ctx, path);
      }
      renderFill(ctx, path) {
        if (this.fill) {
          const { globalAlpha } = ctx;
          this.applyFill(ctx);
          this.applyFillAlpha(ctx);
          this.applyShadow(ctx);
          this.executeFill(ctx, path);
          ctx.globalAlpha = globalAlpha;
        }
        ctx.shadowColor = "rgba(0, 0, 0, 0)";
      }
      executeFill(ctx, path) {
        path ? ctx.fill(path) : ctx.fill();
      }
      applyFill(ctx) {
        var _a2, _b;
        ctx.fillStyle = (_b = (_a2 = this.gradient) == null ? void 0 : _a2.createGradient(ctx, this.computeBBox())) != null ? _b : this.fill;
      }
      applyFillAlpha(ctx) {
        ctx.globalAlpha *= this.opacity * this.fillOpacity;
      }
      applyShadow(ctx) {
        var _a2, _b;
        const pixelRatio = (_b = (_a2 = this.layerManager) == null ? void 0 : _a2.canvas.pixelRatio) != null ? _b : 1;
        const fillShadow = this.fillShadow;
        if (fillShadow == null ? void 0 : fillShadow.enabled) {
          ctx.shadowColor = fillShadow.color;
          ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;
          ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;
          ctx.shadowBlur = fillShadow.blur * pixelRatio;
        }
      }
      renderStroke(ctx, path) {
        if (this.stroke && this.strokeWidth) {
          const { globalAlpha } = ctx;
          ctx.strokeStyle = this.stroke;
          ctx.globalAlpha *= this.opacity * this.strokeOpacity;
          ctx.lineWidth = this.strokeWidth;
          if (this.lineDash) {
            ctx.setLineDash(this.lineDash);
          }
          if (this.lineDashOffset) {
            ctx.lineDashOffset = this.lineDashOffset;
          }
          if (this.lineCap) {
            ctx.lineCap = this.lineCap;
          }
          if (this.lineJoin) {
            ctx.lineJoin = this.lineJoin;
          }
          this.executeStroke(ctx, path);
          ctx.globalAlpha = globalAlpha;
        }
      }
      executeStroke(ctx, path) {
        path ? ctx.stroke(path) : ctx.stroke();
      }
      containsPoint(x, y) {
        return this.isPointInPath(x, y);
      }
    };
    /**
     * Defaults for style properties. Note that properties that affect the position
     * and shape of the node are not considered style properties, for example:
     * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.
     * Can be used to reset to the original styling after some custom styling
     * has been applied (using the `restoreOwnStyles` method).
     * These static defaults are meant to be inherited by subclasses.
     */
    _Shape.defaultStyles = {
      fill: "black",
      stroke: void 0,
      strokeWidth: 0,
      lineDash: void 0,
      lineDashOffset: 0,
      lineCap: void 0,
      lineJoin: void 0,
      opacity: 1,
      fillShadow: void 0
    };
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], _Shape.prototype, "fillOpacity", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], _Shape.prototype, "strokeOpacity", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */, changeCb: (s) => s.onFillChange() })
    ], _Shape.prototype, "fill", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], _Shape.prototype, "stroke", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], _Shape.prototype, "strokeWidth", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], _Shape.prototype, "lineDash", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], _Shape.prototype, "lineDashOffset", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], _Shape.prototype, "lineCap", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], _Shape.prototype, "lineJoin", 2);
    __decorateClass([
      SceneChangeDetection({
        redraw: 2 /* MINOR */,
        convertor: (v) => clamp(0, v, 1)
      })
    ], _Shape.prototype, "opacity", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */, checkDirtyOnAssignment: true })
    ], _Shape.prototype, "fillShadow", 2);
    Shape = _Shape;
  }
});

// packages/ag-charts-community/src/scene/shape/range.ts
var Range;
var init_range = __esm({
  "packages/ag-charts-community/src/scene/shape/range.ts"() {
    "use strict";
    init_bbox();
    init_node();
    init_shape();
    Range = class extends Shape {
      constructor(opts = {}) {
        super(opts);
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;
        this.startLine = false;
        this.endLine = false;
        this.isRange = false;
        this.restoreOwnStyles();
      }
      computeBBox() {
        return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);
      }
      isPointInPath(_x, _y) {
        return false;
      }
      render(renderCtx) {
        var _a2;
        const { ctx, forceRender, stats } = renderCtx;
        if (this.dirty === 0 /* NONE */ && !forceRender) {
          if (stats)
            stats.nodesSkipped += this.nodeCount.count;
          return;
        }
        this.computeTransformMatrix();
        this.matrix.toContext(ctx);
        let { x1, y1, x2, y2 } = this;
        x1 = this.align(x1);
        y1 = this.align(y1);
        x2 = this.align(x2);
        y2 = this.align(y2);
        const { fill, opacity, isRange } = this;
        const fillActive = !!(isRange && fill);
        if (fillActive) {
          const { fillOpacity } = this;
          ctx.fillStyle = fill;
          ctx.globalAlpha = opacity * fillOpacity;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y1);
          ctx.lineTo(x2, y2);
          ctx.lineTo(x1, y2);
          ctx.closePath();
          ctx.fill();
        }
        const { stroke, strokeWidth, startLine, endLine } = this;
        const strokeActive = !!((startLine || endLine) && stroke && strokeWidth);
        if (strokeActive) {
          const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;
          ctx.strokeStyle = stroke;
          ctx.globalAlpha = opacity * strokeOpacity;
          ctx.lineWidth = strokeWidth;
          if (lineDash) {
            ctx.setLineDash(lineDash);
          }
          if (lineDashOffset) {
            ctx.lineDashOffset = lineDashOffset;
          }
          if (lineCap) {
            ctx.lineCap = lineCap;
          }
          if (lineJoin) {
            ctx.lineJoin = lineJoin;
          }
          ctx.beginPath();
          if (startLine) {
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y1);
          }
          if (endLine) {
            ctx.moveTo(x2, y2);
            ctx.lineTo(x1, y2);
          }
          ctx.stroke();
        }
        (_a2 = this.fillShadow) == null ? void 0 : _a2.markClean();
        super.render(renderCtx);
      }
    };
    Range.className = "Range";
    Range.defaultStyles = __spreadProps(__spreadValues({}, Shape.defaultStyles), {
      strokeWidth: 1
    });
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], Range.prototype, "x1", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], Range.prototype, "y1", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], Range.prototype, "x2", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], Range.prototype, "y2", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], Range.prototype, "startLine", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], Range.prototype, "endLine", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 2 /* MINOR */ })
    ], Range.prototype, "isRange", 2);
  }
});

// packages/ag-charts-community/src/util/memo.ts
function memo(params, fnGenerator) {
  var _a2, _b, _c;
  const serialisedParams = JSON.stringify(params, null, 0);
  if (!memorizedFns.has(fnGenerator)) {
    memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());
  }
  if (!((_a2 = memorizedFns.get(fnGenerator)) == null ? void 0 : _a2.has(serialisedParams))) {
    (_b = memorizedFns.get(fnGenerator)) == null ? void 0 : _b.set(serialisedParams, fnGenerator(params));
  }
  return (_c = memorizedFns.get(fnGenerator)) == null ? void 0 : _c.get(serialisedParams);
}
function memoizeFunction(baseFn) {
  return (params, ...rest) => {
    var _a2, _b, _c;
    const serialisedParams = JSON.stringify(params, null, 0);
    if (!memorizedMap.has(baseFn)) {
      memorizedMap.set(baseFn, /* @__PURE__ */ new Map());
    }
    if (!((_a2 = memorizedMap.get(baseFn)) == null ? void 0 : _a2.has(serialisedParams))) {
      (_b = memorizedMap.get(baseFn)) == null ? void 0 : _b.set(serialisedParams, baseFn(params, ...rest));
    }
    return (_c = memorizedMap.get(baseFn)) == null ? void 0 : _c.get(serialisedParams);
  };
}
var memorizedFns, memorizedMap;
var init_memo = __esm({
  "packages/ag-charts-community/src/util/memo.ts"() {
    "use strict";
    memorizedFns = /* @__PURE__ */ new WeakMap();
    memorizedMap = /* @__PURE__ */ new WeakMap();
  }
});

// packages/ag-charts-community/src/scene/shape/text.ts
function SceneFontChangeDetection(opts) {
  const { redraw = 3 /* MAJOR */, changeCb } = opts != null ? opts : {};
  return SceneChangeDetection({ redraw, type: "font", changeCb });
}
function getFont(fontProps) {
  const { fontFamily, fontSize, fontStyle, fontWeight } = fontProps;
  return [fontStyle != null ? fontStyle : "", fontWeight != null ? fontWeight : "", fontSize + "px", fontFamily].join(" ").trim();
}
var ellipsis, _Text, Text, TextMeasurer;
var init_text = __esm({
  "packages/ag-charts-community/src/scene/shape/text.ts"() {
    "use strict";
    init_dom();
    init_memo();
    init_type_guards();
    init_bbox();
    init_node();
    init_shape();
    ellipsis = "\u2026";
    _Text = class _Text extends Shape {
      constructor() {
        super(...arguments);
        this.x = 0;
        this.y = 0;
        this.lines = [];
        this.text = void 0;
        this._dirtyFont = true;
        this.fontSize = 10;
        this.fontFamily = "sans-serif";
        this.textAlign = _Text.defaultStyles.textAlign;
        this.textBaseline = _Text.defaultStyles.textBaseline;
      }
      onTextChange() {
        var _a2, _b;
        this.lines = (_b = (_a2 = this.text) == null ? void 0 : _a2.split("\n").map((s) => s.trim())) != null ? _b : [];
      }
      get font() {
        if (this._font == null || this._dirtyFont) {
          this._dirtyFont = false;
          this._font = getFont(this);
        }
        return this._font;
      }
      computeBBox() {
        const { x, y, lines, lineHeight, textBaseline, textAlign } = this;
        const { top, left, width, height } = _Text.getTextSizeMultiline(
          lines,
          getFont(this),
          textBaseline,
          textAlign,
          lineHeight
        );
        return new BBox(x - left, y - top, width, height);
      }
      getLineHeight(line) {
        var _a2, _b;
        if (this.lineHeight) {
          return this.lineHeight;
        }
        const metrics = _Text.measureText(line, this.font, this.textBaseline, this.textAlign);
        return (
          // Fallback to emHeightAscent + emHeightDescent is needed for server-side rendering.
          ((_a2 = metrics.fontBoundingBoxAscent) != null ? _a2 : metrics.emHeightAscent) + ((_b = metrics.fontBoundingBoxDescent) != null ? _b : metrics.emHeightDescent)
        );
      }
      isPointInPath(x, y) {
        const point = this.transformPoint(x, y);
        const bbox = this.computeBBox();
        return bbox ? bbox.containsPoint(point.x, point.y) : false;
      }
      render(renderCtx) {
        const { ctx, forceRender, stats } = renderCtx;
        if (this.dirty === 0 /* NONE */ && !forceRender) {
          if (stats)
            stats.nodesSkipped += this.nodeCount.count;
          return;
        }
        if (!this.lines.length || !this.layerManager) {
          if (stats)
            stats.nodesSkipped += this.nodeCount.count;
          return;
        }
        this.computeTransformMatrix();
        this.matrix.toContext(ctx);
        const { fill, stroke, strokeWidth } = this;
        ctx.font = this.font;
        ctx.textAlign = this.textAlign;
        ctx.textBaseline = this.textBaseline;
        const pixelRatio = this.layerManager.canvas.pixelRatio || 1;
        const { globalAlpha } = ctx;
        if (fill) {
          ctx.fillStyle = fill;
          ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;
          const { fillShadow } = this;
          if (fillShadow == null ? void 0 : fillShadow.enabled) {
            ctx.shadowColor = fillShadow.color;
            ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;
            ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;
            ctx.shadowBlur = fillShadow.blur * pixelRatio;
          }
          this.renderLines((line, x, y) => ctx.fillText(line, x, y));
        }
        if (stroke && strokeWidth) {
          ctx.strokeStyle = stroke;
          ctx.lineWidth = strokeWidth;
          ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;
          const { lineDash, lineDashOffset, lineCap, lineJoin } = this;
          if (lineDash) {
            ctx.setLineDash(lineDash);
          }
          if (lineDashOffset) {
            ctx.lineDashOffset = lineDashOffset;
          }
          if (lineCap) {
            ctx.lineCap = lineCap;
          }
          if (lineJoin) {
            ctx.lineJoin = lineJoin;
          }
          this.renderLines((line, x, y) => ctx.strokeText(line, x, y));
        }
        super.render(renderCtx);
      }
      renderLines(renderCallback) {
        const { lines, x, y } = this;
        const lineHeights = lines.map((line) => this.getLineHeight(line));
        const totalHeight = lineHeights.reduce((a, b) => a + b, 0);
        let offsetY = (lineHeights[0] - totalHeight) * _Text.getVerticalModifier(this.textBaseline);
        for (let i = 0; i < lines.length; i++) {
          renderCallback(lines[i], x, y + offsetY);
          offsetY += lineHeights[i];
        }
      }
      static wrapLines(text, maxWidth, maxHeight, textProps, wrapping, overflow) {
        const canOverflow = overflow !== "hide";
        const measurer = new TextMeasurer(textProps);
        const lines = text.split(/\r?\n/g);
        if (lines.length === 0) {
          return { lines: void 0, truncated: false };
        }
        if (wrapping === "never") {
          const { text: truncText, truncated: truncated2 } = _Text.truncateLine(
            lines[0],
            maxWidth,
            measurer,
            canOverflow ? "auto" : "never"
          );
          return { lines: truncText != null ? [truncText] : void 0, truncated: truncated2 };
        }
        const wrappedLines = [];
        let cumulativeHeight = 0;
        let truncated = false;
        for (const line of lines) {
          const wrappedLine = _Text.wrapLine(
            line,
            maxWidth,
            maxHeight,
            measurer,
            textProps,
            wrapping,
            cumulativeHeight,
            canOverflow
          );
          if (wrappedLine == null) {
            return { lines: void 0, truncated: false };
          }
          wrappedLines.push(...wrappedLine.result);
          cumulativeHeight = wrappedLine.cumulativeHeight;
          if (wrappedLine.truncated) {
            truncated = true;
            break;
          }
        }
        return { lines: wrappedLines, truncated };
      }
      static wrap(text, maxWidth, maxHeight, textProps, wrapping, overflow = "ellipsis") {
        var _a2;
        const { lines, truncated } = _Text.wrapLines(text, maxWidth, maxHeight, textProps, wrapping, overflow);
        return { text: (_a2 = lines == null ? void 0 : lines.join("\n").trim()) != null ? _a2 : "", truncated };
      }
      static wrapLine(text, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow) {
        text = text.trim();
        if (!text) {
          return { result: [], truncated: false, cumulativeHeight };
        }
        const initialSize = measurer.size(text);
        if (initialSize.width <= maxWidth) {
          return {
            result: [text],
            truncated: false,
            cumulativeHeight: cumulativeHeight + initialSize.height
          };
        }
        if (initialSize.height > maxHeight || measurer.width("W") > maxWidth) {
          return canOverflow ? { result: [], truncated: true, cumulativeHeight } : void 0;
        }
        const words = text.split(/\s+/g);
        const wrapResult = _Text.wrapLineSequentially(
          words,
          maxWidth,
          maxHeight,
          measurer,
          textProps,
          wrapping,
          cumulativeHeight,
          canOverflow
        );
        if (wrapResult == null) {
          return;
        }
        cumulativeHeight = wrapResult.cumulativeHeight;
        let { lines } = wrapResult;
        if (!(wrapResult.wordsBrokenOrTruncated || wrapResult.linesTruncated)) {
          const linesCount = wrapResult.lines.length;
          const balanced = _Text.wrapLineBalanced(words, maxWidth, measurer, linesCount);
          if (balanced.length === lines.length) {
            lines = balanced;
          }
        }
        const wrappedText = lines.map((ln) => ln.join(" "));
        return { result: wrappedText, truncated: wrapResult.linesTruncated, cumulativeHeight };
      }
      static breakWord(word, firstLineWidth, maxWidth, hyphens, measurer) {
        const isPunctuationAt = (index) => _Text.punctuationMarks.includes(word[index]);
        const h = hyphens ? measurer.width("-") : 0;
        const breaks = [];
        let partWidth = 0;
        let p = 0;
        for (let i = 0; i < word.length; i++) {
          const c = word[i];
          const w = measurer.width(c);
          const limit = p === 0 ? firstLineWidth : maxWidth;
          if (partWidth + w + h > limit) {
            breaks.push(i);
            partWidth = 0;
            p++;
          }
          partWidth += w;
        }
        const parts = [];
        let start = 0;
        for (const index of breaks) {
          let part = word.substring(start, index);
          if (hyphens && part.length > 0 && !isPunctuationAt(index - 1) && !isPunctuationAt(index)) {
            part += "-";
          }
          parts.push(part);
          start = index;
        }
        parts.push(word.substring(start));
        return parts;
      }
      static truncateLine(text, maxWidth, measurer, ellipsisMode) {
        text = text.trimEnd();
        const lineWidth = measurer.width(text);
        if (lineWidth > maxWidth && ellipsisMode === "never") {
          return { text: void 0, truncated: false };
        } else if (lineWidth <= maxWidth && ellipsisMode !== "force") {
          return { text, truncated: false };
        }
        const ellipsisWidth = measurer.width(ellipsis);
        let trunc = text;
        let truncWidth = lineWidth;
        while (trunc.length > 0 && truncWidth + ellipsisWidth > maxWidth) {
          trunc = trunc.slice(0, -1).trimEnd();
          truncWidth = measurer.width(trunc);
        }
        if (truncWidth + ellipsisWidth <= maxWidth) {
          return { text: `${trunc}${ellipsis}`, truncated: true };
        } else {
          return { text: void 0, truncated: false };
        }
      }
      static wrapLineSequentially(words, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow) {
        const { fontSize = 0, lineHeight = fontSize * _Text.defaultLineHeightRatio } = textProps;
        const breakWord = wrapping === "always" || wrapping === "hyphenate";
        const hyphenate = wrapping === "hyphenate";
        const spaceWidth = measurer.width(" ");
        let wordsBrokenOrTruncated = false;
        let linesTruncated = false;
        const lines = [];
        let currentLine = [];
        let lineWidth = 0;
        const getReturnValue = () => ({
          lines,
          linesTruncated,
          wordsBrokenOrTruncated,
          cumulativeHeight
        });
        const truncateLastLine = () => {
          if (!canOverflow) {
            return;
          }
          const lastLine = currentLine.join(" ");
          const { text } = _Text.truncateLine(lastLine, maxWidth, measurer, "force");
          if (text == null) {
            return;
          }
          currentLine.splice(0, currentLine.length, text);
          linesTruncated = true;
          return getReturnValue();
        };
        const addNewLine = () => {
          const expectedHeight = cumulativeHeight + lineHeight;
          if (expectedHeight >= maxHeight) {
            return false;
          }
          currentLine = [];
          lineWidth = 0;
          cumulativeHeight = expectedHeight;
          lines.push(currentLine);
          return true;
        };
        if (!addNewLine()) {
          return truncateLastLine();
        }
        for (let i = 0; i < words.length; i++) {
          const word = words[i];
          const wordWidth = measurer.width(word);
          const expectedSpaceWidth = currentLine.length === 0 ? 0 : spaceWidth;
          const expectedLineWidth = lineWidth + expectedSpaceWidth + wordWidth;
          if (expectedLineWidth <= maxWidth) {
            currentLine.push(word);
            lineWidth = expectedLineWidth;
            continue;
          }
          if (wordWidth <= maxWidth) {
            if (!addNewLine()) {
              return truncateLastLine();
            }
            currentLine.push(word);
            lineWidth = wordWidth;
            continue;
          }
          wordsBrokenOrTruncated = true;
          if (breakWord) {
            const availWidth = maxWidth - lineWidth - expectedSpaceWidth;
            const parts = _Text.breakWord(word, availWidth, maxWidth, hyphenate, measurer);
            for (let p = 0; p < parts.length; p++) {
              const part = parts[p];
              part && currentLine.push(part);
              if (p === parts.length - 1) {
                lineWidth = measurer.width(part);
              } else if (!addNewLine()) {
                return truncateLastLine();
              }
            }
          } else if (canOverflow) {
            if (!addNewLine()) {
              return truncateLastLine();
            }
            const { text } = _Text.truncateLine(word, maxWidth, measurer, "force");
            if (text == null) {
              return;
            }
            currentLine.push(text);
            if (i < words.length - 1) {
              linesTruncated = true;
            }
            break;
          } else {
            return;
          }
        }
        return getReturnValue();
      }
      static wrapLineBalanced(words, maxWidth, measurer, linesCount) {
        const totalWordsWidth = words.reduce((sum2, w) => sum2 + measurer.width(w), 0);
        const spaceWidth = measurer.width(" ");
        const totalSpaceWidth = spaceWidth * (words.length - linesCount - 2);
        const averageLineWidth = (totalWordsWidth + totalSpaceWidth) / linesCount;
        const lines = [];
        let currentLine = [];
        let lineWidth = measurer.width(words[0]);
        let newLine = true;
        for (const word of words) {
          const width = measurer.width(word);
          if (newLine) {
            currentLine = [];
            currentLine.push(word);
            lineWidth = width;
            newLine = false;
            lines.push(currentLine);
            continue;
          }
          const expectedLineWidth = lineWidth + spaceWidth + width;
          if (expectedLineWidth <= averageLineWidth) {
            currentLine.push(word);
            lineWidth = expectedLineWidth;
          } else if (expectedLineWidth <= maxWidth) {
            currentLine.push(word);
            newLine = true;
          } else {
            currentLine = [word];
            lineWidth = width;
            lines.push(currentLine);
          }
        }
        return lines;
      }
      setFont(props) {
        this.fontFamily = props.fontFamily;
        this.fontSize = props.fontSize;
        this.fontStyle = props.fontStyle;
        this.fontWeight = props.fontWeight;
      }
      setAlign(props) {
        this.textAlign = props.textAlign;
        this.textBaseline = props.textBaseline;
      }
      static getVerticalModifier(textBaseline) {
        switch (textBaseline) {
          case "top":
          case "hanging":
            return 0;
          case "bottom":
          case "alphabetic":
          case "ideographic":
            return 1;
          case "middle":
            return 0.5;
        }
      }
      static get textContext() {
        if (!this._textContext) {
          const canvasElement = createElement("canvas");
          canvasElement.width = 0;
          canvasElement.height = 0;
          this._textContext = canvasElement.getContext("2d");
        }
        return this._textContext;
      }
      static measureText(text, font, textBaseline, textAlign) {
        return this._measureText({ text, font, textBaseline, textAlign });
      }
      /**
       * Returns the width and height of the measured text.
       * @param text The single-line text to measure.
       * @param font The font shorthand string.
       */
      static getTextSize(text, font) {
        return this._getTextSize({ text, font });
      }
      static getTextSizeMultiline(lines, font, textBaseline = _Text.defaultStyles.textBaseline, textAlign = _Text.defaultStyles.textAlign, lineHeight) {
        var _a2, _b;
        let top = 0;
        let left = 0;
        let width = 0;
        let height = 0;
        let baselineDistance = 0;
        for (const [i, text] of lines.entries()) {
          const metrics = this._measureText({ text, font, textBaseline, textAlign });
          left = Math.max(left, metrics.actualBoundingBoxLeft);
          width = Math.max(width, metrics.width);
          if (i == 0) {
            top += metrics.actualBoundingBoxAscent;
            height += metrics.actualBoundingBoxAscent;
          } else {
            baselineDistance += (_a2 = metrics.fontBoundingBoxAscent) != null ? _a2 : metrics.emHeightAscent;
          }
          if (i == lines.length - 1) {
            height += metrics.actualBoundingBoxDescent;
          } else {
            baselineDistance += (_b = metrics.fontBoundingBoxDescent) != null ? _b : metrics.emHeightDescent;
          }
        }
        if (lineHeight != null) {
          baselineDistance = (lines.length - 1) * lineHeight;
        }
        height += baselineDistance;
        top += baselineDistance * _Text.getVerticalModifier(textBaseline);
        return { top, left, width, height };
      }
    };
    _Text.className = "Text";
    // The default line spacing for document editors is usually 1.15
    _Text.defaultLineHeightRatio = 1.15;
    _Text.defaultStyles = Object.assign({}, Shape.defaultStyles, {
      textAlign: "start",
      fontStyle: void 0,
      fontWeight: void 0,
      fontSize: 10,
      fontFamily: "sans-serif",
      textBaseline: "alphabetic"
    });
    _Text.ellipsis = ellipsis;
    _Text.punctuationMarks = [".", ",", "-", ":", ";", "!", "?", `'`, '"', "(", ")"];
    _Text._measureText = memoizeFunction(
      ({
        text,
        font,
        textBaseline,
        textAlign
      }) => {
        const ctx = _Text.textContext;
        if (ctx.font !== font) {
          ctx.font = font;
        }
        if (ctx.textBaseline !== textBaseline) {
          ctx.textBaseline = textBaseline;
        }
        if (ctx.textAlign !== textAlign) {
          ctx.textAlign = textAlign;
        }
        return ctx.measureText(text);
      }
    );
    _Text._getTextSize = memoizeFunction(({ text, font }) => {
      const ctx = _Text.textContext;
      if (ctx.font !== font) {
        ctx.font = font;
      }
      const metrics = ctx.measureText(text);
      return {
        width: metrics.width,
        height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent
      };
    });
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], _Text.prototype, "x", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], _Text.prototype, "y", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */, changeCb: (o) => o.onTextChange() })
    ], _Text.prototype, "text", 2);
    __decorateClass([
      SceneFontChangeDetection()
    ], _Text.prototype, "fontStyle", 2);
    __decorateClass([
      SceneFontChangeDetection()
    ], _Text.prototype, "fontWeight", 2);
    __decorateClass([
      SceneFontChangeDetection()
    ], _Text.prototype, "fontSize", 2);
    __decorateClass([
      SceneFontChangeDetection()
    ], _Text.prototype, "fontFamily", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], _Text.prototype, "textAlign", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], _Text.prototype, "textBaseline", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], _Text.prototype, "lineHeight", 2);
    Text = _Text;
    TextMeasurer = class {
      constructor(font) {
        this.font = isString(font) ? font : getFont(font);
      }
      size(text) {
        return text.includes("\n") ? Text.getTextSizeMultiline(
          text.split("\n").map((s) => s.trim()),
          this.font
        ) : Text.getTextSize(text, this.font);
      }
      width(text) {
        const { width } = this.size(text);
        return width;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/label.ts
function calculateLabelRotation(opts) {
  const { parallelFlipRotation = 0, regularFlipRotation = 0 } = opts;
  const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;
  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;
  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;
  let defaultRotation = 0;
  if (opts.parallel) {
    defaultRotation = parallelFlipFlag * Math.PI / 2;
  } else if (regularFlipFlag === -1) {
    defaultRotation = Math.PI;
  }
  return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };
}
function getLabelSpacing(minSpacing, rotated) {
  if (!isNaN(minSpacing)) {
    return minSpacing;
  }
  return rotated ? 0 : 10;
}
function getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {
  if (parallel && !labelRotation) {
    return sideFlag * parallelFlipFlag === -1 ? "hanging" : "bottom";
  }
  return "middle";
}
function getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {
  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;
  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;
  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;
  if (parallel) {
    if (labelRotation || labelAutoRotation) {
      if (sideFlag * alignFlag === -1) {
        return "end";
      }
    } else {
      return "center";
    }
  } else if (sideFlag * regularFlipFlag === -1) {
    return "end";
  }
  return "start";
}
function calculateLabelBBox(text, bbox, labelX, labelY, labelMatrix) {
  const { width, height } = bbox;
  const translatedBBox = new BBox(labelX, labelY, 0, 0);
  labelMatrix.transformBBox(translatedBBox, bbox);
  const { x, y } = bbox;
  bbox.width = width;
  bbox.height = height;
  return {
    point: { x, y },
    label: { text, width, height }
  };
}
var Label;
var init_label = __esm({
  "packages/ag-charts-community/src/chart/label.ts"() {
    "use strict";
    init_bbox();
    init_text();
    init_angle();
    init_properties();
    init_validation();
    Label = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.enabled = true;
        this.fontSize = 12;
        this.fontFamily = "Verdana, sans-serif";
      }
      getFont() {
        return getFont(this);
      }
    };
    __decorateClass([
      Validate(BOOLEAN)
    ], Label.prototype, "enabled", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], Label.prototype, "color", 2);
    __decorateClass([
      Validate(FONT_STYLE, { optional: true })
    ], Label.prototype, "fontStyle", 2);
    __decorateClass([
      Validate(FONT_WEIGHT2, { optional: true })
    ], Label.prototype, "fontWeight", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], Label.prototype, "fontSize", 2);
    __decorateClass([
      Validate(STRING)
    ], Label.prototype, "fontFamily", 2);
    __decorateClass([
      Validate(FUNCTION, { optional: true })
    ], Label.prototype, "formatter", 2);
  }
});

// packages/ag-charts-community/src/chart/layers.ts
var Layers;
var init_layers = __esm({
  "packages/ag-charts-community/src/chart/layers.ts"() {
    "use strict";
    Layers = /* @__PURE__ */ ((Layers7) => {
      Layers7[Layers7["SERIES_BACKGROUND_ZINDEX"] = 0] = "SERIES_BACKGROUND_ZINDEX";
      Layers7[Layers7["AXIS_GRID_ZINDEX"] = 1] = "AXIS_GRID_ZINDEX";
      Layers7[Layers7["AXIS_ZINDEX"] = 2] = "AXIS_ZINDEX";
      Layers7[Layers7["SERIES_CROSSLINE_RANGE_ZINDEX"] = 3] = "SERIES_CROSSLINE_RANGE_ZINDEX";
      Layers7[Layers7["SERIES_LAYER_ZINDEX"] = 4] = "SERIES_LAYER_ZINDEX";
      Layers7[Layers7["SERIES_HIGHLIGHT_ZINDEX"] = 5] = "SERIES_HIGHLIGHT_ZINDEX";
      Layers7[Layers7["AXIS_FOREGROUND_ZINDEX"] = 6] = "AXIS_FOREGROUND_ZINDEX";
      Layers7[Layers7["SERIES_CROSSHAIR_ZINDEX"] = 7] = "SERIES_CROSSHAIR_ZINDEX";
      Layers7[Layers7["SERIES_LABEL_ZINDEX"] = 8] = "SERIES_LABEL_ZINDEX";
      Layers7[Layers7["SERIES_CROSSLINE_LINE_ZINDEX"] = 9] = "SERIES_CROSSLINE_LINE_ZINDEX";
      Layers7[Layers7["SERIES_ANNOTATION_ZINDEX"] = 10] = "SERIES_ANNOTATION_ZINDEX";
      Layers7[Layers7["LEGEND_ZINDEX"] = 11] = "LEGEND_ZINDEX";
      Layers7[Layers7["NAVIGATOR_ZINDEX"] = 12] = "NAVIGATOR_ZINDEX";
      return Layers7;
    })(Layers || {});
  }
});

// packages/ag-charts-community/src/util/value.ts
function isStringObject(value) {
  return value != null && Object.hasOwn(value, "toString") && isString(value.toString());
}
function isNumberObject(value) {
  return value != null && Object.hasOwn(value, "valueOf") && isFiniteNumber(value.valueOf());
}
function isContinuous(value) {
  return isFiniteNumber(value) || isValidDate(value) || isNumberObject(value);
}
function checkDatum(value, isContinuousScale) {
  return value != null && (!isContinuousScale || isContinuous(value));
}
function transformIntegratedCategoryValue(value) {
  if (isStringObject(value) && Object.hasOwn(value, "id")) {
    return value.id;
  }
  return value;
}
var init_value = __esm({
  "packages/ag-charts-community/src/util/value.ts"() {
    "use strict";
    init_type_guards();
  }
});

// packages/ag-charts-community/src/chart/crossline/crossLine.ts
var MATCHING_CROSSLINE_TYPE, validateCrossLineValues;
var init_crossLine = __esm({
  "packages/ag-charts-community/src/chart/crossline/crossLine.ts"() {
    "use strict";
    init_continuousScale();
    init_ordinalTimeScale();
    init_logger();
    init_validation();
    init_value();
    MATCHING_CROSSLINE_TYPE = (property) => {
      return property === "value" ? predicateWithMessage(
        (_, ctx) => ctx.target["type"] === "line",
        (ctx) => ctx.target["type"] === "range" ? `crossLine type 'range' to have a 'range' property instead of 'value'` : `crossLine property 'type' to be 'line'`
      ) : predicateWithMessage(
        (_, ctx) => ctx.target["type"] === "range",
        (ctx) => ctx.target.type === "line" ? `crossLine type 'line' to have a 'value' property instead of 'range'` : `crossLine property 'type' to be 'range'`
      );
    };
    validateCrossLineValues = (type, value, range4, scale2) => {
      const lineCrossLine = type === "line" && value !== void 0;
      const rangeCrossLine = type === "range" && range4 !== void 0;
      if (!lineCrossLine && !rangeCrossLine) {
        return true;
      }
      const [start, end] = range4 != null ? range4 : [value, void 0];
      const isContinuous3 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);
      const validStart = checkDatum(start, isContinuous3) && !isNaN(scale2.convert(start));
      const validEnd = checkDatum(end, isContinuous3) && !isNaN(scale2.convert(end));
      if (lineCrossLine && validStart || rangeCrossLine && validStart && validEnd) {
        return true;
      }
      const message = [`Expecting crossLine`];
      if (rangeCrossLine) {
        if (!validStart) {
          message.push(`range start ${stringify(start)}`);
        }
        if (!validEnd) {
          message.push(`${validStart ? "" : "and "}range end ${stringify(end)}`);
        }
      } else {
        message.push(`value ${stringify(start)}`);
      }
      message.push(`to match the axis scale domain.`);
      Logger.warnOnce(message.join(" "));
      return false;
    };
  }
});

// packages/ag-charts-community/src/chart/crossline/crossLineLabelPosition.ts
function calculateLabelTranslation({
  yDirection,
  padding = 0,
  position = "top",
  bbox
}) {
  const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;
  const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];
  const w = yDirection ? bbox.width : bbox.height;
  const h = yDirection ? bbox.height : bbox.width;
  const xTranslation = xTranslationDirection * (padding + w / 2);
  const yTranslation = yTranslationDirection * (padding + h / 2);
  return {
    xTranslation,
    yTranslation
  };
}
function calculateLabelChartPadding({
  yDirection,
  bbox,
  padding = 0,
  position = "top"
}) {
  const chartPadding = {};
  if (position.startsWith("inside"))
    return chartPadding;
  if (position === "top" && !yDirection) {
    chartPadding.top = padding + bbox.height;
  } else if (position === "bottom" && !yDirection) {
    chartPadding.bottom = padding + bbox.height;
  } else if (position === "left" && yDirection) {
    chartPadding.left = padding + bbox.width;
  } else if (position === "right" && yDirection) {
    chartPadding.right = padding + bbox.width;
  }
  return chartPadding;
}
var horizontalCrosslineTranslationDirections, verticalCrossLineTranslationDirections, POSITION_TOP_COORDINATES, POSITION_LEFT_COORDINATES, POSITION_RIGHT_COORDINATES, POSITION_BOTTOM_COORDINATES, POSITION_INSIDE_COORDINATES, POSITION_TOP_LEFT_COORDINATES, POSITION_BOTTOM_LEFT_COORDINATES, POSITION_TOP_RIGHT_COORDINATES, POSITION_BOTTOM_RIGHT_COORDINATES, labelDirectionHandling;
var init_crossLineLabelPosition = __esm({
  "packages/ag-charts-community/src/chart/crossline/crossLineLabelPosition.ts"() {
    "use strict";
    horizontalCrosslineTranslationDirections = {
      top: { xTranslationDirection: 0, yTranslationDirection: -1 },
      bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },
      left: { xTranslationDirection: -1, yTranslationDirection: 0 },
      right: { xTranslationDirection: 1, yTranslationDirection: 0 },
      topLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },
      topRight: { xTranslationDirection: -1, yTranslationDirection: -1 },
      bottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },
      bottomRight: { xTranslationDirection: -1, yTranslationDirection: 1 },
      inside: { xTranslationDirection: 0, yTranslationDirection: 0 },
      insideLeft: { xTranslationDirection: 1, yTranslationDirection: 0 },
      insideRight: { xTranslationDirection: -1, yTranslationDirection: 0 },
      insideTop: { xTranslationDirection: 0, yTranslationDirection: 1 },
      insideBottom: { xTranslationDirection: 0, yTranslationDirection: -1 },
      insideTopLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },
      insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },
      insideTopRight: { xTranslationDirection: -1, yTranslationDirection: 1 },
      insideBottomRight: { xTranslationDirection: -1, yTranslationDirection: -1 }
    };
    verticalCrossLineTranslationDirections = {
      top: { xTranslationDirection: 1, yTranslationDirection: 0 },
      bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },
      left: { xTranslationDirection: 0, yTranslationDirection: -1 },
      right: { xTranslationDirection: 0, yTranslationDirection: 1 },
      topLeft: { xTranslationDirection: -1, yTranslationDirection: -1 },
      topRight: { xTranslationDirection: -1, yTranslationDirection: 1 },
      bottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },
      bottomRight: { xTranslationDirection: 1, yTranslationDirection: 1 },
      inside: { xTranslationDirection: 0, yTranslationDirection: 0 },
      insideLeft: { xTranslationDirection: 0, yTranslationDirection: 1 },
      insideRight: { xTranslationDirection: 0, yTranslationDirection: -1 },
      insideTop: { xTranslationDirection: -1, yTranslationDirection: 0 },
      insideBottom: { xTranslationDirection: 1, yTranslationDirection: 0 },
      insideTopLeft: { xTranslationDirection: -1, yTranslationDirection: 1 },
      insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },
      insideTopRight: { xTranslationDirection: -1, yTranslationDirection: -1 },
      insideBottomRight: { xTranslationDirection: 1, yTranslationDirection: -1 }
    };
    POSITION_TOP_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {
      if (yDirection) {
        return { x: xEnd / 2, y: yStart };
      } else {
        return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };
      }
    };
    POSITION_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {
      if (yDirection) {
        return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };
      } else {
        return { x: xEnd / 2, y: yStart };
      }
    };
    POSITION_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {
      if (yDirection) {
        return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };
      } else {
        return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };
      }
    };
    POSITION_BOTTOM_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {
      if (yDirection) {
        return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };
      } else {
        return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };
      }
    };
    POSITION_INSIDE_COORDINATES = ({ xEnd, yStart, yEnd }) => {
      return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };
    };
    POSITION_TOP_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart }) => {
      if (yDirection) {
        return { x: xStart / 2, y: yStart };
      } else {
        return { x: xEnd, y: yStart };
      }
    };
    POSITION_BOTTOM_LEFT_COORDINATES = ({ yDirection, xStart, yStart, yEnd }) => {
      if (yDirection) {
        return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };
      } else {
        return { x: xStart, y: yStart };
      }
    };
    POSITION_TOP_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {
      if (yDirection) {
        return { x: xEnd, y: yStart };
      } else {
        return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };
      }
    };
    POSITION_BOTTOM_RIGHT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {
      if (yDirection) {
        return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };
      } else {
        return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };
      }
    };
    labelDirectionHandling = {
      top: { c: POSITION_TOP_COORDINATES },
      bottom: { c: POSITION_BOTTOM_COORDINATES },
      left: { c: POSITION_LEFT_COORDINATES },
      right: { c: POSITION_RIGHT_COORDINATES },
      topLeft: { c: POSITION_TOP_LEFT_COORDINATES },
      topRight: { c: POSITION_TOP_RIGHT_COORDINATES },
      bottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },
      bottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES },
      inside: { c: POSITION_INSIDE_COORDINATES },
      insideLeft: { c: POSITION_LEFT_COORDINATES },
      insideRight: { c: POSITION_RIGHT_COORDINATES },
      insideTop: { c: POSITION_TOP_COORDINATES },
      insideBottom: { c: POSITION_BOTTOM_COORDINATES },
      insideTopLeft: { c: POSITION_TOP_LEFT_COORDINATES },
      insideBottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },
      insideTopRight: { c: POSITION_TOP_RIGHT_COORDINATES },
      insideBottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES }
    };
  }
});

// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts
var CROSSLINE_LABEL_POSITION, CartesianCrossLineLabel, _CartesianCrossLine, CartesianCrossLine;
var init_cartesianCrossLine = __esm({
  "packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts"() {
    "use strict";
    init_bandScale();
    init_continuousScale();
    init_ordinalTimeScale();
    init_bbox();
    init_group();
    init_node();
    init_range();
    init_text();
    init_id();
    init_number();
    init_validation();
    init_chartAxisDirection();
    init_label();
    init_layers();
    init_crossLine();
    init_crossLineLabelPosition();
    CROSSLINE_LABEL_POSITION = UNION(
      [
        "top",
        "left",
        "right",
        "bottom",
        "topLeft",
        "topRight",
        "bottomLeft",
        "bottomRight",
        "inside",
        "insideLeft",
        "insideRight",
        "insideTop",
        "insideBottom",
        "insideTopLeft",
        "insideBottomLeft",
        "insideTopRight",
        "insideBottomRight"
      ],
      "crossLine label position"
    );
    CartesianCrossLineLabel = class {
      constructor() {
        this.enabled = void 0;
        this.text = void 0;
        this.fontStyle = void 0;
        this.fontWeight = void 0;
        this.fontSize = 14;
        this.fontFamily = "Verdana, sans-serif";
        this.padding = 5;
        this.color = "rgba(87, 87, 87, 1)";
        this.position = void 0;
        this.rotation = void 0;
        this.parallel = void 0;
      }
    };
    __decorateClass([
      Validate(BOOLEAN, { optional: true })
    ], CartesianCrossLineLabel.prototype, "enabled", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], CartesianCrossLineLabel.prototype, "text", 2);
    __decorateClass([
      Validate(FONT_STYLE, { optional: true })
    ], CartesianCrossLineLabel.prototype, "fontStyle", 2);
    __decorateClass([
      Validate(FONT_WEIGHT2, { optional: true })
    ], CartesianCrossLineLabel.prototype, "fontWeight", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], CartesianCrossLineLabel.prototype, "fontSize", 2);
    __decorateClass([
      Validate(STRING)
    ], CartesianCrossLineLabel.prototype, "fontFamily", 2);
    __decorateClass([
      Validate(NUMBER)
    ], CartesianCrossLineLabel.prototype, "padding", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], CartesianCrossLineLabel.prototype, "color", 2);
    __decorateClass([
      Validate(CROSSLINE_LABEL_POSITION, { optional: true })
    ], CartesianCrossLineLabel.prototype, "position", 2);
    __decorateClass([
      Validate(DEGREE, { optional: true })
    ], CartesianCrossLineLabel.prototype, "rotation", 2);
    __decorateClass([
      Validate(BOOLEAN, { optional: true })
    ], CartesianCrossLineLabel.prototype, "parallel", 2);
    _CartesianCrossLine = class _CartesianCrossLine {
      constructor() {
        this.id = createId(this);
        this.enabled = void 0;
        this.type = void 0;
        this.range = void 0;
        this.value = void 0;
        this.fill = void 0;
        this.fillOpacity = void 0;
        this.stroke = void 0;
        this.strokeWidth = void 0;
        this.strokeOpacity = void 0;
        this.lineDash = void 0;
        this.label = new CartesianCrossLineLabel();
        this.scale = void 0;
        this.clippedRange = [-Infinity, Infinity];
        this.gridLength = 0;
        this.sideFlag = -1;
        this.parallelFlipRotation = 0;
        this.regularFlipRotation = 0;
        this.direction = "x" /* X */;
        this.group = new Group({ name: `${this.id}`, layer: true, zIndex: _CartesianCrossLine.LINE_LAYER_ZINDEX });
        this.labelGroup = new Group({ name: `${this.id}`, layer: true, zIndex: _CartesianCrossLine.LABEL_LAYER_ZINDEX });
        this.crossLineRange = new Range();
        this.crossLineLabel = new Text();
        this.labelPoint = void 0;
        this.data = [];
        this.startLine = false;
        this.endLine = false;
        this.isRange = false;
        const { group: group2, labelGroup, crossLineRange, crossLineLabel } = this;
        group2.append(crossLineRange);
        labelGroup.append(crossLineLabel);
        crossLineRange.pointerEvents = 1 /* None */;
      }
      update(visible) {
        const { enabled, data, type, value, range: range4, scale: scale2 } = this;
        if (!type || !scale2 || !enabled || !visible || !validateCrossLineValues(type, value, range4, scale2) || data.length === 0) {
          this.group.visible = false;
          this.labelGroup.visible = false;
          return;
        }
        this.group.visible = visible;
        this.labelGroup.visible = visible;
        this.group.zIndex = this.getZIndex(this.isRange);
        this.updateNodes();
      }
      calculateLayout(visible, reversedAxis) {
        if (!visible) {
          return;
        }
        const dataCreated = this.createNodeData(reversedAxis);
        if (!dataCreated) {
          return;
        }
        const { sideFlag, gridLength, data } = this;
        const boxes = [];
        const x1 = 0;
        const x2 = sideFlag * gridLength;
        const y1 = data[0];
        const y2 = data[1];
        const crossLineBox = new BBox(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));
        boxes.push(crossLineBox);
        const labelBox = this.computeLabelBBox();
        if (labelBox) {
          boxes.push(labelBox);
        }
        return BBox.merge(boxes);
      }
      updateNodes() {
        this.updateRangeNode();
        if (this.label.enabled) {
          this.updateLabel();
          this.positionLabel();
        }
      }
      createNodeData(reversedAxis) {
        var _a2, _b, _c;
        const {
          scale: scale2,
          gridLength,
          sideFlag,
          direction,
          label: { position = "top" },
          clippedRange,
          strokeWidth = 0
        } = this;
        this.data = [];
        if (!scale2) {
          return false;
        }
        const bandwidth = (_a2 = scale2.bandwidth) != null ? _a2 : 0;
        const step = (_b = scale2.step) != null ? _b : 0;
        const padding = (reversedAxis ? -1 : 1) * (scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0);
        const [xStart, xEnd] = [0, sideFlag * gridLength];
        let [yStart, yEnd] = this.getRange();
        const ordinalTimeScalePadding = yEnd === void 0 && OrdinalTimeScale.is(scale2) ? bandwidth / 2 + padding : 0;
        let [clampedYStart, clampedYEnd] = [
          Number(scale2.convert(yStart, { clampMode: "clamped" })) - padding + ordinalTimeScalePadding,
          scale2.convert(yEnd, { clampMode: "clamped" }) + bandwidth + padding
        ];
        clampedYStart = clampArray(clampedYStart, clippedRange);
        clampedYEnd = clampArray(clampedYEnd, clippedRange);
        [yStart, yEnd] = [Number(scale2.convert(yStart)) + ordinalTimeScalePadding, scale2.convert(yEnd) + bandwidth];
        const validRange = (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;
        if (validRange && clampedYStart > clampedYEnd) {
          [clampedYStart, clampedYEnd] = [clampedYEnd, clampedYStart];
          [yStart, yEnd] = [yEnd, yStart];
        }
        if (yStart - padding >= clampedYStart)
          yStart -= padding;
        if (yEnd + padding <= clampedYEnd)
          yEnd += padding;
        this.isRange = validRange;
        this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + padding;
        this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - padding && yEnd <= clampedYEnd;
        if (!validRange && !this.startLine && !this.endLine) {
          return false;
        }
        this.data = [clampedYStart, clampedYEnd];
        if (this.label.enabled) {
          const yDirection = direction === "y" /* Y */;
          const { c = POSITION_TOP_COORDINATES } = (_c = labelDirectionHandling[position]) != null ? _c : {};
          const { x: labelX, y: labelY } = c({
            yDirection,
            xStart,
            xEnd,
            yStart: clampedYStart,
            yEnd: clampedYEnd
          });
          this.labelPoint = {
            x: labelX,
            y: labelY
          };
        }
        return true;
      }
      updateRangeNode() {
        var _a2;
        const {
          crossLineRange,
          sideFlag,
          gridLength,
          data,
          startLine,
          endLine,
          isRange,
          fill,
          fillOpacity,
          stroke,
          strokeWidth,
          lineDash
        } = this;
        crossLineRange.x1 = 0;
        crossLineRange.x2 = sideFlag * gridLength;
        crossLineRange.y1 = data[0];
        crossLineRange.y2 = data[1];
        crossLineRange.startLine = startLine;
        crossLineRange.endLine = endLine;
        crossLineRange.isRange = isRange;
        crossLineRange.fill = fill;
        crossLineRange.fillOpacity = fillOpacity != null ? fillOpacity : 1;
        crossLineRange.stroke = stroke;
        crossLineRange.strokeWidth = strokeWidth != null ? strokeWidth : 1;
        crossLineRange.strokeOpacity = (_a2 = this.strokeOpacity) != null ? _a2 : 1;
        crossLineRange.lineDash = lineDash;
      }
      updateLabel() {
        const { crossLineLabel, label } = this;
        if (!label.text) {
          return;
        }
        crossLineLabel.fontStyle = label.fontStyle;
        crossLineLabel.fontWeight = label.fontWeight;
        crossLineLabel.fontSize = label.fontSize;
        crossLineLabel.fontFamily = label.fontFamily;
        crossLineLabel.fill = label.color;
        crossLineLabel.text = label.text;
      }
      positionLabel() {
        const {
          crossLineLabel,
          labelPoint: { x = void 0, y = void 0 } = {},
          label: { parallel, rotation, position = "top", padding = 0 },
          direction,
          parallelFlipRotation,
          regularFlipRotation
        } = this;
        if (x === void 0 || y === void 0) {
          return;
        }
        const { defaultRotation, configuredRotation } = calculateLabelRotation({
          rotation,
          parallel,
          regularFlipRotation,
          parallelFlipRotation
        });
        crossLineLabel.rotation = defaultRotation + configuredRotation;
        crossLineLabel.textBaseline = "middle";
        crossLineLabel.textAlign = "center";
        const bbox = crossLineLabel.computeTransformedBBox();
        if (!bbox) {
          return;
        }
        const yDirection = direction === "y" /* Y */;
        const { xTranslation, yTranslation } = calculateLabelTranslation({
          yDirection,
          padding,
          position,
          bbox
        });
        crossLineLabel.translationX = x + xTranslation;
        crossLineLabel.translationY = y + yTranslation;
      }
      getZIndex(isRange = false) {
        if (isRange) {
          return _CartesianCrossLine.RANGE_LAYER_ZINDEX;
        }
        return _CartesianCrossLine.LINE_LAYER_ZINDEX;
      }
      getRange() {
        var _a2;
        const { value, range: range4, scale: scale2 } = this;
        const isContinuous3 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);
        const start = (_a2 = range4 == null ? void 0 : range4[0]) != null ? _a2 : value;
        let end = range4 == null ? void 0 : range4[1];
        if (!isContinuous3 && end === void 0) {
          end = start;
        }
        if (isContinuous3 && start === end) {
          end = void 0;
        }
        return [start, end];
      }
      computeLabelBBox() {
        const { label } = this;
        if (!label.enabled) {
          return;
        }
        const tempText2 = new Text();
        tempText2.fontFamily = label.fontFamily;
        tempText2.fontSize = label.fontSize;
        tempText2.fontStyle = label.fontStyle;
        tempText2.fontWeight = label.fontWeight;
        tempText2.text = label.text;
        const {
          labelPoint: { x = void 0, y = void 0 } = {},
          label: { parallel, rotation, position = "top", padding = 0 },
          direction,
          parallelFlipRotation,
          regularFlipRotation
        } = this;
        if (x === void 0 || y === void 0) {
          return;
        }
        const { configuredRotation } = calculateLabelRotation({
          rotation,
          parallel,
          regularFlipRotation,
          parallelFlipRotation
        });
        tempText2.rotation = configuredRotation;
        tempText2.textBaseline = "middle";
        tempText2.textAlign = "center";
        const bbox = tempText2.computeTransformedBBox();
        if (!bbox) {
          return;
        }
        const yDirection = direction === "y" /* Y */;
        const { xTranslation, yTranslation } = calculateLabelTranslation({
          yDirection,
          padding,
          position,
          bbox
        });
        tempText2.translationX = x + xTranslation;
        tempText2.translationY = y + yTranslation;
        return tempText2.computeTransformedBBox();
      }
      calculatePadding(padding) {
        var _a2, _b, _c, _d, _e, _f, _g, _h;
        const {
          isRange,
          startLine,
          endLine,
          direction,
          label: { padding: labelPadding = 0, position = "top" }
        } = this;
        if (!isRange && !startLine && !endLine) {
          return;
        }
        const crossLineLabelBBox = this.computeLabelBBox();
        if ((crossLineLabelBBox == null ? void 0 : crossLineLabelBBox.x) == null || (crossLineLabelBBox == null ? void 0 : crossLineLabelBBox.y) == null) {
          return;
        }
        const chartPadding = calculateLabelChartPadding({
          yDirection: direction === "y" /* Y */,
          padding: labelPadding,
          position,
          bbox: crossLineLabelBBox
        });
        padding.left = Math.max((_a2 = padding.left) != null ? _a2 : 0, (_b = chartPadding.left) != null ? _b : 0);
        padding.right = Math.max((_c = padding.right) != null ? _c : 0, (_d = chartPadding.right) != null ? _d : 0);
        padding.top = Math.max((_e = padding.top) != null ? _e : 0, (_f = chartPadding.top) != null ? _f : 0);
        padding.bottom = Math.max((_g = padding.bottom) != null ? _g : 0, (_h = chartPadding.bottom) != null ? _h : 0);
      }
    };
    _CartesianCrossLine.LINE_LAYER_ZINDEX = 9 /* SERIES_CROSSLINE_LINE_ZINDEX */;
    _CartesianCrossLine.RANGE_LAYER_ZINDEX = 3 /* SERIES_CROSSLINE_RANGE_ZINDEX */;
    _CartesianCrossLine.LABEL_LAYER_ZINDEX = 8 /* SERIES_LABEL_ZINDEX */;
    _CartesianCrossLine.className = "CrossLine";
    __decorateClass([
      Validate(BOOLEAN, { optional: true })
    ], _CartesianCrossLine.prototype, "enabled", 2);
    __decorateClass([
      Validate(UNION(["range", "line"], "a crossLine type"), { optional: true })
    ], _CartesianCrossLine.prototype, "type", 2);
    __decorateClass([
      Validate(AND(MATCHING_CROSSLINE_TYPE("range"), ARRAY.restrict({ length: 2 })), {
        optional: true
      })
    ], _CartesianCrossLine.prototype, "range", 2);
    __decorateClass([
      Validate(MATCHING_CROSSLINE_TYPE("value"), { optional: true })
    ], _CartesianCrossLine.prototype, "value", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], _CartesianCrossLine.prototype, "fill", 2);
    __decorateClass([
      Validate(RATIO, { optional: true })
    ], _CartesianCrossLine.prototype, "fillOpacity", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], _CartesianCrossLine.prototype, "stroke", 2);
    __decorateClass([
      Validate(NUMBER, { optional: true })
    ], _CartesianCrossLine.prototype, "strokeWidth", 2);
    __decorateClass([
      Validate(RATIO, { optional: true })
    ], _CartesianCrossLine.prototype, "strokeOpacity", 2);
    __decorateClass([
      Validate(LINE_DASH, { optional: true })
    ], _CartesianCrossLine.prototype, "lineDash", 2);
    CartesianCrossLine = _CartesianCrossLine;
  }
});

// packages/ag-charts-community/src/module/moduleMap.ts
var ModuleMap;
var init_moduleMap = __esm({
  "packages/ag-charts-community/src/module/moduleMap.ts"() {
    "use strict";
    init_type_guards();
    ModuleMap = class {
      constructor() {
        this.moduleMap = /* @__PURE__ */ new Map();
      }
      *modules() {
        for (const m of this.moduleMap.values()) {
          yield m.moduleInstance;
        }
      }
      addModule(module2, moduleFactory) {
        if (this.moduleMap.has(module2.optionsKey)) {
          throw new Error(`AG Charts - module already initialised: ${module2.optionsKey}`);
        }
        this.moduleMap.set(module2.optionsKey, { module: module2, moduleInstance: moduleFactory(module2) });
      }
      removeModule(module2) {
        var _a2;
        const moduleKey = isString(module2) ? module2 : module2.optionsKey;
        (_a2 = this.moduleMap.get(moduleKey)) == null ? void 0 : _a2.moduleInstance.destroy();
        this.moduleMap.delete(moduleKey);
      }
      getModule(module2) {
        var _a2;
        return (_a2 = this.moduleMap.get(isString(module2) ? module2 : module2.optionsKey)) == null ? void 0 : _a2.moduleInstance;
      }
      isEnabled(module2) {
        return this.moduleMap.has(isString(module2) ? module2 : module2.optionsKey);
      }
      mapModules(callback) {
        return Array.from(this.moduleMap.values(), (m, i) => callback(m.moduleInstance, i));
      }
      destroy() {
        var _a2;
        for (const moduleKey of this.moduleMap.keys()) {
          (_a2 = this.moduleMap.get(moduleKey)) == null ? void 0 : _a2.moduleInstance.destroy();
        }
        this.moduleMap.clear();
      }
    };
  }
});

// packages/ag-charts-community/src/motion/resetMotion.ts
var resetMotion_exports = {};
__export(resetMotion_exports, {
  resetMotion: () => resetMotion
});
function resetMotion(selectionsOrNodes, propsFn) {
  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);
  for (const selection of selections) {
    for (const node of selection.nodes()) {
      const from = propsFn(node, node.datum);
      node.setProperties(from);
    }
    selection.cleanup();
  }
  for (const node of nodes) {
    const from = propsFn(node, node.datum);
    node.setProperties(from);
  }
}
var init_resetMotion = __esm({
  "packages/ag-charts-community/src/motion/resetMotion.ts"() {
    "use strict";
    init_animation();
  }
});

// packages/ag-charts-community/src/motion/states.ts
var StateMachine;
var init_states = __esm({
  "packages/ag-charts-community/src/motion/states.ts"() {
    "use strict";
    init_debug();
    StateMachine = class {
      constructor(initialState, states, preTransitionCb) {
        this.states = states;
        this.preTransitionCb = preTransitionCb;
        this.debug = Debug.create(true, "animation");
        this.state = initialState;
        this.debug(`%c${this.constructor.name} | init -> ${initialState}`, "color: green");
      }
      transition(event, data) {
        var _a2, _b;
        const currentStateConfig = this.states[this.state];
        const destinationTransition = currentStateConfig == null ? void 0 : currentStateConfig[event];
        if (!destinationTransition) {
          this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.state}`, "color: grey");
          return;
        }
        let destinationState = this.state;
        if (typeof destinationTransition === "string") {
          destinationState = destinationTransition;
        } else if (typeof destinationTransition === "object") {
          destinationState = destinationTransition.target;
        }
        this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${destinationState}`, "color: green");
        (_a2 = this.preTransitionCb) == null ? void 0 : _a2.call(this, this.state, destinationState);
        this.state = destinationState;
        if (typeof destinationTransition === "function") {
          destinationTransition(data);
        } else if (typeof destinationTransition === "object") {
          (_b = destinationTransition.action) == null ? void 0 : _b.call(destinationTransition, data);
        }
        return this.state;
      }
    };
  }
});

// packages/ag-charts-community/src/util/numberFormat.ts
function parseFormatter(formatter) {
  let prefix;
  let suffix;
  const surrounded = surroundedRegEx.exec(formatter);
  if (surrounded) {
    [, prefix, formatter, suffix] = surrounded;
  }
  const match = formatRegEx.exec(formatter);
  if (!match) {
    throw new Error(`The number formatter is invalid: ${formatter}`);
  }
  const [, fill, align, sign, symbol, zero, width, comma, precision, trim, type] = match;
  return {
    fill,
    align,
    sign,
    symbol,
    zero,
    width: parseInt(width),
    comma,
    precision: parseInt(precision),
    trim: Boolean(trim),
    type,
    prefix,
    suffix
  };
}
function format(formatter) {
  const options = typeof formatter === "string" ? parseFormatter(formatter) : formatter;
  const { fill, align, sign = "-", symbol, zero, width, comma, type, prefix = "", suffix = "", precision } = options;
  let { trim } = options;
  const precisionIsNaN = precision === void 0 || isNaN(precision);
  let formatBody;
  if (!type) {
    formatBody = decimalTypes["g"];
    trim = true;
  } else if (type in decimalTypes && type in integerTypes) {
    formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];
  } else if (type in decimalTypes) {
    formatBody = decimalTypes[type];
  } else if (type in integerTypes) {
    formatBody = integerTypes[type];
  } else {
    throw new Error(`The number formatter type is invalid: ${type}`);
  }
  let formatterPrecision;
  if (precision == null || precisionIsNaN) {
    formatterPrecision = type ? 6 : 12;
  } else {
    formatterPrecision = precision;
  }
  return (n) => {
    let result = formatBody(n, formatterPrecision);
    if (trim) {
      result = removeTrailingZeros(result);
    }
    if (comma) {
      result = insertSeparator(result, comma);
    }
    result = addSign(n, result, sign);
    if (symbol && symbol !== "#") {
      result = `${symbol}${result}`;
    }
    if (symbol === "#" && type === "x") {
      result = `0x${result}`;
    }
    if (type === "s") {
      result = `${result}${getSIPrefix(n)}`;
    }
    if (type === "%" || type === "p") {
      result = `${result}%`;
    }
    if (width != null && !isNaN(width)) {
      result = addPadding(result, width, fill != null ? fill : zero, align);
    }
    result = `${prefix}${result}${suffix}`;
    return result;
  };
}
function removeTrailingZeros(numString) {
  return numString.replace(/\.0+$/, "").replace(/(\.[1-9])0+$/, "$1");
}
function insertSeparator(numString, separator) {
  let dotIndex = numString.indexOf(".");
  if (dotIndex < 0) {
    dotIndex = numString.length;
  }
  const integerChars = numString.substring(0, dotIndex).split("");
  const fractionalPart = numString.substring(dotIndex);
  for (let i = integerChars.length - 3; i > 0; i -= 3) {
    integerChars.splice(i, 0, separator);
  }
  return `${integerChars.join("")}${fractionalPart}`;
}
function getSIPrefix(n) {
  return siPrefixes[getSIPrefixPower(n)];
}
function getSIPrefixPower(n) {
  return clamp(minSIPrefix, n ? Math.floor(Math.log10(Math.abs(n)) / 3) * 3 : 0, maxSIPrefix);
}
function addSign(num, numString, signType = "") {
  if (signType === "(") {
    return num >= 0 ? numString : `(${numString})`;
  }
  const plusSign = signType === "+" ? "+" : "";
  return `${num >= 0 ? plusSign : minusSign}${numString}`;
}
function addPadding(numString, width, fill = " ", align = ">") {
  let result = numString;
  if (align === ">" || !align) {
    result = result.padStart(width, fill);
  } else if (align === "<") {
    result = result.padEnd(width, fill);
  } else if (align === "^") {
    const padWidth = Math.max(0, width - result.length);
    const padLeft = Math.ceil(padWidth / 2);
    const padRight = Math.floor(padWidth / 2);
    result = result.padStart(padLeft + result.length, fill);
    result = result.padEnd(padRight + result.length, fill);
  }
  return result;
}
function tickFormat(ticks, formatter) {
  const options = parseFormatter(formatter != null ? formatter : ",f");
  const { precision } = options;
  if (precision == null || isNaN(precision)) {
    if (options.type === "f" || options.type === "%") {
      options.precision = Math.max(
        ...ticks.map((x) => {
          if (typeof x !== "number" || x === 0) {
            return 0;
          }
          const l = Math.floor(Math.log10(Math.abs(x)));
          const digits = options.type ? 6 : 12;
          const exp = x.toExponential(digits - 1).replace(/\.?0+e/, "e");
          const dotIndex = exp.indexOf(".");
          if (dotIndex < 0) {
            return l >= 0 ? 0 : -l;
          }
          const s = exp.indexOf("e") - dotIndex;
          return Math.max(0, s - l - 1);
        })
      );
    } else if (!options.type || options.type in decimalTypes) {
      options.precision = Math.max(
        ...ticks.map((x) => {
          if (typeof x !== "number") {
            return 0;
          }
          const exp = x.toExponential((options.type ? 6 : 12) - 1).replace(/\.?0+e/, "e");
          return exp.substring(0, exp.indexOf("e")).replace(".", "").length;
        })
      );
    }
  }
  const f = format(options);
  return (n) => f(Number(n));
}
var group, optionalGroup, nonCapturingGroup, formatRegEx, surroundedRegEx, absFloor, integerTypes, decimalTypes, minSIPrefix, maxSIPrefix, siPrefixes, minusSign;
var init_numberFormat = __esm({
  "packages/ag-charts-community/src/util/numberFormat.ts"() {
    "use strict";
    init_number();
    group = (content) => `(${content})`;
    optionalGroup = (content) => `${group(content)}?`;
    nonCapturingGroup = (content) => optionalGroup(`?:${content}`);
    formatRegEx = (() => {
      const fill = ".";
      const align = "[<>=^]";
      const sign = "[+\\-( ]";
      const symbol = "[$\u20AC\xA3\xA5\u20A3\u20B9#]";
      const zero = "0";
      const width = "\\d+";
      const comma = ",";
      const precision = "\\d+";
      const tilde = "~";
      const type = "[%a-z]";
      return new RegExp(
        [
          "^",
          nonCapturingGroup(`${optionalGroup(fill)}${group(align)}`),
          optionalGroup(sign),
          optionalGroup(symbol),
          optionalGroup(zero),
          optionalGroup(width),
          optionalGroup(comma),
          nonCapturingGroup(`\\.${group(precision)}`),
          optionalGroup(tilde),
          optionalGroup(type),
          "$"
        ].join(""),
        "i"
      );
    })();
    surroundedRegEx = (() => {
      const prefix = ".*?";
      const content = ".+?";
      const suffix = ".*?";
      return new RegExp(["^", group(prefix), `#\\{${group(content)}\\}`, group(suffix), "$"].join(""));
    })();
    absFloor = (n) => Math.floor(Math.abs(n));
    integerTypes = {
      b: (n) => absFloor(n).toString(2),
      c: (n) => String.fromCharCode(n),
      d: (n) => Math.round(Math.abs(n)).toFixed(0),
      o: (n) => absFloor(n).toString(8),
      x: (n) => absFloor(n).toString(16),
      X: (n) => integerTypes.x(n).toUpperCase(),
      n: (n) => integerTypes.d(n),
      "%": (n) => `${absFloor(n * 100).toFixed(0)}`
    };
    decimalTypes = {
      e: (n, f) => Math.abs(n).toExponential(f),
      E: (n, f) => decimalTypes.e(n, f).toUpperCase(),
      f: (n, f) => Math.abs(n).toFixed(f),
      F: (n, f) => decimalTypes.f(n, f).toUpperCase(),
      g: (n, f) => {
        if (n === 0) {
          return "0";
        }
        const a = Math.abs(n);
        const p = Math.floor(Math.log10(a));
        if (p >= -4 && p < f) {
          return a.toFixed(f - 1 - p);
        }
        return a.toExponential(f - 1);
      },
      G: (n, f) => decimalTypes.g(n, f).toUpperCase(),
      n: (n, f) => decimalTypes.g(n, f),
      p: (n, f) => decimalTypes.r(n * 100, f),
      r: (n, f) => {
        if (n === 0) {
          return "0";
        }
        const a = Math.abs(n);
        const p = Math.floor(Math.log10(a));
        const q = p - (f - 1);
        if (q <= 0) {
          return a.toFixed(-q);
        }
        const x = Math.pow(10, q);
        return (Math.round(a / x) * x).toFixed();
      },
      s: (n, f) => {
        const p = getSIPrefixPower(n);
        return decimalTypes.r(n / Math.pow(10, p), f);
      },
      "%": (n, f) => decimalTypes.f(n * 100, f)
    };
    minSIPrefix = -24;
    maxSIPrefix = 24;
    siPrefixes = {
      [minSIPrefix]: "y",
      [-21]: "z",
      [-18]: "a",
      [-15]: "f",
      [-12]: "p",
      [-9]: "n",
      [-6]: "\xB5",
      [-3]: "m",
      [0]: "",
      [3]: "k",
      [6]: "M",
      [9]: "G",
      [12]: "T",
      [15]: "P",
      [18]: "E",
      [21]: "Z",
      [maxSIPrefix]: "Y"
    };
    minusSign = "\u2212";
  }
});

// packages/ag-charts-community/src/scale/logScale.ts
var _LogScale, LogScale;
var init_logScale = __esm({
  "packages/ag-charts-community/src/scale/logScale.ts"() {
    "use strict";
    init_function();
    init_logger();
    init_number();
    init_numberFormat();
    init_ticks();
    init_type_guards();
    init_continuousScale();
    init_invalidating();
    _LogScale = class _LogScale extends ContinuousScale {
      constructor() {
        super([1, 10], [0, 1]);
        this.type = "log";
        this.base = 10;
        this.baseLog = identity;
        this.basePow = identity;
        this.log = (x) => {
          const start = Math.min(...this.domain);
          return start >= 0 ? this.baseLog(x) : -this.baseLog(-x);
        };
        this.pow = (x) => {
          const start = Math.min(...this.domain);
          return start >= 0 ? this.basePow(x) : -this.basePow(-x);
        };
        this.defaultClampMode = "clamped";
      }
      toDomain(d) {
        return d;
      }
      transform(x) {
        const start = Math.min(...this.domain);
        return start >= 0 ? Math.log(x) : -Math.log(-x);
      }
      transformInvert(x) {
        const start = Math.min(...this.domain);
        return start >= 0 ? Math.exp(x) : -Math.exp(-x);
      }
      refresh() {
        if (this.base <= 0) {
          this.base = 0;
          Logger.warnOnce("expecting a finite Number greater than to 0");
        }
        super.refresh();
      }
      update() {
        if (!this.domain || this.domain.length < 2) {
          return;
        }
        this.baseLog = _LogScale.getBaseLogMethod(this.base);
        this.basePow = _LogScale.getBasePowerMethod(this.base);
        if (this.nice) {
          this.updateNiceDomain();
        }
      }
      updateNiceDomain() {
        const [d0, d1] = this.domain;
        const roundStart = d0 > d1 ? Math.ceil : Math.floor;
        const roundStop = d0 > d1 ? Math.floor : Math.ceil;
        const n0 = this.pow(roundStart(this.log(d0)));
        const n1 = this.pow(roundStop(this.log(d1)));
        this.niceDomain = [n0, n1];
      }
      ticks() {
        var _a2;
        const count = (_a2 = this.tickCount) != null ? _a2 : 10;
        if (!this.domain || this.domain.length < 2 || count < 1) {
          return [];
        }
        this.refresh();
        const base = this.base;
        const [d0, d1] = this.getDomain();
        const start = Math.min(d0, d1);
        const stop = Math.max(d0, d1);
        let p0 = this.log(start);
        let p1 = this.log(stop);
        if (this.interval) {
          const step = Math.abs(this.interval);
          const absDiff = Math.abs(p1 - p0);
          let ticks2 = range(p0, p1, Math.min(absDiff, step));
          ticks2 = createNumericTicks(
            ticks2.fractionDigits,
            ticks2.map((x) => this.pow(x)).filter((t) => t >= start && t <= stop)
          );
          const availableRange = this.getPixelRange();
          if (!isDenseInterval({ start, stop, interval: step, count: ticks2.length, availableRange })) {
            return ticks2;
          }
        }
        const isBaseInteger = base % 1 === 0;
        const isDiffLarge = p1 - p0 >= count;
        if (!isBaseInteger || isDiffLarge) {
          let ticks2 = ticks_default(p0, p1, Math.min(p1 - p0, count));
          ticks2 = createNumericTicks(
            ticks2.fractionDigits,
            ticks2.map((x) => this.pow(x))
          );
          return ticks2;
        }
        const ticks = [];
        const isPositive = start > 0;
        p0 = Math.floor(p0) - 1;
        p1 = Math.round(p1) + 1;
        const availableSpacing = findRangeExtent(this.range) / count;
        let lastTickPosition = Infinity;
        for (let p = p0; p <= p1; p++) {
          const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));
          for (let k = 1; k < base; k++) {
            const q = isPositive ? k : base - k + 1;
            const t = this.pow(p) * q;
            const tickPosition = this.convert(t);
            const prevSpacing = Math.abs(lastTickPosition - tickPosition);
            const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);
            const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;
            if (t >= start && t <= stop && (k === 1 || fits || ticks.length === 0)) {
              ticks.push(t);
              lastTickPosition = tickPosition;
            }
          }
        }
        return ticks;
      }
      tickFormat({
        count,
        ticks,
        specifier
      }) {
        if (count !== Infinity && ticks == null) {
          this.ticks();
        }
        specifier != null ? specifier : specifier = this.base === 10 ? ".0e" : ",";
        return isString(specifier) ? format(specifier) : specifier;
      }
      static getBaseLogMethod(base) {
        switch (base) {
          case 10:
            return Math.log10;
          case Math.E:
            return Math.log;
          case 2:
            return Math.log2;
          default:
            const logBase = Math.log(base);
            return (x) => Math.log(x) / logBase;
        }
      }
      static getBasePowerMethod(base) {
        switch (base) {
          case 10:
            return (x) => x >= 0 ? __pow(10, x) : 1 / __pow(10, -x);
          case Math.E:
            return Math.exp;
          default:
            return (x) => __pow(base, x);
        }
      }
    };
    __decorateClass([
      Invalidating
    ], _LogScale.prototype, "base", 2);
    LogScale = _LogScale;
  }
});

// packages/ag-charts-community/src/scene/selection.ts
var Selection;
var init_selection = __esm({
  "packages/ag-charts-community/src/scene/selection.ts"() {
    "use strict";
    init_debug();
    init_node();
    Selection = class _Selection {
      constructor(parentNode, classOrFactory, autoCleanup = true) {
        this.parentNode = parentNode;
        this.autoCleanup = autoCleanup;
        this.garbageBin = /* @__PURE__ */ new Set();
        this._nodesMap = /* @__PURE__ */ new Map();
        this._nodes = [];
        this.data = [];
        this.debug = Debug.create(true, "scene", "scene:selections");
        this.nodeFactory = Object.prototype.isPrototypeOf.call(Node, classOrFactory) ? () => new classOrFactory() : classOrFactory;
      }
      static select(parent, classOrFactory, garbageCollection = true) {
        return new _Selection(parent, classOrFactory, garbageCollection);
      }
      static selectAll(parent, predicate) {
        const results = [];
        const traverse = (node) => {
          if (predicate(node)) {
            results.push(node);
          }
          node.children.forEach(traverse);
        };
        traverse(parent);
        return results;
      }
      static selectByClass(node, Class, ...ExtraClasses) {
        return _Selection.selectAll(node, (n) => {
          return n instanceof Class || ExtraClasses.some((C) => n instanceof C);
        });
      }
      static selectByTag(node, tag) {
        return _Selection.selectAll(node, (n) => n.tag === tag);
      }
      createNode(datum, initializer, idx) {
        const node = this.nodeFactory(datum);
        node.datum = datum;
        initializer == null ? void 0 : initializer(node);
        if (idx == null) {
          this._nodes.push(node);
        } else {
          this._nodes.splice(idx, 0, node);
        }
        this.parentNode.appendChild(node);
        return node;
      }
      /**
       * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to
       * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end
       * of the array.
       */
      update(data, initializer, getDatumId) {
        if (this.garbageBin.size > 0) {
          this.debug(`Selection - update() called with pending garbage: ${data}`);
        }
        if (getDatumId) {
          const dataMap = new Map(
            data.map((datum, idx) => [getDatumId(datum), [datum, idx]])
          );
          for (const [node, datumId] of this._nodesMap.entries()) {
            if (dataMap.has(datumId)) {
              const [newDatum] = dataMap.get(datumId);
              node.datum = newDatum;
              this.garbageBin.delete(node);
              dataMap.delete(datumId);
            } else {
              this.garbageBin.add(node);
            }
          }
          for (const [datumId, [datum, idx]] of dataMap.entries()) {
            this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);
          }
        } else {
          const maxLength = Math.max(data.length, this.data.length);
          for (let i = 0; i < maxLength; i++) {
            if (i >= data.length) {
              this.garbageBin.add(this._nodes[i]);
            } else if (i >= this._nodes.length) {
              this.createNode(data[i], initializer);
            } else {
              this._nodes[i].datum = data[i];
              this.garbageBin.delete(this._nodes[i]);
            }
          }
        }
        this.data = data.slice();
        if (this.autoCleanup) {
          this.cleanup();
        }
        return this;
      }
      cleanup() {
        if (this.garbageBin.size === 0) {
          return this;
        }
        this._nodes = this._nodes.filter((node) => {
          if (this.garbageBin.has(node)) {
            this._nodesMap.delete(node);
            this.garbageBin.delete(node);
            this.parentNode.removeChild(node);
            return false;
          }
          return true;
        });
        return this;
      }
      clear() {
        this.update([]);
        return this;
      }
      isGarbage(node) {
        return this.garbageBin.has(node);
      }
      hasGarbage() {
        return this.garbageBin.size > 0;
      }
      each(iterate2) {
        for (const entry of this._nodes.entries()) {
          iterate2(entry[1], entry[1].datum, entry[0]);
        }
        return this;
      }
      *[Symbol.iterator]() {
        for (let index = 0; index < this._nodes.length; index++) {
          const node = this._nodes[index];
          const datum = this._nodes[index].datum;
          yield { node, datum, index };
        }
      }
      select(predicate) {
        return _Selection.selectAll(this.parentNode, predicate);
      }
      selectByClass(Class) {
        return _Selection.selectByClass(this.parentNode, Class);
      }
      selectByTag(tag) {
        return _Selection.selectByTag(this.parentNode, tag);
      }
      nodes() {
        return this._nodes;
      }
    };
  }
});

// packages/ag-charts-community/src/util/distance.ts
function pointsDistanceSquared(x1, y1, x2, y2) {
  const dx2 = x1 - x2;
  const dy2 = y1 - y2;
  return dx2 * dx2 + dy2 * dy2;
}
function lineDistanceSquared(x, y, x1, y1, x2, y2, best) {
  if (x1 === x2 && y1 === y2) {
    return Math.min(best, pointsDistanceSquared(x, y, x1, y1));
  }
  const dx2 = x2 - x1;
  const dy2 = y2 - y1;
  const t = Math.max(0, Math.min(1, ((x - x1) * dx2 + (y - y1) * dy2) / (dx2 * dx2 + dy2 * dy2)));
  const ix = x1 + t * dx2;
  const iy = y1 + t * dy2;
  return Math.min(best, pointsDistanceSquared(x, y, ix, iy));
}
function arcDistanceSquared(x, y, cx, cy, radius, startAngle, endAngle, counterClockwise, best) {
  if (counterClockwise) {
    [endAngle, startAngle] = [startAngle, endAngle];
  }
  const angle = Math.atan2(y - cy, x - cx);
  if (!isBetweenAngles(angle, startAngle, endAngle)) {
    const startX = cx + Math.cos(startAngle) * radius;
    const startY = cy + Math.sin(startAngle) * radius;
    const endX = cx + Math.cos(startAngle) * radius;
    const endY = cy + Math.sin(startAngle) * radius;
    return Math.min(best, pointsDistanceSquared(x, y, startX, startY), pointsDistanceSquared(x, y, endX, endY));
  }
  const distToArc = radius - Math.sqrt(pointsDistanceSquared(x, y, cx, cy));
  return Math.min(best, distToArc * distToArc);
}
var init_distance = __esm({
  "packages/ag-charts-community/src/util/distance.ts"() {
    "use strict";
    init_angle();
  }
});

// packages/ag-charts-community/src/scene/shape/line.ts
var Line;
var init_line = __esm({
  "packages/ag-charts-community/src/scene/shape/line.ts"() {
    "use strict";
    init_distance();
    init_bbox();
    init_node();
    init_shape();
    Line = class extends Shape {
      constructor(opts = {}) {
        super(opts);
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 0;
        this.y2 = 0;
        this.restoreOwnStyles();
      }
      set x(value) {
        this.x1 = value;
        this.x2 = value;
      }
      set y(value) {
        this.y1 = value;
        this.y2 = value;
      }
      computeBBox() {
        return new BBox(
          Math.min(this.x1, this.x2),
          Math.min(this.y1, this.y2),
          Math.abs(this.x2 - this.x1),
          Math.abs(this.y2 - this.y1)
        );
      }
      isPointInPath(px, py) {
        if (this.x1 === this.x2 || this.y1 === this.y2) {
          const { x, y } = this.transformPoint(px, py);
          return this.computeBBox().grow(this.strokeWidth / 2).containsPoint(x, y);
        }
        return false;
      }
      distanceSquared(px, py) {
        const { x1, y1, x2, y2 } = this;
        return lineDistanceSquared(px, py, x1, y1, x2, y2, Infinity);
      }
      render(renderCtx) {
        var _a2;
        const { ctx, forceRender, stats, devicePixelRatio } = renderCtx;
        if (this.dirty === 0 /* NONE */ && !forceRender) {
          if (stats)
            stats.nodesSkipped += this.nodeCount.count;
          return;
        }
        this.computeTransformMatrix();
        this.matrix.toContext(ctx);
        let { x1, y1, x2, y2 } = this;
        if (x1 === x2) {
          const { strokeWidth } = this;
          const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
          x1 = x;
          x2 = x;
        } else if (y1 === y2) {
          const { strokeWidth } = this;
          const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);
          y1 = y;
          y2 = y;
        }
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        this.fillStroke(ctx);
        (_a2 = this.fillShadow) == null ? void 0 : _a2.markClean();
        super.render(renderCtx);
      }
    };
    Line.className = "Line";
    Line.defaultStyles = Object.assign({}, Shape.defaultStyles, {
      fill: void 0,
      strokeWidth: 1
    });
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], Line.prototype, "x1", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], Line.prototype, "y1", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], Line.prototype, "x2", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], Line.prototype, "y2", 2);
  }
});

// packages/ag-charts-community/src/scene/util/labelPlacement.ts
function circleRectOverlap(c, unitCenter, x, y, w, h) {
  if (c.size === 0)
    return false;
  let cx = c.x;
  let cy = c.y;
  if (unitCenter != null) {
    cx -= (unitCenter.x - 0.5) * c.size;
    cy -= (unitCenter.y - 0.5) * c.size;
  }
  let edgeX = cx;
  if (cx < x) {
    edgeX = x;
  } else if (cx > x + w) {
    edgeX = x + w;
  }
  let edgeY = cy;
  if (cy < y) {
    edgeY = y;
  } else if (cy > y + h) {
    edgeY = y + h;
  }
  const dx2 = cx - edgeX;
  const dy2 = cy - edgeY;
  const d = Math.sqrt(dx2 * dx2 + dy2 * dy2);
  return d <= c.size * 0.5;
}
function rectRectOverlap(r1, x2, y2, w2, h2) {
  const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;
  const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;
  return xOverlap && yOverlap;
}
function rectContainsRect(r1, r2x, r2y, r2w, r2h) {
  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;
}
function isPointLabelDatum(x) {
  return x != null && typeof x.point === "object" && typeof x.label === "object";
}
function placeLabels(data, bounds, padding = 5) {
  var _a2, _b;
  const result = [];
  data = data.map((d) => d.slice().sort((a, b) => b.point.size - a.point.size));
  for (let j = 0; j < data.length; j++) {
    const labels = result[j] = [];
    const datum = data[j];
    if (!((datum == null ? void 0 : datum.length) && datum[0].label)) {
      continue;
    }
    for (let i = 0, ln = datum.length; i < ln; i++) {
      const d = datum[i];
      const { point, label, marker } = d;
      const { text, width, height } = label;
      const r = point.size * 0.5;
      let dx2 = 0;
      let dy2 = 0;
      if (r > 0 && d.placement != null) {
        const placement = labelPlacements[d.placement];
        dx2 = (width * 0.5 + r + padding) * placement.x;
        dy2 = (height * 0.5 + r + padding) * placement.y;
      }
      const x = point.x - width * 0.5 + dx2 - (((_a2 = marker == null ? void 0 : marker.center.x) != null ? _a2 : 0.5) - 0.5) * point.size;
      const y = point.y - height * 0.5 + dy2 - (((_b = marker == null ? void 0 : marker.center.y) != null ? _b : 0.5) - 0.5) * point.size;
      const withinBounds = !bounds || rectContainsRect(bounds, x, y, width, height);
      if (!withinBounds) {
        continue;
      }
      const overlapPoints = data.some(
        (dataDatums) => dataDatums.some(
          (dataDatum) => {
            var _a3;
            return circleRectOverlap(dataDatum.point, (_a3 = dataDatum.marker) == null ? void 0 : _a3.center, x, y, width, height);
          }
        )
      );
      if (overlapPoints) {
        continue;
      }
      const overlapLabels = result.some((l2) => l2.some((l3) => rectRectOverlap(l3, x, y, width, height)));
      if (overlapLabels) {
        continue;
      }
      labels.push({
        index: i,
        text,
        x,
        y,
        width,
        height,
        datum: d
      });
    }
  }
  return result;
}
function axisLabelsOverlap(data, padding) {
  const result = [];
  for (let i = 0; i < data.length; i++) {
    const datum = data[i];
    const {
      point: { x, y },
      label: { text }
    } = datum;
    let {
      label: { width, height }
    } = datum;
    width += padding != null ? padding : 0;
    height += padding != null ? padding : 0;
    const overlapLabels = result.some((l) => {
      return rectRectOverlap(l, x, y, width, height);
    });
    if (overlapLabels) {
      return true;
    }
    result.push({
      index: i,
      text,
      x,
      y,
      width,
      height,
      datum
    });
  }
  return false;
}
var labelPlacements;
var init_labelPlacement = __esm({
  "packages/ag-charts-community/src/scene/util/labelPlacement.ts"() {
    "use strict";
    labelPlacements = {
      top: { x: 0, y: -1 },
      bottom: { x: 0, y: 1 },
      left: { x: -1, y: 0 },
      right: { x: 1, y: 0 }
    };
  }
});

// packages/ag-charts-community/src/util/equal.ts
function areArrayItemsStrictlyEqual(arrA, arrB) {
  return arrA.length === arrB.length && arrA.every((a, i) => {
    const b = arrB[i];
    if (Array.isArray(a) && Array.isArray(b)) {
      return areArrayItemsStrictlyEqual(a, b);
    }
    return a === b;
  });
}
function areArrayNumbersEqual(arrA, arrB) {
  return arrA.length === arrB.length && arrA.every((item, i) => Number(item) === Number(arrB[i]));
}
var init_equal = __esm({
  "packages/ag-charts-community/src/util/equal.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/util/proxy.ts
function ProxyProperty(proxyPath) {
  const pathArray = isArray(proxyPath) ? proxyPath : proxyPath.split(".");
  if (pathArray.length === 1) {
    const [property] = pathArray;
    return addTransformToInstanceProperty(
      (target, _, value) => target[property] = value,
      (target) => target[property]
    );
  }
  return addTransformToInstanceProperty(
    (target, _, value) => setPath(target, pathArray, value),
    (target) => getPath(target, pathArray)
  );
}
function ProxyOnWrite(proxyProperty) {
  return addTransformToInstanceProperty((target, _, value) => target[proxyProperty] = value);
}
function ProxyPropertyOnWrite(childName, childProperty) {
  return addTransformToInstanceProperty((target, key, value) => target[childName][childProperty != null ? childProperty : key] = value);
}
function ActionOnSet(opts) {
  const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;
  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {
    if (newValue !== oldValue) {
      if (oldValue !== void 0) {
        oldValueFn == null ? void 0 : oldValueFn.call(target, oldValue);
      }
      if (newValue !== void 0) {
        newValueFn == null ? void 0 : newValueFn.call(target, newValue);
      }
      changeValueFn == null ? void 0 : changeValueFn.call(target, newValue, oldValue);
    }
    return newValue;
  });
}
function ObserveChanges(observerFn) {
  return addObserverToInstanceProperty(observerFn);
}
var init_proxy = __esm({
  "packages/ag-charts-community/src/util/proxy.ts"() {
    "use strict";
    init_decorator();
    init_object();
    init_type_guards();
  }
});

// packages/ag-charts-community/src/util/attributeUtil.ts
function setAttribute(e, qualifiedName, value) {
  if (value === void 0 || value === "") {
    e == null ? void 0 : e.removeAttribute(qualifiedName);
  } else {
    e == null ? void 0 : e.setAttribute(qualifiedName, value.toString());
  }
}
var init_attributeUtil = __esm({
  "packages/ag-charts-community/src/util/attributeUtil.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/util/placement.ts
function calculatePlacement(naturalWidth, naturalHeight, containerWidth, containerHeight, bounds) {
  let { top, right, bottom, left, width, height } = bounds;
  if (left != null) {
    if (width != null) {
      right = containerWidth - left + width;
    } else if (right != null) {
      width = containerWidth - left - right;
    }
  } else if (right != null && width != null) {
    left = containerWidth - right - width;
  }
  if (top != null) {
    if (height != null) {
      bottom = containerHeight - top - height;
    } else if (bottom != null) {
      height = containerHeight - bottom - top;
    }
  } else if (bottom != null && height != null) {
    top = containerHeight - bottom - height;
  }
  if (width == null) {
    if (height == null) {
      width = naturalWidth;
      height = naturalHeight;
    } else {
      width = Math.ceil(naturalWidth * height / naturalHeight);
    }
  } else if (height == null) {
    height = Math.ceil(naturalHeight * width / naturalWidth);
  }
  if (left == null) {
    if (right == null) {
      left = Math.floor((containerWidth - width) / 2);
    } else {
      left = containerWidth - right - width;
    }
  }
  if (top == null) {
    if (bottom == null) {
      top = Math.floor((containerHeight - height) / 2);
    } else {
      top = containerHeight - height - bottom;
    }
  }
  return { x: left, y: top, width, height };
}
var init_placement = __esm({
  "packages/ag-charts-community/src/util/placement.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/tooltip/tooltip.ts
function toAccessibleText(inputHtml) {
  const lineConverter = (_match, offset4, str) => {
    if (offset4 === 0 || str[offset4 - 1] !== ".") {
      return ". ";
    }
    return " ";
  };
  return inputHtml.replace(/<br\s*\/?>/g, lineConverter).replace(/<\/p\s+>/g, lineConverter).replace(/<\/li\s*\/>/g, lineConverter).replace(/<[^>]+>/g, "");
}
function toTooltipHtml(input, defaults) {
  var _a2, _b, _c;
  if (typeof input === "string") {
    return { html: input, ariaLabel: input };
  }
  const {
    content = (_a2 = defaults == null ? void 0 : defaults.content) != null ? _a2 : "",
    title = defaults == null ? void 0 : defaults.title,
    color = (_b = defaults == null ? void 0 : defaults.color) != null ? _b : "white",
    backgroundColor = (_c = defaults == null ? void 0 : defaults.backgroundColor) != null ? _c : "#888"
  } = input;
  const titleHtml = title ? `<div class="${DEFAULT_TOOLTIP_CLASS}-title"
        style="color: ${color}; background-color: ${backgroundColor}">${title}</div>` : "";
  const titleAria = title ? `${title}: ` : "";
  const contentHtml = content ? `<div class="${DEFAULT_TOOLTIP_CLASS}-content">${content}</div>` : "";
  return {
    html: `${titleHtml}${contentHtml}`,
    ariaLabel: toAccessibleText(`${titleAria}${content}`)
  };
}
var DEFAULT_TOOLTIP_CLASS, DEFAULT_TOOLTIP_DARK_CLASS, EMPTY_TOOLTIP_CONTENT, TooltipPosition, Tooltip;
var init_tooltip = __esm({
  "packages/ag-charts-community/src/chart/tooltip/tooltip.ts"() {
    "use strict";
    init_attributeUtil();
    init_dom();
    init_number();
    init_placement();
    init_properties();
    init_proxy();
    init_validation();
    DEFAULT_TOOLTIP_CLASS = "ag-chart-tooltip";
    DEFAULT_TOOLTIP_DARK_CLASS = "ag-chart-dark-tooltip";
    EMPTY_TOOLTIP_CONTENT = { html: "", ariaLabel: "" };
    TooltipPosition = class extends BaseProperties {
      constructor() {
        super(...arguments);
        /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */
        this.type = "pointer";
        /** The horizontal offset in pixels for the position of the tooltip. */
        this.xOffset = 0;
        /** The vertical offset in pixels for the position of the tooltip. */
        this.yOffset = 0;
      }
    };
    __decorateClass([
      Validate(
        UNION(
          [
            "pointer",
            "node",
            "top",
            "right",
            "bottom",
            "left",
            "top-left",
            "top-right",
            "bottom-right",
            "bottom-left"
          ],
          "a position type"
        )
      )
    ], TooltipPosition.prototype, "type", 2);
    __decorateClass([
      Validate(NUMBER)
    ], TooltipPosition.prototype, "xOffset", 2);
    __decorateClass([
      Validate(NUMBER)
    ], TooltipPosition.prototype, "yOffset", 2);
    Tooltip = class extends BaseProperties {
      constructor() {
        super();
        this.enabled = true;
        this.delay = 0;
        this.range = "nearest";
        this.wrapping = "hyphenate";
        this.position = new TooltipPosition();
        this.darkTheme = false;
        this.enableInteraction = false;
        this.lastVisibilityChange = Date.now();
        this.wrapTypes = ["always", "hyphenate", "on-space", "never"];
        this.showTimeout = 0;
        this._showArrow = true;
        this.element = createElement("div", DEFAULT_TOOLTIP_CLASS);
        setAttribute(this.element, "aria-hidden", true);
        this.root = getDocument("body");
        this.root.appendChild(this.element);
      }
      destroy() {
        this.element.remove();
      }
      isVisible() {
        return !this.element.classList.contains(DEFAULT_TOOLTIP_CLASS + "-hidden");
      }
      /**
       * Shows tooltip at the given event's coordinates.
       * If the `html` parameter is missing, moves the existing tooltip to the new position.
       */
      show(canvasRect, meta, content, instantly = false) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
        const { element: element2 } = this;
        if (content != null) {
          element2.innerHTML = content.html;
        } else if (!element2.innerHTML) {
          this.toggle(false);
          return;
        }
        const positionType = (_b = (_a2 = meta.position) == null ? void 0 : _a2.type) != null ? _b : this.position.type;
        const xOffset = (_d = (_c = meta.position) == null ? void 0 : _c.xOffset) != null ? _d : 0;
        const yOffset = (_f = (_e = meta.position) == null ? void 0 : _e.yOffset) != null ? _f : 0;
        const tooltipBounds = this.getTooltipBounds({ positionType, meta, yOffset, xOffset, canvasRect });
        const windowBounds = this.getWindowSize();
        const position = calculatePlacement(
          element2.clientWidth,
          element2.clientHeight,
          canvasRect.width,
          canvasRect.height,
          tooltipBounds
        );
        position.x += canvasRect.x;
        position.y += canvasRect.y;
        const left = clamp(0, position.x, windowBounds.width - element2.clientWidth - 1);
        const top = clamp(0, position.y, windowBounds.height - element2.clientHeight);
        const constrained = left !== position.x || top !== position.y;
        const defaultShowArrow = (positionType === "node" || positionType === "pointer") && !constrained && !xOffset && !yOffset;
        const showArrow = (_h = (_g = meta.showArrow) != null ? _g : this.showArrow) != null ? _h : defaultShowArrow;
        this.updateShowArrow(showArrow);
        element2.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;
        this.enableInteraction = (_i = meta.enableInteraction) != null ? _i : false;
        if (this.delay > 0 && !instantly) {
          this.toggle(false);
          this.showTimeout = setTimeout(() => {
            this.toggle(true);
          }, this.delay);
        } else {
          this.toggle(true);
        }
      }
      getWindowSize() {
        const { innerWidth, innerHeight } = getWindow();
        return { width: innerWidth, height: innerHeight };
      }
      toggle(visible) {
        const { classList } = this.element;
        const toggleClass = (name, include) => classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-${name}`, include);
        const wasVisible = this.isVisible();
        let timeSinceLastVisibilityChangeMs = Infinity;
        if (!visible) {
          clearTimeout(this.showTimeout);
        }
        if (wasVisible !== visible) {
          const now = Date.now();
          timeSinceLastVisibilityChangeMs = now - this.lastVisibilityChange;
          this.lastVisibilityChange = now;
        }
        const animatedMoveThresholdMs = 100;
        const thrashingThresholdMs = 5;
        const noAnimation = !wasVisible && visible && timeSinceLastVisibilityChangeMs > animatedMoveThresholdMs;
        if (timeSinceLastVisibilityChangeMs > thrashingThresholdMs) {
          toggleClass("no-animation", noAnimation);
        }
        toggleClass("no-interaction", !this.enableInteraction);
        toggleClass("hidden", !visible);
        toggleClass("arrow", this._showArrow);
        classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);
        for (const wrapType of this.wrapTypes) {
          classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-wrap-${wrapType}`, wrapType === this.wrapping);
        }
      }
      pointerLeftOntoTooltip(event) {
        var _a2;
        if (!this.enableInteraction)
          return false;
        const classList = (_a2 = event.sourceEvent.relatedTarget) == null ? void 0 : _a2.classList;
        const classes = ["", "-title", "-content"];
        const classListContains = Boolean(classes.filter((c) => classList == null ? void 0 : classList.contains(`${DEFAULT_TOOLTIP_CLASS}${c}`)));
        return classList !== void 0 && classListContains;
      }
      updateShowArrow(show) {
        this._showArrow = show;
      }
      getTooltipBounds({
        positionType,
        meta,
        yOffset,
        xOffset,
        canvasRect
      }) {
        const { clientWidth: tooltipWidth, clientHeight: tooltipHeight } = this.element;
        const bounds = { width: tooltipWidth, height: tooltipHeight };
        switch (positionType) {
          case "node":
          case "pointer": {
            bounds.top = meta.offsetY + yOffset - tooltipHeight - 8;
            bounds.left = meta.offsetX + xOffset - tooltipWidth / 2;
            return bounds;
          }
          case "top": {
            bounds.top = yOffset;
            bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;
            return bounds;
          }
          case "right": {
            bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;
            bounds.left = canvasRect.width - tooltipWidth / 2 + xOffset;
            return bounds;
          }
          case "left": {
            bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;
            bounds.left = xOffset;
            return bounds;
          }
          case "bottom": {
            bounds.top = canvasRect.height - tooltipHeight + yOffset;
            bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;
            return bounds;
          }
          case "top-left": {
            bounds.top = yOffset;
            bounds.left = xOffset;
            return bounds;
          }
          case "top-right": {
            bounds.top = yOffset;
            bounds.left = canvasRect.width - tooltipWidth + xOffset;
            return bounds;
          }
          case "bottom-right": {
            bounds.top = canvasRect.height - tooltipHeight + yOffset;
            bounds.left = canvasRect.width - tooltipWidth + xOffset;
            return bounds;
          }
          case "bottom-left": {
            bounds.top = canvasRect.height - tooltipHeight + yOffset;
            bounds.left = xOffset;
            return bounds;
          }
        }
      }
    };
    __decorateClass([
      Validate(BOOLEAN)
    ], Tooltip.prototype, "enabled", 2);
    __decorateClass([
      Validate(BOOLEAN, { optional: true })
    ], Tooltip.prototype, "showArrow", 2);
    __decorateClass([
      ObserveChanges((target, newValue, oldValue) => {
        if (newValue) {
          target.element.classList.add(newValue);
        }
        if (oldValue) {
          target.element.classList.remove(oldValue);
        }
      }),
      Validate(STRING, { optional: true })
    ], Tooltip.prototype, "class", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], Tooltip.prototype, "delay", 2);
    __decorateClass([
      Validate(INTERACTION_RANGE)
    ], Tooltip.prototype, "range", 2);
    __decorateClass([
      Validate(TEXT_WRAP)
    ], Tooltip.prototype, "wrapping", 2);
    __decorateClass([
      Validate(OBJECT)
    ], Tooltip.prototype, "position", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], Tooltip.prototype, "darkTheme", 2);
  }
});

// packages/ag-charts-community/src/chart/caption.ts
var Caption;
var init_caption = __esm({
  "packages/ag-charts-community/src/chart/caption.ts"() {
    "use strict";
    init_node();
    init_text();
    init_function();
    init_id();
    init_properties();
    init_proxy();
    init_validation();
    init_tooltip();
    Caption = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.id = createId(this);
        this.node = new Text({ zIndex: 1 }).setProperties({
          textAlign: "center",
          pointerEvents: 1 /* None */
        });
        this.enabled = false;
        this.textAlign = "center";
        this.fontSize = 10;
        this.fontFamily = "sans-serif";
        this.wrapping = "always";
        this.truncated = false;
      }
      getOrAddRegion(moduleCtx, regionName) {
        if (regionName === "root") {
          return moduleCtx.regionManager.getRegion("root");
        } else {
          return moduleCtx.regionManager.addRegionFromProperties({
            name: regionName,
            bboxproviders: [this.node],
            canInteraction: () => this.enabled && this.node.visible
          });
        }
      }
      registerInteraction(moduleCtx, regionName) {
        const region = this.getOrAddRegion(moduleCtx, regionName);
        const destroyFns = [
          region.addListener("hover", (event) => this.handleMouseMove(moduleCtx, event)),
          region.addListener("leave", (event) => this.handleMouseLeave(moduleCtx, event))
        ];
        return joinFunctions(...destroyFns);
      }
      computeTextWrap(containerWidth, containerHeight) {
        var _a2, _b;
        const { text, wrapping } = this;
        const maxWidth = Math.min((_a2 = this.maxWidth) != null ? _a2 : Infinity, containerWidth);
        const maxHeight = (_b = this.maxHeight) != null ? _b : containerHeight;
        if (!isFinite(maxWidth) && !isFinite(maxHeight)) {
          this.node.text = text;
          return;
        }
        const { text: wrappedText, truncated } = Text.wrap(text != null ? text : "", maxWidth, maxHeight, this, wrapping);
        this.node.text = wrappedText;
        this.truncated = truncated;
      }
      updateTooltip(moduleCtx, event) {
        if (event !== void 0 && this.enabled && this.node.visible && this.truncated) {
          const { offsetX, offsetY } = event;
          moduleCtx.tooltipManager.updateTooltip(
            this.id,
            { offsetX, offsetY, lastPointerEvent: event, showArrow: false },
            toTooltipHtml({ content: this.text })
          );
          return true;
        }
        return false;
      }
      handleMouseMove(moduleCtx, event) {
        if (this.updateTooltip(moduleCtx, event)) {
          event.consume();
        }
      }
      handleMouseLeave(moduleCtx, _event) {
        moduleCtx.tooltipManager.removeTooltip(this.id);
      }
    };
    Caption.SMALL_PADDING = 10;
    Caption.LARGE_PADDING = 20;
    __decorateClass([
      Validate(BOOLEAN)
    ], Caption.prototype, "enabled", 2);
    __decorateClass([
      Validate(STRING, { optional: true }),
      ProxyPropertyOnWrite("node")
    ], Caption.prototype, "text", 2);
    __decorateClass([
      Validate(TEXT_ALIGN, { optional: true }),
      ProxyPropertyOnWrite("node")
    ], Caption.prototype, "textAlign", 2);
    __decorateClass([
      Validate(FONT_STYLE, { optional: true }),
      ProxyPropertyOnWrite("node")
    ], Caption.prototype, "fontStyle", 2);
    __decorateClass([
      Validate(FONT_WEIGHT2, { optional: true }),
      ProxyPropertyOnWrite("node")
    ], Caption.prototype, "fontWeight", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER),
      ProxyPropertyOnWrite("node")
    ], Caption.prototype, "fontSize", 2);
    __decorateClass([
      Validate(STRING),
      ProxyPropertyOnWrite("node")
    ], Caption.prototype, "fontFamily", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true }),
      ProxyPropertyOnWrite("node", "fill")
    ], Caption.prototype, "color", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], Caption.prototype, "spacing", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], Caption.prototype, "lineHeight", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], Caption.prototype, "maxWidth", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], Caption.prototype, "maxHeight", 2);
    __decorateClass([
      Validate(TEXT_WRAP)
    ], Caption.prototype, "wrapping", 2);
  }
});

// packages/ag-charts-community/src/chart/axis/axisGridLine.ts
var GRID_STYLE_KEYS, GRID_STYLE, AxisGridLine;
var init_axisGridLine = __esm({
  "packages/ag-charts-community/src/chart/axis/axisGridLine.ts"() {
    "use strict";
    init_type_guards();
    init_validation();
    GRID_STYLE_KEYS = ["stroke", "lineDash"];
    GRID_STYLE = ARRAY_OF(
      (value) => isObject(value) && Object.keys(value).every((key) => GRID_STYLE_KEYS.includes(key)),
      "objects with gridline style properties such as 'stroke' or 'lineDash'"
    );
    AxisGridLine = class {
      constructor() {
        this.enabled = true;
        this.width = 1;
        this.style = [
          {
            stroke: void 0,
            lineDash: []
          }
        ];
      }
    };
    __decorateClass([
      Validate(BOOLEAN)
    ], AxisGridLine.prototype, "enabled", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], AxisGridLine.prototype, "width", 2);
    __decorateClass([
      Validate(GRID_STYLE)
    ], AxisGridLine.prototype, "style", 2);
  }
});

// packages/ag-charts-community/src/chart/axis/axisLabel.ts
var AxisLabel;
var init_axisLabel = __esm({
  "packages/ag-charts-community/src/chart/axis/axisLabel.ts"() {
    "use strict";
    init_default();
    init_properties();
    init_validation();
    AxisLabel = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.enabled = true;
        this.autoWrap = false;
        this.fontSize = 12;
        this.fontFamily = "Verdana, sans-serif";
        this.padding = 5;
        this.minSpacing = NaN;
        this.color = "rgba(87, 87, 87, 1)";
        this.avoidCollisions = true;
        this.mirrored = false;
        this.parallel = false;
      }
      /**
       * The side of the axis line to position the labels on.
       * -1 = left (default)
       * 1 = right
       */
      getSideFlag() {
        return this.mirrored ? 1 : -1;
      }
    };
    __decorateClass([
      Validate(BOOLEAN)
    ], AxisLabel.prototype, "enabled", 2);
    __decorateClass([
      Validate(BOOLEAN, { optional: true })
    ], AxisLabel.prototype, "autoWrap", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], AxisLabel.prototype, "maxWidth", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], AxisLabel.prototype, "maxHeight", 2);
    __decorateClass([
      Validate(FONT_STYLE, { optional: true })
    ], AxisLabel.prototype, "fontStyle", 2);
    __decorateClass([
      Validate(FONT_WEIGHT2, { optional: true })
    ], AxisLabel.prototype, "fontWeight", 2);
    __decorateClass([
      Validate(NUMBER.restrict({ min: 1 }))
    ], AxisLabel.prototype, "fontSize", 2);
    __decorateClass([
      Validate(STRING)
    ], AxisLabel.prototype, "fontFamily", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], AxisLabel.prototype, "padding", 2);
    __decorateClass([
      Validate(NUMBER_OR_NAN),
      Default(NaN)
    ], AxisLabel.prototype, "minSpacing", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], AxisLabel.prototype, "color", 2);
    __decorateClass([
      Validate(DEGREE, { optional: true })
    ], AxisLabel.prototype, "rotation", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], AxisLabel.prototype, "avoidCollisions", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], AxisLabel.prototype, "mirrored", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], AxisLabel.prototype, "parallel", 2);
    __decorateClass([
      Validate(FUNCTION, { optional: true })
    ], AxisLabel.prototype, "formatter", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], AxisLabel.prototype, "format", 2);
  }
});

// packages/ag-charts-community/src/chart/axis/axisLine.ts
var AxisLine;
var init_axisLine = __esm({
  "packages/ag-charts-community/src/chart/axis/axisLine.ts"() {
    "use strict";
    init_validation();
    AxisLine = class {
      constructor() {
        this.enabled = true;
        this.width = 1;
        this.color = void 0;
      }
    };
    __decorateClass([
      Validate(BOOLEAN)
    ], AxisLine.prototype, "enabled", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], AxisLine.prototype, "width", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], AxisLine.prototype, "color", 2);
  }
});

// packages/ag-charts-community/src/chart/axis/axisTitle.ts
var AxisTitle;
var init_axisTitle = __esm({
  "packages/ag-charts-community/src/chart/axis/axisTitle.ts"() {
    "use strict";
    init_properties();
    init_validation();
    init_caption();
    AxisTitle = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.enabled = false;
        this.spacing = Caption.SMALL_PADDING;
        this.fontSize = 10;
        this.fontFamily = "sans-serif";
        this.wrapping = "always";
      }
    };
    __decorateClass([
      Validate(BOOLEAN)
    ], AxisTitle.prototype, "enabled", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], AxisTitle.prototype, "text", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], AxisTitle.prototype, "spacing", 2);
    __decorateClass([
      Validate(FONT_STYLE, { optional: true })
    ], AxisTitle.prototype, "fontStyle", 2);
    __decorateClass([
      Validate(FONT_WEIGHT2, { optional: true })
    ], AxisTitle.prototype, "fontWeight", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], AxisTitle.prototype, "fontSize", 2);
    __decorateClass([
      Validate(STRING)
    ], AxisTitle.prototype, "fontFamily", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], AxisTitle.prototype, "color", 2);
    __decorateClass([
      Validate(TEXT_WRAP)
    ], AxisTitle.prototype, "wrapping", 2);
    __decorateClass([
      Validate(FUNCTION, { optional: true })
    ], AxisTitle.prototype, "formatter", 2);
  }
});

// packages/ag-charts-community/src/chart/axis/axisUtil.ts
function prepareAxisAnimationContext(axis) {
  const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);
  const min = Math.floor(requestedRangeMin);
  const max = Math.ceil(requestedRangeMax);
  return { min, max, visible: min !== max };
}
function normaliseEndRotation(start, end) {
  const directDistance = Math.abs(end - start);
  if (directDistance < halfCircle)
    return end;
  if (start > end)
    return end + fullCircle;
  return end - fullCircle;
}
function prepareAxisAnimationFunctions(ctx) {
  const outOfBounds = (y, range4) => {
    const [min = ctx.min, max = ctx.max] = findMinMax(range4 != null ? range4 : []);
    return y < min || y > max;
  };
  const tick = {
    fromFn(node, datum, status) {
      let y = node.y1 + node.translationY;
      let opacity = node.opacity;
      if (status === "added" || outOfBounds(node.datum.translationY, node.datum.range)) {
        y = datum.translationY;
        opacity = 0;
      }
      return { y: 0, translationY: y, opacity, phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] };
    },
    toFn(_node, datum, status) {
      const y = datum.translationY;
      let opacity = 1;
      if (status === "removed") {
        opacity = 0;
      }
      return {
        y: 0,
        translationY: y,
        opacity,
        finish: {
          // Set explicit y after animation so it's pixel aligned
          y,
          translationY: 0
        }
      };
    },
    intermediateFn(node, _datum, _status) {
      return { visible: !outOfBounds(node.y) };
    }
  };
  const label = {
    fromFn(node, newDatum, status) {
      var _a2;
      const datum = (_a2 = node.previousDatum) != null ? _a2 : newDatum;
      const x = datum.x;
      const y = datum.y;
      const rotationCenterX = datum.rotationCenterX;
      let translationY = Math.round(node.translationY);
      let rotation = datum.rotation;
      let opacity = node.opacity;
      if (status === "removed" || outOfBounds(datum.y, datum.range)) {
        rotation = newDatum.rotation;
      } else if (status === "added" || outOfBounds(node.datum.y, node.datum.range)) {
        translationY = Math.round(datum.translationY);
        opacity = 0;
        rotation = newDatum.rotation;
      }
      return {
        x,
        y,
        rotationCenterX,
        translationY,
        rotation,
        opacity,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
      };
    },
    toFn(node, datum, status) {
      var _a2, _b;
      const x = datum.x;
      const y = datum.y;
      const rotationCenterX = datum.rotationCenterX;
      const translationY = Math.round(datum.translationY);
      let rotation = 0;
      let opacity = 1;
      if (status === "added") {
        opacity = 1;
        rotation = datum.rotation;
      } else if (status === "removed") {
        opacity = 0;
        rotation = datum.rotation;
      } else {
        rotation = normaliseEndRotation((_b = (_a2 = node.previousDatum) == null ? void 0 : _a2.rotation) != null ? _b : datum.rotation, datum.rotation);
      }
      return { x, y, rotationCenterX, translationY, rotation, opacity, finish: { rotation: datum.rotation } };
    }
  };
  const line = {
    fromFn(node, datum) {
      var _a2;
      return __spreadProps(__spreadValues({}, (_a2 = node.previousDatum) != null ? _a2 : datum), {
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
      });
    },
    toFn(_node, datum) {
      return __spreadValues({}, datum);
    }
  };
  const group2 = {
    fromFn(node, _datum) {
      const { rotation, translationX, translationY } = node;
      return {
        rotation,
        translationX,
        translationY,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["updated"]
      };
    },
    toFn(_node, datum) {
      const { rotation, translationX, translationY } = datum;
      return {
        rotation,
        translationX,
        translationY
      };
    }
  };
  return { tick, line, label, group: group2 };
}
function resetAxisGroupFn() {
  return (_node, datum) => {
    return {
      rotation: datum.rotation,
      rotationCenterX: datum.rotationCenterX,
      rotationCenterY: datum.rotationCenterY,
      translationX: datum.translationX,
      translationY: datum.translationY
    };
  };
}
function resetAxisSelectionFn(ctx) {
  const { visible: rangeVisible, min, max } = ctx;
  return (_node, datum) => {
    const y = datum.translationY;
    const visible = rangeVisible && y >= min && y <= max;
    return {
      y,
      translationY: 0,
      opacity: 1,
      visible
    };
  };
}
function resetAxisLabelSelectionFn() {
  return (_node, datum) => {
    return {
      x: datum.x,
      y: datum.y,
      translationY: datum.translationY,
      rotation: datum.rotation,
      rotationCenterX: datum.rotationCenterX
    };
  };
}
function resetAxisLineSelectionFn() {
  return (_node, datum) => {
    return __spreadValues({}, datum);
  };
}
var fullCircle, halfCircle;
var init_axisUtil = __esm({
  "packages/ag-charts-community/src/chart/axis/axisUtil.ts"() {
    "use strict";
    init_fromToMotion();
    init_number();
    fullCircle = Math.PI * 2;
    halfCircle = fullCircle / 2;
  }
});

// packages/ag-charts-community/src/chart/axis/axis.ts
var _Axis, Axis;
var init_axis = __esm({
  "packages/ag-charts-community/src/chart/axis/axis.ts"() {
    "use strict";
    init_moduleMap();
    init_fromToMotion();
    init_resetMotion();
    init_states();
    init_continuousScale();
    init_logScale();
    init_ordinalTimeScale();
    init_timeScale();
    init_bbox();
    init_group();
    init_matrix();
    init_selection();
    init_line();
    init_text();
    init_labelPlacement();
    init_angle();
    init_equal();
    init_id();
    init_json();
    init_logger();
    init_number();
    init_proxy();
    init_validation();
    init_caption();
    init_chartAxisDirection();
    init_cartesianCrossLine();
    init_label();
    init_layers();
    init_axisGridLine();
    init_axisLabel();
    init_axisLine();
    init_axisTitle();
    init_axisUtil();
    _Axis = class _Axis {
      constructor(moduleCtx, scale2, options) {
        this.moduleCtx = moduleCtx;
        this.scale = scale2;
        this.id = createId(this);
        this.nice = true;
        this.reverse = false;
        this.keys = [];
        this.dataDomain = { domain: [], clipped: false };
        this.boundSeries = [];
        this.includeInvisibleDomains = false;
        this.interactionEnabled = true;
        this.axisGroup = new Group({ name: `${this.id}-axis`, zIndex: 2 /* AXIS_ZINDEX */ });
        this.lineNode = this.axisGroup.appendChild(new Line());
        this.tickLineGroup = this.axisGroup.appendChild(
          new Group({ name: `${this.id}-Axis-tick-lines`, zIndex: 2 /* AXIS_ZINDEX */ })
        );
        this.tickLabelGroup = this.axisGroup.appendChild(
          new Group({ name: `${this.id}-Axis-tick-labels`, zIndex: 2 /* AXIS_ZINDEX */ })
        );
        this.crossLineGroup = new Group({ name: `${this.id}-CrossLines` });
        this.gridGroup = new Group({ name: `${this.id}-Axis-grid` });
        this.gridLineGroup = this.gridGroup.appendChild(
          new Group({
            name: `${this.id}-gridLines`,
            zIndex: 1 /* AXIS_GRID_ZINDEX */
          })
        );
        this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line, false);
        this.tickLabelGroupSelection = Selection.select(this.tickLabelGroup, Text, false);
        this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line, false);
        this.line = new AxisLine();
        this.tick = this.createTick();
        this.gridLine = new AxisGridLine();
        this.label = this.createLabel();
        this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;
        this.translation = { x: 0, y: 0 };
        this.rotation = 0;
        // axis rotation angle in degrees
        this.layout = {
          label: {
            fractionDigits: 0,
            padding: this.label.padding,
            format: this.label.format
          }
        };
        this.destroyFns = [];
        this.range = [0, 1];
        this.visibleRange = [0, 1];
        this.title = new AxisTitle();
        this._titleCaption = new Caption();
        this.gridLength = 0;
        this.fractionDigits = 0;
        /**
         * The distance between the grid ticks and the axis ticks.
         */
        this.gridPadding = 0;
        /**
         * Is used to avoid collisions between axis labels and series.
         */
        this.seriesAreaPadding = 0;
        this.tickGenerationResult = void 0;
        this.maxThickness = Infinity;
        this.moduleMap = new ModuleMap();
        this.refreshScale();
        this.destroyFns.push(this._titleCaption.registerInteraction(this.moduleCtx, "root"));
        this._titleCaption.node.rotation = -Math.PI / 2;
        this.axisGroup.appendChild(this._titleCaption.node);
        this.destroyFns.push(
          moduleCtx.regionManager.getRegion("series").addListener("hover", (e) => this.checkAxisHover(e))
        );
        this.animationManager = moduleCtx.animationManager;
        this.animationState = new StateMachine("empty", {
          empty: {
            update: {
              target: "ready",
              action: () => this.resetSelectionNodes()
            },
            reset: "empty"
          },
          ready: {
            update: (data) => this.animateReadyUpdate(data),
            resize: () => this.resetSelectionNodes(),
            reset: "empty"
          }
        });
        this._crossLines = [];
        this.assignCrossLineArrayConstructor(this._crossLines);
        let previousSize = void 0;
        this.destroyFns.push(
          moduleCtx.layoutService.addListener("layout-complete", (e) => {
            if (previousSize != null && jsonDiff(e.chart, previousSize) != null) {
              this.animationState.transition("resize");
            }
            previousSize = __spreadValues({}, e.chart);
          })
        );
        if ((options == null ? void 0 : options.respondsToZoom) !== false) {
          this.destroyFns.push(
            moduleCtx.updateService.addListener("update-complete", (e) => {
              this.minRect = e.minRect;
            })
          );
        }
      }
      get type() {
        var _a2;
        return (_a2 = this.constructor.type) != null ? _a2 : "";
      }
      set crossLines(value) {
        var _a2, _b;
        (_a2 = this._crossLines) == null ? void 0 : _a2.forEach((crossLine) => this.detachCrossLine(crossLine));
        if (value) {
          this.assignCrossLineArrayConstructor(value);
        }
        this._crossLines = value;
        (_b = this._crossLines) == null ? void 0 : _b.forEach((crossLine) => {
          this.attachCrossLine(crossLine);
          this.initCrossLine(crossLine);
        });
      }
      get crossLines() {
        return this._crossLines;
      }
      resetAnimation(phase) {
        if (phase === "initial") {
          this.animationState.transition("reset");
        }
      }
      attachCrossLine(crossLine) {
        this.crossLineGroup.appendChild(crossLine.group);
        this.crossLineGroup.appendChild(crossLine.labelGroup);
      }
      detachCrossLine(crossLine) {
        this.crossLineGroup.removeChild(crossLine.group);
        this.crossLineGroup.removeChild(crossLine.labelGroup);
      }
      destroy() {
        this.moduleMap.destroy();
        this.destroyFns.forEach((f) => f());
      }
      refreshScale() {
        var _a2;
        this.range = this.scale.range.slice();
        (_a2 = this.crossLines) == null ? void 0 : _a2.forEach(this.initCrossLine, this);
      }
      updateRange() {
        var _a2;
        const { range: rr, visibleRange: vr, scale: scale2 } = this;
        const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);
        const shift = span * vr[0];
        const start = rr[0] - shift;
        scale2.range = [start, start + span];
        (_a2 = this.crossLines) == null ? void 0 : _a2.forEach((crossLine) => {
          crossLine.clippedRange = [rr[0], rr[1]];
        });
      }
      setCrossLinesVisible(visible) {
        this.crossLineGroup.visible = visible;
      }
      attachAxis(axisNode, gridNode) {
        gridNode.appendChild(this.gridGroup);
        axisNode.appendChild(this.axisGroup);
        axisNode.appendChild(this.crossLineGroup);
      }
      detachAxis(axisNode, gridNode) {
        gridNode.removeChild(this.gridGroup);
        axisNode.removeChild(this.axisGroup);
        axisNode.removeChild(this.crossLineGroup);
      }
      /**
       * Checks if a point or an object is in range.
       * @param x A point (or object's starting point).
       * @param width Object's width.
       * @param tolerance Expands the range on both ends by this amount.
       */
      inRange(x, width = 0, tolerance = 0) {
        const [min, max] = findMinMax(this.range);
        return x + width >= min - tolerance && x <= max + tolerance;
      }
      onLabelFormatChange(ticks, _domain, format2) {
        const { scale: scale2, fractionDigits } = this;
        const logScale = scale2 instanceof LogScale;
        const defaultLabelFormatter = !logScale && fractionDigits > 0 ? (x) => typeof x === "number" ? x.toFixed(fractionDigits) : String(x) : (x) => String(x);
        if (format2 && scale2 && scale2.tickFormat) {
          try {
            this.labelFormatter = scale2.tickFormat({ ticks, specifier: format2 });
          } catch (e) {
            this.labelFormatter = defaultLabelFormatter;
            Logger.warnOnce(`the axis label format string ${format2} is invalid. No formatting will be applied`);
          }
        } else {
          this.labelFormatter = defaultLabelFormatter;
        }
      }
      setTickInterval(interval) {
        var _a2;
        this.scale.interval = (_a2 = this.tick.interval) != null ? _a2 : interval;
      }
      setTickCount(count, minTickCount, maxTickCount) {
        const { scale: scale2 } = this;
        const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);
        if (!(count && continuous)) {
          return;
        }
        if (typeof count === "number") {
          scale2.tickCount = count;
          scale2.minTickCount = minTickCount != null ? minTickCount : 0;
          scale2.maxTickCount = maxTickCount != null ? maxTickCount : Infinity;
          return;
        }
        if (scale2 instanceof TimeScale) {
          this.setTickInterval(count);
        }
      }
      onGridLengthChange(value, prevValue) {
        var _a2;
        if (prevValue && !value || !prevValue && value) {
          this.onGridVisibilityChange();
        }
        (_a2 = this.crossLines) == null ? void 0 : _a2.forEach(this.initCrossLine, this);
      }
      onGridVisibilityChange() {
        this.gridLineGroupSelection.clear();
      }
      createLabel() {
        return new AxisLabel();
      }
      checkAxisHover(event) {
        if (!this.interactionEnabled)
          return;
        const bbox = this.computeBBox();
        const isInAxis = bbox.containsPoint(event.offsetX, event.offsetY);
        if (!isInAxis)
          return;
        this.moduleCtx.chartEventManager.axisHover(this.id, this.direction);
      }
      /**
       * Creates/removes/updates the scene graph nodes that constitute the axis.
       */
      update(_primaryTickCount = 0, animated = true) {
        if (!this.tickGenerationResult) {
          return;
        }
        const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();
        const sideFlag = this.label.getSideFlag();
        this.updatePosition();
        const lineData = this.getAxisLineCoordinates();
        const { tickData, combinedRotation, textBaseline, textAlign, primaryTickCount } = this.tickGenerationResult;
        const previousTicks = this.tickLabelGroupSelection.nodes().map((node) => node.datum.tickId);
        this.updateSelections(lineData, tickData.ticks, {
          combinedRotation,
          textAlign,
          textBaseline,
          range: this.scale.range
        });
        if (!animated || this.animationManager.isSkipped()) {
          this.resetSelectionNodes();
        } else {
          const diff8 = this.calculateUpdateDiff(previousTicks, tickData);
          this.animationState.transition("update", diff8);
        }
        this.updateAxisLine();
        this.updateLabels();
        this.updateVisibility();
        this.updateGridLines(sideFlag);
        this.updateTickLines();
        this.updateTitle({ anyTickVisible: tickData.ticks.length > 0 });
        this.updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation });
        this.updateLayoutState();
        return primaryTickCount;
      }
      getAxisLineCoordinates() {
        const [min, max] = findMinMax(this.range);
        return { x: 0, y1: min, y2: max };
      }
      getTickLineCoordinates(datum) {
        const sideFlag = this.label.getSideFlag();
        const x = sideFlag * this.getTickSize();
        const x1 = Math.min(0, x);
        const x2 = x1 + Math.abs(x);
        const y = datum.translationY;
        return { x1, x2, y };
      }
      getTickLabelProps(datum, params) {
        const { label } = this;
        const { combinedRotation, textBaseline, textAlign, range: range4 } = params;
        const text = datum.tickLabel;
        const sideFlag = label.getSideFlag();
        const labelX = sideFlag * (this.getTickSize() + label.padding + this.seriesAreaPadding);
        const visible = text !== "" && text != null;
        return {
          tickId: datum.tickId,
          translationY: datum.translationY,
          fill: label.color,
          fontFamily: label.fontFamily,
          fontSize: label.fontSize,
          fontStyle: label.fontStyle,
          fontWeight: label.fontWeight,
          rotation: combinedRotation,
          rotationCenterX: labelX,
          text,
          textAlign,
          textBaseline,
          visible,
          x: labelX,
          y: 0,
          range: range4
        };
      }
      getTickSize() {
        return this.tick.enabled ? this.tick.size : this.createTick().size;
      }
      setTitleProps(caption, params) {
        var _a2;
        const { title } = this;
        if (!title.enabled) {
          caption.enabled = false;
          return;
        }
        caption.color = title.color;
        caption.fontFamily = title.fontFamily;
        caption.fontSize = title.fontSize;
        caption.fontStyle = title.fontStyle;
        caption.fontWeight = title.fontWeight;
        caption.enabled = title.enabled;
        caption.wrapping = title.wrapping;
        if (title.enabled) {
          const titleNode = caption.node;
          const padding = ((_a2 = title.spacing) != null ? _a2 : 0) + params.spacing;
          const sideFlag = this.label.getSideFlag();
          const parallelFlipRotation = normalizeAngle360(this.rotation);
          const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;
          const rotation = titleRotationFlag * sideFlag * Math.PI / 2;
          const textBaseline = titleRotationFlag === 1 ? "bottom" : "top";
          const { range: range4 } = this;
          const x = Math.floor(titleRotationFlag * sideFlag * (range4[0] + range4[1]) / 2);
          const y = sideFlag === -1 ? Math.floor(titleRotationFlag * -padding) : Math.floor(-padding);
          const { callbackCache } = this.moduleCtx;
          const { formatter = (p) => p.defaultValue } = title;
          const text = callbackCache.call(formatter, this.getTitleFormatterParams());
          titleNode.setProperties({
            rotation,
            text,
            textBaseline,
            visible: true,
            x,
            y
          });
        }
      }
      calculateLayout(primaryTickCount) {
        var _b, _c;
        const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();
        const sideFlag = this.label.getSideFlag();
        const labelX = sideFlag * (this.getTickSize() + this.label.padding + this.seriesAreaPadding);
        this.updateScale();
        this.tickGenerationResult = this.generateTicks({
          primaryTickCount,
          parallelFlipRotation,
          regularFlipRotation,
          labelX,
          sideFlag
        });
        this.updateLayoutState();
        const _a2 = this.tickGenerationResult, { tickData, combinedRotation, textBaseline, textAlign } = _a2, ticksResult = __objRest(_a2, ["tickData", "combinedRotation", "textBaseline", "textAlign"]);
        const boxes = [];
        const { x, y1, y2 } = this.getAxisLineCoordinates();
        const lineBox = new BBox(
          x + Math.min(sideFlag * this.seriesAreaPadding, 0),
          y1,
          this.seriesAreaPadding,
          y2 - y1
        );
        boxes.push(lineBox);
        if (this.tick.enabled) {
          tickData.ticks.forEach((datum) => {
            const { x1, x2, y } = this.getTickLineCoordinates(datum);
            const tickLineBox = new BBox(x1, y, x2 - x1, 0);
            boxes.push(tickLineBox);
          });
        }
        if (this.label.enabled) {
          const tempText2 = new Text();
          tickData.ticks.forEach((datum) => {
            const labelProps = this.getTickLabelProps(datum, {
              combinedRotation,
              textAlign,
              textBaseline,
              range: this.scale.range
            });
            if (!labelProps.visible) {
              return;
            }
            tempText2.setProperties(__spreadProps(__spreadValues({}, labelProps), {
              translationY: Math.round(datum.translationY)
            }));
            const box = tempText2.computeTransformedBBox();
            if (box) {
              boxes.push(box);
            }
          });
        }
        const getTransformBox = (bbox2) => {
          const matrix = new Matrix();
          const {
            rotation: axisRotation,
            translationX,
            translationY,
            rotationCenterX,
            rotationCenterY
          } = this.getAxisTransform();
          Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {
            scalingCenterX: 0,
            scalingCenterY: 0,
            rotationCenterX,
            rotationCenterY
          });
          return matrix.transformBBox(bbox2);
        };
        if ((_b = this.title) == null ? void 0 : _b.enabled) {
          const caption = new Caption();
          const spacing = BBox.merge(boxes).width;
          this.setTitleProps(caption, { spacing });
          const titleNode = caption.node;
          const titleBox = titleNode.computeTransformedBBox();
          if (titleBox) {
            boxes.push(titleBox);
          }
        }
        const bbox = BBox.merge(boxes);
        const transformedBBox = getTransformBox(bbox);
        const anySeriesActive = this.isAnySeriesActive();
        (_c = this.crossLines) == null ? void 0 : _c.forEach((crossLine) => {
          var _a3;
          crossLine.sideFlag = -sideFlag;
          crossLine.direction = rotation === -Math.PI / 2 ? "x" /* X */ : "y" /* Y */;
          if (crossLine instanceof CartesianCrossLine) {
            crossLine.label.parallel = (_a3 = crossLine.label.parallel) != null ? _a3 : this.label.parallel;
          }
          crossLine.parallelFlipRotation = parallelFlipRotation;
          crossLine.regularFlipRotation = regularFlipRotation;
          crossLine.calculateLayout(anySeriesActive, this.reverse);
        });
        primaryTickCount = ticksResult.primaryTickCount;
        return { primaryTickCount, bbox: transformedBBox };
      }
      updateLayoutState() {
        this.layout.label = {
          fractionDigits: this.fractionDigits,
          padding: this.label.padding,
          format: this.label.format
        };
      }
      setDomain(domain) {
        this.dataDomain = this.normaliseDataDomain(domain);
        if (this.reverse) {
          this.dataDomain.domain.reverse();
        }
        this.scale.domain = this.dataDomain.domain;
      }
      updateScale() {
        this.updateRange();
        this.calculateDomain();
        this.setTickInterval(this.tick.interval);
        const { scale: scale2, nice } = this;
        if (!ContinuousScale.is(scale2)) {
          return;
        }
        scale2.nice = nice;
        scale2.update();
      }
      calculateRotations() {
        const rotation = toRadians(this.rotation);
        const parallelFlipRotation = normalizeAngle360(rotation);
        const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);
        return { rotation, parallelFlipRotation, regularFlipRotation };
      }
      generateTicks({
        primaryTickCount,
        parallelFlipRotation,
        regularFlipRotation,
        labelX,
        sideFlag
      }) {
        var _a2;
        const {
          scale: scale2,
          tick,
          label: { parallel, rotation, fontFamily, fontSize, fontStyle, fontWeight }
        } = this;
        const secondaryAxis = primaryTickCount !== void 0;
        const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation({
          rotation,
          parallel,
          regularFlipRotation,
          parallelFlipRotation
        });
        const initialRotation = configuredRotation + defaultRotation;
        const labelMatrix = new Matrix();
        const { maxTickCount } = this.estimateTickCount({
          minSpacing: tick.minSpacing,
          maxSpacing: (_a2 = tick.maxSpacing) != null ? _a2 : NaN
        });
        const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);
        const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;
        let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);
        const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);
        const textProps = {
          fontFamily,
          fontSize,
          fontStyle,
          fontWeight,
          textBaseline,
          textAlign
        };
        let tickData = {
          rawTicks: [],
          ticks: [],
          labelCount: 0
        };
        let index = 0;
        let autoRotation = 0;
        let labelOverlap = true;
        let terminate = false;
        while (labelOverlap && index <= maxIterations) {
          if (terminate) {
            break;
          }
          autoRotation = 0;
          textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);
          const tickStrategies = this.getTickStrategies({ secondaryAxis, index });
          for (const strategy of tickStrategies) {
            ({ tickData, index, autoRotation, terminate } = strategy({
              index,
              tickData,
              textProps,
              labelOverlap,
              terminate,
              primaryTickCount
            }));
            const rotated = configuredRotation !== 0 || autoRotation !== 0;
            const labelRotation = initialRotation + autoRotation;
            textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);
            labelOverlap = this.label.avoidCollisions ? this.checkLabelOverlap(labelRotation, rotated, labelMatrix, tickData.ticks, labelX, __spreadProps(__spreadValues({}, textProps), {
              textAlign
            })) : false;
          }
        }
        const combinedRotation = defaultRotation + configuredRotation + autoRotation;
        if (!secondaryAxis && tickData.rawTicks.length > 0) {
          primaryTickCount = tickData.rawTicks.length;
        }
        return { tickData, primaryTickCount, combinedRotation, textBaseline, textAlign };
      }
      getTickStrategies({
        index: iteration,
        secondaryAxis
      }) {
        const { scale: scale2, label, tick } = this;
        const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);
        const avoidLabelCollisions = label.enabled && label.avoidCollisions;
        const filterTicks = !continuous && iteration !== 0 && avoidLabelCollisions;
        const autoRotate = label.autoRotate === true && label.rotation === void 0;
        const strategies = [];
        let tickGenerationType;
        if (this.tick.values) {
          tickGenerationType = 3 /* VALUES */;
        } else if (secondaryAxis) {
          tickGenerationType = 1 /* CREATE_SECONDARY */;
        } else if (filterTicks) {
          tickGenerationType = 2 /* FILTER */;
        } else {
          tickGenerationType = 0 /* CREATE */;
        }
        const tickGenerationStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount);
        strategies.push(tickGenerationStrategy);
        if (!continuous && !isNaN(tick.minSpacing)) {
          const tickFilterStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(2 /* FILTER */, index, tickData, terminate, primaryTickCount);
          strategies.push(tickFilterStrategy);
        }
        if (!avoidLabelCollisions) {
          return strategies;
        }
        if (label.autoWrap) {
          const autoWrapStrategy = ({ index, tickData, textProps }) => this.wrapLabels(tickData, index, textProps);
          strategies.push(autoWrapStrategy);
        } else if (autoRotate) {
          const autoRotateStrategy = ({ index, tickData, labelOverlap, terminate }) => ({
            index,
            tickData,
            autoRotation: this.getAutoRotation(labelOverlap),
            terminate
          });
          strategies.push(autoRotateStrategy);
        }
        return strategies;
      }
      createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount) {
        var _a2;
        const { scale: scale2, tick } = this;
        const { maxTickCount, minTickCount, defaultTickCount } = this.estimateTickCount({
          minSpacing: tick.minSpacing,
          maxSpacing: (_a2 = tick.maxSpacing) != null ? _a2 : NaN
        });
        const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);
        const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;
        let tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;
        const regenerateTicks = tick.interval === void 0 && tick.values === void 0 && tickCount > minTickCount && (continuous || tickGenerationType === 2 /* FILTER */);
        let unchanged = true;
        while (unchanged && index <= maxIterations) {
          const prevTicks = tickData.rawTicks;
          tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;
          const { rawTicks, ticks, labelCount } = this.getTicks({
            tickGenerationType,
            previousTicks: prevTicks,
            tickCount,
            minTickCount,
            maxTickCount,
            primaryTickCount
          });
          tickData.rawTicks = rawTicks;
          tickData.ticks = ticks;
          tickData.labelCount = labelCount;
          unchanged = regenerateTicks ? areArrayNumbersEqual(rawTicks, prevTicks) : false;
          index++;
        }
        const shouldTerminate = tick.interval !== void 0 || tick.values !== void 0;
        terminate || (terminate = shouldTerminate);
        return { tickData, index, autoRotation: 0, terminate };
      }
      checkLabelOverlap(rotation, rotated, labelMatrix, tickData, labelX, textProps) {
        Matrix.updateTransformMatrix(labelMatrix, 1, 1, rotation, 0, 0);
        const labelData = this.createLabelData(tickData, labelX, textProps, labelMatrix);
        const labelSpacing = getLabelSpacing(this.label.minSpacing, rotated);
        return axisLabelsOverlap(labelData, labelSpacing);
      }
      createLabelData(tickData, labelX, textProps, labelMatrix) {
        const labelData = [];
        const measurer = new TextMeasurer(textProps);
        for (const { tickLabel, translationY } of tickData) {
          if (tickLabel === "" || tickLabel == null)
            continue;
          const { width, height } = measurer.size(tickLabel);
          const bbox = new BBox(labelX, translationY, width, height);
          const labelDatum = calculateLabelBBox(tickLabel, bbox, labelX, translationY, labelMatrix);
          labelData.push(labelDatum);
        }
        return labelData;
      }
      getAutoRotation(labelOverlap) {
        var _a2;
        return labelOverlap ? normalizeAngle360(toRadians((_a2 = this.label.autoRotateAngle) != null ? _a2 : 0)) : 0;
      }
      getTicks({
        tickGenerationType,
        previousTicks,
        tickCount,
        minTickCount,
        maxTickCount,
        primaryTickCount
      }) {
        var _a2;
        const { range: range4, scale: scale2, visibleRange } = this;
        let rawTicks;
        switch (tickGenerationType) {
          case 3 /* VALUES */:
            if (ContinuousScale.is(scale2)) {
              const [d0, d1] = findMinMax(scale2.getDomain().map(Number));
              rawTicks = this.tick.values.filter((value) => value >= d0 && value <= d1).sort((a, b) => a - b);
            } else {
              rawTicks = this.tick.values;
            }
            break;
          case 1 /* CREATE_SECONDARY */:
            if (ContinuousScale.is(scale2)) {
              rawTicks = this.updateSecondaryAxisTicks(primaryTickCount);
            } else {
              rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);
            }
            break;
          case 2 /* FILTER */:
            rawTicks = this.filterTicks(previousTicks, tickCount);
            break;
          default:
            rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);
            break;
        }
        this.fractionDigits = rawTicks.fractionDigits >= 0 ? rawTicks.fractionDigits : 0;
        const halfBandwidth = ((_a2 = scale2.bandwidth) != null ? _a2 : 0) / 2;
        const ticks = [];
        let labelCount = 0;
        const tickIdCounts = /* @__PURE__ */ new Map();
        const start = Math.max(0, Math.floor(visibleRange[0] * rawTicks.length));
        const end = Math.min(rawTicks.length, Math.ceil(visibleRange[1] * rawTicks.length));
        const filteredTicks = rawTicks.slice(start, end);
        this.onLabelFormatChange(filteredTicks, rawTicks, this.label.format);
        for (let i = 0; i < filteredTicks.length; i++) {
          const tick = filteredTicks[i];
          const translationY = scale2.convert(tick) + halfBandwidth;
          if (range4.length > 0 && !this.inRange(translationY, 0, 1e-3))
            continue;
          const tickLabel = this.formatTick(tick, start + i);
          let tickId = tickLabel;
          if (tickIdCounts.has(tickId)) {
            const count = tickIdCounts.get(tickId);
            tickIdCounts.set(tickId, count + 1);
            tickId = `${tickId}_${count}`;
          } else {
            tickIdCounts.set(tickId, 1);
          }
          ticks.push({ tick, tickId, tickLabel, translationY: Math.floor(translationY) });
          if (tickLabel === "" || tickLabel == null) {
            continue;
          }
          labelCount++;
        }
        return { rawTicks, ticks, labelCount };
      }
      filterTicks(ticks, tickCount) {
        var _a2;
        const tickSpacing = !isNaN(this.tick.minSpacing) || !isNaN((_a2 = this.tick.maxSpacing) != null ? _a2 : NaN);
        const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;
        return ticks.filter((_, i) => i % keepEvery === 0);
      }
      createTicks(tickCount, minTickCount, maxTickCount) {
        var _a2, _b, _c;
        this.setTickCount(tickCount, minTickCount, maxTickCount);
        return (_c = (_b = (_a2 = this.scale).ticks) == null ? void 0 : _b.call(_a2)) != null ? _c : [];
      }
      estimateTickCount({ minSpacing, maxSpacing }) {
        const {
          minRect,
          label: { avoidCollisions }
        } = this;
        if (!avoidCollisions) {
          return {
            minTickCount: ContinuousScale.defaultMaxTickCount,
            maxTickCount: ContinuousScale.defaultMaxTickCount,
            defaultTickCount: ContinuousScale.defaultMaxTickCount
          };
        }
        const rangeWithBleed = this.calculateRangeWithBleed();
        const defaultMinSpacing = Math.max(
          this.defaultTickMinSpacing,
          rangeWithBleed / ContinuousScale.defaultMaxTickCount
        );
        let clampMaxTickCount = !isNaN(maxSpacing);
        if (isNaN(minSpacing)) {
          minSpacing = defaultMinSpacing;
        }
        if (isNaN(maxSpacing)) {
          maxSpacing = rangeWithBleed;
        }
        if (minSpacing > maxSpacing) {
          if (minSpacing === defaultMinSpacing) {
            minSpacing = maxSpacing;
          } else {
            maxSpacing = minSpacing;
          }
        }
        let minRectDistance = 1;
        if (minRect) {
          minRectDistance = this.direction === "x" /* X */ ? minRect.width : minRect.height;
        }
        clampMaxTickCount && (clampMaxTickCount = minRectDistance < defaultMinSpacing);
        const maxTickCount = clamp(
          1,
          Math.floor(rangeWithBleed / minSpacing),
          clampMaxTickCount ? Math.min(Math.floor(rangeWithBleed / minRectDistance), 100) : 100
        );
        const minTickCount = Math.min(maxTickCount, Math.ceil(rangeWithBleed / maxSpacing));
        const defaultTickCount = clamp(minTickCount, ContinuousScale.defaultTickCount, maxTickCount);
        return { minTickCount, maxTickCount, defaultTickCount };
      }
      updateVisibility() {
        if (this.moduleCtx.animationManager.isSkipped()) {
          this.resetSelectionNodes();
        }
        this.tickLineGroup.visible = this.tick.enabled;
        this.gridLineGroup.visible = this.gridLine.enabled;
        this.tickLabelGroup.visible = this.label.enabled;
      }
      updateCrossLines({
        rotation,
        parallelFlipRotation,
        regularFlipRotation
      }) {
        var _a2;
        const sideFlag = this.label.getSideFlag();
        const anySeriesActive = this.isAnySeriesActive();
        (_a2 = this.crossLines) == null ? void 0 : _a2.forEach((crossLine) => {
          var _a3;
          crossLine.sideFlag = -sideFlag;
          crossLine.direction = rotation === -Math.PI / 2 ? "x" /* X */ : "y" /* Y */;
          if (crossLine instanceof CartesianCrossLine) {
            crossLine.label.parallel = (_a3 = crossLine.label.parallel) != null ? _a3 : this.label.parallel;
          }
          crossLine.parallelFlipRotation = parallelFlipRotation;
          crossLine.regularFlipRotation = regularFlipRotation;
          crossLine.update(anySeriesActive);
        });
      }
      updateTickLines() {
        const { tick, label } = this;
        const sideFlag = label.getSideFlag();
        this.tickLineGroupSelection.each((line) => {
          line.strokeWidth = tick.width;
          line.stroke = tick.color;
          line.x1 = sideFlag * this.getTickSize();
          line.x2 = 0;
        });
      }
      calculateAvailableRange() {
        return findRangeExtent(this.range);
      }
      /**
       * Calculates the available range with an additional "bleed" beyond the canvas that encompasses the full axis when
       * the visible range is only a portion of the axis.
       */
      calculateRangeWithBleed() {
        const visibleScale = 1 / findRangeExtent(this.visibleRange);
        return round(this.calculateAvailableRange() * visibleScale, 2);
      }
      calculateDomain() {
        const visibleSeries = this.boundSeries.filter((s) => this.includeInvisibleDomains || s.isEnabled());
        const domains = visibleSeries.flatMap((series) => series.getDomain(this.direction));
        this.setDomain(domains);
      }
      getAxisTransform() {
        return {
          rotation: toRadians(this.rotation),
          rotationCenterX: 0,
          rotationCenterY: 0,
          translationX: Math.floor(this.translation.x),
          translationY: Math.floor(this.translation.y)
        };
      }
      updatePosition() {
        const { crossLineGroup, axisGroup, gridGroup, translation, gridLineGroupSelection, gridPadding, gridLength } = this;
        const { rotation } = this.calculateRotations();
        const sideFlag = this.label.getSideFlag();
        const translationX = Math.floor(translation.x);
        const translationY = Math.floor(translation.y);
        crossLineGroup.setProperties({ rotation, translationX, translationY });
        gridGroup.setProperties({ rotation, translationX, translationY });
        axisGroup.datum = this.getAxisTransform();
        gridLineGroupSelection.each((line) => {
          line.x1 = gridPadding;
          line.x2 = -sideFlag * gridLength + gridPadding;
        });
      }
      updateSecondaryAxisTicks(_primaryTickCount) {
        throw new Error("AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.");
      }
      updateSelections(lineData, data, params) {
        this.lineNode.datum = lineData;
        this.gridLineGroupSelection.update(
          this.gridLength ? data : [],
          (group2) => group2.append(new Line()),
          (datum) => datum.tickId
        );
        this.tickLineGroupSelection.update(
          data,
          (group2) => group2.appendChild(new Line()),
          (datum) => datum.tickId
        );
        this.tickLabelGroupSelection.update(
          data.map((d) => this.getTickLabelProps(d, params)),
          (group2) => group2.appendChild(new Text()),
          (datum) => datum.tickId
        );
      }
      updateAxisLine() {
        const { line } = this;
        const strokeWidth = line.enabled ? line.width : 0;
        this.lineNode.setProperties({
          stroke: line.color,
          strokeWidth
        });
      }
      updateGridLines(sideFlag) {
        const {
          gridLine: { style, width },
          gridPadding,
          gridLength
        } = this;
        if (gridLength === 0 || style.length === 0) {
          return;
        }
        this.gridLineGroupSelection.each((line, _, index) => {
          const { stroke, lineDash } = style[index % style.length];
          line.setProperties({
            x1: gridPadding,
            x2: -sideFlag * gridLength + gridPadding,
            fill: void 0,
            stroke,
            strokeWidth: width,
            lineDash
          });
        });
      }
      updateLabels() {
        const { label } = this;
        if (!label.enabled) {
          return;
        }
        this.tickLabelGroupSelection.each((node, datum) => {
          node.setProperties(datum, [
            "fill",
            "fontFamily",
            "fontSize",
            "fontStyle",
            "fontWeight",
            "text",
            "textAlign",
            "textBaseline"
          ]);
        });
      }
      wrapLabels(tickData, index, labelProps) {
        const { parallel, maxWidth, maxHeight } = this.label;
        let defaultMaxWidth = this.maxThickness;
        let defaultMaxHeight = Math.round(this.calculateAvailableRange() / tickData.labelCount);
        if (parallel) {
          [defaultMaxWidth, defaultMaxHeight] = [defaultMaxHeight, defaultMaxWidth];
        }
        tickData.ticks.forEach((tickDatum) => {
          const { text } = Text.wrap(
            tickDatum.tickLabel,
            maxWidth != null ? maxWidth : defaultMaxWidth,
            maxHeight != null ? maxHeight : defaultMaxHeight,
            labelProps,
            "hyphenate"
          );
          tickDatum.tickLabel = text;
        });
        return { tickData, index, autoRotation: 0, terminate: true };
      }
      updateTitle(params) {
        const { rotation, title, _titleCaption, lineNode, tickLineGroup, tickLabelGroup } = this;
        if (!title) {
          _titleCaption.enabled = false;
          return;
        }
        let spacing = 0;
        if (title.enabled && params.anyTickVisible) {
          const tickBBox = Group.computeBBox([tickLineGroup, tickLabelGroup, lineNode]);
          const tickWidth = rotation === 0 ? tickBBox.width : tickBBox.height;
          spacing += tickWidth + (this.tickLabelGroup.visible ? 0 : this.seriesAreaPadding);
        }
        this.setTitleProps(_titleCaption, { spacing });
      }
      // For formatting (nice rounded) tick values.
      formatTick(datum, index) {
        return this.datumFormatter(index)(datum);
      }
      // For formatting arbitrary values between the ticks.
      formatDatum(datum) {
        return String(datum);
      }
      datumFormatter(index = 0) {
        const {
          label,
          labelFormatter,
          fractionDigits,
          moduleCtx: { callbackCache }
        } = this;
        if (label.formatter) {
          return (datum) => {
            var _a2;
            return (_a2 = callbackCache.call(label.formatter, {
              value: fractionDigits > 0 ? datum : String(datum),
              index,
              fractionDigits,
              formatter: labelFormatter
            })) != null ? _a2 : datum;
          };
        } else if (labelFormatter) {
          return (datum) => {
            var _a2;
            return (_a2 = callbackCache.call(labelFormatter, datum)) != null ? _a2 : String(datum);
          };
        }
        return (datum) => String(datum);
      }
      computeBBox() {
        return this.axisGroup.computeBBox();
      }
      initCrossLine(crossLine) {
        crossLine.scale = this.scale;
        crossLine.gridLength = this.gridLength;
      }
      isAnySeriesActive() {
        return this.boundSeries.some((s) => this.includeInvisibleDomains || s.isEnabled());
      }
      clipTickLines(x, y, width, height) {
        this.tickLineGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));
      }
      clipGrid(x, y, width, height) {
        this.gridGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));
      }
      calculatePadding(min, max) {
        const padding = Math.abs(this.reverse ? max : min) * 0.01;
        return [padding, padding];
      }
      getTitleFormatterParams() {
        var _a2;
        const boundSeries = this.boundSeries.reduce((acc, next) => {
          const keys = next.getKeys(this.direction);
          const names = next.getNames(this.direction);
          for (let idx = 0; idx < keys.length; idx++) {
            acc.push({ key: keys[idx], name: names[idx] });
          }
          return acc;
        }, []);
        return {
          direction: this.direction,
          boundSeries,
          defaultValue: (_a2 = this.title) == null ? void 0 : _a2.text
        };
      }
      normaliseDataDomain(d) {
        return { domain: [...d], clipped: false };
      }
      getLayoutState() {
        return __spreadValues({
          rect: this.computeBBox(),
          gridPadding: this.gridPadding,
          seriesAreaPadding: this.seriesAreaPadding,
          tickSize: this.getTickSize(),
          direction: this.direction,
          domain: this.dataDomain.domain,
          scale: this.scale
        }, this.layout);
      }
      getModuleMap() {
        return this.moduleMap;
      }
      createModuleContext() {
        var _a2;
        (_a2 = this.axisContext) != null ? _a2 : this.axisContext = this.createAxisContext();
        return __spreadProps(__spreadValues({}, this.moduleCtx), { parent: this.axisContext });
      }
      createAxisContext() {
        return {
          axisId: this.id,
          direction: this.direction,
          continuous: ContinuousScale.is(this.scale),
          keys: () => this.boundSeries.flatMap((s) => s.getKeys(this.direction)),
          seriesKeyProperties: () => this.boundSeries.reduce((keys, series) => {
            const seriesKeys = series.getKeyProperties(this.direction);
            seriesKeys.forEach((key) => {
              if (keys.indexOf(key) < 0) {
                keys.push(key);
              }
            });
            return keys;
          }, []),
          scaleValueFormatter: (specifier) => {
            var _a2, _b;
            return specifier ? (_b = (_a2 = this.scale).tickFormat) == null ? void 0 : _b.call(_a2, { specifier }) : this.formatDatum;
          },
          scaleBandwidth: () => {
            var _a2;
            return (_a2 = this.scale.bandwidth) != null ? _a2 : 0;
          },
          scaleConvert: (val) => this.scale.convert(val),
          scaleInvert: (val) => {
            var _a2, _b;
            return (_b = (_a2 = this.scale).invert) == null ? void 0 : _b.call(_a2, val);
          }
        };
      }
      animateReadyUpdate(diff8) {
        const { animationManager } = this.moduleCtx;
        const selectionCtx = prepareAxisAnimationContext(this);
        const fns = prepareAxisAnimationFunctions(selectionCtx);
        fromToMotion(this.id, "axis-group", animationManager, [this.axisGroup], fns.group);
        fromToMotion(this.id, "line", animationManager, [this.lineNode], fns.line);
        fromToMotion(
          this.id,
          "line-paths",
          animationManager,
          [this.gridLineGroupSelection, this.tickLineGroupSelection],
          fns.tick,
          (_, d) => d.tickId,
          diff8
        );
        fromToMotion(
          this.id,
          "tick-labels",
          animationManager,
          [this.tickLabelGroupSelection],
          fns.label,
          (_, d) => d.tickId,
          diff8
        );
      }
      resetSelectionNodes() {
        const { gridLineGroupSelection, tickLineGroupSelection, tickLabelGroupSelection, lineNode } = this;
        const selectionCtx = prepareAxisAnimationContext(this);
        resetMotion([this.axisGroup], resetAxisGroupFn());
        resetMotion([gridLineGroupSelection, tickLineGroupSelection], resetAxisSelectionFn(selectionCtx));
        resetMotion([tickLabelGroupSelection], resetAxisLabelSelectionFn());
        resetMotion([lineNode], resetAxisLineSelectionFn());
      }
      calculateUpdateDiff(previous, tickData) {
        const added = /* @__PURE__ */ new Set();
        const removed = /* @__PURE__ */ new Set();
        const tickMap = {};
        const tickCount = Math.max(previous.length, tickData.ticks.length);
        for (let i = 0; i < tickCount; i++) {
          const tickDatum = tickData.ticks[i];
          const prev = previous[i];
          const tick = tickDatum == null ? void 0 : tickDatum.tickId;
          tickMap[tick != null ? tick : prev] = tickDatum;
          if (prev === tick) {
            continue;
          }
          if (removed.has(tick)) {
            removed.delete(tick);
          } else if (tick) {
            added.add(tick);
          }
          if (added.has(prev)) {
            added.delete(prev);
          } else if (prev) {
            removed.add(prev);
          }
        }
        return { changed: added.size > 0 || removed.size > 0, added, removed };
      }
      isReversed() {
        return this.reverse;
      }
    };
    _Axis.defaultTickMinSpacing = 50;
    __decorateClass([
      Validate(BOOLEAN)
    ], _Axis.prototype, "nice", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], _Axis.prototype, "reverse", 2);
    __decorateClass([
      Validate(STRING_ARRAY)
    ], _Axis.prototype, "keys", 2);
    __decorateClass([
      Validate(OBJECT, { optional: true })
    ], _Axis.prototype, "title", 2);
    __decorateClass([
      ObserveChanges((target, value, oldValue) => target.onGridLengthChange(value, oldValue))
    ], _Axis.prototype, "gridLength", 2);
    Axis = _Axis;
  }
});

// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts
var CartesianAxisLabel;
var init_cartesianAxisLabel = __esm({
  "packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts"() {
    "use strict";
    init_validation();
    init_axisLabel();
    CartesianAxisLabel = class extends AxisLabel {
      constructor() {
        super(...arguments);
        this.autoRotateAngle = 335;
      }
    };
    __decorateClass([
      Validate(BOOLEAN, { optional: true })
    ], CartesianAxisLabel.prototype, "autoRotate", 2);
    __decorateClass([
      Validate(DEGREE)
    ], CartesianAxisLabel.prototype, "autoRotateAngle", 2);
  }
});

// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts
var _CartesianAxis, CartesianAxis;
var init_cartesianAxis = __esm({
  "packages/ag-charts-community/src/chart/axis/cartesianAxis.ts"() {
    "use strict";
    init_validation();
    init_chartAxisDirection();
    init_chartOptions2();
    init_cartesianCrossLine();
    init_axis();
    init_cartesianAxisLabel();
    _CartesianAxis = class _CartesianAxis extends Axis {
      constructor() {
        super(...arguments);
        this.thickness = 0;
        this.position = "left";
      }
      static is(value) {
        return value instanceof _CartesianAxis;
      }
      get direction() {
        return ["top", "bottom"].includes(this.position) ? "x" /* X */ : "y" /* Y */;
      }
      updateDirection() {
        switch (this.position) {
          case "top":
            this.rotation = -90;
            this.label.mirrored = true;
            this.label.parallel = true;
            break;
          case "right":
            this.rotation = 0;
            this.label.mirrored = true;
            this.label.parallel = false;
            break;
          case "bottom":
            this.rotation = -90;
            this.label.mirrored = false;
            this.label.parallel = true;
            break;
          case "left":
            this.rotation = 0;
            this.label.mirrored = false;
            this.label.parallel = false;
            break;
        }
        if (this.axisContext) {
          this.axisContext.position = this.position;
          this.axisContext.direction = this.direction;
        }
      }
      update(primaryTickCount, animated) {
        this.updateDirection();
        return super.update(primaryTickCount, animated);
      }
      calculateLayout(primaryTickCount) {
        this.updateDirection();
        return super.calculateLayout(primaryTickCount);
      }
      createAxisContext() {
        return __spreadProps(__spreadValues({}, super.createAxisContext()), {
          position: this.position
        });
      }
      assignCrossLineArrayConstructor(crossLines) {
        assignJsonApplyConstructedArray(crossLines, CartesianCrossLine);
      }
      createLabel() {
        return new CartesianAxisLabel();
      }
    };
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], _CartesianAxis.prototype, "thickness", 2);
    __decorateClass([
      Validate(POSITION2)
    ], _CartesianAxis.prototype, "position", 2);
    CartesianAxis = _CartesianAxis;
  }
});

// packages/ag-charts-community/src/chart/axis/categoryAxis.ts
var CategoryAxisTick, CategoryAxis;
var init_categoryAxis = __esm({
  "packages/ag-charts-community/src/chart/axis/categoryAxis.ts"() {
    "use strict";
    init_bandScale();
    init_default();
    init_validation();
    init_axisTick();
    init_cartesianAxis();
    CategoryAxisTick = class extends AxisTick {
      constructor() {
        super(...arguments);
        this.minSpacing = NaN;
      }
    };
    __decorateClass([
      Validate(MIN_SPACING),
      Default(NaN)
    ], CategoryAxisTick.prototype, "minSpacing", 2);
    CategoryAxis = class extends CartesianAxis {
      constructor(moduleCtx, scale2 = new BandScale()) {
        super(moduleCtx, scale2);
        this._paddingOverrideEnabled = false;
        this.groupPaddingInner = 0.1;
        this.includeInvisibleDomains = true;
      }
      set paddingInner(value) {
        this._paddingOverrideEnabled = true;
        this.scale.paddingInner = value;
      }
      get paddingInner() {
        this._paddingOverrideEnabled = true;
        return this.scale.paddingInner;
      }
      set paddingOuter(value) {
        this.scale.paddingOuter = value;
      }
      get paddingOuter() {
        return this.scale.paddingOuter;
      }
      createTick() {
        return new CategoryAxisTick();
      }
      normaliseDataDomain(d) {
        const domain = [];
        const uniqueValues = /* @__PURE__ */ new Set();
        for (const v of d) {
          const key = v instanceof Date ? v.getTime() : v;
          if (!uniqueValues.has(key)) {
            uniqueValues.add(key);
            domain.push(v);
          }
        }
        return { domain, clipped: false };
      }
      calculateDomain() {
        if (!this._paddingOverrideEnabled) {
          const paddings = this.boundSeries.map((s) => {
            var _a2;
            return (_a2 = s.getBandScalePadding) == null ? void 0 : _a2.call(s);
          }).filter((p) => p != null);
          if (paddings.length > 0) {
            this.scale.paddingInner = Math.min(...paddings.map((p) => p.inner));
            this.scale.paddingOuter = Math.max(...paddings.map((p) => p.outer));
          }
        }
        return super.calculateDomain();
      }
    };
    CategoryAxis.className = "CategoryAxis";
    CategoryAxis.type = "category";
    __decorateClass([
      Validate(RATIO)
    ], CategoryAxis.prototype, "groupPaddingInner", 2);
  }
});

// packages/ag-charts-community/src/chart/axis/tree.ts
function ticksToTree(ticks, pad2 = true) {
  const root = new TreeNode();
  let depth = 0;
  if (pad2) {
    ticks.forEach((tick) => depth = Math.max(depth, tick.labels.length));
  }
  ticks.forEach((tick) => {
    if (pad2) {
      while (tick.labels.length < depth) {
        tick.labels.unshift("");
      }
    }
    insertTick(root, tick);
  });
  return root;
}
function insertTick(root, tick) {
  const pathParts = tick.labels.slice().reverse();
  const lastPartIndex = pathParts.length - 1;
  pathParts.forEach((pathPart, partIndex) => {
    const children = root.children;
    const existingNode = children.find((child) => child.label === pathPart);
    const isNotLeaf = partIndex !== lastPartIndex;
    if (existingNode && isNotLeaf) {
      root = existingNode;
    } else {
      const node = new TreeNode(pathPart, root);
      node.number = children.length;
      children.push(node);
      if (isNotLeaf) {
        root = node;
      }
    }
  });
}
function moveSubtree(wm, wp, shift) {
  const subtrees = wp.number - wm.number;
  const ratio = shift / subtrees;
  wp.change -= ratio;
  wp.shift += shift;
  wm.change += ratio;
  wp.prelim += shift;
  wp.mod += shift;
}
function ancestor(vim, v, defaultAncestor) {
  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;
}
function executeShifts(v) {
  const children = v.children;
  if (children) {
    let shift = 0;
    let change = 0;
    for (let i = children.length - 1; i >= 0; i--) {
      const w = children[i];
      w.prelim += shift;
      w.mod += shift;
      change += w.change;
      shift += w.shift + change;
    }
  }
}
function apportion(v, defaultAncestor, distance2) {
  const w = v.getLeftSibling();
  if (w) {
    let vop = v;
    let vip = v;
    let vim = w;
    let vom = vip.getLeftmostSibling();
    let sip = vip.mod;
    let sop = vop.mod;
    let sim = vim.mod;
    let som = vom.mod;
    while (vim.nextRight() && vip.nextLeft()) {
      vim = vim.nextRight();
      vip = vip.nextLeft();
      vom = vom.nextLeft();
      vop = vop.nextRight();
      vop.ancestor = v;
      const shift = vim.prelim + sim - (vip.prelim + sip) + distance2;
      if (shift > 0) {
        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);
        sip += shift;
        sop += shift;
      }
      sim += vim.mod;
      sip += vip.mod;
      som += vom.mod;
      sop += vop.mod;
    }
    if (vim.nextRight() && !vop.nextRight()) {
      vop.thread = vim.nextRight();
      vop.mod += sim - sop;
    } else {
      if (vip.nextLeft() && !vom.nextLeft()) {
        vom.thread = vip.nextLeft();
        vom.mod += sip - som;
      }
      defaultAncestor = v;
    }
  }
  return defaultAncestor;
}
function firstWalk(node, distance2) {
  const children = node.children;
  if (children.length) {
    let defaultAncestor = children[0];
    children.forEach((child) => {
      firstWalk(child, distance2);
      defaultAncestor = apportion(child, defaultAncestor, distance2);
    });
    executeShifts(node);
    const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;
    const leftSibling = node.getLeftSibling();
    if (leftSibling) {
      node.prelim = leftSibling.prelim + distance2;
      node.mod = node.prelim - midpoint;
    } else {
      node.prelim = midpoint;
    }
  } else {
    const leftSibling = node.getLeftSibling();
    node.prelim = leftSibling ? leftSibling.prelim + distance2 : 0;
  }
}
function secondWalk(v, m, layout) {
  v.x = v.prelim + m;
  v.y = v.depth;
  layout.update(v);
  v.children.forEach((w) => secondWalk(w, m + v.mod, layout));
}
function thirdWalk(v) {
  const children = v.children;
  let leafCount = 0;
  children.forEach((w) => {
    thirdWalk(w);
    if (w.children.length) {
      leafCount += w.leafCount;
    } else {
      leafCount++;
    }
  });
  v.leafCount = leafCount;
  if (children.length) {
    v.subtreeLeft = children[0].subtreeLeft;
    v.subtreeRight = children[v.children.length - 1].subtreeRight;
    v.x = (v.subtreeLeft + v.subtreeRight) / 2;
  } else {
    v.subtreeLeft = v.x;
    v.subtreeRight = v.x;
  }
}
function treeLayout(root) {
  const layout = new TreeLayout();
  firstWalk(root, 1);
  secondWalk(root, -root.prelim, layout);
  thirdWalk(root);
  return layout;
}
var TreeNode, Dimensions, TreeLayout;
var init_tree = __esm({
  "packages/ag-charts-community/src/chart/axis/tree.ts"() {
    "use strict";
    TreeNode = class {
      // current number in sibling group (index)
      constructor(label = "", parent, number = 0) {
        this.x = 0;
        this.y = 0;
        this.subtreeLeft = NaN;
        this.subtreeRight = NaN;
        this.screenX = 0;
        this.screenY = 0;
        this.children = [];
        this.leafCount = 0;
        this.prelim = 0;
        this.mod = 0;
        this.ancestor = this;
        this.change = 0;
        this.shift = 0;
        this.label = label;
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        this.number = number;
      }
      getLeftSibling() {
        return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : void 0;
      }
      getLeftmostSibling() {
        return this.number > 0 && this.parent ? this.parent.children[0] : void 0;
      }
      // traverse the left contour of a subtree, return the successor of v on this contour
      nextLeft() {
        return this.children ? this.children[0] : this.thread;
      }
      // traverse the right contour of a subtree, return the successor of v on this contour
      nextRight() {
        return this.children ? this.children[this.children.length - 1] : this.thread;
      }
      getSiblings() {
        return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];
      }
    };
    Dimensions = class {
      constructor() {
        this.top = Infinity;
        this.right = -Infinity;
        this.bottom = -Infinity;
        this.left = Infinity;
      }
      update(node, xy) {
        const { x, y } = xy(node);
        if (x > this.right) {
          this.right = x;
        }
        if (x < this.left) {
          this.left = x;
        }
        if (y > this.bottom) {
          this.bottom = y;
        }
        if (y < this.top) {
          this.top = y;
        }
      }
    };
    TreeLayout = class {
      constructor() {
        this.dimensions = new Dimensions();
        this.leafCount = 0;
        this.nodes = [];
        // One might want to process leaf nodes separately from the rest of the tree.
        // For example, position labels corresponding to leafs vertically, rather than horizontally.
        this.leafNodes = [];
        this.nonLeafNodes = [];
        this.depth = 0;
      }
      update(node) {
        this.dimensions.update(node, (n) => ({ x: n.x, y: n.y }));
        if (node.children.length) {
          this.nonLeafNodes.push(node);
        } else {
          this.leafCount++;
          this.leafNodes.push(node);
        }
        if (node.depth > this.depth) {
          this.depth = node.depth;
        }
        this.nodes.push(node);
      }
      resize(width, height, shiftX = 0, shiftY = 0, flipX = false) {
        const xSteps = this.leafCount - 1;
        const ySteps = this.depth;
        const dimensions = this.dimensions;
        let scalingX = 1;
        let scalingY = 1;
        if (width > 0 && xSteps) {
          const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;
          const desiredSpacingX = width / xSteps;
          scalingX = desiredSpacingX / existingSpacingX;
          if (flipX) {
            scalingX = -scalingX;
          }
        }
        if (height > 0 && ySteps) {
          const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;
          const desiredSpacingY = height / ySteps;
          scalingY = desiredSpacingY / existingSpacingY;
        }
        const screenDimensions = new Dimensions();
        this.nodes.forEach((node) => {
          node.screenX = node.x * scalingX;
          node.screenY = node.y * scalingY;
          screenDimensions.update(node, (n) => ({ x: n.screenX, y: n.screenY }));
        });
        const offsetX = -screenDimensions.left;
        const offsetY = -screenDimensions.top;
        this.nodes.forEach((node) => {
          node.screenX += offsetX + shiftX;
          node.screenY += offsetY + shiftY;
        });
      }
    };
  }
});

// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts
var GroupedCategoryAxisLabel, GroupedCategoryAxis;
var init_groupedCategoryAxis = __esm({
  "packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts"() {
    "use strict";
    init_bandScale();
    init_bbox();
    init_matrix();
    init_selection();
    init_line();
    init_text();
    init_angle();
    init_array();
    init_type_guards();
    init_validation();
    init_chartAxisDirection();
    init_label();
    init_axisLabel();
    init_axisLine();
    init_cartesianAxis();
    init_categoryAxis();
    init_tree();
    GroupedCategoryAxisLabel = class extends AxisLabel {
      constructor() {
        super(...arguments);
        this.grid = false;
      }
    };
    __decorateClass([
      Validate(BOOLEAN)
    ], GroupedCategoryAxisLabel.prototype, "grid", 2);
    GroupedCategoryAxis = class extends CartesianAxis {
      constructor(moduleCtx) {
        super(moduleCtx, new BandScale());
        // Label scale (labels are positioned between ticks, tick count = label count + 1).
        // We don't call is `labelScale` for consistency with other axes.
        this.tickScale = new BandScale();
        this.line = new AxisLine();
        this.label = new GroupedCategoryAxisLabel();
        this.labelColor = "rgba(87, 87, 87, 1)";
        this.includeInvisibleDomains = true;
        const { tickLineGroup, tickLabelGroup, gridLineGroup, tickScale, scale: scale2 } = this;
        scale2.paddingOuter = 0.1;
        scale2.paddingInner = scale2.paddingOuter * 2;
        this.refreshScale();
        tickScale.paddingInner = 1;
        tickScale.paddingOuter = 0;
        this.gridLineSelection = Selection.select(gridLineGroup, Line);
        this.axisLineSelection = Selection.select(tickLineGroup, Line);
        this.separatorSelection = Selection.select(tickLineGroup, Line);
        this.labelSelection = Selection.select(tickLabelGroup, Text);
      }
      updateRange() {
        const { range: rr, visibleRange: vr, scale: scale2 } = this;
        const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);
        const shift = span * vr[0];
        const start = rr[0] - shift;
        this.tickScale.range = scale2.range = [start, start + span];
        this.resizeTickTree();
      }
      resizeTickTree() {
        var _a2;
        const s = this.scale;
        const range4 = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;
        const layout = this.tickTreeLayout;
        const lineHeight = this.lineHeight;
        if (layout) {
          layout.resize(
            Math.abs(range4[1] - range4[0]),
            layout.depth * lineHeight,
            (Math.min(range4[0], range4[1]) || 0) + ((_a2 = s.bandwidth) != null ? _a2 : 0) / 2,
            -layout.depth * lineHeight,
            range4[1] - range4[0] < 0
          );
        }
      }
      get lineHeight() {
        return this.label.fontSize * 1.5;
      }
      /**
       * The length of the grid. The grid is only visible in case of a non-zero value.
       */
      onGridVisibilityChange() {
        this.gridLineSelection.clear();
        this.labelSelection.clear();
      }
      createTick() {
        return new CategoryAxisTick();
      }
      calculateDomain() {
        var _a2;
        const { direction } = this;
        let isNumericX = null;
        const flatDomains = this.boundSeries.filter((s) => s.visible).flatMap((series) => {
          if (direction === "y" /* Y */ || isNumericX) {
            return series.getDomain(direction);
          }
          if (isNumericX === null) {
            const domain2 = series.getDomain(direction);
            isNumericX = isNumber(domain2[0]);
            return domain2;
          }
          return [];
        });
        this.setDomain((_a2 = extent(flatDomains)) != null ? _a2 : unique(flatDomains));
        const { domain } = this.dataDomain;
        this.tickTreeLayout = treeLayout(ticksToTree(domain));
        this.tickScale.domain = domain.concat("");
        this.resizeTickTree();
      }
      /**
       * Creates/removes/updates the scene graph nodes that constitute the axis.
       * Supposed to be called _manually_ after changing _any_ of the axis properties.
       * This allows to bulk set axis properties before updating the nodes.
       * The node changes made by this method are rendered on the next animation frame.
       * We could schedule this method call automatically on the next animation frame
       * when any of the axis properties change (the way we do when properties of scene graph's
       * nodes change), but this will mean that we first wait for the next animation
       * frame to make changes to the nodes of the axis, then wait for another animation
       * frame to render those changes. It's nice to have everything update automatically,
       * but this extra level of async indirection will not just introduce an unwanted delay,
       * it will also make it harder to reason about the program.
       */
      update() {
        if (!this.computedLayout) {
          return;
        }
        this.updatePosition();
        this.updateTitleCaption();
        this.updateCategoryLabels();
        this.updateSeparators();
        this.updateAxisLines();
        this.updateCategoryGridLines();
        this.resetSelectionNodes();
      }
      updateTitleCaption() {
        const { _titleCaption } = this;
        _titleCaption.node.visible = false;
      }
      updateCategoryLabels() {
        if (!this.computedLayout)
          return;
        const { tickLabelLayout } = this.computedLayout;
        const labelSelection = this.labelSelection.update(tickLabelLayout);
        labelSelection.each((node, datum) => {
          node.setProperties(datum);
        });
      }
      updateSeparators() {
        if (!this.computedLayout)
          return;
        const { separatorLayout } = this.computedLayout;
        const { range: range4 } = this;
        const epsilon2 = 1e-7;
        const separatorSelection = this.separatorSelection.update(separatorLayout);
        separatorSelection.each((line, datum) => {
          line.x1 = datum.x1;
          line.x2 = datum.x2;
          line.y1 = datum.y;
          line.y2 = datum.y;
          line.visible = datum.y >= range4[0] - epsilon2 && datum.y <= range4[1] + epsilon2;
          line.stroke = this.tick.color;
          line.fill = void 0;
          line.strokeWidth = 1;
        });
      }
      updateAxisLines() {
        if (!this.computedLayout)
          return;
        const { axisLineLayout } = this.computedLayout;
        const axisLineSelection = this.axisLineSelection.update(axisLineLayout);
        axisLineSelection.each((line, datum) => {
          line.setProperties(__spreadProps(__spreadValues({}, datum), {
            stroke: this.line.color,
            strokeWidth: this.line.width
          }));
          line.x1 = datum.x;
          line.x2 = datum.x;
          line.y1 = datum.y1;
          line.y2 = datum.y2;
          line.strokeWidth = this.line.width;
          line.stroke = this.line.color;
        });
      }
      updateCategoryGridLines() {
        const { gridLength, gridLine, label, range: range4, tickScale } = this;
        const ticks = tickScale.ticks();
        const sideFlag = label.getSideFlag();
        const gridSelection = this.gridLineSelection.update(gridLength ? ticks : []);
        if (gridLength) {
          const { width, style } = gridLine;
          const styleCount = style.length;
          gridSelection.each((line, datum, index) => {
            const y = Math.round(tickScale.convert(datum));
            line.x1 = 0;
            line.x2 = -sideFlag * gridLength;
            line.y1 = y;
            line.y2 = y;
            line.visible = y >= range4[0] && y <= range4[1];
            const { stroke, lineDash } = style[index % styleCount];
            line.stroke = stroke;
            line.strokeWidth = width;
            line.lineDash = lineDash;
            line.fill = void 0;
          });
        }
      }
      computeLayout() {
        this.updateDirection();
        this.calculateDomain();
        this.updateRange();
        const {
          scale: scale2,
          label,
          label: { parallel },
          moduleCtx: { callbackCache },
          range: range4,
          title,
          title: { formatter = (p) => p.defaultValue } = {}
        } = this;
        const rangeStart = scale2.range[0];
        const rangeEnd = scale2.range[1];
        const rangeLength = Math.abs(rangeEnd - rangeStart);
        const bandwidth = rangeLength / scale2.domain.length || 0;
        const keepEvery = Math.ceil(label.fontSize / bandwidth);
        const rotation = toRadians(this.rotation);
        const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;
        const sideFlag = label.getSideFlag();
        const lineHeight = this.lineHeight;
        const tickTreeLayout = this.tickTreeLayout;
        const labels = scale2.ticks();
        const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];
        const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;
        const { defaultRotation, configuredRotation, parallelFlipFlag } = calculateLabelRotation({
          rotation: label.rotation,
          parallel,
          regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),
          parallelFlipRotation: normalizeAngle360(rotation)
        });
        const tickLabelLayout = [];
        const copyLabelProps = (node) => {
          return {
            fill: node.fill,
            fontFamily: node.fontFamily,
            fontSize: node.fontSize,
            fontStyle: node.fontStyle,
            fontWeight: node.fontWeight,
            rotation: node.rotation,
            rotationCenterX: node.rotationCenterX,
            rotationCenterY: node.rotationCenterY,
            text: node.text,
            textAlign: node.textAlign,
            textBaseline: node.textBaseline,
            translationX: node.translationX,
            translationY: node.translationY,
            visible: node.visible,
            x: node.x,
            y: node.y
          };
        };
        const labelBBoxes = /* @__PURE__ */ new Map();
        let maxLeafLabelWidth = 0;
        const tempText2 = new Text();
        const setLabelProps = (datum, index) => {
          var _a2;
          tempText2.setProperties({
            fill: label.color,
            fontFamily: label.fontFamily,
            fontSize: label.fontSize,
            fontStyle: label.fontStyle,
            fontWeight: label.fontWeight,
            textAlign: "center",
            textBaseline: parallelFlipFlag === -1 ? "bottom" : "hanging",
            translationX: datum.screenY - label.fontSize * 0.25,
            translationY: datum.screenX
          });
          if (index === 0) {
            const isCaptionEnabled = (title == null ? void 0 : title.enabled) && labels.length > 0;
            if (!isCaptionEnabled) {
              return false;
            }
            const text = callbackCache.call(formatter, this.getTitleFormatterParams());
            tempText2.setProperties({
              fill: title.color,
              fontFamily: title.fontFamily,
              fontSize: title.fontSize,
              fontStyle: title.fontStyle,
              fontWeight: title.fontWeight,
              text,
              textBaseline: "hanging",
              translationX: datum.screenY - label.fontSize * 0.25,
              translationY: datum.screenX
            });
          } else if (index % keepEvery === 0) {
            const isInRange = datum.screenX >= range4[0] && datum.screenX <= range4[1];
            if (!isInRange) {
              return false;
            }
            if (label.formatter) {
              tempText2.text = (_a2 = callbackCache.call(label.formatter, {
                value: String(datum.label),
                index
              })) != null ? _a2 : String(datum.label);
            } else {
              tempText2.text = String(datum.label);
            }
          } else {
            return false;
          }
          return true;
        };
        treeLabels.forEach((datum, index) => {
          const isVisible = setLabelProps(datum, index);
          if (!isVisible)
            return;
          const bbox2 = tempText2.computeTransformedBBox();
          if (!bbox2)
            return;
          labelBBoxes.set(index, bbox2);
          const isLeaf = !datum.children.length;
          if (isLeaf && bbox2.width > maxLeafLabelWidth) {
            maxLeafLabelWidth = bbox2.width;
          }
        });
        const labelX = sideFlag * label.padding;
        const labelGrid = this.label.grid;
        const separatorData = [];
        treeLabels.forEach((datum, index) => {
          let visible = setLabelProps(datum, index);
          const id = index;
          tempText2.x = labelX;
          tempText2.rotationCenterX = labelX;
          const isLeaf = !datum.children.length;
          if (isLeaf) {
            tempText2.rotation = configuredRotation;
            tempText2.textAlign = "end";
            tempText2.textBaseline = "middle";
          } else {
            tempText2.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;
            const availableRange = datum.leafCount * bandwidth;
            const bbox2 = labelBBoxes.get(id);
            if (bbox2 && bbox2.width > availableRange) {
              visible = false;
              labelBBoxes.delete(id);
            } else if (isHorizontal) {
              tempText2.rotation = defaultRotation;
            } else {
              tempText2.rotation = -Math.PI / 2;
            }
          }
          if (datum.parent && isLabelTree) {
            const y = isLeaf ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;
            if (isLeaf) {
              if (datum.number !== datum.children.length - 1 || labelGrid) {
                separatorData.push({
                  y,
                  x1: 0,
                  x2: -maxLeafLabelWidth - this.label.padding * 2
                });
              }
            } else {
              const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;
              separatorData.push({
                y,
                x1: x + lineHeight,
                x2: x
              });
            }
          }
          let props;
          if (visible) {
            const bbox2 = tempText2.computeTransformedBBox();
            if (bbox2) {
              labelBBoxes.set(index, bbox2);
            }
            props = __spreadProps(__spreadValues({}, copyLabelProps(tempText2)), { visible });
          } else {
            labelBBoxes.delete(index);
            props = { visible };
          }
          tickLabelLayout.push(props);
        });
        let minX = 0;
        separatorData.forEach((d) => minX = Math.min(minX, d.x2));
        separatorData.push({
          y: Math.max(rangeStart, rangeEnd),
          x1: 0,
          x2: minX
        });
        const separatorLayout = [];
        const separatorBoxes = [];
        const epsilon2 = 1e-7;
        separatorData.forEach((datum) => {
          if (datum.y >= range4[0] - epsilon2 && datum.y <= range4[1] + epsilon2) {
            const { x1, x2, y } = datum;
            const separatorBox = new BBox(Math.min(x1, x2), y, Math.abs(x1 - x2), 0);
            separatorBoxes.push(separatorBox);
            separatorLayout.push({ x1, x2, y });
          }
        });
        const axisLineLayout = [];
        const axisLineBoxes = [];
        const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;
        for (let i = 0; i < lineCount; i++) {
          const visible = labels.length > 0 && (i === 0 || labelGrid && isLabelTree);
          const x = i > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (i - 1) * lineHeight : 0;
          const lineBox = new BBox(x, Math.min(...range4), 0, Math.abs(range4[1] - range4[0]));
          axisLineBoxes.push(lineBox);
          axisLineLayout.push({ x, y1: range4[0], y2: range4[1], visible });
        }
        const getTransformBox = (bbox2) => {
          const matrix = new Matrix();
          const {
            rotation: axisRotation,
            translationX,
            translationY,
            rotationCenterX,
            rotationCenterY
          } = this.getAxisTransform();
          Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {
            scalingCenterX: 0,
            scalingCenterY: 0,
            rotationCenterX,
            rotationCenterY
          });
          return matrix.transformBBox(bbox2);
        };
        const bbox = BBox.merge([...labelBBoxes.values(), ...separatorBoxes, ...axisLineBoxes]);
        const transformedBBox = getTransformBox(bbox);
        return {
          bbox: transformedBBox,
          tickLabelLayout,
          separatorLayout,
          axisLineLayout
        };
      }
      calculateLayout() {
        const { axisLineLayout, separatorLayout, tickLabelLayout, bbox } = this.computeLayout();
        this.computedLayout = {
          axisLineLayout,
          separatorLayout,
          tickLabelLayout
        };
        return { bbox, primaryTickCount: void 0 };
      }
    };
    GroupedCategoryAxis.className = "GroupedCategoryAxis";
    GroupedCategoryAxis.type = "grouped-category";
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], GroupedCategoryAxis.prototype, "labelColor", 2);
  }
});

// packages/ag-charts-community/src/util/userAgent.ts
function hasConstrainedCanvasMemory() {
  if (typeof navigator === "undefined") {
    return false;
  }
  const iPhoneOSMatch = navigator.userAgent.match(/\(iPhone; CPU iPhone OS (\d+_\d+_\d+) like Mac OS X\)/);
  if (iPhoneOSMatch == null) {
    return false;
  }
  const [major, minor] = iPhoneOSMatch[1].split("_").map(Number);
  return major < 16 || major === 16 && minor < 6;
}
var init_userAgent = __esm({
  "packages/ag-charts-community/src/util/userAgent.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts
var _HdpiCanvas, HdpiCanvas;
var init_hdpiCanvas = __esm({
  "packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts"() {
    "use strict";
    init_debug();
    init_dom();
    init_proxy();
    init_userAgent();
    _HdpiCanvas = class _HdpiCanvas {
      constructor(options) {
        this.enabled = true;
        this.width = 600;
        this.height = 300;
        const { width, height, pixelRatio, position, insertAsFirstChild } = options;
        this.insertAsFirstChild = insertAsFirstChild != null ? insertAsFirstChild : false;
        this.pixelRatio = hasConstrainedCanvasMemory() ? 1 : pixelRatio != null ? pixelRatio : getWindow("devicePixelRatio");
        this.element = createElement("canvas");
        this.element.width = Math.round((width != null ? width : this.width) * this.pixelRatio);
        this.element.height = Math.round((height != null ? height : this.height) * this.pixelRatio);
        if (position) {
          this.element.style.position = position;
        }
        this.context = this.element.getContext("2d");
        this.onEnabledChange();
        this.resize(width != null ? width : 0, height != null ? height : 0);
        _HdpiCanvas.debugContext(this.context);
      }
      static is(value) {
        return value instanceof _HdpiCanvas;
      }
      drawImage(context, dx2 = 0, dy2 = 0) {
        return context.drawImage(this.context.canvas, dx2, dy2);
      }
      toDataURL(type) {
        return this.element.toDataURL(type);
      }
      resize(width, height) {
        if (!(width > 0 && height > 0))
          return;
        const { element: element2, context, pixelRatio } = this;
        element2.width = Math.round(width * pixelRatio);
        element2.height = Math.round(height * pixelRatio);
        context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        element2.style.width = width + "px";
        element2.style.height = height + "px";
        this.width = width;
        this.height = height;
      }
      snapshot() {
      }
      clear() {
        this.context.save();
        this.context.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);
        this.context.clearRect(0, 0, this.width, this.height);
        this.context.restore();
      }
      destroy() {
        this.element.remove();
        this.element.width = 0;
        this.element.height = 0;
        this.context.clearRect(0, 0, 0, 0);
        Object.freeze(this);
      }
      onContainerChange(newValue, oldValue) {
        var _a2, _b, _c, _d;
        if (newValue === oldValue)
          return;
        (_a2 = this.element.parentNode) == null ? void 0 : _a2.removeChild(this.element);
        if (this.insertAsFirstChild && ((_b = this.container) == null ? void 0 : _b.firstChild)) {
          (_c = this.container) == null ? void 0 : _c.insertBefore(this.element, this.container.firstChild);
        } else {
          (_d = this.container) == null ? void 0 : _d.appendChild(this.element);
        }
      }
      onEnabledChange() {
        if (this.element) {
          this.element.style.display = this.enabled ? "block" : "none";
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
      static debugContext(ctx) {
        if (Debug.check("canvas")) {
          const save = ctx.save.bind(ctx);
          const restore = ctx.restore.bind(ctx);
          let depth = 0;
          Object.assign(ctx, {
            save() {
              save();
              depth++;
            },
            restore() {
              if (depth === 0) {
                throw new Error("AG Charts - Unable to restore() past depth 0");
              }
              restore();
              depth--;
            },
            verifyDepthZero() {
              if (depth !== 0) {
                throw new Error(`AG Charts - Save/restore depth is non-zero: ${depth}`);
              }
            }
          });
        }
      }
    };
    __decorateClass([
      ObserveChanges((target) => target.onEnabledChange())
    ], _HdpiCanvas.prototype, "enabled", 2);
    __decorateClass([
      ObserveChanges((target, newValue, oldValue) => target.onContainerChange(newValue, oldValue))
    ], _HdpiCanvas.prototype, "container", 2);
    HdpiCanvas = _HdpiCanvas;
  }
});

// packages/ag-charts-community/src/scene/layersManager.ts
var LayersManager;
var init_layersManager = __esm({
  "packages/ag-charts-community/src/scene/layersManager.ts"() {
    "use strict";
    init_compare();
    init_debug();
    init_hdpiCanvas();
    LayersManager = class _LayersManager {
      constructor(canvas, markDirty) {
        this.canvas = canvas;
        this.markDirty = markDirty;
        this.debug = Debug.create(true, "scene");
        this.layersMap = /* @__PURE__ */ new Map();
        this.nextZIndex = 0;
        this.nextLayerId = 0;
      }
      static sortLayers(a, b) {
        var _a2, _b;
        return compoundAscending(
          [a.zIndex, ...(_a2 = a.zIndexSubOrder) != null ? _a2 : [void 0, void 0], a.id],
          [b.zIndex, ...(_b = b.zIndexSubOrder) != null ? _b : [void 0, void 0], b.id],
          ascendingStringNumberUndefined
        );
      }
      get size() {
        return this.layersMap.size;
      }
      forEach(callback) {
        Array.from(this.layersMap.values()).sort(_LayersManager.sortLayers).forEach(callback);
      }
      resize(width, height) {
        this.canvas.resize(width, height);
        this.layersMap.forEach(({ canvas }) => canvas.resize(width, height));
      }
      addLayer(opts) {
        const { width, height, pixelRatio } = this.canvas;
        const { zIndex = this.nextZIndex++, name, zIndexSubOrder, getComputedOpacity, getVisibility } = opts;
        const canvas = new HdpiCanvas({ width, height, pixelRatio, position: "absolute" });
        const newLayer = {
          id: this.nextLayerId++,
          name,
          canvas,
          zIndex,
          zIndexSubOrder,
          getComputedOpacity,
          getVisibility
        };
        if (zIndex >= this.nextZIndex) {
          this.nextZIndex = zIndex + 1;
        }
        this.layersMap.set(canvas, newLayer);
        this.debug("Scene.addLayer() - layers", this.layersMap);
        return newLayer.canvas;
      }
      removeLayer(canvas) {
        if (this.layersMap.has(canvas)) {
          this.layersMap.delete(canvas);
          canvas.destroy();
          this.markDirty();
          this.debug("Scene.removeLayer() -  layers", this.layersMap);
        }
      }
      moveLayer(canvas, newZIndex, newZIndexSubOrder) {
        const layer = this.layersMap.get(canvas);
        if (layer) {
          layer.zIndex = newZIndex;
          layer.zIndexSubOrder = newZIndexSubOrder;
          this.markDirty();
          this.debug("Scene.moveLayer() -  layers", this.layersMap);
        }
      }
      clear() {
        this.layersMap.clear();
      }
    };
  }
});

// packages/ag-charts-community/src/scene/sceneDebug.ts
function debugStats(layersManager, debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}) {
  if (!Debug.check("scene:stats" /* SCENE_STATS */, "scene:stats:verbose" /* SCENE_STATS_VERBOSE */))
    return;
  const { layersRendered = 0, layersSkipped = 0, nodesRendered = 0, nodesSkipped = 0 } = renderCtxStats != null ? renderCtxStats : {};
  const end = performance.now();
  const _a2 = debugSplitTimes, { start } = _a2, durations = __objRest(_a2, ["start"]);
  const splits = Object.entries(durations).map(([n, t]) => {
    return time(n, t);
  }).filter((v) => v != null).join(" + ");
  const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${v}`).join(" ; ");
  const detailedStats = Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */);
  const stats = [
    `${time("\u23F1\uFE0F", start, end)} (${splits})`,
    `${extras}`,
    `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : layersManager.size}`,
    detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null
  ].filter(isString);
  const statsSize = new Map(stats.map((t) => [t, Text.getTextSize(t, ctx.font)]));
  const width = Math.max(...Array.from(statsSize.values(), (s) => s.width));
  const height = accumulate(statsSize.values(), (s) => s.height);
  ctx.save();
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, width, height);
  ctx.fillStyle = "black";
  let y = 0;
  for (const [stat, size] of statsSize.entries()) {
    y += size.height;
    ctx.fillText(stat, 2, y);
  }
  ctx.restore();
}
function debugSceneNodeHighlight(ctx, debugNodes) {
  ctx.save();
  for (const [name, node] of Object.entries(debugNodes)) {
    const bbox = node.computeTransformedBBox();
    if (!bbox) {
      Logger.log(`Scene.render() - no bbox for debugged node [${name}].`);
      continue;
    }
    ctx.globalAlpha = 0.8;
    ctx.strokeStyle = "red";
    ctx.lineWidth = 1;
    ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);
    ctx.fillStyle = "red";
    ctx.strokeStyle = "white";
    ctx.font = "16px sans-serif";
    ctx.textBaseline = "top";
    ctx.textAlign = "left";
    ctx.lineWidth = 2;
    ctx.strokeText(name, bbox.x, bbox.y, bbox.width);
    ctx.fillText(name, bbox.x, bbox.y, bbox.width);
  }
  ctx.restore();
}
function buildTree(node) {
  var _a2, _b;
  if (!Debug.check(true, "scene" /* SCENE */))
    return {};
  return __spreadValues(__spreadValues({
    node,
    name: (_a2 = node instanceof Group ? node.name : null) != null ? _a2 : node.id,
    dirty: RedrawType[node.dirty]
  }, ((_b = node.parent) == null ? void 0 : _b.isVirtual) ? {
    virtualParentDirty: RedrawType[node.parent.dirty],
    virtualParent: node.parent
  } : {}), node.children.map((c) => buildTree(c)).reduce((result, childTree) => {
    let { name: treeNodeName } = childTree;
    const {
      node: { visible, opacity, zIndex, zIndexSubOrder },
      node: childNode,
      virtualParent
    } = childTree;
    if (!visible || opacity <= 0) {
      treeNodeName = `(${treeNodeName})`;
    }
    if (childNode instanceof Group && childNode.isLayer()) {
      treeNodeName = `*${treeNodeName}*`;
    }
    const key = [
      `${treeNodeName != null ? treeNodeName : "<unknown>"}`,
      `z: ${zIndex}`,
      zIndexSubOrder && `zo: ${zIndexSubOrder.map((v) => typeof v === "function" ? `${v()} (fn)` : v).join(" / ")}`,
      virtualParent && `(virtual parent)`
    ].filter((v) => !!v).join(" ");
    let selectedKey = key;
    let index = 1;
    while (result[selectedKey] != null && index < 100) {
      selectedKey = `${key} (${index++})`;
    }
    result[selectedKey] = childTree;
    return result;
  }, {}));
}
function buildDirtyTree(node) {
  var _a2;
  if (node.dirty === 0 /* NONE */) {
    return { dirtyTree: {}, paths: [] };
  }
  const childrenDirtyTree = node.children.map((c) => buildDirtyTree(c)).filter((c) => c.paths.length > 0);
  const name = Group.is(node) ? (_a2 = node.name) != null ? _a2 : node.id : node.id;
  const paths = childrenDirtyTree.length ? childrenDirtyTree.flatMap((c) => c.paths).map((p) => `${name}.${p}`) : [name];
  return {
    dirtyTree: __spreadValues({
      name,
      node,
      dirty: RedrawType[node.dirty]
    }, childrenDirtyTree.map((c) => c.dirtyTree).filter((t) => t.dirty != null).reduce((result, childTree) => {
      var _a3;
      result[(_a3 = childTree.name) != null ? _a3 : "<unknown>"] = childTree;
      return result;
    }, {})),
    paths
  };
}
function pct(rendered, skipped) {
  const total = rendered + skipped;
  return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;
}
function time(name, start, end) {
  const duration = end != null ? end - start : start;
  return `${name}: ${Math.round(duration * 100) / 100}ms`;
}
function accumulate(iterator, mapper) {
  let sum2 = 0;
  for (const item of iterator) {
    sum2 += mapper(item);
  }
  return sum2;
}
var init_sceneDebug = __esm({
  "packages/ag-charts-community/src/scene/sceneDebug.ts"() {
    "use strict";
    init_debug();
    init_logger();
    init_type_guards();
    init_group();
    init_node();
    init_text();
  }
});

// packages/ag-charts-community/src/scene/scene.ts
var Scene;
var init_scene = __esm({
  "packages/ag-charts-community/src/scene/scene.ts"() {
    "use strict";
    init_debug();
    init_dom();
    init_id();
    init_hdpiCanvas();
    init_layersManager();
    init_node();
    init_sceneDebug();
    Scene = class {
      constructor({ width, height, pixelRatio, canvasPosition }) {
        this.debug = Debug.create(true, "scene" /* SCENE */);
        this.id = createId(this);
        this.root = null;
        this.isDirty = false;
        this.canvas = new HdpiCanvas({
          width,
          height,
          pixelRatio,
          position: canvasPosition,
          insertAsFirstChild: canvasPosition === "absolute"
        });
        this.layersManager = new LayersManager(this.canvas, () => {
          this.isDirty = true;
        });
      }
      get width() {
        var _a2, _b;
        return (_b = (_a2 = this.pendingSize) == null ? void 0 : _a2[0]) != null ? _b : this.canvas.width;
      }
      get height() {
        var _a2, _b;
        return (_b = (_a2 = this.pendingSize) == null ? void 0 : _a2[1]) != null ? _b : this.canvas.height;
      }
      setContainer(value) {
        this.canvas.container = value;
        return this;
      }
      setRoot(node) {
        var _a2;
        if (this.root === node) {
          return this;
        }
        this.isDirty = true;
        (_a2 = this.root) == null ? void 0 : _a2._setLayerManager();
        this.root = node;
        if (node) {
          node.visible = true;
          node._setLayerManager(this.layersManager);
        }
        return this;
      }
      attachNode(node) {
        var _a2;
        (_a2 = this.root) == null ? void 0 : _a2.appendChild(node);
        return () => this.removeChild(node);
      }
      appendChild(node) {
        var _a2;
        (_a2 = this.root) == null ? void 0 : _a2.appendChild(node);
        return this;
      }
      removeChild(node) {
        var _a2;
        (_a2 = this.root) == null ? void 0 : _a2.removeChild(node);
        return this;
      }
      download(fileName, fileFormat) {
        var _a2;
        downloadUrl(this.canvas.toDataURL(fileFormat), (_a2 = fileName == null ? void 0 : fileName.trim()) != null ? _a2 : "image");
      }
      /** NOTE: Integrated Charts undocumented image download method. */
      getDataURL(fileFormat) {
        return this.canvas.toDataURL(fileFormat);
      }
      resize(width, height) {
        width = Math.round(width);
        height = Math.round(height);
        if (width > 0 && height > 0 && (width !== this.width || height !== this.height)) {
          this.pendingSize = [width, height];
          this.isDirty = true;
          return true;
        }
        return false;
      }
      render(opts) {
        return __async(this, null, function* () {
          var _a2, _b;
          const { debugSplitTimes = { start: performance.now() }, extraDebugStats } = opts != null ? opts : {};
          const { canvas, canvas: { context: ctx } = {}, root, pendingSize } = this;
          if (!ctx) {
            return;
          }
          const renderStartTime = performance.now();
          if (pendingSize) {
            this.layersManager.resize(...pendingSize);
            this.pendingSize = void 0;
          }
          if (root && !root.visible) {
            this.isDirty = false;
            return;
          }
          if (root && !this.isDirty) {
            if (this.debug.check()) {
              this.debug("Scene.render() - no-op", {
                redrawType: RedrawType[root.dirty],
                tree: buildTree(root)
              });
            }
            debugStats(this.layersManager, debugSplitTimes, ctx, void 0, extraDebugStats);
            return;
          }
          const renderCtx = {
            ctx,
            devicePixelRatio: (_a2 = this.canvas.pixelRatio) != null ? _a2 : 1,
            forceRender: true,
            resized: Boolean(pendingSize),
            debugNodes: {}
          };
          if (Debug.check("scene:stats:verbose" /* SCENE_STATS_VERBOSE */)) {
            renderCtx.stats = { layersRendered: 0, layersSkipped: 0, nodesRendered: 0, nodesSkipped: 0 };
          }
          let canvasCleared = false;
          if (!root || root.dirty >= 1 /* TRIVIAL */) {
            canvasCleared = true;
            canvas.clear();
          }
          if (root && Debug.check("scene:dirtyTree" /* SCENE_DIRTY_TREE */)) {
            const { dirtyTree, paths } = buildDirtyTree(root);
            Debug.create("scene:dirtyTree" /* SCENE_DIRTY_TREE */)("Scene.render() - dirtyTree", { dirtyTree, paths });
          }
          if (root && canvasCleared) {
            this.debug("Scene.render() - before", {
              redrawType: RedrawType[root.dirty],
              canvasCleared,
              tree: buildTree(root)
            });
            if (root.visible) {
              root.preRender();
              ctx.save();
              root.render(renderCtx);
              ctx.restore();
            }
          }
          debugSplitTimes["\u270D\uFE0F"] = performance.now() - renderStartTime;
          if (this.layersManager.size && canvasCleared) {
            const layerRenderStart = performance.now();
            ctx.save();
            ctx.resetTransform();
            this.layersManager.forEach((layer) => {
              if (layer.canvas.enabled && layer.getVisibility()) {
                ctx.globalAlpha = layer.getComputedOpacity();
                layer.canvas.drawImage(ctx);
              }
            });
            ctx.restore();
            debugSplitTimes["\u26D9"] = performance.now() - layerRenderStart;
          }
          (_b = ctx.verifyDepthZero) == null ? void 0 : _b.call(ctx);
          this.isDirty = false;
          debugStats(this.layersManager, debugSplitTimes, ctx, renderCtx.stats, extraDebugStats);
          debugSceneNodeHighlight(ctx, renderCtx.debugNodes);
          if (root && this.debug.check()) {
            this.debug("Scene.render() - after", {
              redrawType: RedrawType[root.dirty],
              tree: buildTree(root),
              canvasCleared
            });
          }
        });
      }
      /** Alternative to destroy() that preserves re-usable resources. */
      strip() {
        const { context, pixelRatio } = this.canvas;
        context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
        this.layersManager.clear();
        this.setRoot(null);
        this.isDirty = false;
      }
      destroy() {
        this.canvas.container = void 0;
        this.strip();
        this.canvas.destroy();
        Object.assign(this, { canvas: void 0 });
      }
    };
    Scene.className = "Scene";
  }
});

// packages/ag-charts-community/src/styles/icons.ts
var icons_default;
var init_icons = __esm({
  "packages/ag-charts-community/src/styles/icons.ts"() {
    "use strict";
    icons_default = `
[class^='ag-charts-icon'] {
    display: block;
    /* speak: none; */
    mask-size: contain;
    mask-repeat: no-repeat;
    background-color: currentColor;
}

.ag-charts-icon-zoom-in {
    mask-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20taW4iPjxjaXJjbGUgY3g9IjExIiBjeT0iMTEiIHI9IjgiLz48bGluZSB4MT0iMjEiIHgyPSIxNi42NSIgeTE9IjIxIiB5Mj0iMTYuNjUiLz48bGluZSB4MT0iMTEiIHgyPSIxMSIgeTE9IjgiIHkyPSIxNCIvPjxsaW5lIHgxPSI4IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjExIi8+PC9zdmc+);
}

.ag-charts-icon-zoom-out {
    mask-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20tb3V0Ij48Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4Ii8+PGxpbmUgeDE9IjIxIiB4Mj0iMTYuNjUiIHkxPSIyMSIgeTI9IjE2LjY1Ii8+PGxpbmUgeDE9IjgiIHgyPSIxNCIgeTE9IjExIiB5Mj0iMTEiLz48L3N2Zz4=);
}

.ag-charts-icon-reset {
    mask-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXJvdGF0ZS1jY3ciPjxwYXRoIGQ9Ik0zIDEyYTkgOSAwIDEgMCA5LTkgOS43NSA5Ljc1IDAgMCAwLTYuNzQgMi43NEwzIDgiLz48cGF0aCBkPSJNMyAzdjVoNSIvPjwvc3ZnPg==);
}

.ag-charts-icon-pan-left {
    mask-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tbGVmdCI+PHBhdGggZD0ibTE1IDE4LTYtNiA2LTYiLz48L3N2Zz4=);
}

.ag-charts-icon-pan-right {
    mask-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tcmlnaHQiPjxwYXRoIGQ9Im05IDE4IDYtNi02LTYiLz48L3N2Zz4=);
}

.ag-charts-icon-pan-start {
    mask-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tZmlyc3QiPjxwYXRoIGQ9Im0xNyAxOC02LTYgNi02Ii8+PHBhdGggZD0iTTcgNnYxMiIvPjwvc3ZnPg==);
}

.ag-charts-icon-pan-end {
    mask-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tbGFzdCI+PHBhdGggZD0ibTcgMTggNi02LTYtNiIvPjxwYXRoIGQ9Ik0xNyA2djEyIi8+PC9zdmc+);
}

`;
  }
});

// packages/ag-charts-community/src/styles/reset.ts
var reset_default;
var init_reset = __esm({
  "packages/ag-charts-community/src/styles/reset.ts"() {
    "use strict";
    reset_default = `
[class^='ag-charts'],
[class^='ag-charts']:focus,
[class^='ag-charts']:after,
[class^='ag-charts']:before {
    box-sizing: border-box;
    outline: none;
}

button[class^='ag-charts'] {
    background: none;
    border: 0;
}

`;
  }
});

// packages/ag-charts-community/src/styles/theme-default.ts
var theme_default_default;
var init_theme_default = __esm({
  "packages/ag-charts-community/src/styles/theme-default.ts"() {
    "use strict";
    theme_default_default = `
.ag-charts-theme-default,
.ag-charts-theme-default-dark {
    /* Colors */
    --ag-charts-active-color: var(--ag-active-color, #2196f3);
    --ag-charts-background-color: var(--ag-background-color, #fff);
    --ag-charts-foreground-color: var(--ag-foreground-color, #181d1f);
    --ag-charts-border-color: var(--ag-border-color, #dddddd);

    /* Sizing */
    --ag-charts-font-size: var(--ag-font-size, 14px);
    --ag-charts-size: var(--ag-grid-size, 8px);

    /* Borders */
    --ag-charts-border: var(--ag-borders, solid 1px);
    --ag-charts-border-critical: var(--ag-borders-critical, solid 1px);

    /* Toolbar */
    --ag-charts-toolbar-foreground-color: var(--ag-header-foreground-color, var(--ag-charts-foreground-color));
    --ag-charts-toolbar-background-color: var(
        --ag-header-background-color,
        color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-foreground-color) 2%)
    );
    --ag-charts-toolbar-size: var(--ag-header-height, 48px);
    --ag-charts-toolbar-padding: calc(var(--ag-charts-size) * 2);
    --ag-charts-toolbar-border: var(--ag-charts-border, solid 1px) var(--ag-charts-border-color);
    --ag-charts-toolbar-border-critical: var(--ag-charts-border-critical, solid 1px) var(--ag-charts-border-color);
    --ag-charts-toolbar-hover-color: color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 12%);
    --ag-charts-toolbar-disabled-foreground-color: var(
        --ag-disabled-foreground-color,
        color-mix(in srgb, transparent, var(--ag-charts-toolbar-foreground-color) 50%)
    );
    --ag-charts-toolbar-disabled-background-color: var(
        --ag-input-disabled-background-color,
        color-mix(in srgb, var(--ag-charts-toolbar-background-color), var(--ag-charts-toolbar-foreground-color) 6%)
    );
    --ag-charts-toolbar-gap: var(--ag-charts-size);

    /* Buttons */
    --ag-charts-button-padding: var(--ag-charts-size);
    --ag-charts-button-radius: var(--ag-border-radius, 4px);

    /* Focus Indicator */
    --ag-charts-focus-border: solid 2px var(--ag-input-focus-border-color, var(--ag-charts-active-color));
    --ag-charts-focus-border-shadow: var(--ag-input-focus-box-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-charts-focus-border) 47%));

    /* Icons */
    --ag-charts-icon-font-family: 'agChartsDefault';
    --ag-charts-icon-font-weight: normal;
    --ag-charts-icon-font-color: color-mix(in srgb, transparent, var(--ag-charts-foreground-color), 90%);
}

`;
  }
});

// packages/ag-charts-community/src/styles/theme-default-dark.ts
var theme_default_dark_default;
var init_theme_default_dark = __esm({
  "packages/ag-charts-community/src/styles/theme-default-dark.ts"() {
    "use strict";
    theme_default_dark_default = `
.ag-charts-theme-default-dark {
    /* Colors */
    --ag-charts-background-color: var(--ag-background-color, color-mix(in srgb, #fff, #182230 97%));
    --ag-charts-foreground-color: var(--ag-foreground-color, #fff);
    --ag-charts-border-color: var(--ag-border-color, rgba(255, 255, 255, 0.16));
    --ag-charts-hover-color: var(
        --ag-row-hover-color,
        color-mix(in srgb, transparent, var(--ag-charts-active-color) 20%)
    );

    /* Toolbar */
    --ag-charts-toolbar-background-color: var(--ag-header-background-color, color-mix(in srgb, #fff, #182230 93%));
}

`;
  }
});

// packages/ag-charts-community/src/styles/styles.ts
var styles_default;
var init_styles = __esm({
  "packages/ag-charts-community/src/styles/styles.ts"() {
    "use strict";
    init_icons();
    init_reset();
    init_theme_default();
    init_theme_default_dark();
    styles_default = `
/* Reset */
${reset_default}

/* Icons */
${icons_default}

/* AG Charts Theme Default */
${theme_default_default}

/* AG Charts Theme Default Dark */
${theme_default_dark_default}
`;
  }
});

// packages/ag-charts-community/src/util/async.ts
function sleep(sleepTimeoutMs) {
  return new Promise((resolve) => {
    setTimeout(() => resolve(void 0), sleepTimeoutMs);
  });
}
var init_async = __esm({
  "packages/ag-charts-community/src/util/async.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/util/mutex.ts
var Mutex;
var init_mutex = __esm({
  "packages/ag-charts-community/src/util/mutex.ts"() {
    "use strict";
    init_logger();
    Mutex = class {
      constructor() {
        this.available = true;
        this.acquireQueue = [];
      }
      acquire(cb) {
        return new Promise((resolve) => {
          this.acquireQueue.push([cb, resolve]);
          if (this.available) {
            this.dispatchNext().catch((e) => Logger.errorOnce(e));
          }
        });
      }
      acquireImmediately(cb) {
        return __async(this, null, function* () {
          if (!this.available) {
            return false;
          }
          yield this.acquire(cb);
          return true;
        });
      }
      waitForClearAcquireQueue() {
        return __async(this, null, function* () {
          return this.acquire(() => __async(this, null, function* () {
            return void 0;
          }));
        });
      }
      dispatchNext() {
        return __async(this, null, function* () {
          var _a2, _b;
          this.available = false;
          let [next, done] = (_a2 = this.acquireQueue.shift()) != null ? _a2 : [];
          while (next) {
            try {
              yield next();
              done == null ? void 0 : done();
            } catch (error) {
              Logger.error("mutex callback error", error);
              done == null ? void 0 : done();
            }
            [next, done] = (_b = this.acquireQueue.shift()) != null ? _b : [];
          }
          this.available = true;
        });
      }
    };
  }
});

// packages/ag-charts-community/src/util/observable.ts
var Observable;
var init_observable = __esm({
  "packages/ag-charts-community/src/util/observable.ts"() {
    "use strict";
    Observable = class {
      constructor() {
        this.eventListeners = /* @__PURE__ */ new Map();
      }
      addEventListener(eventType, listener) {
        if (typeof listener !== "function") {
          throw new Error("AG Charts - listener must be a Function");
        }
        const eventTypeListeners = this.eventListeners.get(eventType);
        if (eventTypeListeners) {
          eventTypeListeners.add(listener);
        } else {
          this.eventListeners.set(eventType, /* @__PURE__ */ new Set([listener]));
        }
      }
      removeEventListener(type, listener) {
        var _a2;
        (_a2 = this.eventListeners.get(type)) == null ? void 0 : _a2.delete(listener);
        if (this.eventListeners.size === 0) {
          this.eventListeners.delete(type);
        }
      }
      hasEventListener(type) {
        return this.eventListeners.has(type);
      }
      clearEventListeners() {
        this.eventListeners.clear();
      }
      fireEvent(event) {
        var _a2;
        (_a2 = this.eventListeners.get(event.type)) == null ? void 0 : _a2.forEach((listener) => listener(event));
      }
    };
  }
});

// packages/ag-charts-community/src/util/padding.ts
var Padding;
var init_padding = __esm({
  "packages/ag-charts-community/src/util/padding.ts"() {
    "use strict";
    init_properties();
    init_validation();
    Padding = class extends BaseProperties {
      constructor(top = 0, right = top, bottom = top, left = right) {
        super();
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        this.left = left;
      }
      clear() {
        this.top = this.right = this.bottom = this.left = 0;
      }
    };
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], Padding.prototype, "top", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], Padding.prototype, "right", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], Padding.prototype, "bottom", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], Padding.prototype, "left", 2);
  }
});

// packages/ag-charts-community/src/util/render.ts
function debouncedAnimationFrame(cb) {
  return buildScheduler((innerCb, _delayMs) => requestAnimationFrame(innerCb), cb);
}
function debouncedCallback(cb) {
  return buildScheduler((innerCb, delayMs = 0) => setTimeout(innerCb, delayMs), cb);
}
function buildScheduler(scheduleFn, cb) {
  let scheduleCount = 0;
  let promiseRunning = false;
  let awaitingPromise;
  let awaitingDone;
  const busy = () => {
    return promiseRunning;
  };
  const done = () => {
    promiseRunning = false;
    awaitingDone == null ? void 0 : awaitingDone();
    awaitingDone = void 0;
    awaitingPromise = void 0;
    if (scheduleCount > 0) {
      scheduleFn(scheduleCb);
    }
  };
  const scheduleCb = () => {
    const count = scheduleCount;
    scheduleCount = 0;
    promiseRunning = true;
    const maybePromise = cb({ count });
    if (!maybePromise) {
      done();
      return;
    }
    maybePromise.then(done, done);
  };
  return {
    schedule(delayMs) {
      if (scheduleCount === 0 && !busy()) {
        scheduleFn(scheduleCb, delayMs);
      }
      scheduleCount++;
    },
    await() {
      return __async(this, null, function* () {
        if (!busy()) {
          return;
        }
        if (awaitingPromise == null) {
          awaitingPromise = new Promise((resolve) => {
            awaitingDone = resolve;
          });
        }
        while (busy()) {
          yield awaitingPromise;
        }
      });
    }
  };
}
var init_render = __esm({
  "packages/ag-charts-community/src/util/render.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/util/sizeMonitor.ts
var SizeMonitor;
var init_sizeMonitor = __esm({
  "packages/ag-charts-community/src/util/sizeMonitor.ts"() {
    "use strict";
    init_dom();
    SizeMonitor = class {
      constructor() {
        this.elements = /* @__PURE__ */ new Map();
        this.documentReady = false;
        this.queuedObserveRequests = [];
        this.onLoad = () => {
          this.documentReady = true;
          this.queuedObserveRequests.forEach(([el, cb]) => this.observe(el, cb));
          this.queuedObserveRequests = [];
        };
        var _a2;
        if (typeof ResizeObserver === "undefined")
          return;
        this.resizeObserver = new ResizeObserver((entries) => {
          for (const { target, contentRect } of entries) {
            const { width, height } = contentRect;
            this.checkSize(this.elements.get(target), target, width, height);
          }
        });
        this.documentReady = getDocument("readyState") === "complete";
        if (!this.documentReady) {
          (_a2 = getWindow()) == null ? void 0 : _a2.addEventListener("load", this.onLoad);
        }
      }
      destroy() {
        var _a2, _b;
        (_a2 = getWindow()) == null ? void 0 : _a2.removeEventListener("load", this.onLoad);
        (_b = this.resizeObserver) == null ? void 0 : _b.disconnect();
        this.resizeObserver = null;
      }
      checkSize(entry, element2, width, height) {
        var _a2, _b;
        if (!entry)
          return;
        if (width !== ((_a2 = entry.size) == null ? void 0 : _a2.width) || height !== ((_b = entry.size) == null ? void 0 : _b.height)) {
          entry.size = { width, height };
          entry.cb(entry.size, element2);
        }
      }
      // Only a single callback is supported.
      observe(element2, cb) {
        var _a2;
        if (!this.documentReady) {
          this.queuedObserveRequests.push([element2, cb]);
          return;
        }
        if (this.elements.has(element2)) {
          this.removeFromQueue(element2);
        } else {
          (_a2 = this.resizeObserver) == null ? void 0 : _a2.observe(element2);
        }
        this.elements.set(element2, { cb });
      }
      unobserve(element2) {
        var _a2;
        (_a2 = this.resizeObserver) == null ? void 0 : _a2.unobserve(element2);
        this.elements.delete(element2);
        this.removeFromQueue(element2);
        if (!this.elements.size) {
          this.destroy();
        }
      }
      removeFromQueue(element2) {
        this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el !== element2);
      }
    };
  }
});

// packages/ag-charts-community/src/util/callbackCache.ts
var CallbackCache;
var init_callbackCache = __esm({
  "packages/ag-charts-community/src/util/callbackCache.ts"() {
    "use strict";
    init_logger();
    CallbackCache = class {
      constructor() {
        this.cache = /* @__PURE__ */ new WeakMap();
      }
      call(fn, ...params) {
        let serialisedParams;
        let paramCache = this.cache.get(fn);
        const invoke = () => {
          try {
            const result = fn(...params);
            if (paramCache && serialisedParams != null) {
              paramCache.set(serialisedParams, result);
            }
            return result;
          } catch (e) {
            Logger.warnOnce(`User callback errored, ignoring`, e);
            return;
          }
        };
        try {
          serialisedParams = JSON.stringify(params);
        } catch (e) {
          return invoke();
        }
        if (paramCache == null) {
          paramCache = /* @__PURE__ */ new Map();
          this.cache.set(fn, paramCache);
        }
        if (!paramCache.has(serialisedParams)) {
          return invoke();
        }
        return paramCache.get(serialisedParams);
      }
      invalidateCache() {
        this.cache = /* @__PURE__ */ new WeakMap();
      }
    };
  }
});

// packages/ag-charts-community/src/chart/annotation/annotationManager.ts
var AnnotationManager;
var init_annotationManager = __esm({
  "packages/ag-charts-community/src/chart/annotation/annotationManager.ts"() {
    "use strict";
    AnnotationManager = class {
      constructor(annotationRoot) {
        this.annotationRoot = annotationRoot;
      }
      attachNode(node) {
        this.annotationRoot.append(node);
        return () => {
          var _a2;
          (_a2 = this.annotationRoot) == null ? void 0 : _a2.removeChild(node);
          return this;
        };
      }
      setAnnotationStyles(styles) {
        this.styles = styles;
      }
      getAnnotationTypeStyles(type) {
        var _a2;
        return (_a2 = this.styles) == null ? void 0 : _a2[type];
      }
    };
  }
});

// packages/ag-charts-community/src/util/listeners.ts
var Listeners;
var init_listeners = __esm({
  "packages/ag-charts-community/src/util/listeners.ts"() {
    "use strict";
    init_logger();
    Listeners = class {
      constructor() {
        this.registeredListeners = /* @__PURE__ */ new Map();
      }
      addListener(eventType, handler) {
        const record = { symbol: Symbol(eventType), handler };
        if (this.registeredListeners.has(eventType)) {
          this.registeredListeners.get(eventType).push(record);
        } else {
          this.registeredListeners.set(eventType, [record]);
        }
        return () => this.removeListener(record.symbol);
      }
      removeListener(eventSymbol) {
        for (const [type, listeners] of this.registeredListeners.entries()) {
          const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);
          if (matchIndex >= 0) {
            listeners.splice(matchIndex, 1);
            if (listeners.length === 0) {
              this.registeredListeners.delete(type);
            }
            break;
          }
        }
      }
      dispatch(eventType, ...params) {
        for (const listener of this.getListenersByType(eventType)) {
          try {
            listener.handler(...params);
          } catch (e) {
            Logger.errorOnce(e);
          }
        }
      }
      dispatchWrapHandlers(eventType, wrapFn, ...params) {
        for (const listener of this.getListenersByType(eventType)) {
          try {
            wrapFn(listener.handler, ...params);
          } catch (e) {
            Logger.errorOnce(e);
          }
        }
      }
      getListenersByType(eventType) {
        var _a2;
        return (_a2 = this.registeredListeners.get(eventType)) != null ? _a2 : [];
      }
      destroy() {
        this.registeredListeners.clear();
      }
    };
  }
});

// packages/ag-charts-community/src/chart/data/dataService.ts
var DataService;
var init_dataService = __esm({
  "packages/ag-charts-community/src/chart/data/dataService.ts"() {
    "use strict";
    init_debug();
    init_function();
    init_listeners();
    init_logger();
    init_proxy();
    DataService = class extends Listeners {
      constructor(animationManager) {
        super();
        this.animationManager = animationManager;
        this.dispatchOnlyLatest = true;
        this.dispatchThrottle = 0;
        this.requestThrottle = 300;
        this.isLoadingInitialData = false;
        this.isLoadingData = false;
        this.freshRequests = [];
        this.requestCounter = 0;
        this.debug = Debug.create(true, "data-model", "data-source");
        this.throttledFetch = this.createThrottledFetch(this.requestThrottle);
        this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);
      }
      updateCallback(dataSourceCallback) {
        if (typeof dataSourceCallback !== "function")
          return;
        this.debug("DataService - updated data source callback");
        this.dataSourceCallback = dataSourceCallback;
        this.isLoadingInitialData = true;
        this.animationManager.skip();
        this.dispatch("data-source-change");
      }
      clearCallback() {
        this.dataSourceCallback = void 0;
      }
      load(params) {
        this.isLoadingData = true;
        this.throttledFetch(params);
      }
      isLazy() {
        return this.dataSourceCallback != null;
      }
      isLoading() {
        return this.isLazy() && (this.isLoadingInitialData || this.isLoadingData);
      }
      createThrottledFetch(requestThrottle) {
        return throttle((params) => this.fetch(params), requestThrottle, {
          leading: false,
          trailing: true
        });
      }
      createThrottledDispatch(dispatchThrottle) {
        return throttle(
          (id, data) => {
            this.debug(`DataService - dispatching 'data-load' | ${id}`);
            this.dispatch("data-load", { type: "data-load", data });
          },
          dispatchThrottle,
          {
            leading: true,
            trailing: true
          }
        );
      }
      fetch(params) {
        return __async(this, null, function* () {
          if (!this.dataSourceCallback) {
            throw new Error("DataService - [dataSource.getData] callback not initialised");
          }
          const start = performance.now();
          const id = this.requestCounter++;
          this.debug(`DataService - requesting | ${id}`);
          this.freshRequests.push(id);
          let response;
          try {
            response = yield this.dataSourceCallback(params);
            this.debug(`DataService - response | ${performance.now() - start}ms | ${id}`);
          } catch (error) {
            this.debug(`DataService - request failed | ${id}`);
            Logger.errorOnce(`DataService - request failed | [${error}]`);
          }
          this.isLoadingInitialData = false;
          const requestIndex = this.freshRequests.findIndex((rid) => rid === id);
          if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {
            this.debug(`DataService - discarding stale request | ${id}`);
            return;
          }
          this.freshRequests = this.freshRequests.slice(requestIndex + 1);
          if (this.freshRequests.length === 0) {
            this.isLoadingData = false;
          }
          if (Array.isArray(response)) {
            this.throttledDispatch(id, response);
          } else {
            this.dispatch("data-error");
          }
        });
      }
    };
    __decorateClass([
      ActionOnSet({
        newValue(dispatchThrottle) {
          this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);
        }
      })
    ], DataService.prototype, "dispatchThrottle", 2);
    __decorateClass([
      ActionOnSet({
        newValue(requestThrottle) {
          this.throttledFetch = this.createThrottledFetch(requestThrottle);
        }
      })
    ], DataService.prototype, "requestThrottle", 2);
  }
});

// packages/ag-charts-community/src/chart/interaction/animationBatch.ts
var AnimationBatch;
var init_animationBatch = __esm({
  "packages/ag-charts-community/src/chart/interaction/animationBatch.ts"() {
    "use strict";
    init_animation();
    init_debug();
    init_logger();
    AnimationBatch = class {
      constructor(maxAnimationTime) {
        this.maxAnimationTime = maxAnimationTime;
        this.debug = Debug.create(true, "animation");
        this.controllers = /* @__PURE__ */ new Map();
        this.stoppedCbs = /* @__PURE__ */ new Set();
        this.currentPhase = 0;
        this.phases = new Map(PHASE_ORDER.map((p) => [p, []]));
        this.skipAnimations = false;
        this.animationTimeConsumed = 0;
        /** Guard against premature animation execution. */
        this.isReady = false;
      }
      get size() {
        return this.controllers.size;
      }
      get consumedTimeMs() {
        return this.animationTimeConsumed;
      }
      isActive() {
        return this.controllers.size > 0;
      }
      getActiveControllers() {
        var _a2;
        return (_a2 = this.phases.get(PHASE_ORDER[this.currentPhase])) != null ? _a2 : [];
      }
      checkOverlappingId(id) {
        if (id != null && this.controllers.has(id)) {
          this.controllers.get(id).stop();
          this.debug(`Skipping animation batch due to update of existing animation: ${id}`);
          this.skip();
        }
      }
      addAnimation(animation) {
        var _a2;
        if (animation.isComplete)
          return;
        const animationPhaseIdx = PHASE_ORDER.indexOf(animation.phase);
        if (animationPhaseIdx < this.currentPhase) {
          this.debug(`Skipping animation due to being for an earlier phase`, animation.id);
          animation.stop();
          return;
        }
        this.controllers.set(animation.id, animation);
        (_a2 = this.phases.get(animation.phase)) == null ? void 0 : _a2.push(animation);
      }
      removeAnimation(animation) {
        this.controllers.delete(animation.id);
        const phase = this.phases.get(animation.phase);
        const index = phase == null ? void 0 : phase.indexOf(animation);
        if (index != null && index >= 0) {
          phase == null ? void 0 : phase.splice(index, 1);
        }
      }
      progress(deltaTime) {
        if (!this.isReady)
          return;
        let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;
        const refresh = () => {
          const phase2 = PHASE_ORDER[this.currentPhase];
          return {
            phaseControllers: [...this.getActiveControllers()],
            phase: phase2,
            phaseMeta: PHASE_METADATA[phase2]
          };
        };
        let { phase, phaseControllers, phaseMeta } = refresh();
        const arePhasesComplete = () => PHASE_ORDER[this.currentPhase] == null;
        const progressPhase = () => {
          ({ phase, phaseControllers, phaseMeta } = refresh());
          while (!arePhasesComplete() && phaseControllers.length === 0) {
            this.currentPhase++;
            ({ phase, phaseControllers, phaseMeta } = refresh());
            this.debug(`AnimationBatch - phase changing to ${phase}`, { unusedTime }, phaseControllers);
          }
        };
        const total = this.controllers.size;
        this.debug(`AnimationBatch - ${deltaTime}ms; phase ${phase} with ${phaseControllers == null ? void 0 : phaseControllers.length} of ${total}`);
        do {
          const phaseDeltaTime = unusedTime;
          const skipPhase = phaseMeta.skipIfNoEarlierAnimations && this.animationTimeConsumed === 0;
          let completeCount = 0;
          for (const controller of phaseControllers) {
            if (skipPhase) {
              controller.stop();
            } else {
              unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);
            }
            if (controller.isComplete) {
              completeCount++;
              this.removeAnimation(controller);
            }
          }
          this.animationTimeConsumed += phaseDeltaTime - unusedTime;
          this.debug(`AnimationBatch - updated ${phaseControllers.length} controllers; ${completeCount} completed`);
          this.debug(`AnimationBatch - animationTimeConsumed: ${this.animationTimeConsumed}`);
          progressPhase();
        } while (unusedTime > 0 && !arePhasesComplete());
        if (this.animationTimeConsumed > this.maxAnimationTime) {
          Logger.warnOnce(
            "Animation batch exceeded max animation time, skipping.",
            new Map(this.controllers.entries())
          );
          this.stop();
        }
      }
      ready() {
        if (this.isReady)
          return;
        this.isReady = true;
        this.debug(`AnimationBatch - ready; skipped: ${this.skipAnimations}`, [...this.controllers]);
        let skipAll = true;
        for (const [, controller] of this.controllers) {
          if (controller.duration > 0 && PHASE_METADATA[controller.phase].skipIfNoEarlierAnimations !== true) {
            skipAll = false;
            break;
          }
        }
        if (!skipAll) {
          for (const [, controller] of this.controllers) {
            if (controller.autoplay) {
              controller.play(true);
            }
          }
        }
      }
      skip(skip = true) {
        if (this.skipAnimations === false && skip === true) {
          for (const controller of this.controllers.values()) {
            controller.stop();
          }
          this.controllers.clear();
        }
        this.skipAnimations = skip;
      }
      play() {
        for (const controller of this.controllers.values()) {
          controller.play();
        }
      }
      pause() {
        for (const controller of this.controllers.values()) {
          controller.pause();
        }
      }
      stop() {
        for (const controller of this.controllers.values()) {
          try {
            controller.stop();
            this.removeAnimation(controller);
          } catch (error) {
            Logger.error("Error during animation stop", error);
          }
        }
        this.dispatchStopped();
      }
      stopByAnimationId(id) {
        if (id != null && this.controllers.has(id)) {
          const controller = this.controllers.get(id);
          if (controller) {
            controller.stop();
            this.removeAnimation(controller);
          }
        }
      }
      stopByAnimationGroupId(id) {
        for (const controller of this.controllers.values()) {
          if (controller.groupId === id) {
            this.stopByAnimationId(controller.id);
          }
        }
      }
      dispatchStopped() {
        this.stoppedCbs.forEach((cb) => cb());
        this.stoppedCbs.clear();
      }
      isSkipped() {
        return this.skipAnimations;
      }
      destroy() {
        this.stop();
        this.controllers.clear();
      }
    };
  }
});

// packages/ag-charts-community/src/chart/interaction/baseManager.ts
var BaseManager;
var init_baseManager = __esm({
  "packages/ag-charts-community/src/chart/interaction/baseManager.ts"() {
    "use strict";
    init_listeners();
    BaseManager = class {
      constructor() {
        this.listeners = new Listeners();
        this.destroyFns = [];
      }
      addListener(type, handler) {
        return this.listeners.addListener(type, handler);
      }
      removeListener(listenerSymbol) {
        this.listeners.removeListener(listenerSymbol);
      }
      destroy() {
        this.listeners.destroy();
        this.destroyFns.forEach((fn) => fn());
      }
    };
  }
});

// packages/ag-charts-community/src/chart/interaction/consumableEvent.ts
function buildConsumable(obj) {
  const builtEvent = __spreadProps(__spreadValues({}, obj), {
    consumed: false,
    consume() {
      var _a2, _b;
      builtEvent.consumed = true;
      if (obj.sourceEvent instanceof Event) {
        (_a2 = obj.sourceEvent) == null ? void 0 : _a2.preventDefault();
      } else {
        (_b = obj.sourceEvent) == null ? void 0 : _b.consume();
      }
    }
  });
  return builtEvent;
}
function buildConsumptionHandler() {
  return (handler, e) => {
    if (!e.consumed) {
      handler(e);
    }
  };
}
function dispatchTypedConsumable(listeners, type, event) {
  listeners.dispatchWrapHandlers(type, buildConsumptionHandler(), event);
}
var init_consumableEvent = __esm({
  "packages/ag-charts-community/src/chart/interaction/consumableEvent.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/interaction/interactionManager.ts
var POINTER_INTERACTION_TYPES, FOCUS_INTERACTION_TYPES, KEY_INTERACTION_TYPES, WINDOW_EVENT_HANDLERS, EVENT_HANDLERS, CSS, InteractionState, _InteractionManager, InteractionManager;
var init_interactionManager = __esm({
  "packages/ag-charts-community/src/chart/interaction/interactionManager.ts"() {
    "use strict";
    init_array();
    init_debug();
    init_dom();
    init_logger();
    init_object();
    init_type_guards();
    init_baseManager();
    init_consumableEvent();
    POINTER_INTERACTION_TYPES = [
      "click",
      "dblclick",
      "contextmenu",
      "hover",
      "drag-start",
      "drag",
      "drag-end",
      "leave",
      "enter",
      "page-left",
      "wheel"
    ];
    FOCUS_INTERACTION_TYPES = ["blur", "focus"];
    KEY_INTERACTION_TYPES = ["keydown", "keyup"];
    WINDOW_EVENT_HANDLERS = ["pagehide", "mousemove", "mouseup"];
    EVENT_HANDLERS = [
      "click",
      "dblclick",
      "contextmenu",
      "mousedown",
      "mouseout",
      "mouseenter",
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel",
      "wheel",
      "blur",
      "focus",
      "keydown",
      "keyup"
    ];
    CSS = `
.ag-chart-wrapper {
    touch-action: none;
}
`;
    InteractionState = /* @__PURE__ */ ((InteractionState3) => {
      InteractionState3[InteractionState3["Default"] = 16] = "Default";
      InteractionState3[InteractionState3["ZoomDrag"] = 8] = "ZoomDrag";
      InteractionState3[InteractionState3["Annotations"] = 4] = "Annotations";
      InteractionState3[InteractionState3["ContextMenu"] = 2] = "ContextMenu";
      InteractionState3[InteractionState3["Animation"] = 1] = "Animation";
      InteractionState3[InteractionState3["All"] = 31] = "All";
      return InteractionState3;
    })(InteractionState || {});
    _InteractionManager = class _InteractionManager extends BaseManager {
      constructor(keyboardOptions, element2) {
        super();
        this.keyboardOptions = keyboardOptions;
        this.debug = Debug.create(true, "interaction");
        this.eventHandler = (event) => this.processEvent(event);
        this.mouseDown = false;
        this.touchDown = false;
        this.clickHistory = [{ offsetX: NaN, offsetY: NaN, type: "mousedown" }];
        this.dblclickHistory = [
          { offsetX: NaN, offsetY: NaN, type: "mousedown" },
          { offsetX: NaN, offsetY: NaN, type: "mouseup" },
          { offsetX: NaN, offsetY: NaN, type: "mousedown" }
        ];
        this.stateQueue = 16 /* Default */ | 1 /* Animation */;
        this.rootElement = getDocument("body");
        this.element = element2;
        for (const type of EVENT_HANDLERS) {
          if (type.startsWith("touch")) {
            element2.addEventListener(type, this.eventHandler, { passive: true });
          } else if (type === "wheel") {
            element2.addEventListener(type, this.eventHandler, { passive: false });
          } else {
            element2.addEventListener(type, this.eventHandler);
          }
        }
        for (const type of WINDOW_EVENT_HANDLERS) {
          getWindow().addEventListener(type, this.eventHandler);
        }
        injectStyle(CSS, "interactionManager");
      }
      destroy() {
        super.destroy();
        for (const type of WINDOW_EVENT_HANDLERS) {
          getWindow().removeEventListener(type, this.eventHandler);
        }
        for (const type of EVENT_HANDLERS) {
          this.element.removeEventListener(type, this.eventHandler);
        }
      }
      // Wrapper to only broadcast events when the InteractionManager is a given state.
      addListener(type, handler, triggeringStates = 16 /* Default */) {
        return super.addListener(type, (e) => {
          const currentState = this.getState();
          if (currentState & triggeringStates) {
            handler(e);
          }
        });
      }
      pushState(state) {
        this.stateQueue |= state;
      }
      popState(state) {
        this.stateQueue &= ~state;
      }
      getState() {
        return this.stateQueue & -this.stateQueue;
      }
      processEvent(event) {
        const types = this.decideInteractionEventTypes(event);
        if (types.length > 0) {
          this.dispatchEvent(event, types).catch((e) => Logger.errorOnce(e));
        }
      }
      dispatchEvent(event, types) {
        return __async(this, null, function* () {
          if (allInStringUnion(POINTER_INTERACTION_TYPES, types)) {
            this.dispatchPointerEvent(event, types);
          } else if (allInStringUnion(FOCUS_INTERACTION_TYPES, types)) {
            for (const type of types) {
              dispatchTypedConsumable(
                this.listeners,
                type,
                buildConsumable({ type, sourceEvent: event })
              );
            }
          } else if (allInStringUnion(KEY_INTERACTION_TYPES, types)) {
            for (const type of types) {
              dispatchTypedConsumable(
                this.listeners,
                type,
                buildConsumable({ type, sourceEvent: event })
              );
            }
          }
        });
      }
      dispatchPointerEvent(event, types) {
        const coords = this.calculateCoordinates(event);
        if (coords == null) {
          return;
        }
        for (const type of types) {
          dispatchTypedConsumable(this.listeners, type, this.buildPointerEvent(__spreadValues({ type, event }, coords)));
        }
      }
      recordDown(event) {
        if (event instanceof MouseEvent) {
          partialAssign(["offsetX", "offsetY"], this.clickHistory[0], event);
          partialAssign(["offsetX", "offsetY"], this.dblclickHistory[2], this.dblclickHistory[0]);
          partialAssign(["offsetX", "offsetY"], this.dblclickHistory[0], event);
        }
        this.dragStartElement = event.target;
      }
      recordUp(event) {
        if (event instanceof MouseEvent) {
          partialAssign(["offsetX", "offsetY"], this.dblclickHistory[1], event);
        }
        this.dragStartElement = void 0;
      }
      decideInteractionEventTypes(event) {
        const dragStart = "drag-start";
        switch (event.type) {
          case "blur":
          case "focus":
          case "keydown":
          case "keyup":
            return this.keyboardOptions.enabled ? [event.type] : [];
          case "click":
          case "dblclick":
          case "contextmenu":
          case "wheel":
            return [event.type];
          case "mousedown":
            if (!this.isEventOverElement(event)) {
              return [];
            }
            this.mouseDown = true;
            this.recordDown(event);
            return [dragStart];
          case "touchstart":
            if (!this.isEventOverElement(event)) {
              return [];
            }
            this.touchDown = true;
            this.recordDown(event);
            return [dragStart];
          case "touchmove":
          case "mousemove":
            if (!this.mouseDown && !this.touchDown && !this.isEventOverElement(event)) {
              return [];
            }
            return this.mouseDown || this.touchDown ? ["drag"] : ["hover"];
          case "mouseup":
            if (!this.mouseDown && !this.isEventOverElement(event)) {
              return [];
            }
            this.mouseDown = false;
            this.recordUp(event);
            return ["drag-end"];
          case "touchend":
            if (!this.touchDown && !this.isEventOverElement(event)) {
              return [];
            }
            this.touchDown = false;
            this.recordUp(event);
            return ["drag-end"];
          case "mouseout":
          case "touchcancel":
            return ["leave"];
          case "mouseenter":
            const mouseButtonDown = event instanceof MouseEvent && (event.buttons & 1) === 1;
            if (this.mouseDown !== mouseButtonDown) {
              this.mouseDown = mouseButtonDown;
              return [mouseButtonDown ? dragStart : "drag-end"];
            }
            return ["enter"];
          case "pagehide":
            return ["page-left"];
        }
        return [];
      }
      isEventOverElement(event) {
        var _a2, _b, _c;
        return event.target === this.element || ((_a2 = event.target) == null ? void 0 : _a2.parentElement) === this.element || ((_c = (_b = event.target) == null ? void 0 : _b.parentElement) == null ? void 0 : _c.parentElement) === this.element;
      }
      calculateCoordinates(event) {
        var _a2;
        if (event instanceof MouseEvent) {
          return this.getMouseEventCoords(event);
        } else if (typeof TouchEvent !== "undefined" && event instanceof TouchEvent) {
          const lastTouch = (_a2 = event.touches[0]) != null ? _a2 : event.changedTouches[0];
          const { clientX, clientY, pageX, pageY } = lastTouch;
          return __spreadProps(__spreadValues({}, _InteractionManager.NULL_COORDS), { clientX, clientY, pageX, pageY });
        } else if (event instanceof PageTransitionEvent) {
          if (event.persisted) {
            return;
          }
          return _InteractionManager.NULL_COORDS;
        }
      }
      getMouseEventCoords(event) {
        const { clientX, clientY, pageX, pageY } = event;
        let { offsetX, offsetY } = event;
        const offsets = (el) => {
          let x = 0;
          let y = 0;
          while (el) {
            x += el.offsetLeft;
            y += el.offsetTop;
            el = el.offsetParent;
          }
          return { x, y };
        };
        if (this.dragStartElement != null && event.target !== this.dragStartElement) {
          const offsetDragStart = offsets(this.dragStartElement);
          const offsetEvent = offsets(event.target);
          offsetX -= offsetDragStart.x - offsetEvent.x;
          offsetY -= offsetDragStart.y - offsetEvent.y;
        }
        return { clientX, clientY, pageX, pageY, offsetX, offsetY };
      }
      isWheelEvent(event) {
        return event.type === "wheel";
      }
      buildPointerEvent(opts) {
        const { type, event, clientX, clientY } = opts;
        let { offsetX, offsetY, pageX, pageY } = opts;
        if (!isFiniteNumber(offsetX) || !isFiniteNumber(offsetY)) {
          const rect = this.element.getBoundingClientRect();
          offsetX = clientX - rect.left;
          offsetY = clientY - rect.top;
        }
        if (!isFiniteNumber(pageX) || !isFiniteNumber(pageY)) {
          const pageRect = this.rootElement.getBoundingClientRect();
          pageX = clientX - pageRect.left;
          pageY = clientY - pageRect.top;
        }
        let [deltaX, deltaY] = [NaN, NaN];
        if (this.isWheelEvent(event)) {
          const factor = event.deltaMode === 0 ? 0.01 : 1;
          deltaX = event.deltaX * factor;
          deltaY = event.deltaY * factor;
        }
        let pointerHistory = [];
        if (event.type === "click") {
          pointerHistory = this.clickHistory;
        } else if (event.type === "dblclick") {
          pointerHistory = this.dblclickHistory;
        }
        const builtEvent = buildConsumable({
          type,
          offsetX,
          offsetY,
          pageX,
          pageY,
          deltaX,
          deltaY,
          pointerHistory,
          sourceEvent: event
        });
        this.debug("InteractionManager - builtEvent: ", builtEvent);
        return builtEvent;
      }
    };
    _InteractionManager.NULL_COORDS = {
      clientX: -Infinity,
      clientY: -Infinity,
      pageX: -Infinity,
      pageY: -Infinity,
      offsetX: -Infinity,
      offsetY: -Infinity
    };
    InteractionManager = _InteractionManager;
  }
});

// packages/ag-charts-community/src/chart/interaction/animationManager.ts
function validAnimationDuration(testee) {
  if (testee == null)
    return true;
  return !isNaN(testee) && testee >= 0 && testee <= 2;
}
var AnimationManager;
var init_animationManager = __esm({
  "packages/ag-charts-community/src/chart/interaction/animationManager.ts"() {
    "use strict";
    init_animation();
    init_debug();
    init_logger();
    init_animationBatch();
    init_baseManager();
    init_interactionManager();
    AnimationManager = class extends BaseManager {
      constructor(interactionManager, chartUpdateMutex) {
        super();
        this.interactionManager = interactionManager;
        this.chartUpdateMutex = chartUpdateMutex;
        this.defaultDuration = 1e3;
        this.batch = new AnimationBatch(this.defaultDuration * 1.5);
        this.debug = Debug.create(true, "animation");
        this.rafAvailable = typeof requestAnimationFrame !== "undefined";
        this.isPlaying = false;
        this.requestId = null;
        this.skipAnimations = false;
      }
      /**
       * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists
       * with the same `id`, immediately stop it.
       */
      animate(_a2) {
        var opts = __objRest(_a2, []);
        var _a3;
        const batch = this.batch;
        try {
          batch.checkOverlappingId(opts.id);
        } catch (error) {
          this.failsafeOnError(error);
          return;
        }
        const id = (_a3 = opts.id) != null ? _a3 : Math.random().toString();
        const skip = this.isSkipped() || opts.phase === "none";
        if (skip) {
          this.debug("AnimationManager - skipping animation");
        }
        const { delay, duration } = opts;
        if (!validAnimationDuration(delay)) {
          throw new Error(`Animation delay of ${delay} is unsupported (${id})`);
        }
        if (!validAnimationDuration(duration)) {
          throw new Error(`Animation duration of ${duration} is unsupported (${id})`);
        }
        const animation = new Animation(__spreadProps(__spreadValues({}, opts), {
          id,
          skip,
          autoplay: this.isPlaying ? opts.autoplay : false,
          phase: opts.phase,
          defaultDuration: this.defaultDuration
        }));
        if (this.forceTimeJump(animation, this.defaultDuration)) {
          return;
        }
        this.batch.addAnimation(animation);
        return animation;
      }
      play() {
        if (this.isPlaying) {
          return;
        }
        this.isPlaying = true;
        this.debug("AnimationManager.play()");
        try {
          this.batch.play();
        } catch (error) {
          this.failsafeOnError(error);
        }
        this.requestAnimation();
      }
      pause() {
        if (!this.isPlaying) {
          return;
        }
        this.isPlaying = false;
        this.cancelAnimation();
        this.debug("AnimationManager.pause()");
        try {
          this.batch.pause();
        } catch (error) {
          this.failsafeOnError(error);
        }
      }
      stop() {
        this.isPlaying = false;
        this.cancelAnimation();
        this.debug("AnimationManager.stop()");
        this.batch.stop();
      }
      stopByAnimationId(id) {
        try {
          this.batch.stopByAnimationId(id);
        } catch (error) {
          this.failsafeOnError(error);
        }
      }
      stopByAnimationGroupId(id) {
        try {
          this.batch.stopByAnimationGroupId(id);
        } catch (error) {
          this.failsafeOnError(error);
        }
      }
      reset() {
        if (this.isPlaying) {
          this.stop();
          this.play();
        } else {
          this.stop();
        }
      }
      skip(skip = true) {
        this.skipAnimations = skip;
      }
      isSkipped() {
        return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();
      }
      isActive() {
        return this.isPlaying && this.batch.isActive();
      }
      skipCurrentBatch() {
        if (this.debug.check()) {
          this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });
        }
        this.batch.skip();
      }
      /** Mocking point for tests to guarantee that animation updates happen. */
      isSkippingFrames() {
        return true;
      }
      /** Mocking point for tests to capture requestAnimationFrame callbacks. */
      scheduleAnimationFrame(cb) {
        this.requestId = requestAnimationFrame(cb);
      }
      /** Mocking point for tests to skip animations to a specific point in time. */
      forceTimeJump(_animation, _defaultDuration) {
        return false;
      }
      requestAnimation() {
        if (!this.rafAvailable)
          return;
        if (!this.batch.isActive() || this.requestId !== null)
          return;
        let prevTime;
        const onAnimationFrame = (time2) => __async(this, null, function* () {
          const executeAnimationFrame = () => __async(this, null, function* () {
            const deltaTime = time2 - (prevTime != null ? prevTime : time2);
            prevTime = time2;
            this.debug("AnimationManager - onAnimationFrame()", {
              controllersCount: this.batch.size,
              deltaTime
            });
            this.interactionManager.pushState(1 /* Animation */);
            try {
              this.batch.progress(deltaTime);
            } catch (error) {
              this.failsafeOnError(error);
            }
            this.listeners.dispatch("animation-frame", {
              type: "animation-frame",
              deltaMs: deltaTime
            });
          });
          if (this.isSkippingFrames()) {
            yield this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);
          } else {
            yield this.chartUpdateMutex.acquire(executeAnimationFrame);
          }
          if (this.batch.isActive()) {
            this.scheduleAnimationFrame(onAnimationFrame);
          } else {
            this.batch.stop();
            this.listeners.dispatch("animation-stop", {
              type: "animation-stop",
              deltaMs: this.batch.consumedTimeMs
            });
          }
        });
        this.listeners.dispatch("animation-start", {
          type: "animation-start",
          deltaMs: 0
        });
        this.scheduleAnimationFrame(onAnimationFrame);
      }
      cancelAnimation() {
        if (this.requestId === null)
          return;
        cancelAnimationFrame(this.requestId);
        this.requestId = null;
        this.startBatch();
      }
      failsafeOnError(error, cancelAnimation = true) {
        Logger.error("Error during animation, skipping animations", error);
        if (cancelAnimation) {
          this.cancelAnimation();
        }
      }
      startBatch(skipAnimations) {
        this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);
        this.reset();
        this.batch.stop();
        this.batch.destroy();
        this.batch = new AnimationBatch(this.defaultDuration * 1.5);
        if (skipAnimations === true) {
          this.batch.skip();
        }
      }
      endBatch() {
        if (this.batch.isActive()) {
          this.batch.ready();
          this.requestAnimation();
        } else {
          this.interactionManager.popState(1 /* Animation */);
          if (this.batch.isSkipped()) {
            this.batch.skip(false);
          }
        }
      }
      onBatchStop(cb) {
        this.batch.stoppedCbs.add(cb);
      }
    };
  }
});

// packages/ag-charts-community/src/chart/interaction/ariaAnnouncementServices.ts
var AriaAnnouncementService;
var init_ariaAnnouncementServices = __esm({
  "packages/ag-charts-community/src/chart/interaction/ariaAnnouncementServices.ts"() {
    "use strict";
    init_attributeUtil();
    init_debug();
    init_dom();
    AriaAnnouncementService = class _AriaAnnouncementService {
      constructor(canvas) {
        this.canvas = canvas;
        this.debug = Debug.create(true, "aria");
        this.canvas.appendChild(this.liveElem = _AriaAnnouncementService.createAnnouncer());
      }
      static createAnnouncer() {
        const e = getDocument().createElement("div");
        e.classList.add("ag-charts-aria-announcer");
        setAttribute(e, "role", "status");
        setAttribute(e, "aria-live", "assertive");
        return e;
      }
      destroy() {
        this.canvas.removeChild(this.liveElem);
      }
      announceValue(value) {
        this.debug(`AriaAnnouncementService - announceValue: ${value}`);
        this.liveElem.textContent = value;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/interaction/chartEventManager.ts
var ChartEventManager;
var init_chartEventManager = __esm({
  "packages/ag-charts-community/src/chart/interaction/chartEventManager.ts"() {
    "use strict";
    init_baseManager();
    ChartEventManager = class extends BaseManager {
      legendItemClick(series, itemId, enabled, legendItemName) {
        const event = {
          type: "legend-item-click",
          series,
          itemId,
          enabled,
          legendItemName
        };
        this.listeners.dispatch("legend-item-click", event);
      }
      legendItemDoubleClick(series, itemId, enabled, numVisibleItems, legendItemName) {
        const event = {
          type: "legend-item-double-click",
          series,
          itemId,
          enabled,
          legendItemName,
          numVisibleItems
        };
        this.listeners.dispatch("legend-item-double-click", event);
      }
      axisHover(axisId, direction) {
        const event = {
          type: "axis-hover",
          axisId,
          direction
        };
        this.listeners.dispatch("axis-hover", event);
      }
    };
  }
});

// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts
var ContextMenuRegistry;
var init_contextMenuRegistry = __esm({
  "packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts"() {
    "use strict";
    ContextMenuRegistry = class {
      constructor() {
        this.defaultActions = [];
        this.disabledActions = /* @__PURE__ */ new Set();
      }
      copyDefaultActions() {
        return [...this.defaultActions];
      }
      registerDefaultAction(action) {
        if (action.id && this.defaultActions.find(({ id }) => id === action.id)) {
          return;
        }
        this.defaultActions.push(action);
      }
      enableAction(actionId) {
        this.disabledActions.delete(actionId);
      }
      disableAction(actionId) {
        this.disabledActions.add(actionId);
      }
      isDisabled(actionId) {
        return this.disabledActions.has(actionId);
      }
    };
  }
});

// packages/ag-charts-community/src/util/stateTracker.ts
var StateTracker;
var init_stateTracker = __esm({
  "packages/ag-charts-community/src/util/stateTracker.ts"() {
    "use strict";
    StateTracker = class extends Map {
      constructor(defaultValue, defaultState) {
        super();
        this.defaultValue = defaultValue;
        this.defaultState = defaultState;
      }
      set(key, value) {
        this.delete(key);
        if (typeof value !== "undefined") {
          super.set(key, value);
        }
        return this;
      }
      stateId() {
        var _a2;
        return (_a2 = Array.from(this.keys()).pop()) != null ? _a2 : this.defaultState;
      }
      stateValue() {
        var _a2;
        return (_a2 = Array.from(this.values()).pop()) != null ? _a2 : this.defaultValue;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/interaction/cursorManager.ts
var CursorManager;
var init_cursorManager = __esm({
  "packages/ag-charts-community/src/chart/interaction/cursorManager.ts"() {
    "use strict";
    init_stateTracker();
    CursorManager = class {
      constructor(element2) {
        this.element = element2;
        this.stateTracker = new StateTracker("default");
      }
      updateCursor(callerId, style) {
        this.stateTracker.set(callerId, style);
        this.element.style.cursor = this.stateTracker.stateValue();
      }
      getCursor() {
        return this.element.style.cursor;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/interaction/gestureDetector.ts
function distanceSquared(finger1, finger2) {
  const dx2 = finger1.screenX - finger2.screenX;
  const dy2 = finger1.screenY - finger2.screenY;
  return dx2 * dx2 + dy2 * dy2;
}
function distance(finger1, finger2) {
  return Math.sqrt(distanceSquared(finger1, finger2));
}
var MIN_DISTANCE_TO_START_PINCH, GestureDetector;
var init_gestureDetector = __esm({
  "packages/ag-charts-community/src/chart/interaction/gestureDetector.ts"() {
    "use strict";
    init_logger();
    init_object();
    init_baseManager();
    MIN_DISTANCE_TO_START_PINCH = 1;
    GestureDetector = class extends BaseManager {
      constructor(element2) {
        super();
        this.touchstart = (event) => this.onTouchStart(event);
        this.touchmove = (event) => this.onTouchMove(event);
        this.touchend = (event) => this.onTouchEnd(event);
        this.touchcancel = (event) => this.onTouchCancel(event);
        this.pinch = {
          finger1: { identifier: NaN, screenX: NaN, screenY: NaN },
          finger2: { identifier: NaN, screenX: NaN, screenY: NaN },
          origin: { x: NaN, y: NaN },
          distance: NaN,
          status: 0 /* Off */
        };
        this.element = element2;
        element2.addEventListener("touchstart", this.touchstart, { passive: true });
        element2.addEventListener("touchmove", this.touchmove, { passive: true });
        element2.addEventListener("touchend", this.touchend);
        element2.addEventListener("touchcancel", this.touchcancel);
      }
      destroy() {
        const { element: element2 } = this;
        element2.removeEventListener("touchstart", this.touchstart);
        element2.removeEventListener("touchmove", this.touchmove);
        element2.removeEventListener("touchend", this.touchend);
        element2.removeEventListener("touchcancel", this.touchcancel);
      }
      findPinchTouches(moveEvent) {
        const { touches } = moveEvent;
        const { finger1, finger2 } = this.pinch;
        if (this.pinch.status !== 0 /* Off */ && touches.length === 2) {
          if (touches[0].identifier === finger1.identifier && touches[1].identifier === finger2.identifier) {
            return [touches[0], touches[1]];
          }
          if (touches[0].identifier === finger2.identifier && touches[1].identifier === finger1.identifier) {
            return [touches[1], touches[0]];
          }
        }
      }
      copyTouchData(event) {
        const keys = ["identifier", "screenX", "screenY"];
        partialAssign(keys, this.pinch.finger1, event.touches[0]);
        partialAssign(keys, this.pinch.finger2, event.touches[1]);
        this.pinch.distance = distance(this.pinch.finger1, this.pinch.finger2);
      }
      dispatchPinchEvent(type, deltaDistance) {
        const { finger1, finger2, origin } = this.pinch;
        const newEvent = { type, finger1, finger2, deltaDistance, origin };
        this.listeners.dispatch(type, newEvent);
      }
      onTouchStart(event) {
        this.stopPinchTracking();
        const { pinch } = this;
        if (event.touches.length === 2) {
          pinch.status = 1 /* Initialized */;
          this.copyTouchData(event);
          pinch.origin.x = (event.touches[0].clientX + event.touches[1].clientX) / 2;
          pinch.origin.y = (event.touches[0].clientY + event.touches[1].clientY) / 2;
        }
      }
      onTouchMove(event) {
        const pinchTouches = this.findPinchTouches(event);
        if (pinchTouches !== void 0) {
          const [touch1, touch2] = pinchTouches;
          const { pinch } = this;
          const newDistance = distance(touch1, touch2);
          const deltaDistance = newDistance - pinch.distance;
          if (pinch.status === 1 /* Initialized */) {
            if (Math.abs(deltaDistance) > MIN_DISTANCE_TO_START_PINCH) {
              pinch.status = 2 /* Running */;
              this.copyTouchData(event);
              this.dispatchPinchEvent("pinch-start", 0);
            }
          } else if (pinch.status === 2 /* Running */) {
            pinch.distance = newDistance;
            this.copyTouchData(event);
            this.dispatchPinchEvent("pinch-move", deltaDistance);
          } else {
            Logger.error(`unexpected pinch.status: ${pinch.status}`);
          }
        }
      }
      onTouchEnd(_event) {
        this.stopPinchTracking();
      }
      onTouchCancel(_event) {
        this.stopPinchTracking();
      }
      stopPinchTracking() {
        const { pinch } = this;
        if (pinch.status === 2 /* Running */) {
          this.dispatchPinchEvent("pinch-end", 0);
        }
        this.pinch.status = 0 /* Off */;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/interaction/highlightManager.ts
var HighlightManager;
var init_highlightManager = __esm({
  "packages/ag-charts-community/src/chart/interaction/highlightManager.ts"() {
    "use strict";
    init_stateTracker();
    init_baseManager();
    HighlightManager = class extends BaseManager {
      constructor() {
        super(...arguments);
        this.highlightStates = new StateTracker();
        this.pickedStates = new StateTracker();
      }
      updateHighlight(callerId, highlightedDatum) {
        const { activeHighlight: previousHighlight } = this;
        this.highlightStates.set(callerId, highlightedDatum);
        this.activeHighlight = this.highlightStates.stateValue();
        if (!this.isEqual(this.activeHighlight, previousHighlight)) {
          this.listeners.dispatch("highlight-change", {
            type: "highlight-change",
            currentHighlight: this.activeHighlight,
            previousHighlight
          });
        }
      }
      getActiveHighlight() {
        return this.activeHighlight;
      }
      updatePicked(callerId, clickableDatum) {
        this.pickedStates.set(callerId, clickableDatum);
        this.activePicked = this.pickedStates.stateValue();
      }
      getActivePicked() {
        return this.activePicked;
      }
      isEqual(a, b) {
        return a === b || (a == null ? void 0 : a.series) === (b == null ? void 0 : b.series) && (a == null ? void 0 : a.itemId) === (b == null ? void 0 : b.itemId) && (a == null ? void 0 : a.datum) === (b == null ? void 0 : b.datum);
      }
    };
  }
});

// packages/ag-charts-community/src/chart/interaction/keyNavManager.ts
var KeyNavManager;
var init_keyNavManager = __esm({
  "packages/ag-charts-community/src/chart/interaction/keyNavManager.ts"() {
    "use strict";
    init_baseManager();
    init_consumableEvent();
    init_interactionManager();
    KeyNavManager = class extends BaseManager {
      constructor(interactionManager) {
        super();
        this.hasBrowserFocus = false;
        this.isMouseBlurred = false;
        this.isClicking = false;
        this.destroyFns.push(
          interactionManager.addListener("drag-start", (e) => this.onClickStart(e), 31 /* All */),
          interactionManager.addListener("click", (e) => this.onClickStop(e), 31 /* All */),
          interactionManager.addListener("drag-end", (e) => this.onClickStop(e), 31 /* All */),
          interactionManager.addListener("wheel", (e) => this.mouseBlur(e)),
          interactionManager.addListener("hover", (e) => this.mouseBlur(e)),
          interactionManager.addListener("drag", (e) => this.mouseBlur(e)),
          interactionManager.addListener("blur", (e) => this.onBlur(e), 31 /* All */),
          interactionManager.addListener("focus", (e) => this.onFocus(e), 31 /* All */),
          interactionManager.addListener("keydown", (e) => this.onKeyDown(e), 31 /* All */)
        );
      }
      destroy() {
        super.destroy();
      }
      onClickStart(event) {
        this.isClicking = true;
        this.mouseBlur(event);
      }
      onClickStop(event) {
        this.isClicking = false;
        this.mouseBlur(event);
      }
      mouseBlur(event) {
        if (!this.hasBrowserFocus)
          return;
        if (!this.isMouseBlurred) {
          this.dispatch("blur", 0, event);
          this.isMouseBlurred = true;
        }
      }
      onBlur(event) {
        this.hasBrowserFocus = false;
        this.isMouseBlurred = false;
        this.dispatch("blur", 0, event);
      }
      onFocus(event) {
        this.hasBrowserFocus = true;
        if (this.isClicking) {
          this.isMouseBlurred = true;
        } else {
          this.dispatch("browserfocus", 1, event);
          this.dispatch("tab", 0, event);
        }
      }
      onKeyDown(event) {
        if (!this.hasBrowserFocus || this.isClicking)
          return;
        this.isMouseBlurred = false;
        switch (event.sourceEvent.code) {
          case "Tab":
            if (event.sourceEvent.shiftKey) {
              return this.dispatch("tab", -1, event);
            } else {
              return this.dispatch("tab", 1, event);
            }
          case "ArrowDown":
            return this.dispatch("nav-vert", 1, event);
          case "ArrowUp":
            return this.dispatch("nav-vert", -1, event);
          case "ArrowLeft":
            return this.dispatch("nav-hori", -1, event);
          case "ArrowRight":
            return this.dispatch("nav-hori", 1, event);
          case "Space":
          case "Enter":
            return this.dispatch("submit", 0, event);
        }
      }
      dispatch(type, delta3, interactionEvent) {
        const event = buildConsumable({ type, delta: delta3, sourceEvent: interactionEvent });
        dispatchTypedConsumable(this.listeners, type, event);
      }
    };
  }
});

// packages/ag-charts-community/src/chart/interaction/focusStyles.ts
var focusStyles_exports = {};
__export(focusStyles_exports, {
  block: () => block,
  css: () => css,
  elements: () => elements,
  modifiers: () => modifiers
});
var block, elements, modifiers, css;
var init_focusStyles = __esm({
  "packages/ag-charts-community/src/chart/interaction/focusStyles.ts"() {
    "use strict";
    block = "ag-charts-focus";
    elements = {
      wrapper: `${block}__wrapper`,
      indicator: `${block}__indicator`
    };
    modifiers = {
      hidden: `${block}--hidden`
    };
    css = `
.${block}.${elements.wrapper} {
    position: relative;
    display: block;
    pointer-events: none;
    user-select: none;
    overflow: hidden;
    top: 0;
    left: 0;
}

.${block}.${elements.indicator} {
    position: absolute;
    display: block;
    pointer-events: none;
    user-select: none;
    border: var(--ag-charts-focus-border);
    box-shadow: var(--ag-charts-focus-border-shadow);
}

.${modifiers.hidden} {
    visibility: hidden;
}
`;
  }
});

// packages/ag-charts-community/src/chart/interaction/regionManager.ts
var REGION_TAB_ORDERING, RegionListeners, RegionManager;
var init_regionManager = __esm({
  "packages/ag-charts-community/src/chart/interaction/regionManager.ts"() {
    "use strict";
    init_dom();
    init_listeners();
    init_consumableEvent();
    init_focusStyles();
    init_interactionManager();
    REGION_TAB_ORDERING = ["series", "legend"];
    RegionListeners = class extends Listeners {
    };
    RegionManager = class {
      constructor(interactionManager, keyNavManager, canvasElement, element2) {
        this.interactionManager = interactionManager;
        this.keyNavManager = keyNavManager;
        this.canvasElement = canvasElement;
        this.currentTabIndex = 0;
        this.isDragging = false;
        this.leftCanvas = false;
        this.regions = /* @__PURE__ */ new Map();
        this.destroyFns = [];
        this.destroyFns.push(
          ...POINTER_INTERACTION_TYPES.map(
            (eventName) => interactionManager.addListener(eventName, this.processPointerEvent.bind(this), 31 /* All */)
          ),
          this.keyNavManager.addListener("blur", this.onNav.bind(this)),
          this.keyNavManager.addListener("browserfocus", this.onFocus.bind(this)),
          this.keyNavManager.addListener("tab", this.onTab.bind(this)),
          this.keyNavManager.addListener("nav-vert", this.onNav.bind(this)),
          this.keyNavManager.addListener("nav-hori", this.onNav.bind(this)),
          this.keyNavManager.addListener("submit", this.onNav.bind(this))
        );
        injectStyle(css, block);
        this.focusWrapper = getDocument().createElement("div");
        this.focusIndicator = getDocument().createElement("div");
        this.focusWrapper.appendChild(this.focusIndicator);
        element2.appendChild(this.focusWrapper);
        const { block: block3, elements: elements3, modifiers: modifiers3 } = focusStyles_exports;
        this.focusWrapper.classList.add(block3, elements3.wrapper);
        this.focusIndicator.classList.add(block3, elements3.indicator, modifiers3.hidden);
      }
      destroy() {
        this.destroyFns.forEach((fn) => fn());
        this.currentRegion = void 0;
        for (const region of this.regions.values()) {
          region.listeners.destroy();
        }
        this.focusWrapper.remove();
        this.regions.clear();
      }
      addRegionFromProperties(properties) {
        const region = { properties, listeners: new RegionListeners() };
        this.regions.set(properties.name, region);
        return this.makeObserver(region);
      }
      addRegion(name, bboxprovider, ...extraProviders) {
        return this.addRegionFromProperties({
          name,
          bboxproviders: [bboxprovider, ...extraProviders],
          canInteraction: () => true
        });
      }
      getRegion(name) {
        return this.makeObserver(this.regions.get(name));
      }
      find(x, y) {
        const matches = [];
        for (const [_name, region] of this.regions.entries()) {
          for (const provider of region.properties.bboxproviders) {
            const bbox = provider.getCachedBBox();
            if (bbox.containsPoint(x, y)) {
              matches.push([region, bbox.width * bbox.height]);
            }
          }
        }
        return matches.sort((a, b) => a[1] - b[1]).map((m) => m[0]);
      }
      // This method return a wrapper object that matches the interface of InteractionManager.addListener.
      // The intent is to allow the InteractionManager and RegionManager to be used almost interchangeably.
      makeObserver(region) {
        const { interactionManager } = this;
        class ObservableRegionImplementation {
          addListener(type, handler, triggeringStates = 16 /* Default */) {
            var _a2;
            return (_a2 = region == null ? void 0 : region.listeners.addListener(type, (e) => {
              if (!e.consumed) {
                const currentState = interactionManager.getState();
                if (currentState & triggeringStates) {
                  handler(e);
                }
              }
            })) != null ? _a2 : () => {
            };
          }
        }
        return new ObservableRegionImplementation();
      }
      checkPointerHistory(targetRegion, event) {
        for (const historyEvent of event.pointerHistory) {
          const historyRegion = this.pickRegion(historyEvent.offsetX, historyEvent.offsetY);
          if (targetRegion.properties.name !== (historyRegion == null ? void 0 : historyRegion.properties.name)) {
            return false;
          }
        }
        return true;
      }
      dispatch(region, event) {
        region == null ? void 0 : region.listeners.dispatch(event.type, event);
      }
      // Process events during a drag action. Returns false if this event should follow the standard
      // RegionManager.processEvent flow, or true if this event already processed by this function.
      handleDragging(event) {
        const { currentRegion } = this;
        switch (event.type) {
          case "drag-start":
            this.isDragging = true;
            this.leftCanvas = false;
            break;
          case "leave":
            this.leftCanvas = true;
            return this.isDragging;
          case "enter":
            this.leftCanvas = false;
            return this.isDragging;
          case "drag":
            if (this.isDragging) {
              this.dispatch(currentRegion, event);
              return true;
            }
            break;
          case "drag-end":
            if (this.isDragging) {
              this.isDragging = false;
              this.dispatch(currentRegion, event);
              if (this.leftCanvas) {
                this.dispatch(currentRegion, __spreadProps(__spreadValues({}, event), { type: "leave" }));
              }
              return true;
            }
            break;
        }
        return false;
      }
      processPointerEvent(event) {
        if (this.handleDragging(event)) {
          return;
        }
        const { currentRegion } = this;
        const newRegion = this.pickRegion(event.offsetX, event.offsetY);
        if (currentRegion !== void 0 && (newRegion == null ? void 0 : newRegion.properties.name) !== currentRegion.properties.name) {
          this.dispatch(currentRegion, __spreadProps(__spreadValues({}, event), { type: "leave" }));
        }
        if (newRegion !== void 0 && newRegion.properties.name !== (currentRegion == null ? void 0 : currentRegion.properties.name)) {
          this.dispatch(newRegion, __spreadProps(__spreadValues({}, event), { type: "enter" }));
        }
        if (newRegion !== void 0 && this.checkPointerHistory(newRegion, event)) {
          this.dispatch(newRegion, event);
        }
        this.currentRegion = newRegion;
      }
      pickRegion(x, y) {
        const matchingRegions = this.find(x, y);
        return matchingRegions.length > 0 ? matchingRegions[0] : void 0;
      }
      getTabRegion(tabIndex) {
        if (tabIndex !== void 0 && tabIndex >= 0 && tabIndex < REGION_TAB_ORDERING.length) {
          return this.regions.get(REGION_TAB_ORDERING[tabIndex]);
        }
        return void 0;
      }
      dispatchTabStart(event) {
        const { delta: delta3, sourceEvent } = event;
        const startEvent = buildConsumable({
          type: "tab-start",
          delta: delta3,
          sourceEvent
        });
        const focusedRegion = this.getTabRegion(this.currentTabIndex);
        this.dispatch(focusedRegion, startEvent);
        return !!startEvent.consumed;
      }
      getNextInteractableTabIndex(currentIndex, delta3) {
        const direction = delta3 < 0 ? -1 : 1;
        let i = currentIndex;
        while (delta3 !== 0) {
          const region = this.getTabRegion(i + direction);
          if (region === void 0) {
            return void 0;
          } else if (region.properties.canInteraction()) {
            delta3 = delta3 - direction;
          }
          i = i + direction;
        }
        return i;
      }
      validateCurrentTabIndex() {
        var _a2;
        const focusedRegion = this.getTabRegion(this.currentTabIndex);
        if (focusedRegion !== void 0 && !focusedRegion.properties.canInteraction()) {
          this.currentTabIndex = (_a2 = this.getNextInteractableTabIndex(-1, 1)) != null ? _a2 : 0;
        }
      }
      onFocus(event) {
        const { delta: delta3, sourceEvent } = event;
        const newIndex = delta3 > 0 ? this.getNextInteractableTabIndex(-1, 1) : this.getNextInteractableTabIndex(REGION_TAB_ORDERING.length, -1);
        this.currentTabIndex = newIndex != null ? newIndex : 0;
        const focusedRegion = this.getTabRegion(this.currentTabIndex);
        if (focusedRegion) {
          this.dispatch(focusedRegion, buildConsumable({ type: "tab", delta: delta3, sourceEvent }));
        }
      }
      onTab(event) {
        const consumed = this.dispatchTabStart(event);
        if (consumed)
          return;
        this.validateCurrentTabIndex();
        const newTabIndex = this.getNextInteractableTabIndex(this.currentTabIndex, event.delta);
        const newRegion = this.getTabRegion(newTabIndex);
        const focusedRegion = this.getTabRegion(this.currentTabIndex);
        if (newTabIndex !== void 0) {
          this.currentTabIndex = newTabIndex;
        }
        if (focusedRegion !== void 0 && (newRegion == null ? void 0 : newRegion.properties.name) !== focusedRegion.properties.name) {
          const { delta: delta3, sourceEvent } = event;
          const blurEvent = buildConsumable({ type: "blur", delta: delta3, sourceEvent });
          this.dispatch(focusedRegion, blurEvent);
        }
        if (newRegion === void 0 || !newRegion.properties.canInteraction()) {
          this.updateFocusIndicatorRect(void 0);
        } else {
          this.dispatch(newRegion, event);
        }
      }
      onNav(event) {
        const focusedRegion = this.getTabRegion(this.currentTabIndex);
        this.dispatch(focusedRegion, event);
      }
      updateFocusWrapperRect() {
        this.focusWrapper.style.width = this.canvasElement.style.width;
        this.focusWrapper.style.height = this.canvasElement.style.height;
      }
      updateFocusIndicatorRect(rect) {
        if (rect == null) {
          this.focusIndicator.classList.add(modifiers.hidden);
          return;
        }
        this.updateFocusWrapperRect();
        this.focusIndicator.classList.remove(modifiers.hidden);
        this.focusIndicator.style.width = `${rect.width}px`;
        this.focusIndicator.style.height = `${rect.height}px`;
        this.focusIndicator.style.left = `${rect.x}px`;
        this.focusIndicator.style.top = `${rect.y}px`;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/interaction/toolbarManager.ts
var ToolbarManager;
var init_toolbarManager = __esm({
  "packages/ag-charts-community/src/chart/interaction/toolbarManager.ts"() {
    "use strict";
    init_baseManager();
    ToolbarManager = class extends BaseManager {
      constructor(element2) {
        super();
        this.element = element2;
      }
      static isGroup(group2, event) {
        return event.group === group2;
      }
      pressButton(group2, value) {
        this.listeners.dispatch("button-pressed", { type: "button-pressed", group: group2, value });
      }
      toggleGroup(group2, visible) {
        this.listeners.dispatch("group-toggled", { type: "group-toggled", group: group2, visible });
      }
      toggleButton(group2, value, enabled) {
        this.listeners.dispatch("button-toggled", { type: "button-toggled", group: group2, value, enabled });
      }
      proxyGroupOptions(group2, options) {
        this.listeners.dispatch("proxy-group-options", { type: "proxy-group-options", group: group2, options });
      }
    };
  }
});

// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts
var defaultTooltipCss, TooltipManager;
var init_tooltipManager = __esm({
  "packages/ag-charts-community/src/chart/interaction/tooltipManager.ts"() {
    "use strict";
    init_dom();
    init_stateTracker();
    init_tooltip();
    defaultTooltipCss = `
.${DEFAULT_TOOLTIP_CLASS} {
    transition: transform 0.1s ease;
    max-width: 100%;
    position: fixed;
    left: 0px;
    top: 0px;
    z-index: 99999;
    font: 12px Verdana, sans-serif;
    color: rgb(70, 70, 70);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
}

.${DEFAULT_TOOLTIP_CLASS}-wrap-always {
    overflow-wrap: break-word;
    word-break: break-word;
    hyphens: none;
}

.${DEFAULT_TOOLTIP_CLASS}-wrap-hyphenate {
    overflow-wrap: break-word;
    word-break: break-word;
    hyphens: auto;
}

.${DEFAULT_TOOLTIP_CLASS}-wrap-on-space {
    overflow-wrap: normal;
    word-break: normal;
}

.${DEFAULT_TOOLTIP_CLASS}-wrap-never {
    white-space: pre;
    text-overflow: ellipsis;
}

.${DEFAULT_TOOLTIP_CLASS}-no-interaction {
    pointer-events: none;
    user-select: none;
}

.${DEFAULT_TOOLTIP_CLASS}-no-animation {
    transition: none !important;
}

.${DEFAULT_TOOLTIP_CLASS}-hidden {
    visibility: hidden;
}

.${DEFAULT_TOOLTIP_CLASS}-title {
    overflow: hidden;
    position: relative;
    padding: 8px 14px;
    border-top-left-radius: 2px;
    border-top-right-radius: 2px;
    color: white;
    background-color: #888888;
    z-index: 1;
    text-overflow: inherit;
}

.${DEFAULT_TOOLTIP_CLASS}-title:only-child {
    border-bottom-left-radius: 2px;
    border-bottom-right-radius: 2px;
}

.${DEFAULT_TOOLTIP_CLASS}-content {
    overflow: hidden;
    padding: 6px 14px;
    line-height: 1.7em;
    background: white;
    border-bottom-left-radius: 2px;
    border-bottom-right-radius: 2px;
    border: 1px solid rgba(0, 0, 0, 0.15);
    overflow: hidden;
    text-overflow: inherit;
}

.${DEFAULT_TOOLTIP_CLASS}-arrow::before {
    content: "";

    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);

    border: 5px solid #d9d9d9;

    border-left-color: transparent;
    border-right-color: transparent;
    border-bottom-color: transparent;

    width: 0;
    height: 0;

    margin: 0 auto;
}

.${DEFAULT_TOOLTIP_CLASS}-arrow::after {
    content: "";

    position: absolute;
    top: calc(100% - 1px);
    left: 50%;
    transform: translateX(-50%);

    border: 5px solid white;

    border-left-color: transparent;
    border-right-color: transparent;
    border-bottom-color: transparent;

    width: 0;
    height: 0;

    margin: 0 auto;
}

.ag-chart-wrapper {
    box-sizing: border-box;
    overflow: hidden;
}
`;
    TooltipManager = class {
      constructor(canvasElement, tooltip) {
        this.canvasElement = canvasElement;
        this.tooltip = tooltip;
        this.stateTracker = new StateTracker();
        this.appliedState = null;
        if (typeof IntersectionObserver !== "undefined") {
          const observer = new IntersectionObserver(
            (entries) => {
              for (const entry of entries) {
                if (entry.target === this.canvasElement && entry.intersectionRatio === 0) {
                  this.tooltip.toggle(false);
                }
              }
            },
            { root: this.tooltip.root }
          );
          observer.observe(this.canvasElement);
          this.observer = observer;
        }
        injectStyle(defaultTooltipCss, "tooltip");
      }
      updateTooltip(callerId, meta, content) {
        var _a2;
        if (!this.tooltip.enabled)
          return;
        content != null ? content : content = (_a2 = this.stateTracker.get(callerId)) == null ? void 0 : _a2.content;
        this.stateTracker.set(callerId, { content, meta });
        this.applyStates();
      }
      removeTooltip(callerId) {
        if (!this.tooltip.enabled)
          return;
        this.stateTracker.delete(callerId);
        this.applyStates();
      }
      getTooltipMeta(callerId) {
        var _a2;
        return (_a2 = this.stateTracker.get(callerId)) == null ? void 0 : _a2.meta;
      }
      destroy() {
        var _a2;
        (_a2 = this.observer) == null ? void 0 : _a2.unobserve(this.canvasElement);
      }
      applyStates() {
        var _a2;
        const id = this.stateTracker.stateId();
        const state = id ? this.stateTracker.get(id) : null;
        if ((state == null ? void 0 : state.meta) == null || (state == null ? void 0 : state.content) == null) {
          this.appliedState = null;
          this.tooltip.toggle(false);
          return;
        }
        const canvasRect = this.canvasElement.getBoundingClientRect();
        if (((_a2 = this.appliedState) == null ? void 0 : _a2.content) === (state == null ? void 0 : state.content)) {
          const renderInstantly = this.tooltip.isVisible();
          this.tooltip.show(canvasRect, state == null ? void 0 : state.meta, null, renderInstantly);
        } else {
          this.tooltip.show(canvasRect, state == null ? void 0 : state.meta, state == null ? void 0 : state.content);
        }
        this.appliedState = state;
      }
      static makeTooltipMeta(event, datum) {
        var _a2, _b, _c, _d, _e, _f, _g;
        const { offsetX, offsetY } = event;
        const { tooltip } = datum.series.properties;
        const meta = {
          offsetX,
          offsetY,
          enableInteraction: (_b = (_a2 = tooltip.interaction) == null ? void 0 : _a2.enabled) != null ? _b : false,
          lastPointerEvent: { type: event.type, offsetX, offsetY },
          showArrow: tooltip.showArrow,
          position: {
            type: tooltip.position.type,
            xOffset: tooltip.position.xOffset,
            yOffset: tooltip.position.yOffset
          }
        };
        const refPoint = (_g = (_d = (_c = datum.yBar) == null ? void 0 : _c.upperPoint) != null ? _d : datum.midPoint) != null ? _g : (_f = (_e = datum.series).datumMidPoint) == null ? void 0 : _f.call(_e, datum);
        if (tooltip.position.type === "node" && refPoint) {
          const { x, y } = refPoint;
          const point = datum.series.contentGroup.inverseTransformPoint(x, y);
          return __spreadProps(__spreadValues({}, meta), {
            offsetX: Math.round(point.x),
            offsetY: Math.round(point.y)
          });
        }
        return meta;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/layout/layoutService.ts
var LayoutService;
var init_layoutService = __esm({
  "packages/ag-charts-community/src/chart/layout/layoutService.ts"() {
    "use strict";
    init_listeners();
    init_logger();
    LayoutService = class extends Listeners {
      constructor() {
        super(...arguments);
        this.layoutComplete = "layout-complete";
      }
      addListener(eventType, handler) {
        if (this.isLayoutStage(eventType) || this.isLayoutComplete(eventType)) {
          return super.addListener(eventType, handler);
        }
        throw new Error(`AG Charts - unsupported listener type: ${eventType}`);
      }
      dispatchPerformLayout(stage, ctx) {
        if (this.isLayoutStage(stage)) {
          return this.getListenersByType(stage).reduce((result, listener) => {
            try {
              return listener.handler(result);
            } catch (e) {
              Logger.errorOnce(e);
              return result;
            }
          }, ctx);
        }
        return ctx;
      }
      dispatchLayoutComplete(event) {
        this.dispatch(this.layoutComplete, event);
      }
      isLayoutStage(eventType) {
        return eventType !== this.layoutComplete;
      }
      isLayoutComplete(eventType) {
        return eventType === this.layoutComplete;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/series/seriesStateManager.ts
var SeriesStateManager;
var init_seriesStateManager = __esm({
  "packages/ag-charts-community/src/chart/series/seriesStateManager.ts"() {
    "use strict";
    SeriesStateManager = class {
      constructor() {
        this.groups = {};
      }
      registerSeries({
        id,
        seriesGrouping,
        visible,
        type
      }) {
        var _a2, _b;
        if (!seriesGrouping)
          return;
        (_b = (_a2 = this.groups)[type]) != null ? _b : _a2[type] = {};
        this.groups[type][id] = { grouping: seriesGrouping, visible };
      }
      deregisterSeries({ id, type }) {
        if (this.groups[type]) {
          delete this.groups[type][id];
        }
        if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {
          delete this.groups[type];
        }
      }
      getVisiblePeerGroupIndex({
        type,
        seriesGrouping,
        visible
      }) {
        var _a2;
        if (!seriesGrouping)
          return { visibleGroupCount: visible ? 1 : 0, visibleSameStackCount: visible ? 1 : 0, index: 0 };
        const visibleGroupsSet = /* @__PURE__ */ new Set();
        const visibleSameStackSet = /* @__PURE__ */ new Set();
        for (const entry of Object.values((_a2 = this.groups[type]) != null ? _a2 : {})) {
          if (!entry.visible)
            continue;
          visibleGroupsSet.add(entry.grouping.groupIndex);
          if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {
            visibleSameStackSet.add(entry.grouping.stackIndex);
          }
        }
        const visibleGroups = Array.from(visibleGroupsSet);
        visibleGroups.sort((a, b) => a - b);
        return {
          visibleGroupCount: visibleGroups.length,
          visibleSameStackCount: visibleSameStackSet.size,
          index: visibleGroups.indexOf(seriesGrouping.groupIndex)
        };
      }
    };
  }
});

// packages/ag-charts-community/src/chart/chartUpdateType.ts
var ChartUpdateType;
var init_chartUpdateType = __esm({
  "packages/ag-charts-community/src/chart/chartUpdateType.ts"() {
    "use strict";
    ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType3) => {
      ChartUpdateType3[ChartUpdateType3["FULL"] = 0] = "FULL";
      ChartUpdateType3[ChartUpdateType3["UPDATE_DATA"] = 1] = "UPDATE_DATA";
      ChartUpdateType3[ChartUpdateType3["PROCESS_DATA"] = 2] = "PROCESS_DATA";
      ChartUpdateType3[ChartUpdateType3["PERFORM_LAYOUT"] = 3] = "PERFORM_LAYOUT";
      ChartUpdateType3[ChartUpdateType3["SERIES_UPDATE"] = 4] = "SERIES_UPDATE";
      ChartUpdateType3[ChartUpdateType3["TOOLTIP_RECALCULATION"] = 5] = "TOOLTIP_RECALCULATION";
      ChartUpdateType3[ChartUpdateType3["SCENE_RENDER"] = 6] = "SCENE_RENDER";
      ChartUpdateType3[ChartUpdateType3["NONE"] = 7] = "NONE";
      return ChartUpdateType3;
    })(ChartUpdateType || {});
  }
});

// packages/ag-charts-community/src/chart/updateService.ts
var UpdateService;
var init_updateService = __esm({
  "packages/ag-charts-community/src/chart/updateService.ts"() {
    "use strict";
    init_listeners();
    init_chartUpdateType();
    UpdateService = class extends Listeners {
      constructor(updateCallback) {
        super();
        this.updateCallback = updateCallback;
      }
      update(type = 0 /* FULL */, options) {
        this.updateCallback(type, options);
      }
      dispatchUpdateComplete(rects) {
        this.dispatch("update-complete", {
          type: "update-complete",
          minRect: rects == null ? void 0 : rects.minRect,
          minVisibleRect: rects == null ? void 0 : rects.minVisibleRect
        });
      }
    };
  }
});

// packages/ag-charts-community/src/chart/chartContext.ts
var ChartContext;
var init_chartContext = __esm({
  "packages/ag-charts-community/src/chart/chartContext.ts"() {
    "use strict";
    init_callbackCache();
    init_annotationManager();
    init_dataService();
    init_animationManager();
    init_ariaAnnouncementServices();
    init_chartEventManager();
    init_contextMenuRegistry();
    init_cursorManager();
    init_gestureDetector();
    init_highlightManager();
    init_interactionManager();
    init_keyNavManager();
    init_regionManager();
    init_toolbarManager();
    init_tooltipManager();
    init_layoutService();
    init_seriesStateManager();
    init_updateService();
    ChartContext = class {
      constructor(chart, vars) {
        const { scene, syncManager, element: element2, updateCallback, updateMutex } = vars;
        this.chartService = chart;
        this.scene = scene;
        this.syncManager = syncManager;
        this.zoomManager = chart.zoomManager;
        this.annotationManager = new AnnotationManager(chart.annotationRoot);
        this.ariaAnnouncementService = new AriaAnnouncementService(scene.canvas.element);
        this.chartEventManager = new ChartEventManager();
        this.contextMenuRegistry = new ContextMenuRegistry();
        this.cursorManager = new CursorManager(element2);
        this.highlightManager = new HighlightManager();
        this.interactionManager = new InteractionManager(chart.keyboard, element2);
        this.keyNavManager = new KeyNavManager(this.interactionManager);
        this.regionManager = new RegionManager(
          this.interactionManager,
          this.keyNavManager,
          this.scene.canvas.element,
          element2
        );
        this.toolbarManager = new ToolbarManager(element2);
        this.gestureDetector = new GestureDetector(element2);
        this.layoutService = new LayoutService();
        this.updateService = new UpdateService(updateCallback);
        this.seriesStateManager = new SeriesStateManager();
        this.callbackCache = new CallbackCache();
        this.animationManager = new AnimationManager(this.interactionManager, updateMutex);
        this.animationManager.skip();
        this.animationManager.play();
        this.dataService = new DataService(this.animationManager);
        this.tooltipManager = new TooltipManager(this.scene.canvas.element, chart.tooltip);
      }
      destroy() {
        this.tooltipManager.destroy();
        this.regionManager.destroy();
        this.keyNavManager.destroy();
        this.interactionManager.destroy();
        this.animationManager.stop();
        this.animationManager.destroy();
        this.ariaAnnouncementService.destroy();
        this.chartEventManager.destroy();
        this.highlightManager.destroy();
        this.callbackCache.invalidateCache();
        this.animationManager.reset();
        this.syncManager.destroy();
      }
    };
  }
});

// packages/ag-charts-community/src/chart/chartHighlight.ts
var ChartHighlight;
var init_chartHighlight = __esm({
  "packages/ag-charts-community/src/chart/chartHighlight.ts"() {
    "use strict";
    init_properties();
    init_validation();
    ChartHighlight = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.range = "tooltip";
      }
    };
    __decorateClass([
      Validate(UNION(["tooltip", "node"], "a range"))
    ], ChartHighlight.prototype, "range", 2);
  }
});

// packages/ag-charts-community/src/chart/data/dataDomain.ts
var DiscreteDomain, ContinuousDomain;
var init_dataDomain = __esm({
  "packages/ag-charts-community/src/chart/data/dataDomain.ts"() {
    "use strict";
    DiscreteDomain = class _DiscreteDomain {
      constructor() {
        this.domain = /* @__PURE__ */ new Set();
      }
      static is(value) {
        return value instanceof _DiscreteDomain;
      }
      extend(val) {
        this.domain.add(val);
      }
      getDomain() {
        return Array.from(this.domain);
      }
    };
    ContinuousDomain = class _ContinuousDomain {
      constructor() {
        this.domain = [Infinity, -Infinity];
      }
      static is(value) {
        return value instanceof _ContinuousDomain;
      }
      static extendDomain(values, domain = [Infinity, -Infinity]) {
        for (const value of values) {
          if (typeof value !== "number") {
            continue;
          }
          if (domain[0] > value) {
            domain[0] = value;
          }
          if (domain[1] < value) {
            domain[1] = value;
          }
        }
        return domain;
      }
      extend(value) {
        if (this.domain[0] > value) {
          this.domain[0] = value;
        }
        if (this.domain[1] < value) {
          this.domain[1] = value;
        }
      }
      getDomain() {
        return [...this.domain];
      }
    };
  }
});

// packages/ag-charts-community/src/chart/data/dataModel.ts
function toKeyString(keys) {
  return keys.map((key) => isObject(key) ? JSON.stringify(key) : key).join("-");
}
function round2(val) {
  const accuracy = 1e4;
  if (Number.isInteger(val)) {
    return val;
  } else if (Math.abs(val) > accuracy) {
    return Math.trunc(val);
  }
  return Math.round(val * accuracy) / accuracy;
}
function fixNumericExtentInternal(extent6) {
  if (extent6 == null) {
    return [];
  }
  let [min, max] = extent6.map(Number);
  if (min === 0 && max === 0) {
    return [0, 1];
  }
  if (min === Infinity && max === -Infinity) {
    return [];
  } else if (min === Infinity) {
    min = 0;
  } else if (max === -Infinity) {
    max = 0;
  }
  return isFiniteNumber(min) && isFiniteNumber(max) ? [min, max] : [];
}
function fixNumericExtent(extent6, axis) {
  var _a2;
  const fixedExtent = fixNumericExtentInternal(extent6);
  if (fixedExtent.length === 0) {
    return fixedExtent;
  }
  let [min, max] = fixedExtent;
  if (min === max) {
    const [paddingMin, paddingMax] = (_a2 = axis == null ? void 0 : axis.calculatePadding(min, max)) != null ? _a2 : [1, 1];
    min -= paddingMin;
    max += paddingMax;
  }
  return [min, max];
}
function getMissCount(scopeProvider, missMap) {
  var _a2;
  return (_a2 = missMap == null ? void 0 : missMap.get(scopeProvider.id)) != null ? _a2 : 0;
}
function logProcessedData(processedData) {
  var _a2, _b;
  const logValues = (name, data) => {
    if (data.length > 0) {
      Logger.log(`DataModel.processData() - ${name}`);
      Logger.table(data);
    }
  };
  Logger.log("DataModel.processData() - processedData", processedData);
  logValues("Key Domains", processedData.domain.keys);
  logValues("Group Domains", (_a2 = processedData.domain.groups) != null ? _a2 : []);
  logValues("Value Domains", processedData.domain.values);
  logValues("Aggregate Domains", (_b = processedData.domain.aggValues) != null ? _b : []);
  if (processedData.type === "grouped") {
    const flattenedValues = processedData.data.reduce((acc, next) => {
      var _a3, _b2;
      const keys = (_a3 = next.keys) != null ? _a3 : [];
      const aggValues = (_b2 = next.aggValues) != null ? _b2 : [];
      const skipKeys = next.keys.map(() => void 0);
      const skipAggValues = aggValues == null ? void 0 : aggValues.map(() => void 0);
      acc.push(
        ...next.values.map((v, i) => [
          ...i === 0 ? keys : skipKeys,
          ...v != null ? v : [],
          ...i == 0 ? aggValues : skipAggValues
        ])
      );
      return acc;
    }, []);
    logValues("Values", flattenedValues);
  } else {
    const flattenedValues = processedData.data.reduce((acc, next) => {
      var _a3;
      const aggValues = (_a3 = next.aggValues) != null ? _a3 : [];
      acc.push([...next.keys, ...next.values, ...aggValues]);
      return acc;
    }, []);
    logValues("Values", flattenedValues);
  }
}
var INVALID_VALUE, DataModel;
var init_dataModel = __esm({
  "packages/ag-charts-community/src/chart/data/dataModel.ts"() {
    "use strict";
    init_debug();
    init_function();
    init_logger();
    init_number();
    init_type_guards();
    init_dataDomain();
    INVALID_VALUE = Symbol("invalid");
    DataModel = class {
      constructor(opts, mode = "standalone") {
        this.opts = opts;
        this.mode = mode;
        this.debug = Debug.create(true, "data-model");
        this.scopeCache = /* @__PURE__ */ new Map();
        this.keys = [];
        this.values = [];
        this.aggregates = [];
        this.groupProcessors = [];
        this.propertyProcessors = [];
        this.reducers = [];
        this.processors = [];
        let keys = true;
        for (const next of opts.props) {
          if (next.type === "key" && !keys) {
            throw new Error("AG Charts - internal config error: keys must come before values.");
          }
          if (next.type === "value" && keys) {
            keys = false;
          }
        }
        const verifyMatchGroupId = ({ matchGroupIds = [] }) => {
          for (const matchGroupId of matchGroupIds) {
            if (this.values.every((def) => def.groupId !== matchGroupId)) {
              throw new Error(
                `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`
              );
            }
          }
        };
        for (const def of opts.props) {
          switch (def.type) {
            case "key":
              this.keys.push(__spreadProps(__spreadValues({}, def), { index: this.keys.length, missing: /* @__PURE__ */ new Map() }));
              break;
            case "value":
              if (def.property == null) {
                throw new Error(
                  `AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(
                    def
                  )}`
                );
              }
              this.values.push(__spreadProps(__spreadValues({}, def), { index: this.values.length, missing: /* @__PURE__ */ new Map() }));
              break;
            case "aggregate":
              verifyMatchGroupId(def);
              this.aggregates.push(__spreadProps(__spreadValues({}, def), { index: this.aggregates.length }));
              break;
            case "group-value-processor":
              verifyMatchGroupId(def);
              this.groupProcessors.push(__spreadProps(__spreadValues({}, def), { index: this.groupProcessors.length }));
              break;
            case "property-value-processor":
              this.propertyProcessors.push(__spreadProps(__spreadValues({}, def), { index: this.propertyProcessors.length }));
              break;
            case "reducer":
              this.reducers.push(__spreadProps(__spreadValues({}, def), { index: this.reducers.length }));
              break;
            case "processor":
              this.processors.push(__spreadProps(__spreadValues({}, def), { index: this.processors.length }));
              break;
          }
        }
      }
      resolveProcessedDataDefById(scope, searchId) {
        var _a2;
        const def = (_a2 = this.scopeCache.get(scope.id)) == null ? void 0 : _a2.get(searchId);
        if (!def) {
          throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${scope.id}]`);
        }
        return { index: def.index, def };
      }
      resolveProcessedDataIndexById(scope, searchId) {
        return this.resolveProcessedDataDefById(scope, searchId).index;
      }
      resolveProcessedDataDefsByIds(scope, searchIds) {
        return searchIds.map((searchId) => [searchId, this.resolveProcessedDataDefById(scope, searchId)]);
      }
      resolveProcessedDataDefsValues(defs, { keys, values }) {
        const result = {};
        for (const [searchId, { index, def }] of defs) {
          const processedData = def.type === "key" ? keys : values;
          result[searchId] = processedData[index];
        }
        return result;
      }
      getDomain(scope, searchId, type = "value", processedData) {
        var _a2;
        const domains = this.getDomainsByType(type, processedData);
        return (_a2 = domains == null ? void 0 : domains[this.resolveProcessedDataIndexById(scope, searchId)]) != null ? _a2 : [];
      }
      getDomainsByType(type, processedData) {
        switch (type) {
          case "key":
            return processedData.domain.keys;
          case "value":
            return processedData.domain.values;
          case "aggregate":
            return processedData.domain.aggValues;
          case "group-value-processor":
            return processedData.domain.groups;
          default:
            return null;
        }
      }
      processData(data, sources) {
        var _a2;
        const {
          opts: { groupByKeys, groupByFn },
          aggregates,
          groupProcessors,
          reducers,
          processors,
          propertyProcessors
        } = this;
        const start = performance.now();
        if (groupByKeys && this.keys.length === 0) {
          return;
        }
        let processedData = this.extractData(data, sources);
        if (groupByKeys) {
          processedData = this.groupData(processedData);
        } else if (groupByFn) {
          processedData = this.groupData(processedData, groupByFn(processedData));
        }
        if (groupProcessors.length > 0) {
          this.postProcessGroups(processedData);
        }
        if (aggregates.length > 0) {
          this.aggregateData(processedData);
        }
        if (propertyProcessors.length > 0) {
          this.postProcessProperties(processedData);
        }
        if (reducers.length > 0) {
          this.reduceData(processedData);
        }
        if (processors.length > 0) {
          this.postProcessData(processedData);
        }
        if (data.length > 0) {
          for (const def of iterate(this.keys, this.values)) {
            for (const [scope, missCount] of def.missing) {
              if (missCount >= data.length) {
                const scopeHint = scope == null ? "" : ` for ${scope}`;
                Logger.warnOnce(`the key '${def.property}' was not found in any data element${scopeHint}.`);
              }
            }
          }
        }
        const end = performance.now();
        processedData.time = end - start;
        if (this.debug.check()) {
          logProcessedData(processedData);
        }
        this.scopeCache.clear();
        for (const def of iterate(this.keys, this.values, this.aggregates)) {
          if (!def.idsMap)
            continue;
          for (const [scope, ids] of def.idsMap) {
            for (const id of ids) {
              if (!this.scopeCache.has(scope)) {
                this.scopeCache.set(scope, /* @__PURE__ */ new Map([[id, def]]));
              } else if ((_a2 = this.scopeCache.get(scope)) == null ? void 0 : _a2.has(id)) {
                throw new Error("duplicate definition ids on the same scope are not allowed.");
              } else {
                this.scopeCache.get(scope).set(id, def);
              }
            }
          }
        }
        return processedData;
      }
      valueGroupIdxLookup({ matchGroupIds }) {
        const result = [];
        for (const [index, def] of this.values.entries()) {
          if (!matchGroupIds || def.groupId && matchGroupIds.includes(def.groupId)) {
            result.push(index);
          }
        }
        return result;
      }
      valueIdxLookup(scopes, prop) {
        const noScopesToMatch = scopes == null || scopes.length === 0;
        const propId = typeof prop === "string" ? prop : prop.id;
        const hasMatchingScopeId = (def) => {
          if (def.idsMap) {
            for (const [scope, ids] of def.idsMap) {
              if ((scopes == null ? void 0 : scopes.includes(scope)) && ids.has(propId)) {
                return true;
              }
            }
          }
          return false;
        };
        const result = this.values.findIndex((def) => {
          const validDefScopes = def.scopes == null || noScopesToMatch && !def.scopes.length || def.scopes.some((s) => scopes == null ? void 0 : scopes.includes(s));
          return validDefScopes && (def.property === propId || def.id === propId || hasMatchingScopeId(def));
        });
        if (result === -1) {
          throw new Error(
            `AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(
              scopes
            )}`
          );
        }
        return result;
      }
      extractData(data, sources) {
        var _a2, _b, _c, _d;
        const { dataDomain, processValue, scopes, allScopesHaveSameDefs } = this.initDataDomainProcessor();
        const sourcesById = new Map(sources == null ? void 0 : sources.map((s) => [s.id, s]));
        const { keys: keyDefs, values: valueDefs } = this;
        const resultData = new Array(data.length);
        let resultDataIdx = 0;
        let partialValidDataCount = 0;
        for (const [datumIdx, datum] of data.entries()) {
          const sourceDatums = {};
          const validScopes = scopes.size > 0 ? new Set(scopes) : void 0;
          const keys = new Array(keyDefs.length);
          let keyIdx = 0;
          let key;
          for (const def of keyDefs) {
            key = processValue(def, datum, key);
            if (key === INVALID_VALUE)
              break;
            if (keys) {
              keys[keyIdx++] = key;
            }
          }
          if (key === INVALID_VALUE)
            continue;
          const values = valueDefs.length > 0 ? new Array(valueDefs.length) : void 0;
          let value;
          for (const [valueDefIdx, def] of valueDefs.entries()) {
            for (const scope of (_a2 = def.scopes) != null ? _a2 : scopes) {
              const source = sourcesById.get(scope);
              const valueDatum = (_b = source == null ? void 0 : source.data[datumIdx]) != null ? _b : datum;
              value = processValue(def, valueDatum, value, scope);
              if (value === INVALID_VALUE || !values)
                continue;
              if (source != null && def.includeProperty !== false) {
                const property = def.includeProperty && def.id != null ? def.id : def.property;
                (_c = sourceDatums[scope]) != null ? _c : sourceDatums[scope] = {};
                sourceDatums[scope][property] = value;
              }
              values[valueDefIdx] = value;
            }
            if (value === INVALID_VALUE) {
              if (allScopesHaveSameDefs)
                break;
              for (const scope of (_d = def.scopes) != null ? _d : scopes) {
                validScopes == null ? void 0 : validScopes.delete(scope);
              }
              if ((validScopes == null ? void 0 : validScopes.size) === 0)
                break;
            }
          }
          if (value === INVALID_VALUE && allScopesHaveSameDefs)
            continue;
          if ((validScopes == null ? void 0 : validScopes.size) === 0)
            continue;
          const result = { datum: __spreadValues(__spreadValues({}, datum), sourceDatums), keys, values };
          if (!allScopesHaveSameDefs && validScopes && validScopes.size < scopes.size) {
            partialValidDataCount++;
            result.validScopes = new Set(validScopes);
          }
          resultData[resultDataIdx++] = result;
        }
        resultData.length = resultDataIdx;
        const propertyDomain = (def) => {
          const defDomain = dataDomain.get(def);
          const result = defDomain.getDomain();
          if (ContinuousDomain.is(defDomain) && result[0] > result[1]) {
            return [];
          }
          return result;
        };
        return {
          type: "ungrouped",
          input: { count: data.length },
          data: resultData,
          domain: {
            keys: keyDefs.map(propertyDomain),
            values: valueDefs.map(propertyDomain)
          },
          defs: {
            allScopesHaveSameDefs,
            keys: keyDefs,
            values: valueDefs
          },
          partialValidDataCount,
          time: 0
        };
      }
      groupData(data, groupingFn) {
        var _a2;
        const processedData = /* @__PURE__ */ new Map();
        for (const dataEntry of data.data) {
          const { keys, values, datum, validScopes } = dataEntry;
          const group2 = (_a2 = groupingFn == null ? void 0 : groupingFn(dataEntry)) != null ? _a2 : keys;
          const groupStr = toKeyString(group2);
          if (processedData.has(groupStr)) {
            const existingData = processedData.get(groupStr);
            existingData.values.push(values);
            existingData.datum.push(datum);
            if (validScopes != null && existingData.validScopes != null) {
              for (const scope of existingData.validScopes) {
                if (!validScopes.has(scope)) {
                  existingData.validScopes.delete(scope);
                }
              }
            }
          } else {
            processedData.set(groupStr, {
              keys: group2,
              values: [values],
              datum: [datum],
              validScopes
            });
          }
        }
        const resultData = new Array(processedData.size);
        const resultGroups = new Array(processedData.size);
        let dataIndex = 0;
        for (const { keys, values, datum, validScopes } of processedData.values()) {
          if ((validScopes == null ? void 0 : validScopes.size) === 0)
            continue;
          resultGroups[dataIndex] = keys;
          resultData[dataIndex++] = {
            keys,
            values,
            datum,
            validScopes
          };
        }
        return __spreadProps(__spreadValues({}, data), {
          type: "grouped",
          data: resultData,
          domain: __spreadProps(__spreadValues({}, data.domain), {
            groups: resultGroups
          })
        });
      }
      aggregateData(processedData) {
        var _a2, _b, _c, _d, _e, _f, _g;
        const isUngrouped = processedData.type === "ungrouped";
        processedData.domain.aggValues = [];
        for (const [index, def] of this.aggregates.entries()) {
          const indices = this.valueGroupIdxLookup(def);
          const domain = [Infinity, -Infinity];
          for (const datum of processedData.data) {
            (_a2 = datum.aggValues) != null ? _a2 : datum.aggValues = new Array(this.aggregates.length);
            if (datum.validScopes)
              continue;
            const values = isUngrouped ? [datum.values] : datum.values;
            let groupAggValues = (_c = (_b = def.groupAggregateFunction) == null ? void 0 : _b.call(def)) != null ? _c : [Infinity, -Infinity];
            for (const distinctValues of values) {
              const valuesToAgg = indices.map((valueIdx) => distinctValues[valueIdx]);
              const valuesAgg = def.aggregateFunction(valuesToAgg, datum.keys);
              if (valuesAgg) {
                groupAggValues = (_e = (_d = def.groupAggregateFunction) == null ? void 0 : _d.call(def, valuesAgg, groupAggValues)) != null ? _e : ContinuousDomain.extendDomain(valuesAgg, groupAggValues);
              }
            }
            const finalValues = ((_g = (_f = def.finalFunction) == null ? void 0 : _f.call(def, groupAggValues)) != null ? _g : groupAggValues).map((v) => round2(v));
            datum.aggValues[index] = finalValues;
            ContinuousDomain.extendDomain(finalValues, domain);
          }
          processedData.domain.aggValues.push(domain);
        }
      }
      postProcessGroups(processedData) {
        var _a2, _b;
        const { groupProcessors } = this;
        const affectedIndices = /* @__PURE__ */ new Set();
        const updatedDomains = /* @__PURE__ */ new Map();
        const groupProcessorIndices = /* @__PURE__ */ new Map();
        const groupProcessorInitFns = /* @__PURE__ */ new Map();
        for (const processor of groupProcessors) {
          const indices = this.valueGroupIdxLookup(processor);
          groupProcessorIndices.set(processor, indices);
          groupProcessorInitFns.set(processor, processor.adjust());
          for (const idx of indices) {
            const valueDef = this.values[idx];
            const isDiscrete = valueDef.valueType === "category";
            affectedIndices.add(idx);
            updatedDomains.set(idx, isDiscrete ? new DiscreteDomain() : new ContinuousDomain());
          }
        }
        const updateDomains = (values) => {
          var _a3;
          for (const valueIndex of affectedIndices) {
            (_a3 = updatedDomains.get(valueIndex)) == null ? void 0 : _a3.extend(values[valueIndex]);
          }
        };
        for (const group2 of processedData.data) {
          for (const processor of groupProcessors) {
            if (group2.validScopes)
              continue;
            const valueIndexes = (_a2 = groupProcessorIndices.get(processor)) != null ? _a2 : [];
            const adjustFn = (_b = groupProcessorInitFns.get(processor)) == null ? void 0 : _b();
            if (!adjustFn)
              continue;
            if (processedData.type === "grouped") {
              for (const values of group2.values) {
                if (values) {
                  adjustFn(values, valueIndexes);
                }
              }
            } else if (group2.values) {
              adjustFn(group2.values, valueIndexes);
            }
          }
          if (processedData.type === "grouped") {
            for (const values of group2.values) {
              updateDomains(values);
            }
          } else {
            updateDomains(group2.values);
          }
        }
        for (const [idx, dataDomain] of updatedDomains) {
          processedData.domain.values[idx] = dataDomain.getDomain();
        }
      }
      postProcessProperties(processedData) {
        for (const { adjust, property, scopes } of this.propertyProcessors) {
          adjust()(processedData, this.valueIdxLookup(scopes, property));
        }
      }
      reduceData(processedData) {
        var _a2, _b;
        (_a2 = processedData.reduced) != null ? _a2 : processedData.reduced = {};
        for (const def of this.reducers) {
          const reducer = def.reducer();
          let accValue = def.initialValue;
          for (const datum of processedData.data) {
            if (!datum.validScopes || ((_b = def.scopes) == null ? void 0 : _b.some((s) => {
              var _a3;
              return (_a3 = datum.validScopes) == null ? void 0 : _a3.has(s);
            }))) {
              accValue = reducer(accValue, datum);
            }
          }
          processedData.reduced[def.property] = accValue;
        }
      }
      postProcessData(processedData) {
        var _a2;
        (_a2 = processedData.reduced) != null ? _a2 : processedData.reduced = {};
        for (const def of this.processors) {
          processedData.reduced[def.property] = def.calculate(processedData);
        }
      }
      initDataDomainProcessor() {
        const { keys: keyDefs, values: valueDefs } = this;
        const scopes = /* @__PURE__ */ new Set();
        for (const valueDef of valueDefs) {
          if (!valueDef.scopes)
            continue;
          for (const scope of valueDef.scopes) {
            scopes.add(scope);
          }
        }
        const dataDomain = /* @__PURE__ */ new Map();
        const processorFns = /* @__PURE__ */ new Map();
        let allScopesHaveSameDefs = true;
        const initDataDomain = () => {
          var _a2;
          for (const def of iterate(keyDefs, valueDefs)) {
            if (def.valueType === "category") {
              dataDomain.set(def, new DiscreteDomain());
            } else {
              dataDomain.set(def, new ContinuousDomain());
              allScopesHaveSameDefs && (allScopesHaveSameDefs = ((_a2 = def.scopes) != null ? _a2 : []).length === scopes.size);
            }
          }
        };
        initDataDomain();
        const accessors = this.buildAccessors(iterate(keyDefs, valueDefs));
        const processValue = (def, datum, previousDatum, scope) => {
          var _a2, _b, _c, _d, _e;
          let valueInDatum;
          let value;
          if (accessors.has(def.property)) {
            try {
              value = accessors.get(def.property)(datum);
            } catch (error) {
            }
            valueInDatum = value != null;
          } else {
            valueInDatum = def.property in datum;
            value = valueInDatum ? datum[def.property] : def.missingValue;
          }
          if (def.forceValue != null) {
            const valueNegative = valueInDatum && isNegative(value);
            value = valueNegative ? -1 * def.forceValue : def.forceValue;
            valueInDatum = true;
          }
          const missingValueDef = "missingValue" in def;
          if (!valueInDatum && !missingValueDef) {
            const missCount = (_a2 = def.missing.get(scope)) != null ? _a2 : 0;
            def.missing.set(scope, missCount + 1);
          }
          if (!dataDomain.has(def)) {
            initDataDomain();
          }
          if (valueInDatum && !((_c = (_b = def.validation) == null ? void 0 : _b.call(def, value, datum)) != null ? _c : true)) {
            if ("invalidValue" in def) {
              value = def.invalidValue;
            } else {
              if (this.mode !== "integrated") {
                Logger.warnOnce(`invalid value of type [${typeof value}] ignored:`, `[${value}]`);
              }
              return INVALID_VALUE;
            }
          }
          if (def.processor) {
            if (!processorFns.has(def)) {
              processorFns.set(def, def.processor());
            }
            value = (_d = processorFns.get(def)) == null ? void 0 : _d(value, previousDatum === INVALID_VALUE ? void 0 : previousDatum);
          }
          (_e = dataDomain.get(def)) == null ? void 0 : _e.extend(value);
          return value;
        };
        return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };
      }
      buildAccessors(defs) {
        const result = /* @__PURE__ */ new Map();
        if (this.mode === "integrated") {
          return result;
        }
        for (const def of defs) {
          const isPath = def.property.includes(".") || def.property.includes("[");
          if (!isPath)
            continue;
          let fnBody;
          if (def.property.startsWith("[")) {
            fnBody = `return datum${def.property};`;
          } else {
            fnBody = `return datum.${def.property};`;
          }
          result.set(def.property, new Function("datum", fnBody));
        }
        return result;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/data/dataController.ts
var _DataController, DataController;
var init_dataController = __esm({
  "packages/ag-charts-community/src/chart/data/dataController.ts"() {
    "use strict";
    init_debug();
    init_dom();
    init_dataModel();
    _DataController = class _DataController {
      constructor(mode) {
        this.mode = mode;
        this.debug = Debug.create(true, "data-model");
        this.requested = [];
        this.status = "setup";
      }
      request(id, data, opts) {
        return __async(this, null, function* () {
          if (this.status !== "setup") {
            throw new Error(`AG Charts - data request after data setup phase.`);
          }
          return new Promise((resolve, reject) => {
            this.requested.push({ id, opts, data, resolve, reject });
          });
        });
      }
      execute() {
        if (this.status !== "setup") {
          throw new Error(`AG Charts - data request after data setup phase.`);
        }
        this.status = "executed";
        this.debug("DataController.execute() - requested", this.requested);
        const valid = this.validateRequests(this.requested);
        this.debug("DataController.execute() - validated", valid);
        const merged = this.mergeRequested(valid);
        this.debug("DataController.execute() - merged", merged);
        if (this.debug.check()) {
          getWindow().processedData = [];
        }
        const scopes = this.requested.map(({ id }) => id);
        const needsValueExtraction = this.hasMultipleDataSources(valid);
        for (const { opts, data, resolves, rejects, ids } of merged) {
          try {
            const dataModel = new DataModel(opts, this.mode);
            const processedData = dataModel.processData(data, valid);
            if (this.debug.check()) {
              getWindow("processedData").push(processedData);
            }
            if ((processedData == null ? void 0 : processedData.partialValidDataCount) === 0) {
              resolves.forEach(
                (resolve, requestIdx) => resolve({
                  dataModel,
                  processedData: this.processScopedData(
                    ids[requestIdx],
                    processedData,
                    scopes,
                    needsValueExtraction
                  )
                })
              );
            } else if (processedData) {
              this.splitResult(dataModel, processedData, ids, resolves);
            } else {
              rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));
            }
          } catch (error) {
            rejects.forEach((cb) => cb(error));
          }
        }
      }
      hasMultipleDataSources(validRequests) {
        if (validRequests.length) {
          const [{ data }, ...restRequests] = validRequests;
          return restRequests.some((v) => data !== v.data);
        }
        return false;
      }
      processScopedData(id, processedData, ids, needsValueExtraction) {
        const extractDatum = (datum) => {
          if (Array.isArray(datum)) {
            return datum.map(extractDatum);
          }
          const extracted = needsValueExtraction ? __spreadValues(__spreadValues({}, datum), datum[id]) : datum;
          for (const otherId of ids) {
            delete extracted[otherId];
          }
          return extracted;
        };
        const extractValues = (values) => {
          var _a2;
          if (Array.isArray(values)) {
            return values.map(extractValues);
          }
          return (_a2 = values == null ? void 0 : values[id]) != null ? _a2 : values;
        };
        return __spreadProps(__spreadValues({}, processedData), {
          data: processedData.data.map((datum) => {
            var _a2;
            return __spreadProps(__spreadValues({}, datum), {
              datum: extractDatum(datum.datum),
              values: needsValueExtraction ? (_a2 = datum.values) == null ? void 0 : _a2.map(extractValues) : datum.values
            });
          })
        });
      }
      validateRequests(requested) {
        const valid = [];
        for (const [index, request] of requested.entries()) {
          if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false) {
            request.reject(
              new Error("all series[].data arrays must be of the same length and have matching keys.")
            );
          } else {
            valid.push(request);
          }
        }
        return valid;
      }
      mergeRequested(requested) {
        const grouped = [];
        for (const request of requested) {
          const match = grouped.find(_DataController.groupMatch(request));
          if (match) {
            match.push(request);
          } else {
            grouped.push([request]);
          }
        }
        return grouped.map(_DataController.mergeRequests);
      }
      splitResult(dataModel, processedData, scopes, resolves) {
        for (let i = 0; i < scopes.length; i++) {
          const scope = scopes[i];
          const resolve = resolves[i];
          resolve({
            dataModel,
            processedData: __spreadProps(__spreadValues({}, processedData), {
              data: processedData.data.filter(({ validScopes }) => {
                var _a2;
                return (_a2 = validScopes == null ? void 0 : validScopes.has(scope)) != null ? _a2 : true;
              })
            })
          });
        }
      }
      static groupMatch({ data, opts }) {
        function keys(props) {
          return props.filter((p) => p.type === "key").map((p) => p.property).join(";");
        }
        return ([group2]) => (opts.groupByData === false || group2.data === data) && group2.opts.groupByKeys === opts.groupByKeys && group2.opts.groupByFn === opts.groupByFn && keys(group2.opts.props) === keys(opts.props);
      }
      static mergeRequests(requests) {
        return requests.reduce(
          (result, _a2) => {
            var { id, data, resolve, reject, opts: _b } = _a2, _c = _b, { props } = _c, opts = __objRest(_c, ["props"]);
            var _a3, _b2, _c2, _d, _e;
            result.ids.push(id);
            result.rejects.push(reject);
            result.resolves.push(resolve);
            (_a3 = result.data) != null ? _a3 : result.data = data;
            (_b2 = result.opts) != null ? _b2 : result.opts = __spreadProps(__spreadValues({}, opts), { props: [] });
            for (const prop of props) {
              const clone = __spreadProps(__spreadValues({}, prop), { scopes: [id] });
              _DataController.createIdsMap(id, clone);
              const match = result.opts.props.find(
                (existing) => existing.type === clone.type && _DataController.deepEqual(existing, clone)
              );
              if (!match) {
                result.opts.props.push(clone);
                continue;
              }
              (_c2 = match.scopes) != null ? _c2 : match.scopes = [];
              match.scopes.push(...(_d = clone.scopes) != null ? _d : []);
              if ((match.type === "key" || match.type === "value") && ((_e = clone.idsMap) == null ? void 0 : _e.size)) {
                _DataController.mergeIdsMap(clone.idsMap, match.idsMap);
              }
            }
            return result;
          },
          { ids: [], rejects: [], resolves: [], data: null, opts: null }
        );
      }
      static mergeIdsMap(fromMap, toMap) {
        for (const [scope, ids] of fromMap) {
          if (toMap.has(scope)) {
            for (const id of ids) {
              toMap.get(scope).add(id);
            }
          } else {
            toMap.set(scope, new Set(ids));
          }
        }
      }
      static createIdsMap(scope, prop) {
        var _a2;
        if (prop.id == null)
          return;
        (_a2 = prop.idsMap) != null ? _a2 : prop.idsMap = /* @__PURE__ */ new Map();
        if (prop.idsMap.has(scope)) {
          prop.idsMap.get(scope).add(prop.id);
        } else {
          prop.idsMap.set(scope, /* @__PURE__ */ new Set([prop.id]));
        }
      }
      static deepEqual(a, b) {
        if (a === b) {
          return true;
        }
        if (a && b && typeof a == "object" && typeof b == "object") {
          if (a.constructor !== b.constructor) {
            return false;
          }
          let i, length;
          if (Array.isArray(a)) {
            length = a.length;
            if (length !== b.length) {
              return false;
            }
            for (i = length - 1; i >= 0; i--) {
              if (!_DataController.deepEqual(a[i], b[i])) {
                return false;
              }
            }
            return true;
          }
          const keys = Object.keys(a);
          length = keys.length;
          if (length !== Object.keys(b).length) {
            return false;
          }
          for (i = length - 1; i >= 0; i--) {
            const key = keys[i];
            if (!_DataController.skipKeys.has(key) && (!Object.hasOwn(b, key) || !_DataController.deepEqual(a[key], b[key]))) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
    };
    // optimized version of deep equality for `mergeRequests` which can potentially loop over 1M times
    _DataController.skipKeys = /* @__PURE__ */ new Set(["id", "idsMap", "type", "scopes"]);
    DataController = _DataController;
  }
});

// packages/ag-charts-community/src/chart/interaction/syncManager.ts
var _SyncManager, SyncManager;
var init_syncManager = __esm({
  "packages/ag-charts-community/src/chart/interaction/syncManager.ts"() {
    "use strict";
    init_baseManager();
    _SyncManager = class _SyncManager extends BaseManager {
      constructor(chart) {
        super();
        this.chart = chart;
      }
      subscribe(groupId = _SyncManager.DEFAULT_GROUP) {
        let syncGroup = this.get(groupId);
        if (!syncGroup) {
          syncGroup = /* @__PURE__ */ new Set();
          _SyncManager.chartsGroups.set(groupId, syncGroup);
        }
        syncGroup.add(this.chart);
        return this;
      }
      unsubscribe(groupId = _SyncManager.DEFAULT_GROUP) {
        var _a2;
        (_a2 = this.get(groupId)) == null ? void 0 : _a2.delete(this.chart);
        return this;
      }
      getChart() {
        return this.chart;
      }
      getGroup(groupId = _SyncManager.DEFAULT_GROUP) {
        const syncGroup = this.get(groupId);
        return syncGroup ? Array.from(syncGroup) : [];
      }
      getGroupSiblings(groupId = _SyncManager.DEFAULT_GROUP) {
        return this.getGroup(groupId).filter((chart) => chart !== this.chart);
      }
      get(groupId) {
        return _SyncManager.chartsGroups.get(groupId);
      }
    };
    _SyncManager.chartsGroups = /* @__PURE__ */ new Map();
    _SyncManager.DEFAULT_GROUP = Symbol("sync-group-default");
    SyncManager = _SyncManager;
  }
});

// packages/ag-charts-community/src/chart/interaction/zoomManager.ts
var ZoomManager, AxisZoomManager;
var init_zoomManager = __esm({
  "packages/ag-charts-community/src/chart/interaction/zoomManager.ts"() {
    "use strict";
    init_json();
    init_stateTracker();
    init_chartAxisDirection();
    init_baseManager();
    ZoomManager = class extends BaseManager {
      constructor() {
        super(...arguments);
        this.axisZoomManagers = /* @__PURE__ */ new Map();
        this.state = new StateTracker(void 0, "initial");
        this.rejectCallbacks = /* @__PURE__ */ new Map();
      }
      updateAxes(axes) {
        var _a2;
        const zoomManagers = new Map(axes.map((axis) => [axis.id, this.axisZoomManagers.get(axis.id)]));
        this.axisZoomManagers.clear();
        for (const axis of axes) {
          this.axisZoomManagers.set(axis.id, (_a2 = zoomManagers.get(axis.id)) != null ? _a2 : new AxisZoomManager(axis));
        }
        if (this.state.size > 0 && axes.length > 0) {
          this.updateZoom(this.state.stateId(), this.state.stateValue());
        }
      }
      updateZoom(callerId, newZoom, canChangeInitial = true, rejectCallback) {
        var _a2;
        if (rejectCallback) {
          this.rejectCallbacks.set(callerId, rejectCallback);
        }
        if (this.axisZoomManagers.size === 0) {
          const stateId = this.state.stateId();
          if (stateId === "initial" || stateId === callerId || canChangeInitial) {
            this.state.set(callerId, newZoom);
            if (stateId !== callerId) {
              (_a2 = this.rejectCallbacks.get(stateId)) == null ? void 0 : _a2(callerId);
            }
          } else {
            rejectCallback == null ? void 0 : rejectCallback(stateId);
          }
          return;
        }
        this.state.set(callerId, newZoom);
        this.axisZoomManagers.forEach((axis) => {
          axis.updateZoom(callerId, newZoom == null ? void 0 : newZoom[axis.getDirection()]);
        });
        this.applyChanges(callerId);
      }
      updateAxisZoom(callerId, axisId, newZoom) {
        var _a2;
        (_a2 = this.axisZoomManagers.get(axisId)) == null ? void 0 : _a2.updateZoom(callerId, newZoom);
        this.applyChanges(callerId);
      }
      // Fire this event to signal to listeners that the view is changing through a zoom and/or pan change.
      fireZoomPanStartEvent(callerId) {
        this.listeners.dispatch("zoom-pan-start", { type: "zoom-pan-start", callerId });
      }
      getZoom() {
        let x;
        let y;
        this.axisZoomManagers.forEach((axis) => {
          if (axis.getDirection() === "x" /* X */) {
            x != null ? x : x = axis.getZoom();
          } else if (axis.getDirection() === "y" /* Y */) {
            y != null ? y : y = axis.getZoom();
          }
        });
        if (x || y) {
          return { x, y };
        }
      }
      getAxisZoom(axisId) {
        var _a2, _b;
        return (_b = (_a2 = this.axisZoomManagers.get(axisId)) == null ? void 0 : _a2.getZoom()) != null ? _b : { min: 0, max: 1 };
      }
      getAxisZooms() {
        const axes = {};
        for (const [axisId, axis] of this.axisZoomManagers.entries()) {
          axes[axisId] = {
            direction: axis.getDirection(),
            zoom: axis.getZoom()
          };
        }
        return axes;
      }
      applyChanges(callerId) {
        const changed = Array.from(this.axisZoomManagers.values(), (axis) => axis.applyChanges()).some(Boolean);
        if (!changed) {
          return;
        }
        const axes = {};
        for (const [axisId, axis] of this.axisZoomManagers.entries()) {
          axes[axisId] = axis.getZoom();
        }
        this.listeners.dispatch("zoom-change", __spreadProps(__spreadValues({ type: "zoom-change" }, this.getZoom()), { axes, callerId }));
      }
    };
    AxisZoomManager = class {
      constructor(axis) {
        this.axis = axis;
        const [min = 0, max = 1] = axis.visibleRange;
        this.state = new StateTracker({ min, max });
        this.currentZoom = this.state.stateValue();
      }
      getDirection() {
        return this.axis.direction;
      }
      updateZoom(callerId, newZoom) {
        this.state.set(callerId, newZoom);
      }
      getZoom() {
        return deepClone(this.state.stateValue());
      }
      applyChanges() {
        const prevZoom = this.currentZoom;
        this.currentZoom = this.state.stateValue();
        return prevZoom.min !== this.currentZoom.min || prevZoom.max !== this.currentZoom.max;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/keyboard.ts
var Keyboard;
var init_keyboard = __esm({
  "packages/ag-charts-community/src/chart/keyboard.ts"() {
    "use strict";
    init_properties();
    init_validation();
    Keyboard = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.enabled = false;
      }
    };
    __decorateClass([
      Validate(BOOLEAN)
    ], Keyboard.prototype, "enabled", 2);
    __decorateClass([
      Validate(NUMBER)
    ], Keyboard.prototype, "tabIndex", 2);
  }
});

// packages/ag-charts-community/src/chart/keyboardUtil.ts
function makeKeyboardPointerEvent(regionManager, pick) {
  const { bbox, showFocusBox } = pick;
  if (showFocusBox) {
    regionManager.updateFocusIndicatorRect(pick.bbox);
  }
  if (bbox !== void 0) {
    const { x: offsetX, y: offsetY } = bbox.computeCenter();
    return { type: "keyboard", offsetX, offsetY };
  }
  return void 0;
}
var init_keyboardUtil = __esm({
  "packages/ag-charts-community/src/chart/keyboardUtil.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts
function hasCartesianAxisPosition(axis) {
  const allowedTypes = CARTESIAN_AXIS_TYPES;
  return allowedTypes.includes(axis.type);
}
function isCartesianAxisOptions(options) {
  const allowedTypes = CARTESIAN_AXIS_TYPES;
  return allowedTypes.includes(options.type);
}
function isAxisPosition(position) {
  const allowedPositions = CARTESIAN_AXIS_POSITIONS;
  return typeof position === "string" && allowedPositions.includes(position);
}
var CARTESIAN_AXIS_POSITIONS, CARTESIAN_AXIS_TYPES, AxisPositionGuesser;
var init_prepareAxis = __esm({
  "packages/ag-charts-community/src/chart/mapping/prepareAxis.ts"() {
    "use strict";
    CARTESIAN_AXIS_POSITIONS = ["top", "right", "bottom", "left"];
    CARTESIAN_AXIS_TYPES = [
      "category",
      "grouped-category",
      "ordinal-time",
      "number",
      "log",
      "time"
    ];
    AxisPositionGuesser = class {
      constructor() {
        this.result = [];
        this.valid = [];
        this.invalid = [];
      }
      push(axis, options) {
        const { result, valid, invalid } = this;
        if (isCartesianAxisOptions(options)) {
          if (isAxisPosition(options.position)) {
            valid.push(axis);
          } else {
            invalid.push(axis);
          }
        }
        result.push(axis);
      }
      guessInvalidPositions() {
        const takenPosition = this.valid.filter((v) => hasCartesianAxisPosition(v)).map((v) => v.position).filter((v) => v !== void 0);
        const guesses = ["top", "right", "bottom", "left"];
        for (const invalidAxis of this.invalid) {
          let nextGuess = guesses.pop();
          while (takenPosition.includes(nextGuess) && nextGuess !== void 0) {
            nextGuess = guesses.pop();
          }
          if (nextGuess === void 0)
            break;
          invalidAxis.position = nextGuess;
        }
        return this.result;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts
function matchSeriesOptions(series, optSeries, oldOptsSeries) {
  var _a2, _b, _c, _d;
  const generateKey = (type, i) => {
    const result = [type];
    for (const key of MATCHING_KEYS) {
      if (key in i && i[key] != null)
        result.push(`${key}=${i[key]}`);
    }
    return result.join(";");
  };
  const seriesMap = /* @__PURE__ */ new Map();
  let idx = 0;
  for (const s of series) {
    const key = generateKey(s.type, s.properties);
    if (!seriesMap.has(key)) {
      seriesMap.set(key, []);
    }
    (_a2 = seriesMap.get(key)) == null ? void 0 : _a2.push([s, idx++]);
  }
  const optsMap = /* @__PURE__ */ new Map();
  for (const o of optSeries) {
    const key = generateKey(o.type, o);
    if (!optsMap.has(key)) {
      optsMap.set(key, []);
    }
    (_b = optsMap.get(key)) == null ? void 0 : _b.push(o);
  }
  const overlap = [...seriesMap.keys()].some((k) => optsMap.has(k));
  if (!overlap) {
    return { status: "no-overlap", oldKeys: seriesMap.keys(), newKeys: optsMap.keys() };
  }
  const changes = [];
  let targetIdx = -1;
  for (const [key, optArray] of optsMap.entries()) {
    for (const opts of optArray) {
      targetIdx++;
      const seriesArray = seriesMap.get(key);
      if (seriesArray == null || seriesArray.length < 1) {
        changes.push({ opts, idx: targetIdx, status: "add" });
        seriesMap.delete(key);
        continue;
      }
      const [outputSeries, outputIdx] = seriesArray.shift();
      const previousOpts = (_c = oldOptsSeries == null ? void 0 : oldOptsSeries[outputIdx]) != null ? _c : {};
      const diff8 = jsonDiff(previousOpts, opts != null ? opts : {});
      const { groupIndex, stackIndex } = (_d = diff8 == null ? void 0 : diff8.seriesGrouping) != null ? _d : {};
      if (groupIndex != null || stackIndex != null) {
        changes.push({ opts, series: outputSeries, diff: diff8, idx: outputIdx, status: "series-grouping" });
      } else if (diff8) {
        changes.push({ opts, series: outputSeries, diff: diff8, idx: outputIdx, status: "update" });
      } else {
        changes.push({ opts, series: outputSeries, idx: outputIdx, status: "no-op" });
      }
      if (seriesArray.length === 0) {
        seriesMap.delete(key);
      }
    }
  }
  for (const seriesArray of seriesMap.values()) {
    for (const [outputSeries, outputIdx] of seriesArray) {
      changes.push({ series: outputSeries, idx: outputIdx, status: "remove" });
    }
  }
  return { status: "overlap", changes };
}
var MATCHING_KEYS;
var init_prepareSeries = __esm({
  "packages/ag-charts-community/src/chart/mapping/prepareSeries.ts"() {
    "use strict";
    init_json();
    MATCHING_KEYS = [
      "direction",
      "xKey",
      "yKey",
      "sizeKey",
      "angleKey",
      "radiusKey",
      "normalizedTo",
      "stacked",
      "grouped",
      "stackGroup"
    ];
  }
});

// packages/ag-charts-community/src/chart/modulesManager.ts
var ModulesManager;
var init_modulesManager = __esm({
  "packages/ag-charts-community/src/chart/modulesManager.ts"() {
    "use strict";
    init_moduleMap();
    init_properties();
    ModulesManager = class extends ModuleMap {
      applyOptions(options) {
        for (const m of this.moduleMap.values()) {
          if (m.module.optionsKey in options && isProperties(m.moduleInstance)) {
            m.moduleInstance.set(options[m.module.optionsKey]);
          }
        }
      }
      *legends() {
        for (const { module: module2, moduleInstance } of this.moduleMap.values()) {
          if (module2.type !== "legend")
            continue;
          yield {
            legendType: module2.identifier,
            legend: moduleInstance
          };
        }
      }
    };
  }
});

// packages/ag-charts-community/src/chart/overlay/overlay.ts
var DEFAULT_OVERLAY_CLASS, DEFAULT_OVERLAY_DARK_CLASS, Overlay;
var init_overlay = __esm({
  "packages/ag-charts-community/src/chart/overlay/overlay.ts"() {
    "use strict";
    init_dom();
    init_properties();
    init_validation();
    DEFAULT_OVERLAY_CLASS = "ag-chart-overlay";
    DEFAULT_OVERLAY_DARK_CLASS = "ag-chart-dark-overlay";
    Overlay = class extends BaseProperties {
      constructor(className, defaultText) {
        super();
        this.className = className;
        this.defaultText = defaultText;
        this.darkTheme = false;
      }
      getText() {
        var _a2;
        return (_a2 = this.text) != null ? _a2 : this.defaultText;
      }
      getElement(animationManager, rect) {
        var _a2;
        (_a2 = this.element) != null ? _a2 : this.element = createElement("div", DEFAULT_OVERLAY_CLASS, { position: "absolute" });
        this.element.classList.toggle(DEFAULT_OVERLAY_DARK_CLASS, this.darkTheme);
        this.focusBox = rect;
        const element2 = this.element;
        element2.style.left = `${rect.x}px`;
        element2.style.top = `${rect.y}px`;
        element2.style.width = `${rect.width}px`;
        element2.style.height = `${rect.height}px`;
        if (this.renderer) {
          const htmlContent = this.renderer();
          if (htmlContent instanceof HTMLElement) {
            element2.replaceChildren(htmlContent);
          } else {
            element2.innerHTML = htmlContent;
          }
        } else {
          const content = createElement("div", {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            boxSizing: "border-box",
            height: "100%",
            margin: "8px",
            font: "12px Verdana, sans-serif"
          });
          content.innerText = this.getText();
          element2.replaceChildren(content);
          animationManager == null ? void 0 : animationManager.animate({
            from: 0,
            to: 1,
            id: "overlay",
            phase: "add",
            groupId: "opacity",
            onUpdate(value) {
              element2.style.opacity = String(value);
            },
            onStop() {
              element2.style.opacity = "1";
            }
          });
        }
        return this.element;
      }
      removeElement(animationManager) {
        if (!this.element)
          return;
        if (animationManager) {
          const { element: element2 } = this;
          animationManager.animate({
            from: 1,
            to: 0,
            phase: "remove",
            id: "overlay",
            groupId: "opacity",
            onUpdate(value) {
              element2.style.opacity = String(value);
            },
            onStop() {
              element2.remove();
            }
          });
        } else {
          this.element.remove();
        }
        this.element = void 0;
        this.focusBox = void 0;
      }
    };
    __decorateClass([
      Validate(STRING, { optional: true })
    ], Overlay.prototype, "text", 2);
    __decorateClass([
      Validate(FUNCTION, { optional: true })
    ], Overlay.prototype, "renderer", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], Overlay.prototype, "darkTheme", 2);
  }
});

// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts
var ChartOverlays;
var init_chartOverlays = __esm({
  "packages/ag-charts-community/src/chart/overlay/chartOverlays.ts"() {
    "use strict";
    init_properties();
    init_validation();
    init_overlay();
    ChartOverlays = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.loading = new Overlay("ag-chart-loading-overlay", "Loading data...");
        this.noData = new Overlay("ag-chart-no-data-overlay", "No data to display");
        this.noVisibleSeries = new Overlay("ag-chart-no-visible-series", "No visible series");
      }
      getFocusInfo() {
        for (const overlay of [this.loading, this.noData, this.noVisibleSeries]) {
          if (overlay.focusBox !== void 0) {
            return { text: overlay.getText(), rect: overlay.focusBox };
          }
        }
        return void 0;
      }
      destroy() {
        this.loading.removeElement();
        this.noData.removeElement();
        this.noVisibleSeries.removeElement();
      }
    };
    __decorateClass([
      Validate(OBJECT)
    ], ChartOverlays.prototype, "loading", 2);
    __decorateClass([
      Validate(OBJECT)
    ], ChartOverlays.prototype, "noData", 2);
    __decorateClass([
      Validate(OBJECT)
    ], ChartOverlays.prototype, "noVisibleSeries", 2);
  }
});

// packages/ag-charts-community/src/chart/overlay/loadingSpinner.ts
function getLoadingSpinner(text, defaultDuration) {
  const { animationDuration } = PHASE_METADATA["add"];
  const duration = animationDuration * defaultDuration;
  const container = createElement("div", `${DEFAULT_OVERLAY_CLASS}--loading`, {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column",
    height: "100%",
    boxSizing: "border-box",
    font: "13px Verdana, sans-serif",
    // FONT_SIZE.MEDIUM
    userSelect: "none",
    animation: `ag-charts-loading ${duration}ms linear 50ms both`
  });
  const matrix = createElement("span", {
    width: "45px",
    height: "40px",
    backgroundImage: [
      "linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), ",
      "linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), ",
      "linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)"
    ].join(""),
    backgroundSize: "10px 400%",
    backgroundRepeat: "no-repeat",
    animation: "ag-charts-loading-matrix 1s infinite linear"
  });
  const label = createElement("p", { marginTop: "1em" });
  label.innerText = text;
  const background = createElement("div", `${DEFAULT_OVERLAY_CLASS}__loading-background`, {
    position: "absolute",
    inset: "0",
    opacity: "0.5",
    zIndex: "-1"
  });
  const animationStyles = createElement("style");
  animationStyles.innerText = [
    "@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }",
    "@keyframes ag-charts-loading-matrix {",
    "0% { background-position: 0% 0%, 50% 0%, 100% 0%; }",
    "100% { background-position: 0% 100%, 50% 100%, 100% 100%; }",
    "}"
  ].join(" ");
  container.replaceChildren(animationStyles, matrix, label, background);
  injectStyle(defaultOverlayCss, "chartOverlays");
  return container;
}
var defaultOverlayCss;
var init_loadingSpinner = __esm({
  "packages/ag-charts-community/src/chart/overlay/loadingSpinner.ts"() {
    "use strict";
    init_animation();
    init_dom();
    init_overlay();
    defaultOverlayCss = `
.${DEFAULT_OVERLAY_CLASS} {
    color: #181d1f;
}

.${DEFAULT_OVERLAY_CLASS}.${DEFAULT_OVERLAY_DARK_CLASS} {
    color: #ffffff;
}

.${DEFAULT_OVERLAY_CLASS}--loading {
    color: rgb(140, 140, 140); /* DEFAULT_MUTED_LABEL_COLOUR */
}

.${DEFAULT_OVERLAY_CLASS}__loading-background {
    background: white; /* DEFAULT_BACKGROUND_FILL */
}

.${DEFAULT_OVERLAY_CLASS}.${DEFAULT_OVERLAY_DARK_CLASS} .${DEFAULT_OVERLAY_CLASS}__loading-background {
    background: #192232; /* DEFAULT_DARK_BACKGROUND_FILL */
}
`;
  }
});

// packages/ag-charts-community/src/chart/data/aggregateFunctions.ts
function sumValues(values, accumulator = [0, 0]) {
  for (const value of values) {
    if (typeof value !== "number") {
      continue;
    }
    if (value < 0) {
      accumulator[0] += value;
    }
    if (value > 0) {
      accumulator[1] += value;
    }
  }
  return accumulator;
}
function sum(id, matchGroupId) {
  const result = {
    id,
    matchGroupIds: [matchGroupId],
    type: "aggregate",
    aggregateFunction: (values) => sumValues(values)
  };
  return result;
}
function groupSum(id, matchGroupId) {
  return {
    id,
    type: "aggregate",
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    aggregateFunction: (values) => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0]) => {
      var _a2, _b;
      acc[0] += (_a2 = next == null ? void 0 : next[0]) != null ? _a2 : 0;
      acc[1] += (_b = next == null ? void 0 : next[1]) != null ? _b : 0;
      return acc;
    }
  };
}
function range2(id, matchGroupId) {
  const result = {
    id,
    matchGroupIds: [matchGroupId],
    type: "aggregate",
    aggregateFunction: (values) => ContinuousDomain.extendDomain(values)
  };
  return result;
}
function groupCount(id) {
  return {
    id,
    type: "aggregate",
    aggregateFunction: () => [0, 1],
    groupAggregateFunction: (next, acc = [0, 0]) => {
      var _a2, _b;
      acc[0] += (_a2 = next == null ? void 0 : next[0]) != null ? _a2 : 0;
      acc[1] += (_b = next == null ? void 0 : next[1]) != null ? _b : 0;
      return acc;
    }
  };
}
function groupAverage(id, matchGroupId) {
  const def = {
    id,
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    type: "aggregate",
    aggregateFunction: (values) => sumValues(values),
    groupAggregateFunction: (next, acc = [0, 0, -1]) => {
      var _a2, _b;
      acc[0] += (_a2 = next == null ? void 0 : next[0]) != null ? _a2 : 0;
      acc[1] += (_b = next == null ? void 0 : next[1]) != null ? _b : 0;
      acc[2]++;
      return acc;
    },
    finalFunction: (acc = [0, 0, 0]) => {
      const result = acc[0] + acc[1];
      if (result >= 0) {
        return [0, result / acc[2]];
      }
      return [result / acc[2], 0];
    }
  };
  return def;
}
function area(id, aggFn, matchGroupId) {
  const result = {
    id,
    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,
    type: "aggregate",
    aggregateFunction: (values, keyRange = []) => {
      const keyWidth = keyRange[1] - keyRange[0];
      return aggFn.aggregateFunction(values).map((v) => v / keyWidth);
    }
  };
  if (aggFn.groupAggregateFunction) {
    result.groupAggregateFunction = aggFn.groupAggregateFunction;
  }
  return result;
}
function accumulatedValue(onlyPositive) {
  return () => {
    let value = 0;
    return (datum) => {
      if (!isFiniteNumber(datum)) {
        return datum;
      }
      value += onlyPositive ? Math.max(0, datum) : datum;
      return value;
    };
  };
}
function trailingAccumulatedValue() {
  return () => {
    let value = 0;
    return (datum) => {
      if (!isFiniteNumber(datum)) {
        return datum;
      }
      const trailingValue = value;
      value += datum;
      return trailingValue;
    };
  };
}
var init_aggregateFunctions = __esm({
  "packages/ag-charts-community/src/chart/data/aggregateFunctions.ts"() {
    "use strict";
    init_type_guards();
    init_dataDomain();
  }
});

// packages/ag-charts-community/src/chart/data/processors.ts
function normaliseFnBuilder({ normaliseTo, mode }) {
  const normalise = (val, extent6) => {
    const result = val * normaliseTo / extent6;
    if (result >= 0) {
      return Math.min(normaliseTo, result);
    }
    return Math.max(-normaliseTo, result);
  };
  return () => () => (values, valueIndexes) => {
    const valuesExtent = [0, 0];
    for (const valueIdx of valueIndexes) {
      const value = values[valueIdx];
      const valIdx = value < 0 ? 0 : 1;
      if (mode === "sum") {
        valuesExtent[valIdx] += value;
      } else if (valIdx === 0) {
        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], value);
      } else {
        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], value);
      }
    }
    const extent6 = Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);
    for (const valueIdx of valueIndexes) {
      values[valueIdx] = normalise(values[valueIdx], extent6);
    }
  };
}
function normaliseGroupTo(matchGroupIds, normaliseTo, mode = "sum") {
  return {
    type: "group-value-processor",
    matchGroupIds,
    adjust: memo({ normaliseTo, mode }, normaliseFnBuilder)
  };
}
function normalisePropertyFnBuilder({
  normaliseTo,
  zeroDomain,
  rangeMin,
  rangeMax
}) {
  const normaliseSpan = normaliseTo[1] - normaliseTo[0];
  const normalise = (val, start, span) => {
    const result = normaliseTo[0] + (val - start) / span * normaliseSpan;
    if (span === 0) {
      return zeroDomain;
    } else if (result >= normaliseTo[1]) {
      return normaliseTo[1];
    } else if (result < normaliseTo[0]) {
      return normaliseTo[0];
    }
    return result;
  };
  return () => (pData, pIdx) => {
    let [start, end] = pData.domain.values[pIdx];
    if (rangeMin != null)
      start = rangeMin;
    if (rangeMax != null)
      end = rangeMax;
    const span = end - start;
    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];
    for (const group2 of pData.data) {
      let groupValues = group2.values;
      if (pData.type === "ungrouped") {
        groupValues = [groupValues];
      }
      for (const values of groupValues) {
        values[pIdx] = normalise(values[pIdx], start, span);
      }
    }
  };
}
function normalisePropertyTo(property, normaliseTo, zeroDomain, rangeMin, rangeMax) {
  return {
    type: "property-value-processor",
    property,
    adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder)
  };
}
function animationValidation(valueKeyIds) {
  return {
    type: "processor",
    property: "animationValidation",
    calculate(result) {
      const { keys, values } = result.defs;
      const { input, data } = result;
      let uniqueKeys = true;
      let orderedKeys = true;
      const valueKeys = [];
      for (let k = 0; k < values.length; k++) {
        if (!(valueKeyIds == null ? void 0 : valueKeyIds.includes(values[k].id)))
          continue;
        valueKeys.push([k, values[k]]);
      }
      const processKey = (idx, def, type) => {
        var _a2;
        if (def.valueType === "category") {
          const keyValues = result.domain[type][idx];
          uniqueKeys && (uniqueKeys = keyValues.length === input.count);
          return;
        }
        let lastValue = (_a2 = data[0]) == null ? void 0 : _a2[type][idx];
        for (let d = 1; (uniqueKeys || orderedKeys) && d < data.length; d++) {
          const keyValue = data[d][type][idx];
          orderedKeys && (orderedKeys = lastValue <= keyValue);
          uniqueKeys && (uniqueKeys = lastValue !== keyValue);
          lastValue = keyValue;
        }
      };
      for (let k = 0; (uniqueKeys || orderedKeys) && k < keys.length; k++) {
        processKey(k, keys[k], "keys");
      }
      for (let k = 0; (uniqueKeys || orderedKeys) && k < valueKeys.length; k++) {
        const [idx, key] = valueKeys[k];
        processKey(idx, key, "values");
      }
      return { uniqueKeys, orderedKeys };
    }
  };
}
function buildGroupAccFn({ mode, separateNegative }) {
  return () => () => (values, valueIndexes) => {
    const acc = [0, 0];
    for (const valueIdx of valueIndexes) {
      const currentVal = values[valueIdx];
      const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;
      if (!isFiniteNumber(currentVal))
        continue;
      if (mode === "normal")
        acc[accIndex] += currentVal;
      values[valueIdx] = acc[accIndex];
      if (mode === "trailing")
        acc[accIndex] += currentVal;
    }
  };
}
function buildGroupWindowAccFn({ mode, sum: sum2 }) {
  return () => {
    const lastValues = [];
    let firstRow = true;
    return () => {
      return (values, valueIndexes) => {
        let acc = 0;
        for (const valueIdx of valueIndexes) {
          const currentVal = values[valueIdx];
          const lastValue = firstRow && sum2 === "current" ? 0 : lastValues[valueIdx];
          lastValues[valueIdx] = currentVal;
          const sumValue = sum2 === "current" ? currentVal : lastValue;
          if (!isFiniteNumber(currentVal) || !isFiniteNumber(lastValue)) {
            values[valueIdx] = acc;
            continue;
          }
          if (mode === "normal") {
            acc += sumValue;
          }
          values[valueIdx] = acc;
          if (mode === "trailing") {
            acc += sumValue;
          }
        }
        firstRow = false;
      };
    };
  };
}
function accumulateGroup(matchGroupId, mode, sum2, separateNegative = false) {
  let adjust;
  if (mode.startsWith("window")) {
    const modeParam = mode.endsWith("-trailing") ? "trailing" : "normal";
    adjust = memo({ mode: modeParam, sum: sum2 }, buildGroupWindowAccFn);
  } else {
    adjust = memo({ mode, separateNegative }, buildGroupAccFn);
  }
  return {
    type: "group-value-processor",
    matchGroupIds: [matchGroupId],
    adjust
  };
}
function diff(previousData, updateMovedData = true) {
  return {
    type: "processor",
    property: "diff",
    calculate: (processedData) => {
      const moved = /* @__PURE__ */ new Map();
      const added = /* @__PURE__ */ new Map();
      const updated = /* @__PURE__ */ new Map();
      const removed = /* @__PURE__ */ new Map();
      const length = Math.max(previousData.data.length, processedData.data.length);
      for (let i = 0; i < length; i++) {
        const prev = previousData.data[i];
        const datum = processedData.data[i];
        const prevId = prev ? createDatumId(prev.keys) : "";
        const datumId = datum ? createDatumId(datum.keys) : "";
        if (datum && prev && prevId === datumId) {
          if (!arraysEqual(prev.values, datum.values)) {
            updated.set(datumId, datum);
          }
          continue;
        }
        if (removed.has(datumId)) {
          if (updateMovedData || !arraysEqual(removed.get(datumId).values, datum.values)) {
            updated.set(datumId, datum);
            moved.set(datumId, datum);
          }
          removed.delete(datumId);
        } else if (datum) {
          added.set(datumId, datum);
        }
        if (added.has(prevId)) {
          if (updateMovedData || !arraysEqual(added.get(prevId).values, prev.values)) {
            updated.set(prevId, prev);
            moved.set(prevId, prev);
          }
          added.delete(prevId);
        } else if (prev) {
          updated.delete(prevId);
          removed.set(prevId, prev);
        }
      }
      const changed = added.size > 0 || updated.size > 0 || removed.size > 0;
      return { changed, added, updated, removed, moved };
    }
  };
}
function createDatumId(keys, ...extraKeys) {
  let result;
  if (isArray(keys)) {
    result = keys.map((key) => transformIntegratedCategoryValue(key)).join("___");
  } else {
    result = transformIntegratedCategoryValue(keys);
  }
  const primitiveType = typeof result === "string" || typeof result === "number" || result instanceof Date;
  if (primitiveType && extraKeys.length > 0) {
    result += `___${extraKeys.join("___")}`;
  }
  return result;
}
var SMALLEST_KEY_INTERVAL, SORT_DOMAIN_GROUPS;
var init_processors = __esm({
  "packages/ag-charts-community/src/chart/data/processors.ts"() {
    "use strict";
    init_array();
    init_memo();
    init_number();
    init_type_guards();
    init_value();
    SMALLEST_KEY_INTERVAL = {
      type: "reducer",
      property: "smallestKeyInterval",
      initialValue: Infinity,
      reducer: () => {
        let prevX = NaN;
        return (smallestSoFar = Infinity, next) => {
          const nextX = next.keys[0];
          const interval = Math.abs(nextX - prevX);
          prevX = nextX;
          if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {
            return interval;
          }
          return smallestSoFar;
        };
      }
    };
    SORT_DOMAIN_GROUPS = {
      type: "processor",
      property: "sortedGroupDomain",
      calculate: ({ domain: { groups } }) => groups == null ? void 0 : groups.slice().sort((a, b) => {
        for (let i = 0; i < a.length; i++) {
          const result = a[i] - b[i];
          if (result !== 0) {
            return result;
          }
        }
        return 0;
      })
    };
  }
});

// packages/ag-charts-community/src/chart/series/series.ts
function basicContinuousCheckDatumValidation(value) {
  return value != null && isContinuous(value);
}
function basicDiscreteCheckDatumValidation(value) {
  return value != null;
}
function getValidationFn(scaleType) {
  switch (scaleType) {
    case "number":
    case "log":
    case "ordinal-time":
    case "time":
    case "color":
      return basicContinuousCheckDatumValidation;
    default:
      return basicDiscreteCheckDatumValidation;
  }
}
function getValueType(scaleType) {
  switch (scaleType) {
    case "number":
    case "log":
    case "time":
    case "color":
      return "range";
    default:
      return "category";
  }
}
function keyProperty(propName, scaleType, opts = {}) {
  const result = __spreadValues({
    property: propName,
    type: "key",
    valueType: getValueType(scaleType),
    validation: getValidationFn(scaleType)
  }, opts);
  return result;
}
function valueProperty(propName, scaleType, opts = {}) {
  const result = __spreadValues({
    property: propName,
    type: "value",
    valueType: getValueType(scaleType),
    validation: getValidationFn(scaleType)
  }, opts);
  return result;
}
function rangedValueProperty(propName, opts = {}) {
  const _a2 = opts, { min = -Infinity, max = Infinity } = _a2, defOpts = __objRest(_a2, ["min", "max"]);
  return __spreadValues({
    type: "value",
    property: propName,
    valueType: "range",
    validation: basicContinuousCheckDatumValidation,
    processor: () => (datum) => isFiniteNumber(datum) ? clamp(min, datum, max) : datum
  }, defOpts);
}
function accumulativeValueProperty(propName, scaleType, opts = {}) {
  const _a2 = opts, { onlyPositive } = _a2, defOpts = __objRest(_a2, ["onlyPositive"]);
  const result = __spreadProps(__spreadValues({}, valueProperty(propName, scaleType, defOpts)), {
    processor: accumulatedValue(onlyPositive)
  });
  return result;
}
function trailingAccumulatedValueProperty(propName, scaleType, opts = {}) {
  const result = __spreadProps(__spreadValues({}, valueProperty(propName, scaleType, opts)), {
    processor: trailingAccumulatedValue()
  });
  return result;
}
function groupAccumulativeValueProperty(propName, mode, sum2 = "current", opts, scaleType) {
  return [
    valueProperty(propName, scaleType, opts),
    accumulateGroup(opts.groupId, mode, sum2, opts.separateNegative),
    ...opts.rangeId != null ? [range2(opts.rangeId, opts.groupId)] : []
  ];
}
var SeriesNodePickMode, SeriesNodeEvent, SeriesGroupingChangedEvent, Series;
var init_series = __esm({
  "packages/ag-charts-community/src/chart/series/series.ts"() {
    "use strict";
    init_moduleMap();
    init_group();
    init_nearest();
    init_id();
    init_json();
    init_listeners();
    init_number();
    init_object();
    init_observable();
    init_proxy();
    init_type_guards();
    init_value();
    init_chartAxisDirection();
    init_aggregateFunctions();
    init_processors();
    init_layers();
    SeriesNodePickMode = /* @__PURE__ */ ((SeriesNodePickMode13) => {
      SeriesNodePickMode13[SeriesNodePickMode13["EXACT_SHAPE_MATCH"] = 0] = "EXACT_SHAPE_MATCH";
      SeriesNodePickMode13[SeriesNodePickMode13["NEAREST_BY_MAIN_AXIS_FIRST"] = 1] = "NEAREST_BY_MAIN_AXIS_FIRST";
      SeriesNodePickMode13[SeriesNodePickMode13["NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST"] = 2] = "NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST";
      SeriesNodePickMode13[SeriesNodePickMode13["NEAREST_NODE"] = 3] = "NEAREST_NODE";
      return SeriesNodePickMode13;
    })(SeriesNodePickMode || {});
    SeriesNodeEvent = class {
      constructor(type, event, { datum }, series) {
        this.type = type;
        this.event = event;
        this.datum = datum;
        this.seriesId = series.id;
      }
    };
    SeriesGroupingChangedEvent = class {
      constructor(series, seriesGrouping, oldGrouping) {
        this.series = series;
        this.seriesGrouping = seriesGrouping;
        this.oldGrouping = oldGrouping;
        this.type = "groupingChanged";
      }
    };
    Series = class extends Observable {
      constructor(seriesOpts) {
        super();
        this.destroyFns = [];
        this.seriesGrouping = void 0;
        this.NodeEvent = SeriesNodeEvent;
        this.internalId = createId(this);
        // The group node that contains all the nodes used to render this series.
        this.rootGroup = new Group({ name: "seriesRoot", isVirtual: true });
        this.axes = {
          ["x" /* X */]: void 0,
          ["y" /* Y */]: void 0
        };
        this.directions = ["x" /* X */, "y" /* Y */];
        // Flag to determine if we should recalculate node data.
        this.nodeDataRefresh = true;
        this.moduleMap = new ModuleMap();
        this._declarationOrder = -1;
        this.seriesListeners = new Listeners();
        const {
          moduleCtx,
          pickModes = [1 /* NEAREST_BY_MAIN_AXIS_FIRST */],
          directionKeys = {},
          directionNames = {},
          contentGroupVirtual = true,
          canHaveAxes = false
        } = seriesOpts;
        this.ctx = moduleCtx;
        this.directionKeys = directionKeys;
        this.directionNames = directionNames;
        this.canHaveAxes = canHaveAxes;
        this.contentGroup = this.rootGroup.appendChild(
          new Group({
            name: `${this.internalId}-content`,
            isVirtual: contentGroupVirtual,
            zIndex: 4 /* SERIES_LAYER_ZINDEX */,
            zIndexSubOrder: this.getGroupZIndexSubOrder("data")
          })
        );
        this.highlightGroup = new Group({
          name: `${this.internalId}-highlight`,
          isVirtual: contentGroupVirtual,
          zIndex: 4 /* SERIES_LAYER_ZINDEX */,
          zIndexSubOrder: this.getGroupZIndexSubOrder("highlight")
        });
        this.highlightNode = this.highlightGroup.appendChild(new Group({ name: "highlightNode", zIndex: 0 }));
        this.highlightLabel = this.highlightGroup.appendChild(new Group({ name: "highlightLabel", zIndex: 10 }));
        this.pickModes = pickModes;
        this.labelGroup = this.rootGroup.appendChild(
          new Group({
            name: `${this.internalId}-series-labels`,
            zIndex: 8 /* SERIES_LABEL_ZINDEX */
          })
        );
        this.annotationGroup = new Group({
          name: `${this.id}-annotation`,
          isVirtual: contentGroupVirtual,
          zIndex: 4 /* SERIES_LAYER_ZINDEX */,
          zIndexSubOrder: this.getGroupZIndexSubOrder("annotation")
        });
      }
      get id() {
        var _a2, _b;
        return (_b = (_a2 = this.properties) == null ? void 0 : _a2.id) != null ? _b : this.internalId;
      }
      get type() {
        var _a2;
        return (_a2 = this.constructor.type) != null ? _a2 : "";
      }
      get data() {
        var _a2;
        return (_a2 = this._data) != null ? _a2 : this._chartData;
      }
      set visible(value) {
        this.properties.visible = value;
        this.visibleChanged();
      }
      get visible() {
        return this.properties.visible;
      }
      get hasData() {
        return this.data != null && this.data.length > 0;
      }
      get tooltipEnabled() {
        var _a2, _b;
        return (_b = (_a2 = this.properties.tooltip) == null ? void 0 : _a2.enabled) != null ? _b : false;
      }
      onDataChange() {
        this.nodeDataRefresh = true;
      }
      setOptionsData(input) {
        this._data = input;
        this.onDataChange();
      }
      setChartData(input) {
        this._chartData = input;
        if (this.data === input) {
          this.onDataChange();
        }
      }
      onSeriesGroupingChange(prev, next) {
        const { internalId, type, visible } = this;
        if (prev) {
          this.ctx.seriesStateManager.deregisterSeries({ id: internalId, type });
        }
        if (next) {
          this.ctx.seriesStateManager.registerSeries({ id: internalId, type, visible, seriesGrouping: next });
        }
        this.fireEvent(new SeriesGroupingChangedEvent(this, next, prev));
      }
      getBandScalePadding() {
        return { inner: 1, outer: 0 };
      }
      getGroupZIndexSubOrder(type, subIndex = 0) {
        let mainAdjust = 0;
        switch (type) {
          case "data":
          case "paths":
            break;
          case "labels":
            mainAdjust += 2e4;
            break;
          case "marker":
            mainAdjust += 1e4;
            break;
          case "highlight":
            subIndex += 15e3;
            break;
          case "annotation":
            mainAdjust += 15e3;
            break;
        }
        const main = () => this._declarationOrder + mainAdjust;
        return [main, subIndex];
      }
      addListener(type, listener) {
        return this.seriesListeners.addListener(type, listener);
      }
      dispatch(type, event) {
        this.seriesListeners.dispatch(type, event);
      }
      addChartEventListeners() {
        return;
      }
      destroy() {
        this.destroyFns.forEach((f) => f());
        this.destroyFns = [];
        this.ctx.seriesStateManager.deregisterSeries(this);
      }
      getDirectionValues(direction, properties) {
        const resolvedDirection = this.resolveKeyDirection(direction);
        const keys = properties == null ? void 0 : properties[resolvedDirection];
        const values = [];
        if (!keys) {
          return values;
        }
        const addValues = (...items) => {
          for (const value of items) {
            if (Array.isArray(value)) {
              addValues(...value);
            } else if (typeof value === "object") {
              addValues(...Object.values(value));
            } else {
              values.push(value);
            }
          }
        };
        addValues(...keys.map((key) => this.properties[key]));
        return values;
      }
      getKeys(direction) {
        return this.getDirectionValues(direction, this.directionKeys);
      }
      getKeyProperties(direction) {
        var _a2;
        return (_a2 = this.directionKeys[this.resolveKeyDirection(direction)]) != null ? _a2 : [];
      }
      getNames(direction) {
        return this.getDirectionValues(direction, this.directionNames);
      }
      resolveKeyDirection(direction) {
        return direction;
      }
      // The union of the series domain ('community') and series-option domains ('enterprise').
      getDomain(direction) {
        const seriesDomain = this.getSeriesDomain(direction);
        const moduleDomains = this.moduleMap.mapModules((module2) => module2.getDomain(direction));
        return seriesDomain.concat(moduleDomains.flat());
      }
      // Indicate that something external changed and we should recalculate nodeData.
      markNodeDataDirty() {
        this.nodeDataRefresh = true;
      }
      visibleChanged() {
        this.ctx.seriesStateManager.registerSeries(this);
      }
      getOpacity() {
        const defaultOpacity = 1;
        const { dimOpacity = 1, enabled = true } = this.properties.highlightStyle.series;
        if (!enabled || dimOpacity === defaultOpacity) {
          return defaultOpacity;
        }
        switch (this.isItemIdHighlighted()) {
          case 0 /* None */:
          case 1 /* This */:
            return defaultOpacity;
          case 2 /* Other */:
          default:
            return dimOpacity;
        }
      }
      getStrokeWidth(defaultStrokeWidth) {
        const { strokeWidth, enabled = true } = this.properties.highlightStyle.series;
        if (!enabled || strokeWidth === void 0) {
          return defaultStrokeWidth;
        }
        switch (this.isItemIdHighlighted()) {
          case 1 /* This */:
            return strokeWidth;
          case 0 /* None */:
          case 2 /* Other */:
            return defaultStrokeWidth;
        }
      }
      isItemIdHighlighted() {
        var _a2, _b;
        const series = (_b = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight()) == null ? void 0 : _b.series;
        if (series == null) {
          return 0 /* None */;
        }
        if (series !== this) {
          return 2 /* Other */;
        }
        return 1 /* This */;
      }
      getModuleTooltipParams() {
        return this.moduleMap.mapModules((module2) => module2.getTooltipParams()).reduce((total, current) => Object.assign(total, current), {});
      }
      pickNode(point, limitPickModes) {
        const { pickModes, visible, rootGroup } = this;
        if (!visible || !rootGroup.visible) {
          return;
        }
        for (const pickMode of pickModes) {
          if (limitPickModes && !limitPickModes.includes(pickMode)) {
            continue;
          }
          let match;
          switch (pickMode) {
            case 0 /* EXACT_SHAPE_MATCH */:
              match = this.pickNodeExactShape(point);
              break;
            case 1 /* NEAREST_BY_MAIN_AXIS_FIRST */:
            case 2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */:
              match = this.pickNodeMainAxisFirst(
                point,
                pickMode === 2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */
              );
              break;
            case 3 /* NEAREST_NODE */:
              match = this.pickNodeClosestDatum(point);
              break;
          }
          if (match) {
            return { pickMode, match: match.datum, distance: match.distance };
          }
        }
      }
      pickNodeExactShape(point) {
        const match = this.contentGroup.pickNode(point.x, point.y);
        if (match && match.datum.missing !== true) {
          return { datum: match.datum, distance: 0 };
        }
        return void 0;
      }
      pickNodeClosestDatum(_point) {
        throw new Error("AG Charts - Series.pickNodeClosestDatum() not implemented");
      }
      pickNodeNearestDistantObject(point, items) {
        const match = nearestSquared(point.x, point.y, items);
        if (match.nearest !== void 0 && match.nearest.datum.missing !== true) {
          return { datum: match.nearest.datum, distance: Math.sqrt(match.distanceSquared) };
        }
        return void 0;
      }
      pickNodeMainAxisFirst(_point, _requireCategoryAxis) {
        throw new Error("AG Charts - Series.pickNodeMainAxisFirst() not implemented");
      }
      fireNodeClickEvent(event, datum) {
        this.fireEvent(new this.NodeEvent("nodeClick", event, datum, this));
      }
      fireNodeDoubleClickEvent(event, datum) {
        this.fireEvent(new this.NodeEvent("nodeDoubleClick", event, datum, this));
      }
      createNodeContextMenuActionEvent(event, datum) {
        return new this.NodeEvent("nodeContextMenuAction", event, datum, this);
      }
      toggleSeriesItem(itemId, enabled) {
        this.visible = enabled;
        this.nodeDataRefresh = true;
        this.dispatch("visibility-changed", { itemId, enabled });
      }
      isEnabled() {
        return this.visible;
      }
      getModuleMap() {
        return this.moduleMap;
      }
      createModuleContext() {
        return __spreadProps(__spreadValues({}, this.ctx), { series: this });
      }
      getLabelText(label, params, defaultFormatter = String) {
        var _a2;
        if (label.formatter) {
          return (_a2 = this.ctx.callbackCache.call(label.formatter, __spreadValues({ seriesId: this.id }, params))) != null ? _a2 : defaultFormatter(params.value);
        }
        return defaultFormatter(params.value);
      }
      getMarkerStyle(marker, params, defaultStyle = marker.getStyle()) {
        var _a2, _b;
        const defaultSize = { size: (_b = (_a2 = params.datum.point) == null ? void 0 : _a2.size) != null ? _b : 0 };
        const markerStyle = mergeDefaults(defaultSize, defaultStyle);
        if (marker.formatter) {
          const style = this.ctx.callbackCache.call(marker.formatter, __spreadProps(__spreadValues(__spreadValues({
            seriesId: this.id
          }, markerStyle), params), {
            datum: params.datum.datum
          }));
          return mergeDefaults(style, markerStyle);
        }
        return markerStyle;
      }
      updateMarkerStyle(markerNode, marker, params, defaultStyle = marker.getStyle(), { applyTranslation = true } = {}) {
        const { point } = params.datum;
        const activeStyle = this.getMarkerStyle(marker, params, defaultStyle);
        const visible = this.visible && activeStyle.size > 0 && point && !isNaN(point.x) && !isNaN(point.y);
        if (applyTranslation) {
          markerNode.setProperties(__spreadProps(__spreadValues({ visible }, activeStyle), { translationX: point == null ? void 0 : point.x, translationY: point == null ? void 0 : point.y }));
        } else {
          markerNode.setProperties(__spreadValues({ visible }, activeStyle));
        }
        if (typeof marker.shape === "function" && !markerNode.dirtyPath) {
          markerNode.path.clear(true);
          markerNode.updatePath();
          markerNode.checkPathDirty();
        }
      }
      getMinRects(_width, _height) {
        return;
      }
      get nodeDataDependencies() {
        var _a2;
        return (_a2 = this._nodeDataDependencies) != null ? _a2 : { seriesRectWidth: NaN, seriesRectHeight: NaN };
      }
      checkResize(newSeriesRect) {
        const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect != null ? newSeriesRect : { width: NaN, height: NaN };
        const newNodeDataDependencies = newSeriesRect ? { seriesRectWidth, seriesRectHeight } : void 0;
        const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
        if (resize) {
          this._nodeDataDependencies = newNodeDataDependencies;
          this.markNodeDataDirty();
        }
        return resize;
      }
      pickFocus(_opts) {
        return void 0;
      }
    };
    Series.highlightedZIndex = 1e12;
    __decorateClass([
      ActionOnSet({
        changeValue: function(newVal, oldVal) {
          this.onSeriesGroupingChange(oldVal, newVal);
        }
      })
    ], Series.prototype, "seriesGrouping", 2);
  }
});

// packages/ag-charts-community/src/chart/series/seriesLayerManager.ts
var SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION, SeriesLayerManager;
var init_seriesLayerManager = __esm({
  "packages/ag-charts-community/src/chart/series/seriesLayerManager.ts"() {
    "use strict";
    init_group();
    init_number();
    init_layers();
    SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;
    SeriesLayerManager = class {
      constructor(seriesRoot, highlightRoot, annotationRoot) {
        this.seriesRoot = seriesRoot;
        this.highlightRoot = highlightRoot;
        this.annotationRoot = annotationRoot;
        this.groups = {};
        this.series = {};
        this.expectedSeriesCount = 1;
        this.mode = "normal";
      }
      setSeriesCount(count) {
        this.expectedSeriesCount = count;
      }
      requestGroup(seriesConfig) {
        var _a2, _b, _c, _d;
        const {
          internalId,
          type,
          rootGroup: seriesRootGroup,
          highlightGroup: seriesHighlightGroup,
          annotationGroup: seriesAnnotationGroup,
          seriesGrouping
        } = seriesConfig;
        const { groupIndex = internalId } = seriesGrouping != null ? seriesGrouping : {};
        if (this.series[internalId] != null) {
          throw new Error(`AG Charts - series already has an allocated layer: ${this.series[internalId]}`);
        }
        if (Object.keys(this.series).length === 0) {
          this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? "aggressive-grouping" : "normal";
        }
        (_b = (_a2 = this.groups)[type]) != null ? _b : _a2[type] = {};
        const lookupIndex = this.lookupIdx(groupIndex);
        let groupInfo = this.groups[type][lookupIndex];
        if (!groupInfo) {
          groupInfo = (_d = (_c = this.groups[type])[lookupIndex]) != null ? _d : _c[lookupIndex] = {
            seriesIds: [],
            group: this.seriesRoot.appendChild(
              new Group({
                name: `${type}-content`,
                layer: true,
                zIndex: 4 /* SERIES_LAYER_ZINDEX */,
                zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder("data")
              })
            ),
            highlight: this.highlightRoot.appendChild(
              new Group({
                name: `${type}-highlight`,
                zIndex: 4 /* SERIES_LAYER_ZINDEX */,
                zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder("highlight")
              })
            ),
            annotation: this.annotationRoot.appendChild(
              new Group({
                name: `${type}-annotation`,
                zIndex: 4 /* SERIES_LAYER_ZINDEX */,
                zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder("annotation")
              })
            )
          };
        }
        this.series[internalId] = { layerState: groupInfo, seriesConfig };
        groupInfo.seriesIds.push(internalId);
        groupInfo.group.appendChild(seriesRootGroup);
        groupInfo.highlight.appendChild(seriesHighlightGroup);
        groupInfo.annotation.appendChild(seriesAnnotationGroup);
        return groupInfo.group;
      }
      changeGroup(seriesConfig) {
        var _a2, _b;
        const { internalId, seriesGrouping, type, rootGroup, highlightGroup, annotationGroup, oldGrouping } = seriesConfig;
        const { groupIndex = internalId } = seriesGrouping != null ? seriesGrouping : {};
        if ((_b = (_a2 = this.groups[type]) == null ? void 0 : _a2[groupIndex]) == null ? void 0 : _b.seriesIds.includes(internalId)) {
          return;
        }
        if (this.series[internalId] != null) {
          this.releaseGroup({
            internalId,
            seriesGrouping: oldGrouping,
            type,
            rootGroup,
            highlightGroup,
            annotationGroup
          });
        }
        this.requestGroup(seriesConfig);
      }
      releaseGroup(seriesConfig) {
        var _a2, _b, _c, _d, _e;
        const { internalId, seriesGrouping, rootGroup, highlightGroup, annotationGroup, type } = seriesConfig;
        const { groupIndex = internalId } = seriesGrouping != null ? seriesGrouping : {};
        if (this.series[internalId] == null) {
          throw new Error(`AG Charts - series doesn't have an allocated layer: ${internalId}`);
        }
        const lookupIndex = this.lookupIdx(groupIndex);
        const groupInfo = (_c = (_a2 = this.groups[type]) == null ? void 0 : _a2[lookupIndex]) != null ? _c : (_b = this.series[internalId]) == null ? void 0 : _b.layerState;
        if (groupInfo) {
          groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== internalId);
          groupInfo.group.removeChild(rootGroup);
          groupInfo.highlight.removeChild(highlightGroup);
          groupInfo.annotation.removeChild(annotationGroup);
        }
        if ((groupInfo == null ? void 0 : groupInfo.seriesIds.length) === 0) {
          this.seriesRoot.removeChild(groupInfo.group);
          this.highlightRoot.removeChild(groupInfo.highlight);
          this.annotationRoot.removeChild(groupInfo.annotation);
          delete this.groups[type][lookupIndex];
          delete this.groups[type][internalId];
        } else if ((groupInfo == null ? void 0 : groupInfo.seriesIds.length) > 0) {
          const leadSeriesConfig = (_e = this.series[(_d = groupInfo == null ? void 0 : groupInfo.seriesIds) == null ? void 0 : _d[0]]) == null ? void 0 : _e.seriesConfig;
          groupInfo.group.zIndexSubOrder = leadSeriesConfig == null ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder("data");
          groupInfo.highlight.zIndexSubOrder = leadSeriesConfig == null ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder("highlight");
          groupInfo.annotation.zIndexSubOrder = leadSeriesConfig == null ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder("annotation");
        }
        delete this.series[internalId];
      }
      lookupIdx(groupIndex) {
        if (this.mode === "normal") {
          return groupIndex;
        }
        if (typeof groupIndex === "string") {
          groupIndex = Number(groupIndex.split("-").slice(-1)[0]);
          if (!groupIndex) {
            return 0;
          }
        }
        return Math.floor(
          clamp(0, groupIndex / this.expectedSeriesCount, 1) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION
        );
      }
      destroy() {
        for (const groups of Object.values(this.groups)) {
          for (const groupInfo of Object.values(groups)) {
            this.seriesRoot.removeChild(groupInfo.group);
            this.highlightRoot.removeChild(groupInfo.highlight);
            this.annotationRoot.removeChild(groupInfo.annotation);
          }
        }
        this.groups = {};
        this.series = {};
      }
    };
  }
});

// packages/ag-charts-community/src/chart/update/baseLayoutProcessor.ts
var BaseLayoutProcessor;
var init_baseLayoutProcessor = __esm({
  "packages/ag-charts-community/src/chart/update/baseLayoutProcessor.ts"() {
    "use strict";
    init_text();
    init_logger();
    init_caption();
    BaseLayoutProcessor = class {
      constructor(chartLike, layoutService) {
        this.chartLike = chartLike;
        this.layoutService = layoutService;
        this.destroyFns = [];
        this.destroyFns.push(
          // eslint-disable-next-line sonarjs/no-duplicate-string
          this.layoutService.addListener("start-layout", (e) => this.positionPadding(e.shrinkRect)),
          this.layoutService.addListener("start-layout", (e) => this.positionCaptions(e.shrinkRect))
        );
      }
      destroy() {
        this.destroyFns.forEach((cb) => cb());
      }
      positionPadding(shrinkRect) {
        const { padding } = this.chartLike;
        shrinkRect.shrink(padding.left, "left");
        shrinkRect.shrink(padding.top, "top");
        shrinkRect.shrink(padding.right, "right");
        shrinkRect.shrink(padding.bottom, "bottom");
        return { shrinkRect };
      }
      positionCaptions(shrinkRect) {
        var _a2, _b;
        const { title, subtitle, footnote } = this.chartLike;
        const newShrinkRect = shrinkRect.clone();
        const updateCaption = (caption) => {
          var _a3;
          const defaultCaptionHeight = shrinkRect.height / 10;
          const captionLineHeight = (_a3 = caption.lineHeight) != null ? _a3 : caption.fontSize * Text.defaultLineHeightRatio;
          const maxWidth = shrinkRect.width;
          const maxHeight = Math.max(captionLineHeight, defaultCaptionHeight);
          caption.computeTextWrap(maxWidth, maxHeight);
        };
        const computeX = (align) => {
          if (align === "left") {
            return newShrinkRect.x;
          } else if (align === "right") {
            return newShrinkRect.x + newShrinkRect.width;
          } else if (align !== "center") {
            Logger.error(`invalid textAlign value: ${align}`);
          }
          return newShrinkRect.x + newShrinkRect.width / 2;
        };
        const positionTopAndShrinkBBox = (caption, spacing) => {
          const baseY = newShrinkRect.y;
          caption.node.x = computeX(caption.textAlign);
          caption.node.y = baseY;
          caption.node.textBaseline = "top";
          updateCaption(caption);
          const bbox = caption.node.computeBBox();
          const bboxHeight = Math.ceil(bbox.y - baseY + bbox.height + spacing);
          newShrinkRect.shrink(bboxHeight, "top");
        };
        const positionBottomAndShrinkBBox = (caption, spacing) => {
          const baseY = newShrinkRect.y + newShrinkRect.height;
          caption.node.x = computeX(caption.textAlign);
          caption.node.y = baseY;
          caption.node.textBaseline = "bottom";
          updateCaption(caption);
          const bbox = caption.node.computeBBox();
          const bboxHeight = Math.ceil(baseY - bbox.y + spacing);
          newShrinkRect.shrink(bboxHeight, "bottom");
        };
        title.node.visible = title.enabled;
        subtitle.node.visible = subtitle.enabled;
        footnote.node.visible = footnote.enabled;
        if (title.enabled) {
          const { spacing = subtitle.enabled ? Caption.SMALL_PADDING : Caption.LARGE_PADDING } = title;
          positionTopAndShrinkBBox(title, spacing);
        }
        if (subtitle.enabled) {
          positionTopAndShrinkBBox(subtitle, (_a2 = subtitle.spacing) != null ? _a2 : 0);
        }
        if (footnote.enabled) {
          positionBottomAndShrinkBBox(footnote, (_b = footnote.spacing) != null ? _b : 0);
        }
        return { shrinkRect: newShrinkRect };
      }
    };
  }
});

// packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts
var DataWindowProcessor;
var init_dataWindowProcessor = __esm({
  "packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts"() {
    "use strict";
    init_logger();
    init_chartUpdateType();
    DataWindowProcessor = class {
      constructor(chart, dataService, updateService, zoomManager) {
        this.chart = chart;
        this.dataService = dataService;
        this.updateService = updateService;
        this.zoomManager = zoomManager;
        this.dirtyZoom = false;
        this.dirtyDataSource = false;
        this.lastAxisZooms = /* @__PURE__ */ new Map();
        this.destroyFns = [];
        this.destroyFns.push(
          this.dataService.addListener("data-source-change", () => this.onDataSourceChange()),
          this.dataService.addListener("data-load", () => this.onDataLoad()),
          this.dataService.addListener("data-error", () => this.onDataError()),
          this.updateService.addListener("update-complete", () => this.onUpdateComplete()),
          this.zoomManager.addListener("zoom-change", () => this.onZoomChange())
        );
      }
      destroy() {
        this.destroyFns.forEach((cb) => cb());
      }
      onDataLoad() {
        this.updateService.update(1 /* UPDATE_DATA */);
      }
      onDataError() {
        this.updateService.update(3 /* PERFORM_LAYOUT */);
      }
      onDataSourceChange() {
        this.dirtyDataSource = true;
      }
      onUpdateComplete() {
        if (!this.dirtyZoom && !this.dirtyDataSource)
          return;
        this.updateWindow().catch((e) => Logger.errorOnce(e));
      }
      onZoomChange() {
        this.dirtyZoom = true;
      }
      updateWindow() {
        return __async(this, null, function* () {
          if (!this.dataService.isLazy())
            return;
          const axis = this.getValidAxis();
          let window2;
          let shouldRefresh = true;
          if (axis) {
            const zoom2 = this.zoomManager.getAxisZoom(axis.id);
            window2 = this.getAxisWindow(axis, zoom2);
            shouldRefresh = this.shouldRefresh(axis, zoom2);
          }
          this.dirtyZoom = false;
          this.dirtyDataSource = false;
          if (!shouldRefresh)
            return;
          this.dataService.load({ windowStart: window2 == null ? void 0 : window2.min, windowEnd: window2 == null ? void 0 : window2.max });
        });
      }
      getValidAxis() {
        return this.chart.axes.find((axis) => axis.type === "time");
      }
      shouldRefresh(axis, zoom2) {
        if (this.dirtyDataSource)
          return true;
        if (!this.dirtyZoom)
          return false;
        const lastZoom = this.lastAxisZooms.get(axis.id);
        if (lastZoom && zoom2.min === lastZoom.min && zoom2.max === lastZoom.max) {
          return false;
        }
        this.lastAxisZooms.set(axis.id, zoom2);
        return true;
      }
      getAxisWindow(axis, zoom2) {
        var _a2, _b;
        const domain = (_b = (_a2 = axis.scale).getDomain) == null ? void 0 : _b.call(_a2);
        if (!zoom2 || !domain || domain.length === 0 || isNaN(Number(domain[0])))
          return;
        const diff8 = Number(domain[1]) - Number(domain[0]);
        const min = new Date(Number(domain[0]) + diff8 * zoom2.min);
        const max = new Date(Number(domain[0]) + diff8 * zoom2.max);
        return { min, max };
      }
    };
  }
});

// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts
var OverlaysProcessor;
var init_overlaysProcessor = __esm({
  "packages/ag-charts-community/src/chart/update/overlaysProcessor.ts"() {
    "use strict";
    OverlaysProcessor = class {
      constructor(chartLike, overlays, dataService, layoutService, animationManager) {
        this.chartLike = chartLike;
        this.overlays = overlays;
        this.dataService = dataService;
        this.layoutService = layoutService;
        this.animationManager = animationManager;
        this.destroyFns = [];
        this.destroyFns.push(this.layoutService.addListener("layout-complete", (e) => this.onLayoutComplete(e)));
      }
      destroy() {
        this.destroyFns.forEach((cb) => cb());
      }
      onLayoutComplete({ series: { rect } }) {
        const isLoading = this.dataService.isLoading();
        const hasData = this.chartLike.series.some((s) => s.hasData);
        const anySeriesVisible = this.chartLike.series.some((s) => s.visible);
        this.toggleOverlay(this.overlays.loading, rect, isLoading);
        this.toggleOverlay(this.overlays.noData, rect, !isLoading && !hasData);
        this.toggleOverlay(this.overlays.noVisibleSeries, rect, hasData && !anySeriesVisible);
      }
      toggleOverlay(overlay, seriesRect, visible) {
        if (visible) {
          const element2 = overlay.getElement(this.animationManager, seriesRect);
          this.chartLike.element.append(element2);
        } else {
          overlay.removeElement(this.animationManager);
        }
      }
    };
  }
});

// packages/ag-charts-community/src/chart/chart.ts
var debug, SeriesArea, _Chart, Chart;
var init_chart = __esm({
  "packages/ag-charts-community/src/chart/chart.ts"() {
    "use strict";
    init_module();
    init_bbox();
    init_group();
    init_scene();
    init_labelPlacement();
    init_styles();
    init_array();
    init_async();
    init_attributeUtil();
    init_debug();
    init_dom();
    init_id();
    init_json();
    init_logger();
    init_mutex();
    init_number();
    init_object();
    init_observable();
    init_padding();
    init_properties();
    init_proxy();
    init_render();
    init_sizeMonitor();
    init_type_guards();
    init_validation();
    init_caption();
    init_chartAxisDirection();
    init_chartContext();
    init_chartHighlight();
    init_chartOptions2();
    init_chartUpdateType();
    init_dataController();
    init_axisRegistry();
    init_expectedEnterpriseModules();
    init_legendRegistry();
    init_seriesRegistry();
    init_interactionManager();
    init_syncManager();
    init_tooltipManager();
    init_zoomManager();
    init_keyboard();
    init_keyboardUtil();
    init_layers();
    init_prepareAxis();
    init_prepareSeries();
    init_types2();
    init_modulesManager();
    init_chartOverlays();
    init_loadingSpinner();
    init_series();
    init_seriesLayerManager();
    init_tooltip();
    init_baseLayoutProcessor();
    init_dataWindowProcessor();
    init_overlaysProcessor();
    debug = Debug.create(true, "opts");
    SeriesArea = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.padding = new Padding(0);
      }
    };
    __decorateClass([
      Validate(BOOLEAN, { optional: true })
    ], SeriesArea.prototype, "clip", 2);
    __decorateClass([
      Validate(OBJECT)
    ], SeriesArea.prototype, "padding", 2);
    _Chart = class _Chart extends Observable {
      constructor(options, resources) {
        var _a2, _b, _c;
        super();
        this.id = createId(this);
        this.seriesRoot = new Group({ name: `${this.id}-series-root` });
        this.highlightRoot = new Group({
          name: `${this.id}-highlight-root`,
          layer: true,
          zIndex: 5 /* SERIES_HIGHLIGHT_ZINDEX */,
          nonEmptyChildDerivedZIndex: true
        });
        this.annotationRoot = new Group({
          name: `${this.id}-annotation-root`,
          layer: true,
          zIndex: 10 /* SERIES_ANNOTATION_ZINDEX */
        });
        this.debug = Debug.create();
        this.extraDebugStats = {};
        this.data = [];
        this._firstAutoSize = true;
        this.padding = new Padding(20);
        this.seriesArea = new SeriesArea();
        this.title = new Caption();
        this.subtitle = new Caption();
        this.footnote = new Caption();
        this.keyboard = new Keyboard();
        this.mode = "standalone";
        this.destroyed = false;
        this._skipSync = false;
        this._destroyFns = [];
        this.chartAnimationPhase = "initial";
        this.modulesManager = new ModulesManager();
        // FIXME: zoomManager should be owned by ctx, but it can't because it is used by CartesianChart.onAxisChange before ctx is initialised
        this.zoomManager = new ZoomManager();
        this.processors = [];
        this.processedOptions = {};
        this.userOptions = {};
        this.queuedUserOptions = [];
        this._pendingFactoryUpdatesCount = 0;
        this._performUpdateNoRenderCount = 0;
        this._performUpdateSkipAnimations = false;
        this.performUpdateType = 7 /* NONE */;
        this.updateShortcutCount = 0;
        this.seriesToUpdate = /* @__PURE__ */ new Set();
        this.updateMutex = new Mutex();
        this.updateRequestors = {};
        this.performUpdateTrigger = debouncedCallback((_0) => __async(this, [_0], function* ({ count }) {
          if (this.destroyed)
            return;
          this.updateMutex.acquire(() => __async(this, null, function* () {
            try {
              yield this.performUpdate(count);
            } catch (error) {
              Logger.error("update error", error);
            }
          })).catch((e) => Logger.errorOnce(e));
        }));
        this._performUpdateSplits = {};
        this.axes = [];
        this.series = [];
        this.focus = {
          hasFocus: false,
          series: void 0,
          seriesIndex: 0,
          datumIndex: 0,
          datum: void 0
        };
        this.pointerScheduler = debouncedAnimationFrame(() => {
          if (!this.lastInteractionEvent)
            return;
          if (this.performUpdateType <= 4 /* SERIES_UPDATE */) {
            this.pointerScheduler.schedule();
            return;
          }
          this.handlePointer(this.lastInteractionEvent, false);
          this.lastInteractionEvent = void 0;
        });
        this.onSeriesNodeClick = (event) => {
          const seriesNodeClickEvent = __spreadProps(__spreadValues({}, event), {
            type: "seriesNodeClick"
          });
          Object.defineProperty(seriesNodeClickEvent, "series", {
            enumerable: false,
            // Should display the deprecation warning
            get: () => event.series
          });
          this.fireEvent(seriesNodeClickEvent);
        };
        this.onSeriesNodeDoubleClick = (event) => {
          const seriesNodeDoubleClick = __spreadProps(__spreadValues({}, event), {
            type: "seriesNodeDoubleClick"
          });
          this.fireEvent(seriesNodeDoubleClick);
        };
        this.seriesGroupingChanged = (event) => {
          if (!(event instanceof SeriesGroupingChangedEvent))
            return;
          const { series, seriesGrouping, oldGrouping } = event;
          if (series.rootGroup.parent == null)
            return;
          this.seriesLayerManager.changeGroup({
            internalId: series.internalId,
            type: series.type,
            rootGroup: series.rootGroup,
            highlightGroup: series.highlightGroup,
            annotationGroup: series.annotationGroup,
            getGroupZIndexSubOrder: (type) => series.getGroupZIndexSubOrder(type),
            seriesGrouping,
            oldGrouping
          });
        };
        this.dataProcessListeners = /* @__PURE__ */ new Set();
        this.chartOptions = options;
        let scene = resources == null ? void 0 : resources.scene;
        const element2 = (_a2 = resources == null ? void 0 : resources.element) != null ? _a2 : createElement("div", "ag-chart-wrapper", { position: "relative", userSelect: "none" });
        const container = resources == null ? void 0 : resources.container;
        this.element = element2;
        const root = new Group({ name: "root" });
        root.visible = false;
        root.append(this.seriesRoot);
        root.append(this.highlightRoot);
        root.append(this.annotationRoot);
        this.axisGridGroup = new Group({ name: "Axes-Grids", layer: true, zIndex: 1 /* AXIS_GRID_ZINDEX */ });
        root.appendChild(this.axisGridGroup);
        this.axisGroup = new Group({ name: "Axes", layer: true, zIndex: 2 /* AXIS_ZINDEX */ });
        root.appendChild(this.axisGroup);
        this.sizeMonitor = new SizeMonitor();
        this.sizeMonitor.observe(this.element, (size) => this.rawResize(size));
        const { overrideDevicePixelRatio } = options.specialOverrides;
        scene != null ? scene : scene = new Scene({ pixelRatio: overrideDevicePixelRatio, canvasPosition: "absolute" });
        scene.setRoot(root).setContainer(element2);
        this.autoSize = true;
        this.tooltip = new Tooltip();
        this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot, this.highlightRoot, this.annotationRoot);
        const ctx = this.ctx = new ChartContext(this, {
          scene,
          syncManager: new SyncManager(this),
          element: element2,
          updateCallback: (type = 0 /* FULL */, opts) => this.update(type, opts),
          updateMutex: this.updateMutex
        });
        this.overlays = new ChartOverlays();
        (_c = (_b = this.overlays.loading).renderer) != null ? _c : _b.renderer = () => getLoadingSpinner(this.overlays.loading.getText(), ctx.animationManager.defaultDuration);
        this.processors = [
          new BaseLayoutProcessor(this, ctx.layoutService),
          new DataWindowProcessor(this, ctx.dataService, ctx.updateService, ctx.zoomManager),
          new OverlaysProcessor(this, this.overlays, ctx.dataService, ctx.layoutService, ctx.animationManager)
        ];
        this.highlight = new ChartHighlight();
        this.container = container;
        const { All } = InteractionState;
        const moduleContext = this.getModuleContext();
        const seriesRegion = ctx.regionManager.addRegion("series", this.seriesRoot, this.axisGroup);
        ctx.regionManager.addRegion("root", root);
        this._destroyFns.push(
          ctx.dataService.addListener("data-load", (event) => {
            this.data = event.data;
          }),
          ctx.scene.attachNode(this.title.node),
          ctx.scene.attachNode(this.subtitle.node),
          ctx.scene.attachNode(this.footnote.node),
          this.title.registerInteraction(moduleContext, "title"),
          this.subtitle.registerInteraction(moduleContext, "subtitle"),
          this.footnote.registerInteraction(moduleContext, "footnote"),
          ctx.interactionManager.addListener("click", (event) => this.onClick(event)),
          ctx.interactionManager.addListener("dblclick", (event) => this.onDoubleClick(event)),
          seriesRegion.addListener("hover", (event) => this.onMouseMove(event)),
          seriesRegion.addListener("leave", (event) => this.onLeave(event)),
          seriesRegion.addListener("blur", () => this.onBlur()),
          seriesRegion.addListener("tab", (event) => this.onTab(event)),
          seriesRegion.addListener("nav-vert", (event) => this.onNavVert(event)),
          seriesRegion.addListener("nav-hori", (event) => this.onNavHori(event)),
          seriesRegion.addListener("submit", (event) => this.onSubmit(event)),
          ctx.keyNavManager.addListener("browserfocus", (event) => this.onBrowserFocus(event)),
          ctx.interactionManager.addListener("page-left", () => this.destroy()),
          ctx.interactionManager.addListener("contextmenu", (event) => this.onContextMenu(event), All),
          ctx.animationManager.addListener("animation-start", () => this.onAnimationStart()),
          ctx.animationManager.addListener("animation-frame", () => {
            this.update(6 /* SCENE_RENDER */);
          }),
          ctx.highlightManager.addListener("highlight-change", (event) => this.changeHighlightDatum(event)),
          ctx.zoomManager.addListener("zoom-pan-start", () => this.resetPointer()),
          ctx.zoomManager.addListener("zoom-change", () => {
            this.resetPointer();
            this.series.map((s) => {
              var _a3;
              return (_a3 = s.animationState) == null ? void 0 : _a3.transition("updateData");
            });
            const skipAnimations = this.chartAnimationPhase !== "initial";
            this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });
          })
        );
      }
      static getInstance(element2) {
        return _Chart.chartsInstances.get(element2);
      }
      /** NOTE: This is exposed for use by Integrated charts only. */
      get canvasElement() {
        return this.ctx.scene.canvas.element;
      }
      /** NOTE: This is exposed for use by Integrated charts only. */
      getCanvasDataURL(fileFormat) {
        return this.ctx.scene.getDataURL(fileFormat);
      }
      onAutoSizeChange(value) {
        const { style } = this.element;
        if (value) {
          style.display = "block";
          style.width = "100%";
          style.height = "100%";
          if (!this._lastAutoSize) {
            return;
          }
          this.resize(void 0, void 0, "autoSize option");
        } else {
          style.display = "inline-block";
          style.width = "auto";
          style.height = "auto";
        }
      }
      download(fileName, fileFormat) {
        this.ctx.scene.download(fileName, fileFormat);
      }
      getOptions() {
        var _a2;
        return (_a2 = this.queuedUserOptions.at(-1)) != null ? _a2 : this.userOptions;
      }
      getModuleContext() {
        return this.ctx;
      }
      getAriaLabel() {
        var _a2;
        const captionText = [this.title, this.subtitle, this.footnote].filter((caption) => caption.enabled && caption.text).map((caption) => caption.text).join(". ");
        const nSeries = (_a2 = this.series.length) != null ? _a2 : 0;
        return `chart, ${nSeries} series, ${captionText}`;
      }
      resetAnimations() {
        this.chartAnimationPhase = "initial";
        for (const series of this.series) {
          series.resetAnimation(this.chartAnimationPhase);
        }
        for (const axis of this.axes) {
          axis.resetAnimation(this.chartAnimationPhase);
        }
        this.animationRect = void 0;
        this.ctx.animationManager.reset();
      }
      skipAnimations() {
        this.ctx.animationManager.skipCurrentBatch();
        this._performUpdateSkipAnimations = true;
      }
      destroy(opts) {
        if (this.destroyed) {
          return;
        }
        const keepTransferableResources = opts == null ? void 0 : opts.keepTransferableResources;
        let result;
        this.performUpdateType = 7 /* NONE */;
        this._destroyFns.forEach((fn) => fn());
        this.processors.forEach((p) => p.destroy());
        this.tooltip.destroy();
        this.overlays.destroy();
        this.sizeMonitor.unobserve(this.element);
        this.modulesManager.destroy();
        if (keepTransferableResources) {
          this.ctx.scene.strip();
          result = { container: this.container, scene: this.ctx.scene, element: this.element };
        } else {
          this.ctx.scene.destroy();
          this.container = void 0;
        }
        this.destroySeries(this.series);
        this.seriesLayerManager.destroy();
        this.axes.forEach((a) => a.destroy());
        this.axes = [];
        this.animationRect = void 0;
        this.ctx.destroy();
        this.zoomManager.destroy();
        this.destroyed = true;
        Object.freeze(this);
        return result;
      }
      resetPointer(highlightOnly = false) {
        if (!highlightOnly) {
          this.ctx.tooltipManager.removeTooltip(this.id);
        }
        this.ctx.highlightManager.updateHighlight(this.id);
        this.lastInteractionEvent = void 0;
      }
      requestFactoryUpdate(cb) {
        if (this.destroyed)
          return;
        this._pendingFactoryUpdatesCount++;
        this.updateMutex.acquire(() => __async(this, null, function* () {
          if (this.destroyed)
            return;
          yield cb(this);
          if (this.destroyed)
            return;
          this._pendingFactoryUpdatesCount--;
        })).catch((e) => Logger.errorOnce(e));
      }
      update(type = 0 /* FULL */, opts) {
        var _a2, _b;
        const {
          forceNodeDataRefresh = false,
          skipAnimations,
          seriesToUpdate = this.series,
          newAnimationBatch
        } = opts != null ? opts : {};
        if (forceNodeDataRefresh) {
          this.series.forEach((series) => series.markNodeDataDirty());
        }
        for (const series of seriesToUpdate) {
          this.seriesToUpdate.add(series);
        }
        if (skipAnimations) {
          this.ctx.animationManager.skipCurrentBatch();
          this._performUpdateSkipAnimations = true;
        }
        if (newAnimationBatch && this.ctx.animationManager.isActive()) {
          this._performUpdateSkipAnimations = true;
        }
        this._skipSync = (_a2 = opts == null ? void 0 : opts.skipSync) != null ? _a2 : false;
        if (this.debug.check()) {
          let stack = (_b = new Error().stack) != null ? _b : "<unknown>";
          stack = stack.replace(/\([^)]*/g, "");
          this.updateRequestors[stack] = type;
        }
        if (type < this.performUpdateType) {
          this.performUpdateType = type;
          this.performUpdateTrigger.schedule(opts == null ? void 0 : opts.backOffMs);
        }
      }
      performUpdate(count) {
        return __async(this, null, function* () {
          var _a2;
          const { performUpdateType, extraDebugStats, _performUpdateSplits: splits, ctx } = this;
          const seriesToUpdate = [...this.seriesToUpdate];
          this.performUpdateType = 7 /* NONE */;
          this.seriesToUpdate.clear();
          if (this.updateShortcutCount === 0 && performUpdateType < 6 /* SCENE_RENDER */) {
            ctx.animationManager.startBatch(this._performUpdateSkipAnimations);
            ctx.animationManager.onBatchStop(() => this.chartAnimationPhase = "ready");
          }
          this.debug("Chart.performUpdate() - start", ChartUpdateType[performUpdateType]);
          let previousSplit = performance.now();
          (_a2 = splits.start) != null ? _a2 : splits.start = previousSplit;
          const updateSplits = (splitName) => {
            var _a3;
            (_a3 = splits[splitName]) != null ? _a3 : splits[splitName] = 0;
            splits[splitName] += performance.now() - previousSplit;
            previousSplit = performance.now();
          };
          let updateDeferred = false;
          switch (performUpdateType) {
            case 0 /* FULL */:
              this.updateDOM();
            case 1 /* UPDATE_DATA */:
              yield this.updateData();
              updateSplits("\u2B07\uFE0F");
            case 2 /* PROCESS_DATA */:
              yield this.processData();
              this.resetPointer(true);
              updateSplits("\u{1F3ED}");
            case 3 /* PERFORM_LAYOUT */:
              if (this.checkUpdateShortcut(3 /* PERFORM_LAYOUT */))
                break;
              if (!this.checkFirstAutoSize(seriesToUpdate)) {
                updateDeferred = true;
                break;
              }
              yield this.processLayout();
              updateSplits("\u2316");
            case 4 /* SERIES_UPDATE */:
              if (this.checkUpdateShortcut(4 /* SERIES_UPDATE */))
                break;
              const { seriesRect } = this;
              yield Promise.all(seriesToUpdate.map((series) => series.update({ seriesRect })));
              updateSplits("\u{1F914}");
            case 5 /* TOOLTIP_RECALCULATION */:
              if (this.checkUpdateShortcut(5 /* TOOLTIP_RECALCULATION */))
                break;
              const tooltipMeta = ctx.tooltipManager.getTooltipMeta(this.id);
              if (performUpdateType <= 4 /* SERIES_UPDATE */ && (tooltipMeta == null ? void 0 : tooltipMeta.lastPointerEvent) != null) {
                this.handlePointer(tooltipMeta.lastPointerEvent, true);
              }
              updateSplits("\u2196");
            case 6 /* SCENE_RENDER */:
              if (this.checkUpdateShortcut(6 /* SCENE_RENDER */))
                break;
              ctx.animationManager.endBatch();
              extraDebugStats["updateShortcutCount"] = this.updateShortcutCount;
              yield ctx.scene.render({ debugSplitTimes: splits, extraDebugStats });
              this.ctx.regionManager.updateFocusWrapperRect();
              this.extraDebugStats = {};
              for (const key in splits) {
                delete splits[key];
              }
            case 7 /* NONE */:
              this.updateShortcutCount = 0;
              this.updateRequestors = {};
              this._performUpdateSkipAnimations = false;
              ctx.animationManager.endBatch();
          }
          if (!updateDeferred) {
            ctx.updateService.dispatchUpdateComplete(this.getMinRects());
          }
          const end = performance.now();
          this.debug("Chart.performUpdate() - end", {
            chart: this,
            durationMs: Math.round((end - splits["start"]) * 100) / 100,
            count,
            performUpdateType: ChartUpdateType[performUpdateType]
          });
        });
      }
      updateThemeClassName() {
        const {
          element: element2,
          processedOptions: { theme }
        } = this;
        const themeClassNamePrefix = "ag-charts-theme-";
        const validThemeClassNames = [`${themeClassNamePrefix}default`, `${themeClassNamePrefix}default-dark`];
        let themeClassName = validThemeClassNames[0];
        let isDark = false;
        if (typeof theme === "string") {
          themeClassName = theme.replace("ag-", themeClassNamePrefix);
          isDark = theme.includes("-dark");
        } else if (typeof (theme == null ? void 0 : theme.baseTheme) === "string") {
          themeClassName = theme.baseTheme.replace("ag-", themeClassNamePrefix);
          isDark = theme.baseTheme.includes("-dark");
        }
        if (!validThemeClassNames.includes(themeClassName)) {
          themeClassName = isDark ? validThemeClassNames[1] : validThemeClassNames[0];
        }
        element2.classList.forEach((className) => {
          if (className.startsWith(themeClassNamePrefix) && className !== themeClassName) {
            element2.classList.remove(className);
          }
        });
        element2.classList.add(themeClassName);
      }
      updateDOM() {
        this.updateThemeClassName();
        const { enabled, tabIndex } = this.keyboard;
        this.element.tabIndex = enabled ? tabIndex != null ? tabIndex : 0 : -1;
        setAttribute(this.ctx.scene.canvas.element, "role", "figure");
        setAttribute(this.ctx.scene.canvas.element, "aria-label", this.getAriaLabel());
      }
      checkUpdateShortcut(checkUpdateType) {
        const maxShortcuts = 3;
        if (this.updateShortcutCount > maxShortcuts) {
          Logger.warn(
            `exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`,
            this.updateRequestors
          );
          return false;
        }
        if (this.performUpdateType <= checkUpdateType) {
          this.updateShortcutCount++;
          return true;
        }
        return false;
      }
      checkFirstAutoSize(seriesToUpdate) {
        if (this.autoSize && !this._lastAutoSize) {
          const count = this._performUpdateNoRenderCount++;
          const backOffMs = __pow(count + 1, 2) * 40;
          if (count < 8) {
            this.update(3 /* PERFORM_LAYOUT */, { seriesToUpdate, backOffMs });
            this.debug("Chart.checkFirstAutoSize() - backing off until first size update", backOffMs);
            return false;
          }
          this.debug("Chart.checkFirstAutoSize() - timeout for first size update.");
        }
        this._performUpdateNoRenderCount = 0;
        return true;
      }
      onAxisChange(newValue, oldValue = []) {
        for (const axis of oldValue) {
          if (newValue.includes(axis))
            continue;
          axis.detachAxis(this.axisGroup, this.axisGridGroup);
          axis.destroy();
        }
        for (const axis of newValue) {
          if (oldValue == null ? void 0 : oldValue.includes(axis))
            continue;
          axis.attachAxis(this.axisGroup, this.axisGridGroup);
        }
      }
      onSeriesChange(newValue, oldValue) {
        var _a2, _b;
        const seriesToDestroy = (_a2 = oldValue == null ? void 0 : oldValue.filter((series) => !newValue.includes(series))) != null ? _a2 : [];
        this.destroySeries(seriesToDestroy);
        (_b = this.seriesLayerManager) == null ? void 0 : _b.setSeriesCount(newValue.length);
        for (const series of newValue) {
          if (oldValue == null ? void 0 : oldValue.includes(series))
            continue;
          if (series.rootGroup.parent == null) {
            this.seriesLayerManager.requestGroup(series);
          }
          const chart = this;
          series.chart = {
            get mode() {
              return chart.mode;
            },
            get isMiniChart() {
              return false;
            },
            get seriesRect() {
              return chart.seriesRect;
            },
            placeLabels() {
              return chart.placeLabels();
            }
          };
          series.resetAnimation(this.chartAnimationPhase);
          this.addSeriesListeners(series);
          series.addChartEventListeners();
        }
      }
      destroySeries(allSeries) {
        allSeries == null ? void 0 : allSeries.forEach((series) => {
          series.removeEventListener("nodeClick", this.onSeriesNodeClick);
          series.removeEventListener("nodeDoubleClick", this.onSeriesNodeDoubleClick);
          series.removeEventListener("groupingChanged", this.seriesGroupingChanged);
          series.destroy();
          this.seriesLayerManager.releaseGroup(series);
          series.chart = void 0;
        });
      }
      addSeriesListeners(series) {
        if (this.hasEventListener("seriesNodeClick")) {
          series.addEventListener("nodeClick", this.onSeriesNodeClick);
        }
        if (this.hasEventListener("seriesNodeDoubleClick")) {
          series.addEventListener("nodeDoubleClick", this.onSeriesNodeDoubleClick);
        }
        series.addEventListener("groupingChanged", this.seriesGroupingChanged);
      }
      updateAllSeriesListeners() {
        this.series.forEach((series) => {
          series.removeEventListener("nodeClick", this.onSeriesNodeClick);
          series.removeEventListener("nodeDoubleClick", this.onSeriesNodeDoubleClick);
          this.addSeriesListeners(series);
        });
      }
      assignSeriesToAxes() {
        this.axes.forEach((axis) => {
          axis.boundSeries = this.series.filter((s) => {
            const seriesAxis = s.axes[axis.direction];
            return seriesAxis === axis;
          });
        });
      }
      assignAxesToSeries() {
        const directionToAxesMap = groupBy(this.axes, (axis) => axis.direction);
        this.series.forEach((series) => {
          series.directions.forEach((direction) => {
            const directionAxes = directionToAxesMap[direction];
            if (!directionAxes) {
              Logger.warnOnce(
                `no available axis for direction [${direction}]; check series and axes configuration.`
              );
              return;
            }
            const seriesKeys = series.getKeys(direction);
            const newAxis = directionAxes.find(
              (axis) => !axis.keys.length || seriesKeys.some((key) => axis.keys.includes(key))
            );
            if (!newAxis) {
              Logger.warnOnce(
                `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`
              );
              return;
            }
            series.axes[direction] = newAxis;
          });
        });
      }
      rawResize({ width, height }) {
        var _a2;
        if (!this.autoSize)
          return;
        width = Math.floor(width);
        height = Math.floor(height);
        if (width === 0 && height === 0)
          return;
        const [autoWidth = 0, authHeight = 0] = (_a2 = this._lastAutoSize) != null ? _a2 : [];
        if (autoWidth === width && authHeight === height)
          return;
        this._lastAutoSize = [width, height];
        this.resize(void 0, void 0, "SizeMonitor");
      }
      resize(width, height, source) {
        var _a2, _b, _c, _d;
        const { scene, animationManager } = this.ctx;
        width != null ? width : width = (_b = this.width) != null ? _b : this.autoSize ? (_a2 = this._lastAutoSize) == null ? void 0 : _a2[0] : scene.canvas.width;
        height != null ? height : height = (_d = this.height) != null ? _d : this.autoSize ? (_c = this._lastAutoSize) == null ? void 0 : _c[1] : scene.canvas.height;
        this.debug(`Chart.resize() from ${source}`, { width, height, stack: new Error().stack });
        if (!width || !height || !isFiniteNumber(width) || !isFiniteNumber(height))
          return;
        if (scene.resize(width, height)) {
          this.resetPointer();
          animationManager.reset();
          let skipAnimations = true;
          if (this.autoSize && this._firstAutoSize) {
            skipAnimations = false;
            this._firstAutoSize = false;
          }
          this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });
        }
      }
      updateData() {
        return __async(this, null, function* () {
          this.series.forEach((s) => s.setChartData(this.data));
          const modulePromises = this.modulesManager.mapModules((m) => {
            var _a2;
            return (_a2 = m.updateData) == null ? void 0 : _a2.call(m, { data: this.data });
          });
          yield Promise.all(modulePromises);
        });
      }
      processData() {
        return __async(this, null, function* () {
          if (this.series.some((s) => s.canHaveAxes)) {
            this.assignAxesToSeries();
            const syncModule = this.modulesManager.getModule("sync");
            if (syncModule == null ? void 0 : syncModule.enabled) {
              syncModule.syncAxes(this._skipSync);
            } else {
              this.assignSeriesToAxes();
            }
          }
          const dataController = new DataController(this.mode);
          const seriesPromises = this.series.map((s) => s.processData(dataController));
          const modulePromises = this.modulesManager.mapModules((m) => {
            var _a2;
            return (_a2 = m.processData) == null ? void 0 : _a2.call(m, { dataController });
          });
          dataController.execute();
          yield Promise.all([...seriesPromises, ...modulePromises]);
          for (const { legendType, legend } of this.modulesManager.legends()) {
            legend.data = this.getLegendData(legendType, this.mode !== "integrated");
          }
          this.dataProcessListeners.forEach((resolve) => resolve());
          this.dataProcessListeners.clear();
        });
      }
      placeLabels() {
        const visibleSeries = [];
        const data = [];
        for (const series of this.series) {
          if (!series.visible)
            continue;
          const labelData = series.getLabelData();
          if (isPointLabelDatum(labelData == null ? void 0 : labelData[0])) {
            data.push(labelData);
            visibleSeries.push(series);
          }
        }
        const { seriesRect } = this;
        const { top, right, bottom, left } = this.seriesArea.padding;
        const labels = seriesRect && data.length > 0 ? placeLabels(data, {
          x: -left,
          y: -top,
          width: seriesRect.width + left + right,
          height: seriesRect.height + top + bottom
        }) : [];
        return new Map(labels.map((l, i) => [visibleSeries[i], l]));
      }
      getLegendData(legendType, warnConflicts) {
        var _a2, _b, _c;
        const legendData = this.series.filter((s) => s.properties.showInLegend).flatMap((s) => s.getLegendData(legendType));
        const isCategoryLegendData = (data) => data.every((d) => d.legendType === "category");
        if (warnConflicts && isCategoryLegendData(legendData)) {
          const seriesMarkerFills = {};
          const seriesTypeMap = new Map(this.series.map((s) => [s.id, s.type]));
          for (const { seriesId, marker, label } of legendData) {
            if (marker.fill == null)
              continue;
            const seriesType = seriesTypeMap.get(seriesId);
            const markerFill = (_a2 = seriesMarkerFills[seriesType]) != null ? _a2 : seriesMarkerFills[seriesType] = {};
            (_c = markerFill[_b = label.text]) != null ? _c : markerFill[_b] = marker.fill;
            if (markerFill[label.text] !== marker.fill) {
              Logger.warnOnce(
                `legend item '${label.text}' has multiple fill colors, this may cause unexpected behaviour.`
              );
            }
          }
        }
        return legendData;
      }
      processLayout() {
        return __async(this, null, function* () {
          var _a2;
          const oldRect = this.animationRect;
          yield this.performLayout();
          if (oldRect && !((_a2 = this.animationRect) == null ? void 0 : _a2.equals(oldRect))) {
            this.ctx.animationManager.skipCurrentBatch();
          }
          this.debug("Chart.performUpdate() - seriesRect", this.seriesRect);
        });
      }
      performLayout() {
        return __async(this, null, function* () {
          const { width, height } = this.ctx.scene;
          let ctx = { shrinkRect: new BBox(0, 0, width, height) };
          ctx = this.ctx.layoutService.dispatchPerformLayout("start-layout", ctx);
          ctx = this.ctx.layoutService.dispatchPerformLayout("before-series", ctx);
          const modulePromises = this.modulesManager.mapModules((m) => __async(this, null, function* () {
            if (m.performLayout != null) {
              ctx = yield m.performLayout(ctx);
            }
          }));
          yield Promise.all(modulePromises);
          return ctx.shrinkRect;
        });
      }
      // x/y are local canvas coordinates in CSS pixels, not actual pixels
      pickSeriesNode(point, exactMatchOnly, maxDistance) {
        var _a2, _b;
        const start = performance.now();
        const pickModes = exactMatchOnly ? [0 /* EXACT_SHAPE_MATCH */] : void 0;
        const reverseSeries = [...this.series].reverse();
        let result;
        for (const series of reverseSeries) {
          if (!series.visible || !series.rootGroup.visible) {
            continue;
          }
          const { match, distance: distance2 } = (_a2 = series.pickNode(point, pickModes)) != null ? _a2 : {};
          if (!match || distance2 == null) {
            continue;
          }
          if ((!result || result.distance > distance2) && distance2 <= (maxDistance != null ? maxDistance : Infinity)) {
            result = { series, distance: distance2, datum: match };
          }
          if (distance2 === 0) {
            break;
          }
        }
        this.extraDebugStats["pickSeriesNode"] = Math.round(
          ((_b = this.extraDebugStats["pickSeriesNode"]) != null ? _b : 0) + (performance.now() - start)
        );
        return result;
      }
      onMouseMove(event) {
        this.lastInteractionEvent = event;
        this.pointerScheduler.schedule();
        this.extraDebugStats["mouseX"] = event.offsetX;
        this.extraDebugStats["mouseY"] = event.offsetY;
        this.update(6 /* SCENE_RENDER */);
      }
      onLeave(event) {
        if (!this.tooltip.pointerLeftOntoTooltip(event)) {
          this.resetPointer();
          this.update(6 /* SCENE_RENDER */);
          this.ctx.cursorManager.updateCursor("chart");
        }
      }
      onBrowserFocus(event) {
        if (event.delta > 0) {
          this.focus.datum = void 0;
          this.focus.series = void 0;
          this.focus.datumIndex = 0;
          this.focus.seriesIndex = 0;
        } else {
          this.focus.datum = void 0;
          this.focus.series = void 0;
          this.focus.datumIndex = Infinity;
          this.focus.seriesIndex = Infinity;
        }
      }
      onAnimationStart() {
        if (this.focus.hasFocus) {
          this.onBlur();
        }
      }
      onBlur() {
        this.ctx.regionManager.updateFocusIndicatorRect(void 0);
        this.resetPointer();
        this.focus.hasFocus = false;
      }
      onTab(event) {
        this.handleFocus();
        event.consume();
        this.focus.hasFocus = true;
      }
      onNavVert(event) {
        this.focus.seriesIndex += event.delta;
        this.handleFocus();
        event.consume();
      }
      onNavHori(event) {
        this.focus.datumIndex += event.delta;
        this.handleFocus(event.delta);
        event.consume();
      }
      onSubmit(event) {
        const { series, datum } = this.focus;
        const sourceEvent = event.sourceEvent.sourceEvent;
        if (series !== void 0 && datum !== void 0) {
          series.fireNodeClickEvent(sourceEvent, datum);
        } else {
          this.fireEvent({
            type: "click",
            event: sourceEvent
          });
        }
      }
      onContextMenu(event) {
        this.ctx.tooltipManager.removeTooltip(this.id);
        const { Default: Default6, ContextMenu: ContextMenu2 } = InteractionState;
        if (this.ctx.interactionManager.getState() & (Default6 | ContextMenu2)) {
          this.checkSeriesNodeRange(event, () => {
            this.ctx.highlightManager.updateHighlight(this.id);
          });
        }
      }
      handleFocus(datumIndexDelta) {
        this.focus.hasFocus = true;
        const overlayFocus = this.overlays.getFocusInfo();
        if (overlayFocus == null) {
          this.handleSeriesFocus(datumIndexDelta != null ? datumIndexDelta : 0);
        } else {
          this.ctx.regionManager.updateFocusIndicatorRect(overlayFocus.rect);
          this.ctx.ariaAnnouncementService.announceValue(overlayFocus.text);
        }
      }
      handleSeriesFocus(datumIndexDelta) {
        const { series, seriesRect, focus } = this;
        const visibleSeries = series.filter((s) => s.visible);
        if (visibleSeries.length === 0)
          return;
        focus.seriesIndex = clamp(0, focus.seriesIndex, visibleSeries.length - 1);
        focus.series = visibleSeries[focus.seriesIndex];
        const pick = focus.series.pickFocus({ datumIndex: focus.datumIndex, datumIndexDelta, seriesRect });
        if (pick === void 0)
          return;
        const { datum, datumIndex } = pick;
        focus.datumIndex = datumIndex;
        focus.datum = datum;
        const keyboardEvent = makeKeyboardPointerEvent(this.ctx.regionManager, pick);
        if (keyboardEvent !== void 0) {
          this.lastInteractionEvent = keyboardEvent;
          const html = focus.series.getTooltipHtml(datum);
          const meta = TooltipManager.makeTooltipMeta(this.lastInteractionEvent, datum);
          this.ctx.highlightManager.updateHighlight(this.id, datum);
          this.ctx.tooltipManager.updateTooltip(this.id, meta, html);
          this.ctx.ariaAnnouncementService.announceValue(html.ariaLabel);
        }
      }
      static isHoverEvent(event) {
        return event !== void 0 && event.type === "hover";
      }
      handlePointer(event, redisplay) {
        if (this.ctx.interactionManager.getState() !== 16 /* Default */ || !_Chart.isHoverEvent(event)) {
          return;
        }
        const { lastPick, hoverRect } = this;
        const { offsetX, offsetY } = event;
        const disablePointer = (highlightOnly = false) => {
          if (lastPick) {
            this.resetPointer(highlightOnly);
          }
        };
        if (redisplay ? this.ctx.animationManager.isActive() : !(hoverRect == null ? void 0 : hoverRect.containsPoint(offsetX, offsetY))) {
          disablePointer();
          return;
        }
        this.handlePointerTooltip(event, disablePointer);
        this.handlePointerNode(event);
      }
      handlePointerTooltip(event, disablePointer) {
        const { lastPick, tooltip } = this;
        const { range: range4 } = tooltip;
        const { offsetX, offsetY } = event;
        let pixelRange;
        if (isFiniteNumber(range4)) {
          pixelRange = range4;
        }
        const pick = this.pickSeriesNode({ x: offsetX, y: offsetY }, range4 === "exact", pixelRange);
        if (!pick) {
          this.ctx.tooltipManager.removeTooltip(this.id);
          if (this.highlight.range === "tooltip") {
            disablePointer(true);
          }
          return;
        }
        const isNewDatum = this.highlight.range === "node" || !lastPick || lastPick !== pick.datum;
        let html;
        if (isNewDatum) {
          html = pick.series.getTooltipHtml(pick.datum);
          if (this.highlight.range === "tooltip") {
            this.ctx.highlightManager.updateHighlight(this.id, pick.datum);
          }
        }
        const isPixelRange = pixelRange != null;
        const tooltipEnabled = this.tooltip.enabled && pick.series.tooltipEnabled;
        const exactlyMatched = range4 === "exact" && pick.distance === 0;
        const rangeMatched = range4 === "nearest" || isPixelRange || exactlyMatched;
        const shouldUpdateTooltip = tooltipEnabled && rangeMatched && (!isNewDatum || html !== void 0);
        const meta = TooltipManager.makeTooltipMeta(event, pick.datum);
        if (shouldUpdateTooltip) {
          this.ctx.tooltipManager.updateTooltip(this.id, meta, html);
        }
      }
      handlePointerNode(event) {
        const found = this.checkSeriesNodeRange(event, (series, datum) => {
          if (series.hasEventListener("nodeClick") || series.hasEventListener("nodeDoubleClick")) {
            this.ctx.cursorManager.updateCursor("chart", "pointer");
          }
          if (this.highlight.range === "node") {
            this.ctx.highlightManager.updateHighlight(this.id, datum);
          }
        });
        if (!found) {
          this.ctx.cursorManager.updateCursor("chart");
          if (this.highlight.range === "node") {
            this.ctx.highlightManager.updateHighlight(this.id);
          }
        }
      }
      onClick(event) {
        if (this.checkSeriesNodeClick(event)) {
          this.update(4 /* SERIES_UPDATE */);
          return;
        }
        this.fireEvent({
          type: "click",
          event: event.sourceEvent
        });
      }
      onDoubleClick(event) {
        if (this.checkSeriesNodeDoubleClick(event)) {
          this.update(4 /* SERIES_UPDATE */);
          return;
        }
        this.fireEvent({
          type: "doubleClick",
          event: event.sourceEvent
        });
      }
      checkSeriesNodeClick(event) {
        return this.checkSeriesNodeRange(event, (series, datum) => series.fireNodeClickEvent(event.sourceEvent, datum));
      }
      checkSeriesNodeDoubleClick(event) {
        return this.checkSeriesNodeRange(
          event,
          (series, datum) => series.fireNodeDoubleClickEvent(event.sourceEvent, datum)
        );
      }
      checkSeriesNodeRange(event, callback) {
        var _a2;
        const nearestNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, false);
        const datum = nearestNode == null ? void 0 : nearestNode.datum;
        const nodeClickRange = datum == null ? void 0 : datum.series.properties.nodeClickRange;
        let pixelRange;
        if (isFiniteNumber(nodeClickRange)) {
          pixelRange = nodeClickRange;
        }
        let pickedNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, true);
        if (pickedNode) {
          this.ctx.highlightManager.updatePicked(this.id, pickedNode.datum);
        } else {
          this.ctx.highlightManager.updatePicked(this.id);
        }
        if (datum && nodeClickRange === "nearest") {
          callback(datum.series, datum);
          return true;
        }
        if (nodeClickRange !== "exact") {
          pickedNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, false, pixelRange);
        }
        if (!pickedNode)
          return false;
        const isPixelRange = pixelRange != null;
        const exactlyMatched = nodeClickRange === "exact" && pickedNode.distance === 0;
        if (isPixelRange || exactlyMatched) {
          const allMatch = event.pointerHistory === void 0 || ((_a2 = event.pointerHistory) == null ? void 0 : _a2.every((pastEvent) => {
            const historyPoint = { x: pastEvent.offsetX, y: pastEvent.offsetY };
            const historyNode = this.pickSeriesNode(historyPoint, false, pixelRange);
            return (historyNode == null ? void 0 : historyNode.datum) === (pickedNode == null ? void 0 : pickedNode.datum);
          }));
          if (allMatch) {
            callback(pickedNode.series, pickedNode.datum);
            return true;
          }
        }
        return false;
      }
      changeHighlightDatum(event) {
        var _a2, _b;
        const seriesToUpdate = /* @__PURE__ */ new Set();
        const { series: newSeries = void 0, datum: newDatum } = (_a2 = event.currentHighlight) != null ? _a2 : {};
        const { series: lastSeries = void 0, datum: lastDatum } = (_b = event.previousHighlight) != null ? _b : {};
        if (lastSeries) {
          seriesToUpdate.add(lastSeries);
        }
        if (newSeries) {
          seriesToUpdate.add(newSeries);
        }
        if ((lastSeries == null ? void 0 : lastSeries.properties.cursor) && lastDatum) {
          this.ctx.cursorManager.updateCursor(lastSeries.id);
        }
        if ((newSeries == null ? void 0 : newSeries.properties.cursor) && newDatum) {
          this.ctx.cursorManager.updateCursor(newSeries.id, newSeries.properties.cursor);
        }
        this.lastPick = event.currentHighlight;
        const updateAll = newSeries == null || lastSeries == null;
        if (updateAll) {
          this.update(4 /* SERIES_UPDATE */);
        } else {
          this.update(4 /* SERIES_UPDATE */, { seriesToUpdate });
        }
      }
      waitForUpdate(timeoutMs = 1e4, failOnTimeout = false) {
        return __async(this, null, function* () {
          const start = performance.now();
          if (this._pendingFactoryUpdatesCount > 0) {
            yield this.updateMutex.waitForClearAcquireQueue();
          }
          while (this.performUpdateType !== 7 /* NONE */) {
            if (performance.now() - start > timeoutMs) {
              const message = `Chart.waitForUpdate() timeout of ${timeoutMs} reached - first chart update taking too long.`;
              if (failOnTimeout) {
                throw new Error(message);
              } else {
                Logger.warnOnce(message);
              }
            }
            yield sleep(50);
          }
          yield this.updateMutex.waitForClearAcquireQueue();
        });
      }
      waitForDataProcess(timeout) {
        return new Promise((resolve) => {
          this.dataProcessListeners.add(resolve);
          if (isNumber(timeout)) {
            setTimeout(() => {
              if (this.dataProcessListeners.has(resolve)) {
                this.dataProcessListeners.delete(resolve);
                resolve();
              }
            }, timeout);
          }
        });
      }
      getMinRects() {
        const { width, height } = this.ctx.scene;
        const minRects = this.series.map((series) => series.getMinRects(width, height)).filter(isDefined);
        if (minRects.length === 0)
          return;
        let maxWidth = 0;
        let maxHeight = 0;
        let maxVisibleWidth = 0;
        let maxVisibleHeight = 0;
        for (const { minRect: minRect2, minVisibleRect: minVisibleRect2 } of minRects) {
          maxWidth = Math.max(maxWidth, minRect2.width);
          maxHeight = Math.max(maxHeight, minRect2.height);
          maxVisibleWidth = Math.max(maxVisibleWidth, minVisibleRect2.width);
          maxVisibleHeight = Math.max(maxVisibleHeight, minVisibleRect2.height);
        }
        const minRect = new BBox(0, 0, maxWidth, maxHeight);
        let minVisibleRect = minRect.clone();
        if (maxVisibleWidth > 0 && maxVisibleHeight > 0) {
          minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);
        }
        return { minRect, minVisibleRect };
      }
      filterMiniChartSeries(series) {
        return series == null ? void 0 : series.filter((s) => s.showInMiniChart !== false);
      }
      applyOptions(chartOptions) {
        var _a2, _b, _c, _d, _e;
        const oldOpts = this.processedOptions;
        const deltaOptions = chartOptions.diffOptions(oldOpts);
        const userOptions = chartOptions.userOptions;
        if (deltaOptions == null)
          return;
        debug("AgChartV2.updateDelta() - applying delta", deltaOptions);
        const completeOptions = mergeDefaults(deltaOptions, oldOpts);
        const modulesChanged = this.applyModules(completeOptions);
        const skip = [
          "type",
          "data",
          "series",
          "listeners",
          "theme",
          "legend.listeners",
          "navigator.miniChart.series",
          "navigator.miniChart.label",
          "axes",
          "topology"
        ];
        if (deltaOptions.listeners) {
          this.registerListeners(this, deltaOptions.listeners);
        }
        jsonApply(this, deltaOptions, { skip });
        let forceNodeDataRefresh = false;
        let seriesStatus = "no-op";
        if ((_a2 = deltaOptions.series) == null ? void 0 : _a2.length) {
          seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts == null ? void 0 : oldOpts.series);
          forceNodeDataRefresh = true;
        }
        if (seriesStatus === "replaced") {
          this.resetAnimations();
        }
        if (this.applyAxes(this, completeOptions, oldOpts, seriesStatus)) {
          forceNodeDataRefresh = true;
        }
        if (deltaOptions.data) {
          this.data = deltaOptions.data;
        }
        if (((_b = deltaOptions.legend) == null ? void 0 : _b.listeners) && this.modulesManager.isEnabled("legend")) {
          Object.assign(this.legend.listeners, deltaOptions.legend.listeners);
        }
        if (deltaOptions.listeners) {
          this.updateAllSeriesListeners();
        }
        this.chartOptions = chartOptions;
        this.processedOptions = completeOptions;
        this.userOptions = mergeDefaults(userOptions, this.userOptions);
        const navigatorModule = this.modulesManager.getModule("navigator");
        const zoomModule = this.modulesManager.getModule("zoom");
        if (!(navigatorModule == null ? void 0 : navigatorModule.enabled) && !(zoomModule == null ? void 0 : zoomModule.enabled)) {
          this.ctx.zoomManager.updateZoom("chart");
        }
        const miniChart = navigatorModule == null ? void 0 : navigatorModule.miniChart;
        const miniChartSeries = (_e = (_d = (_c = completeOptions.navigator) == null ? void 0 : _c.miniChart) == null ? void 0 : _d.series) != null ? _e : completeOptions.series;
        if ((miniChart == null ? void 0 : miniChart.enabled) === true && miniChartSeries != null) {
          this.applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts);
        } else if ((miniChart == null ? void 0 : miniChart.enabled) === false) {
          miniChart.series = [];
          miniChart.axes = [];
        }
        injectStyle(styles_default, "chart");
        this.ctx.annotationManager.setAnnotationStyles(chartOptions.annotationThemes);
        forceNodeDataRefresh || (forceNodeDataRefresh = this.shouldForceNodeDataRefresh(deltaOptions, seriesStatus));
        const majorChange = forceNodeDataRefresh || modulesChanged;
        const updateType = majorChange ? 0 /* FULL */ : 3 /* PERFORM_LAYOUT */;
        this.maybeResetAnimations(seriesStatus);
        debug("AgChartV2.applyChartOptions() - update type", ChartUpdateType[updateType], {
          seriesStatus,
          forceNodeDataRefresh
        });
        this.update(updateType, { forceNodeDataRefresh, newAnimationBatch: true });
      }
      maybeResetAnimations(seriesStatus) {
        if (this.mode !== "standalone")
          return;
        switch (seriesStatus) {
          case "series-grouping-change":
          case "replaced":
            this.resetAnimations();
            break;
          default:
        }
      }
      shouldForceNodeDataRefresh(deltaOptions, seriesStatus) {
        const seriesDataUpdate = !!deltaOptions.data || seriesStatus === "data-change" || seriesStatus === "replaced";
        const legendKeys = legendRegistry.getKeys();
        const optionsHaveLegend = Object.values(legendKeys).some(
          (legendKey) => deltaOptions[legendKey] != null
        );
        const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null;
        return seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;
      }
      applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts) {
        var _a2, _b, _c, _d, _e;
        const oldSeries = (_c = (_b = (_a2 = oldOpts == null ? void 0 : oldOpts.navigator) == null ? void 0 : _a2.miniChart) == null ? void 0 : _b.series) != null ? _c : oldOpts == null ? void 0 : oldOpts.series;
        const miniChartSeriesStatus = this.applySeries(
          miniChart,
          this.filterMiniChartSeries(miniChartSeries),
          this.filterMiniChartSeries(oldSeries)
        );
        this.applyAxes(miniChart, completeOptions, oldOpts, miniChartSeriesStatus, [
          "axes[].tick",
          "axes[].thickness",
          "axes[].title",
          "axes[].crosshair",
          "axes[].gridLine",
          "axes[].label"
        ]);
        const axes = miniChart.axes;
        const horizontalAxis = axes.find((axis) => axis.direction === "x" /* X */);
        for (const axis of axes) {
          axis.gridLine.enabled = false;
          axis.label.enabled = axis === horizontalAxis;
          axis.tick.enabled = false;
          axis.interactionEnabled = false;
        }
        if (horizontalAxis != null) {
          const miniChartOpts = (_d = completeOptions.navigator) == null ? void 0 : _d.miniChart;
          const labelOptions = miniChartOpts == null ? void 0 : miniChartOpts.label;
          const intervalOptions = (_e = miniChartOpts == null ? void 0 : miniChartOpts.label) == null ? void 0 : _e.interval;
          horizontalAxis.line.enabled = false;
          horizontalAxis.label.set(
            without(labelOptions, ["interval", "rotation", "minSpacing", "autoRotate", "autoRotateAngle"])
          );
          horizontalAxis.tick.set(
            without(intervalOptions, ["enabled", "width", "size", "color", "interval", "step"])
          );
          const step = intervalOptions == null ? void 0 : intervalOptions.step;
          if (step != null) {
            horizontalAxis.tick.interval = step;
          }
        }
      }
      applyModules(options) {
        var _a2;
        const { type: chartType2 } = this.constructor;
        let modulesChanged = false;
        for (const module2 of moduleRegistry.byType("root", "legend")) {
          const isConfigured = options[module2.optionsKey] != null;
          const shouldBeEnabled = isConfigured && module2.chartTypes.includes(chartType2);
          if (shouldBeEnabled === this.modulesManager.isEnabled(module2))
            continue;
          if (shouldBeEnabled) {
            this.modulesManager.addModule(module2, (m) => new m.instanceConstructor(this.getModuleContext()));
            if (module2.type === "legend") {
              (_a2 = this.modulesManager.getModule(module2)) == null ? void 0 : _a2.attachLegend(this.ctx.scene);
            }
            this[module2.optionsKey] = this.modulesManager.getModule(module2);
          } else {
            this.modulesManager.removeModule(module2);
            delete this[module2.optionsKey];
          }
          modulesChanged = true;
        }
        return modulesChanged;
      }
      applySeries(chart, optSeries, oldOptSeries) {
        var _a2;
        if (!optSeries) {
          return "no-change";
        }
        const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);
        if (matchResult.status === "no-overlap") {
          debug(
            `AgChartV2.applySeries() - creating new series instances, status: ${matchResult.status}`,
            matchResult
          );
          chart.series = optSeries.map((opts) => this.createSeries(opts));
          return "replaced";
        }
        debug(`AgChartV2.applySeries() - matchResult`, matchResult);
        const seriesInstances = [];
        let dataChanged = false;
        let groupingChanged = false;
        let isUpdated = false;
        for (const change of matchResult.changes) {
          groupingChanged || (groupingChanged = change.status === "series-grouping");
          dataChanged || (dataChanged = ((_a2 = change.diff) == null ? void 0 : _a2.data) != null);
          isUpdated || (isUpdated = change.status !== "no-op");
          switch (change.status) {
            case "add":
              const newSeries = this.createSeries(change.opts);
              seriesInstances.push(newSeries);
              debug(`AgChartV2.applySeries() - created new series`, newSeries);
              break;
            case "remove":
              debug(`AgChartV2.applySeries() - removing series at previous idx ${change.idx}`, change.series);
              break;
            case "no-op":
              seriesInstances.push(change.series);
              debug(`AgChartV2.applySeries() - no change to series at previous idx ${change.idx}`, change.series);
              break;
            case "series-grouping":
            case "update":
            default:
              const { series, diff: diff8, idx } = change;
              debug(`AgChartV2.applySeries() - applying series diff previous idx ${idx}`, diff8, series);
              this.applySeriesValues(series, diff8);
              series.markNodeDataDirty();
              seriesInstances.push(series);
          }
        }
        for (let idx = 0; idx < seriesInstances.length; idx++) {
          seriesInstances[idx]._declarationOrder = idx;
        }
        debug(`AgChartV2.applySeries() - final series instances`, seriesInstances);
        chart.series = seriesInstances;
        if (groupingChanged) {
          return "series-grouping-change";
        }
        if (dataChanged) {
          return "data-change";
        }
        return isUpdated ? "updated" : "no-op";
      }
      applyAxes(chart, options, oldOpts, seriesStatus, skip = []) {
        if (!("axes" in options) || !options.axes) {
          return false;
        }
        skip = ["axes[].type", ...skip];
        const { axes } = options;
        const forceRecreate = seriesStatus === "replaced";
        const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i) => a.type === axes[i].type);
        if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {
          chart.axes.forEach((axis, index) => {
            var _a2, _b;
            const previousOpts = (_b = (_a2 = oldOpts.axes) == null ? void 0 : _a2[index]) != null ? _b : {};
            const axisDiff = jsonDiff(previousOpts, axes[index]);
            debug(`AgChartV2.applyAxes() - applying axis diff idx ${index}`, axisDiff);
            const path = `axes[${index}]`;
            jsonApply(axis, axisDiff, __spreadProps(__spreadValues({}, JSON_APPLY_PLUGINS), { path, skip }));
          });
          return true;
        }
        debug(`AgChartV2.applyAxes() - creating new axes instances; seriesStatus: ${seriesStatus}`);
        chart.axes = this.createAxis(axes, skip);
        return true;
      }
      createSeries(seriesOptions) {
        const seriesInstance = seriesRegistry.create(seriesOptions.type, this.getModuleContext());
        this.applySeriesOptionModules(seriesInstance, seriesOptions);
        this.applySeriesValues(seriesInstance, seriesOptions);
        return seriesInstance;
      }
      applySeriesOptionModules(series, options) {
        const moduleContext = series.createModuleContext();
        const moduleMap = series.getModuleMap();
        for (const module2 of moduleRegistry.byType("series-option")) {
          if (module2.optionsKey in options && module2.seriesTypes.includes(series.type)) {
            moduleMap.addModule(module2, (m) => new m.instanceConstructor(moduleContext));
          }
        }
      }
      applySeriesValues(target, options) {
        const moduleMap = target.getModuleMap();
        const _a2 = options, { type: _, data, listeners, seriesGrouping, showInMiniChart: __ } = _a2, seriesOptions = __objRest(_a2, ["type", "data", "listeners", "seriesGrouping", "showInMiniChart"]);
        for (const moduleDef of EXPECTED_ENTERPRISE_MODULES) {
          if (moduleDef.type !== "series-option")
            continue;
          if (moduleDef.optionsKey in seriesOptions) {
            const module2 = moduleMap.getModule(moduleDef.optionsKey);
            const moduleOptions = seriesOptions[moduleDef.optionsKey];
            delete seriesOptions[moduleDef.optionsKey];
            module2.properties.set(moduleOptions);
          }
        }
        target.properties.set(seriesOptions);
        if ("data" in options) {
          target.setOptionsData(data);
        }
        if (listeners) {
          this.registerListeners(target, listeners);
        }
        if ("seriesGrouping" in options) {
          if (seriesGrouping == null) {
            target.seriesGrouping = void 0;
          } else {
            target.seriesGrouping = __spreadValues(__spreadValues({}, target.seriesGrouping), seriesGrouping);
          }
        }
      }
      createAxis(options, skip) {
        const guesser = new AxisPositionGuesser();
        const moduleContext = this.getModuleContext();
        for (let index = 0; index < options.length; index++) {
          const axisOptions = options[index];
          const axis = axisRegistry.create(axisOptions.type, moduleContext);
          this.applyAxisModules(axis, axisOptions);
          jsonApply(axis, axisOptions, __spreadProps(__spreadValues({}, JSON_APPLY_PLUGINS), { path: `axes[${index}]`, skip }));
          guesser.push(axis, axisOptions);
        }
        return guesser.guessInvalidPositions();
      }
      applyAxisModules(axis, options) {
        const moduleContext = axis.createModuleContext();
        const moduleMap = axis.getModuleMap();
        for (const module2 of moduleRegistry.byType("axis-option")) {
          const shouldBeEnabled = options[module2.optionsKey] != null;
          if (shouldBeEnabled === moduleMap.isEnabled(module2))
            continue;
          if (shouldBeEnabled) {
            moduleMap.addModule(module2, (m) => new m.instanceConstructor(moduleContext));
            axis[module2.optionsKey] = moduleMap.getModule(module2);
          } else {
            moduleMap.removeModule(module2);
            delete axis[module2.optionsKey];
          }
        }
      }
      registerListeners(source, listeners) {
        source.clearEventListeners();
        for (const [property, listener] of Object.entries(listeners)) {
          if (isFunction(listener)) {
            source.addEventListener(property, listener);
          }
        }
      }
    };
    _Chart.chartsInstances = /* @__PURE__ */ new WeakMap();
    __decorateClass([
      ActionOnSet({
        newValue(value) {
          if (this.destroyed)
            return;
          value.setAttribute("data-ag-charts", "");
          value.appendChild(this.element);
          _Chart.chartsInstances.set(value, this);
        },
        oldValue(value) {
          value.removeAttribute("data-ag-charts");
          value.removeChild(this.element);
          _Chart.chartsInstances.delete(value);
        }
      })
    ], _Chart.prototype, "container", 2);
    __decorateClass([
      ActionOnSet({
        newValue(value) {
          this.resize(value, void 0, "width option");
        }
      })
    ], _Chart.prototype, "width", 2);
    __decorateClass([
      ActionOnSet({
        newValue(value) {
          this.resize(void 0, value, "height option");
        }
      })
    ], _Chart.prototype, "height", 2);
    __decorateClass([
      ActionOnSet({
        newValue(value) {
          this.onAutoSizeChange(value);
        }
      }),
      Validate(BOOLEAN)
    ], _Chart.prototype, "autoSize", 2);
    __decorateClass([
      Validate(OBJECT)
    ], _Chart.prototype, "padding", 2);
    __decorateClass([
      Validate(OBJECT)
    ], _Chart.prototype, "seriesArea", 2);
    __decorateClass([
      Validate(OBJECT)
    ], _Chart.prototype, "title", 2);
    __decorateClass([
      Validate(OBJECT)
    ], _Chart.prototype, "subtitle", 2);
    __decorateClass([
      Validate(OBJECT)
    ], _Chart.prototype, "footnote", 2);
    __decorateClass([
      Validate(OBJECT)
    ], _Chart.prototype, "keyboard", 2);
    __decorateClass([
      Validate(UNION(["standalone", "integrated"], "a chart mode"))
    ], _Chart.prototype, "mode", 2);
    __decorateClass([
      ActionOnSet({
        changeValue(newValue, oldValue) {
          this.onAxisChange(newValue, oldValue);
        }
      })
    ], _Chart.prototype, "axes", 2);
    __decorateClass([
      ActionOnSet({
        changeValue(newValue, oldValue) {
          this.onSeriesChange(newValue, oldValue);
        }
      })
    ], _Chart.prototype, "series", 2);
    Chart = _Chart;
  }
});

// packages/ag-charts-community/src/scene/polyRoots.ts
function linearRoot(a, b) {
  const t = -b / a;
  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];
}
function quadraticRoots(a, b, c) {
  if (a === 0) {
    return linearRoot(b, c);
  }
  const D = b * b - 4 * a * c;
  const roots = [];
  if (D === 0) {
    const t = -b / (2 * a);
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
  } else if (D > 0) {
    const rD = Math.sqrt(D);
    const t1 = (-b - rD) / (2 * a);
    const t2 = (-b + rD) / (2 * a);
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
  }
  return roots;
}
function cubicRoots(a, b, c, d) {
  if (a === 0) {
    return quadraticRoots(b, c, d);
  }
  const A = b / a;
  const B = c / a;
  const C = d / a;
  const Q = (3 * B - A * A) / 9;
  const R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;
  const D = Q * Q * Q + R * R;
  const third = 1 / 3;
  const roots = [];
  if (D >= 0) {
    const rD = Math.sqrt(D);
    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);
    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);
    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);
    const t = -third * A + (S + T);
    if (t >= 0 && t <= 1) {
      roots.push(t);
    }
    if (Im === 0) {
      const t2 = -third * A - (S + T) / 2;
      if (t2 >= 0 && t2 <= 1) {
        roots.push(t2);
      }
    }
  } else {
    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));
    const thirdA = third * A;
    const twoSqrtQ = 2 * Math.sqrt(-Q);
    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;
    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;
    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;
    if (t1 >= 0 && t1 <= 1) {
      roots.push(t1);
    }
    if (t2 >= 0 && t2 <= 1) {
      roots.push(t2);
    }
    if (t3 >= 0 && t3 <= 1) {
      roots.push(t3);
    }
  }
  return roots;
}
var init_polyRoots = __esm({
  "packages/ag-charts-community/src/scene/polyRoots.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/scene/intersection.ts
function segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {
  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);
  if (d === 0) {
    return 0;
  }
  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;
  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    return 1;
  }
  return 0;
}
function cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {
  let intersections = 0;
  const A = y1 - y2;
  const B = x2 - x1;
  const C = x1 * (y2 - y1) - y1 * (x2 - x1);
  const bx = bezierCoefficients(px1, px2, px3, px4);
  const by = bezierCoefficients(py1, py2, py3, py4);
  const a = A * bx[0] + B * by[0];
  const b = A * bx[1] + B * by[1];
  const c = A * bx[2] + B * by[2];
  const d = A * bx[3] + B * by[3] + C;
  const roots = cubicRoots(a, b, c, d);
  for (const t of roots) {
    const tt = t * t;
    const ttt = t * tt;
    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];
    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];
    let s;
    if (x1 === x2) {
      s = (y - y1) / (y2 - y1);
    } else {
      s = (x - x1) / (x2 - x1);
    }
    if (s >= 0 && s <= 1) {
      intersections++;
    }
  }
  return intersections;
}
function bezierCoefficients(P1, P2, P3, P4) {
  return [
    // Bzier expressed as matrix operations:
    -P1 + 3 * P2 - 3 * P3 + P4,
    //                 |-1  3 -3  1| |P1|
    3 * P1 - 6 * P2 + 3 * P3,
    //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|
    -3 * P1 + 3 * P2,
    //                 |-3  3  0  0| |P3|
    P1
    //                 | 1  0  0  0| |P4|
  ];
}
function arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {
  if (isNaN(cx) || isNaN(cy)) {
    return 0;
  }
  if (counterClockwise) {
    [endAngle, startAngle] = [startAngle, endAngle];
  }
  const k = (y2 - y1) / (x2 - x1);
  const y0 = y1 - k * x1;
  const a = Math.pow(k, 2) + 1;
  const b = 2 * (k * (y0 - cy) - cx);
  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);
  const d = Math.pow(b, 2) - 4 * a * c;
  if (d < 0) {
    return 0;
  }
  const i1x = (-b + Math.sqrt(d)) / 2 / a;
  const i2x = (-b - Math.sqrt(d)) / 2 / a;
  let intersections = 0;
  [i1x, i2x].forEach((x) => {
    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);
    if (!isXInsideLine) {
      return;
    }
    const y = k * x + y0;
    const adjacent = x - cx;
    const opposite = y - cy;
    const angle = Math.atan2(opposite, adjacent);
    if (isBetweenAngles(angle, startAngle, endAngle)) {
      intersections++;
    }
  });
  return intersections;
}
var init_intersection = __esm({
  "packages/ag-charts-community/src/scene/intersection.ts"() {
    "use strict";
    init_angle();
    init_polyRoots();
  }
});

// packages/ag-charts-community/src/scene/extendedPath2D.ts
var ExtendedPath2D;
var init_extendedPath2D = __esm({
  "packages/ag-charts-community/src/scene/extendedPath2D.ts"() {
    "use strict";
    init_distance();
    init_logger();
    init_intersection();
    ExtendedPath2D = class {
      constructor() {
        // The methods of this class will likely be called many times per animation frame,
        // and any allocation can trigger a GC cycle during animation, so we attempt
        // to minimize the number of allocations.
        this.path2d = new Path2D();
        this.previousCommands = [];
        this.previousParams = [];
        this.previousClosedPath = false;
        this.commands = [];
        this.params = [];
        this.openedPath = false;
        this.closedPath = false;
      }
      isDirty() {
        return this.closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length || this.previousCommands.toString() !== this.commands.toString() || this.previousParams.toString() !== this.params.toString();
      }
      getPath2D() {
        return this.path2d;
      }
      moveTo(x, y) {
        this.openedPath = true;
        this.path2d.moveTo(x, y);
        this.commands.push(0 /* Move */);
        this.params.push(x, y);
      }
      lineTo(x, y) {
        if (this.openedPath) {
          this.path2d.lineTo(x, y);
          this.commands.push(1 /* Line */);
          this.params.push(x, y);
        } else {
          this.moveTo(x, y);
        }
      }
      rect(x, y, width, height) {
        this.moveTo(x, y);
        this.lineTo(x + width, y);
        this.lineTo(x + width, y + height);
        this.lineTo(x, y + height);
        this.closePath();
      }
      roundRect(x, y, width, height, radii) {
        radii = Math.min(radii, width / 2, height / 2);
        this.moveTo(x, y + radii);
        this.arc(x + radii, y + radii, radii, Math.PI, 1.5 * Math.PI);
        this.lineTo(x + radii, y);
        this.lineTo(x + width - radii, y);
        this.arc(x + width - radii, y + radii, radii, 1.5 * Math.PI, 2 * Math.PI);
        this.lineTo(x + width, y + radii);
        this.lineTo(x + width, y + height - radii);
        this.arc(x + width - radii, y + height - radii, radii, 0, Math.PI / 2);
        this.lineTo(x + width - radii, y + height);
        this.lineTo(x + radii, y + height);
        this.arc(x + +radii, y + height - radii, radii, Math.PI / 2, Math.PI);
        this.lineTo(x, y + height - radii);
        this.closePath();
      }
      arc(x, y, r, sAngle, eAngle, counterClockwise) {
        this.openedPath = true;
        this.path2d.arc(x, y, r, sAngle, eAngle, counterClockwise);
        this.commands.push(2 /* Arc */);
        this.params.push(x, y, r, sAngle, eAngle, counterClockwise ? 1 : 0);
      }
      cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {
        if (!this.openedPath) {
          this.moveTo(cx1, cy1);
        }
        this.path2d.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);
        this.commands.push(3 /* Curve */);
        this.params.push(cx1, cy1, cx2, cy2, x, y);
      }
      closePath() {
        if (this.openedPath) {
          this.path2d.closePath();
          this.commands.push(4 /* ClosePath */);
          this.openedPath = false;
          this.closedPath = true;
        }
      }
      clear(trackChanges) {
        if (trackChanges) {
          this.previousCommands = this.commands;
          this.previousParams = this.params;
          this.previousClosedPath = this.closedPath;
        }
        this.path2d = new Path2D();
        this.openedPath = false;
        this.closedPath = false;
        this.commands = [];
        this.params = [];
      }
      isPointInPath(x, y) {
        const commands = this.commands;
        const params = this.params;
        const cn = commands.length;
        const ox = -1e4;
        const oy = -1e4;
        let sx = NaN;
        let sy = NaN;
        let px = 0;
        let py = 0;
        let intersectionCount = 0;
        for (let ci = 0, pi = 0; ci < cn; ci++) {
          switch (commands[ci]) {
            case 0 /* Move */:
              intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);
              px = params[pi++];
              sx = px;
              py = params[pi++];
              sy = py;
              break;
            case 1 /* Line */:
              intersectionCount += segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y);
              px = params[pi - 2];
              py = params[pi - 1];
              break;
            case 3 /* Curve */:
              intersectionCount += cubicSegmentIntersections(
                px,
                py,
                params[pi++],
                params[pi++],
                params[pi++],
                params[pi++],
                params[pi++],
                params[pi++],
                ox,
                oy,
                x,
                y
              );
              px = params[pi - 2];
              py = params[pi - 1];
              break;
            case 2 /* Arc */:
              const cx = params[pi++];
              const cy = params[pi++];
              const r = params[pi++];
              const startAngle = params[pi++];
              const endAngle = params[pi++];
              const counterClockwise = Boolean(params[pi++]);
              intersectionCount += arcIntersections(
                cx,
                cy,
                r,
                startAngle,
                endAngle,
                counterClockwise,
                ox,
                oy,
                x,
                y
              );
              if (!isNaN(sx)) {
                const startX = cx + Math.cos(startAngle) * r;
                const startY = cy + Math.sin(startAngle) * r;
                intersectionCount += segmentIntersection(px, py, startX, startY, ox, oy, x, y);
              }
              px = cx + Math.cos(endAngle) * r;
              py = cy + Math.sin(endAngle) * r;
              break;
            case 4 /* ClosePath */:
              intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);
              break;
          }
        }
        return intersectionCount % 2 === 1;
      }
      distanceSquared(x, y) {
        let best = Infinity;
        const commands = this.commands;
        const params = this.params;
        const cn = commands.length;
        let sx = NaN;
        let sy = NaN;
        let px = 0;
        let py = 0;
        for (let ci = 0, pi = 0; ci < cn; ci++) {
          switch (commands[ci]) {
            case 0 /* Move */:
              px = sx = params[pi++];
              py = sy = params[pi++];
              break;
            case 1 /* Line */: {
              const nx = params[pi++];
              const ny = params[pi++];
              best = lineDistanceSquared(x, y, px, py, nx, ny, best);
              break;
            }
            case 3 /* Curve */:
              Logger.error("Command.Curve distanceSquare not implemented");
              break;
            case 2 /* Arc */: {
              const cx = params[pi++];
              const cy = params[pi++];
              const r = params[pi++];
              const startAngle = params[pi++];
              const endAngle = params[pi++];
              const startX = cx + Math.cos(startAngle) * r;
              const startY = cy + Math.sin(startAngle) * r;
              const counterClockwise = Boolean(params[pi++]);
              best = lineDistanceSquared(x, y, px, py, startX, startY, best);
              best = arcDistanceSquared(x, y, cx, cy, r, startAngle, endAngle, counterClockwise, best);
              px = cx + Math.cos(endAngle) * r;
              py = cy + Math.sin(endAngle) * r;
              break;
            }
            case 4 /* ClosePath */:
              best = lineDistanceSquared(x, y, px, py, sx, sy, best);
              break;
          }
        }
        return best;
      }
      getPoints() {
        const { commands, params } = this;
        const coords = [];
        let pi = 0;
        for (let ci = 0; ci < commands.length; ci++) {
          switch (commands[ci]) {
            case 0 /* Move */:
            case 1 /* Line */:
              coords.push({ x: params[pi++], y: params[pi++] });
              break;
            case 3 /* Curve */:
              pi += 4;
              coords.push({ x: params[pi++], y: params[pi++] });
              break;
            case 2 /* Arc */:
              coords.push({ x: params[pi++], y: params[pi++] });
              pi += 4;
              break;
            case 4 /* ClosePath */:
              break;
          }
        }
        return coords;
      }
    };
  }
});

// packages/ag-charts-community/src/scene/shape/path.ts
function ScenePathChangeDetection(opts) {
  const { redraw = 3 /* MAJOR */, changeCb, convertor } = opts != null ? opts : {};
  return SceneChangeDetection({ redraw, type: "path", convertor, changeCb });
}
var Path;
var init_path = __esm({
  "packages/ag-charts-community/src/scene/shape/path.ts"() {
    "use strict";
    init_extendedPath2D();
    init_node();
    init_shape();
    Path = class extends Shape {
      constructor() {
        super(...arguments);
        /**
         * Declare a path to retain for later rendering and hit testing
         * using custom Path2D class. Think of it as a TypeScript version
         * of the native Path2D (with some differences) that works in all browsers.
         */
        this.path = new ExtendedPath2D();
        this._clipX = NaN;
        this._clipY = NaN;
        /**
         * The path only has to be updated when certain attributes change.
         * For example, if transform attributes (such as `translationX`)
         * are changed, we don't have to update the path. The `dirtyPath` flag
         * is how we keep track if the path has to be updated or not.
         */
        this._dirtyPath = true;
      }
      set clipX(value) {
        this._clipX = value;
        this.dirtyPath = true;
      }
      set clipY(value) {
        this._clipY = value;
        this.dirtyPath = true;
      }
      set dirtyPath(value) {
        if (this._dirtyPath !== value) {
          this._dirtyPath = value;
          if (value) {
            this.markDirty(this, 3 /* MAJOR */);
          }
        }
      }
      get dirtyPath() {
        return this._dirtyPath;
      }
      checkPathDirty() {
        var _a2, _b, _c, _d;
        if (this._dirtyPath) {
          return;
        }
        this.dirtyPath = this.path.isDirty() || ((_b = (_a2 = this.fillShadow) == null ? void 0 : _a2.isDirty()) != null ? _b : false) || ((_d = (_c = this._clipPath) == null ? void 0 : _c.isDirty()) != null ? _d : false);
      }
      isPointInPath(x, y) {
        const point = this.transformPoint(x, y);
        return this.path.closedPath && this.path.isPointInPath(point.x, point.y);
      }
      distanceSquared(x, y) {
        const point = this.transformPoint(x, y);
        return this.path.distanceSquared(point.x, point.y);
      }
      isDirtyPath() {
        return false;
      }
      updatePath() {
      }
      render(renderCtx) {
        var _a2, _b, _c, _d, _e;
        const { ctx, forceRender, stats } = renderCtx;
        if (this.dirty === 0 /* NONE */ && !forceRender) {
          if (stats)
            stats.nodesSkipped += this.nodeCount.count;
          return;
        }
        this.computeTransformMatrix();
        this.matrix.toContext(ctx);
        if (this.dirtyPath || this.isDirtyPath()) {
          this.updatePath();
          this.dirtyPath = false;
        }
        if (!isNaN(this._clipX) && !isNaN(this._clipY) && this.clipMode != null) {
          ctx.save();
          const margin = this.strokeWidth / 2;
          (_a2 = this._clipPath) != null ? _a2 : this._clipPath = new ExtendedPath2D();
          this._clipPath.clear();
          this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);
          if (this.clipMode === "normal") {
            ctx.clip((_b = this._clipPath) == null ? void 0 : _b.getPath2D());
          }
          if (this._clipX > 0 && this._clipY > 0) {
            this.drawPath(ctx);
          }
          if (this.clipMode === "punch-out") {
            ctx.clip((_c = this._clipPath) == null ? void 0 : _c.getPath2D());
            const { x = -1e4, y = -1e4, width = 2e4, height = 2e4 } = (_d = this.computeBBox()) != null ? _d : {};
            ctx.clearRect(x, y, width, height);
          }
          ctx.restore();
        } else {
          this.drawPath(ctx);
        }
        (_e = this.fillShadow) == null ? void 0 : _e.markClean();
        super.render(renderCtx);
      }
      drawPath(ctx) {
        this.fillStroke(ctx, this.path.getPath2D());
      }
    };
    Path.className = "Path";
    __decorateClass([
      ScenePathChangeDetection()
    ], Path.prototype, "clipMode", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Path.prototype, "clipX", 1);
    __decorateClass([
      ScenePathChangeDetection()
    ], Path.prototype, "clipY", 1);
  }
});

// packages/ag-charts-community/src/scene/util/quadtree.ts
var QuadtreeNearest, QuadtreeSubdivisions, QuadtreeNode, QuadtreeNodeNearest;
var init_quadtree = __esm({
  "packages/ag-charts-community/src/scene/util/quadtree.ts"() {
    "use strict";
    init_bbox();
    init_nearest();
    QuadtreeNearest = class {
      constructor(capacity, maxdepth, boundary) {
        this.root = new QuadtreeNodeNearest(capacity, maxdepth, boundary);
      }
      clear(boundary) {
        this.root.clear(boundary);
      }
      addValue(hitTester, value) {
        const elem = {
          hitTester,
          value,
          distanceSquared: (x, y) => {
            return hitTester.distanceSquared(x, y);
          }
        };
        this.root.addElem(elem);
      }
      find(x, y) {
        const arg = { best: { nearest: void 0, distanceSquared: Infinity } };
        this.root.find(x, y, arg);
        return arg.best;
      }
    };
    QuadtreeSubdivisions = class {
      constructor(nw, ne, sw, se) {
        this.nw = nw;
        this.ne = ne;
        this.sw = sw;
        this.se = se;
      }
      addElem(elem) {
        this.nw.addElem(elem);
        this.ne.addElem(elem);
        this.sw.addElem(elem);
        this.se.addElem(elem);
      }
      find(x, y, arg) {
        this.nw.find(x, y, arg);
        this.ne.find(x, y, arg);
        this.sw.find(x, y, arg);
        this.se.find(x, y, arg);
      }
    };
    QuadtreeNode = class {
      constructor(capacity, maxdepth, boundary) {
        this.capacity = capacity;
        this.maxdepth = maxdepth;
        this.boundary = boundary != null ? boundary : BBox.NaN;
        this.elems = [];
        this.subdivisions = void 0;
      }
      clear(boundary) {
        this.elems.length = 0;
        this.boundary = boundary;
        this.subdivisions = void 0;
      }
      addElem(e) {
        if (this.addCondition(e)) {
          if (this.subdivisions === void 0) {
            if (this.maxdepth === 0 || this.elems.length < this.capacity) {
              this.elems.push(e);
            } else {
              this.subdivide(e);
            }
          } else {
            this.subdivisions.addElem(e);
          }
        }
      }
      find(x, y, arg) {
        if (this.findCondition(x, y, arg)) {
          if (this.subdivisions === void 0) {
            this.findAction(x, y, arg);
          } else {
            this.subdivisions.find(x, y, arg);
          }
        }
      }
      subdivide(newElem) {
        this.subdivisions = this.makeSubdivisions();
        for (const e of this.elems) {
          this.subdivisions.addElem(e);
        }
        this.subdivisions.addElem(newElem);
        this.elems.length = 0;
      }
      makeSubdivisions() {
        const { x, y, width, height } = this.boundary;
        const { capacity } = this;
        const depth = this.maxdepth - 1;
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        const nwBoundary = new BBox(x, y, halfWidth, halfHeight);
        const neBoundary = new BBox(x + halfWidth, y, halfWidth, halfHeight);
        const swBoundary = new BBox(x, y + halfHeight, halfWidth, halfHeight);
        const seBoundary = new BBox(x + halfWidth, y + halfHeight, halfWidth, halfHeight);
        return new QuadtreeSubdivisions(
          this.child(capacity, depth, nwBoundary),
          this.child(capacity, depth, neBoundary),
          this.child(capacity, depth, swBoundary),
          this.child(capacity, depth, seBoundary)
        );
      }
    };
    QuadtreeNodeNearest = class _QuadtreeNodeNearest extends QuadtreeNode {
      addCondition(e) {
        const { x, y } = e.hitTester.midPoint;
        return this.boundary.containsPoint(x, y);
      }
      findCondition(x, y, arg) {
        const { best } = arg;
        return best.distanceSquared !== 0 && this.boundary.distanceSquared(x, y) < best.distanceSquared;
      }
      findAction(x, y, arg) {
        const other = nearestSquared(x, y, this.elems, arg.best.distanceSquared);
        if (other.nearest !== void 0 && other.distanceSquared < arg.best.distanceSquared) {
          arg.best = other;
        }
      }
      child(capacity, depth, boundary) {
        return new _QuadtreeNodeNearest(capacity, depth, boundary);
      }
    };
  }
});

// packages/ag-charts-community/src/chart/marker/marker.ts
var Marker;
var init_marker = __esm({
  "packages/ag-charts-community/src/chart/marker/marker.ts"() {
    "use strict";
    init_bbox();
    init_path();
    Marker = class extends Path {
      constructor() {
        super(...arguments);
        this.x = 0;
        this.y = 0;
        this.size = 12;
      }
      computeBBox() {
        const { x, y, size } = this;
        const { center } = this.constructor;
        return new BBox(x - size * center.x, y - size * center.y, size, size);
      }
      applyPath(s, moves) {
        const { path } = this;
        let { x, y } = this;
        if (this.repeat != null) {
          x = 0;
          y = 0;
        }
        path.clear();
        for (const { x: mx, y: my, t } of moves) {
          x += mx * s;
          y += my * s;
          if (t === "move") {
            path.moveTo(x, y);
          } else {
            path.lineTo(x, y);
          }
        }
        path.closePath();
      }
      executeFill(ctx, path) {
        if (!path)
          return;
        if (this.repeat == null) {
          return super.executeFill(ctx, path);
        }
        ctx.save();
        let x = this.translationX;
        let y = this.translationY;
        for (const translation of this.repeat) {
          ctx.translate(translation.x - x, translation.y - y);
          ctx.fill(path);
          x = translation.x;
          y = translation.y;
        }
        ctx.restore();
      }
      executeStroke(ctx, path) {
        if (!path)
          return;
        if (this.repeat == null) {
          return super.executeStroke(ctx, path);
        }
        ctx.save();
        let x = this.translationX;
        let y = this.translationY;
        for (const translation of this.repeat) {
          ctx.translate(translation.x - x, translation.y - y);
          ctx.stroke(path);
          x = translation.x;
          y = translation.y;
        }
        ctx.restore();
      }
    };
    Marker.center = { x: 0.5, y: 0.5 };
    __decorateClass([
      ScenePathChangeDetection()
    ], Marker.prototype, "x", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Marker.prototype, "y", 2);
    __decorateClass([
      ScenePathChangeDetection({ convertor: Math.abs })
    ], Marker.prototype, "size", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Marker.prototype, "repeat", 2);
  }
});

// packages/ag-charts-community/src/chart/marker/circle.ts
var Circle;
var init_circle = __esm({
  "packages/ag-charts-community/src/chart/marker/circle.ts"() {
    "use strict";
    init_marker();
    Circle = class extends Marker {
      updatePath() {
        const { x, y, path, size } = this;
        const r = size / 2;
        path.clear();
        path.arc(x, y, r, 0, Math.PI * 2);
        path.closePath();
      }
    };
    Circle.className = "Circle";
  }
});

// packages/ag-charts-community/src/chart/marker/cross.ts
var _Cross, Cross;
var init_cross = __esm({
  "packages/ag-charts-community/src/chart/marker/cross.ts"() {
    "use strict";
    init_marker();
    _Cross = class _Cross extends Marker {
      updatePath() {
        const s = this.size / 4.2;
        super.applyPath(s, _Cross.moves);
      }
    };
    _Cross.className = "Cross";
    _Cross.moves = [
      { x: -1, y: 0, t: "move" },
      { x: -1, y: -1 },
      { x: 1, y: -1 },
      { x: 1, y: 1 },
      { x: 1, y: -1 },
      { x: 1, y: 1 },
      { x: -1, y: 1 },
      { x: 1, y: 1 },
      { x: -1, y: 1 },
      { x: -1, y: -1 },
      { x: -1, y: 1 },
      { x: -1, y: -1 }
    ];
    Cross = _Cross;
  }
});

// packages/ag-charts-community/src/chart/marker/diamond.ts
var _Diamond, Diamond;
var init_diamond = __esm({
  "packages/ag-charts-community/src/chart/marker/diamond.ts"() {
    "use strict";
    init_marker();
    _Diamond = class _Diamond extends Marker {
      updatePath() {
        const s = this.size / 2;
        super.applyPath(s, _Diamond.moves);
      }
    };
    _Diamond.className = "Diamond";
    _Diamond.moves = [
      { x: 0, y: -1, t: "move" },
      { x: 1, y: 1 },
      { x: -1, y: 1 },
      { x: -1, y: -1 },
      { x: 1, y: -1 }
    ];
    Diamond = _Diamond;
  }
});

// packages/ag-charts-community/src/chart/marker/heart.ts
var Heart;
var init_heart = __esm({
  "packages/ag-charts-community/src/chart/marker/heart.ts"() {
    "use strict";
    init_marker();
    Heart = class extends Marker {
      rad(degree) {
        return degree / 180 * Math.PI;
      }
      updatePath() {
        const { x, path, size, rad } = this;
        const r = size / 4;
        const y = this.y + r / 2;
        path.clear();
        path.arc(x - r, y - r, r, rad(130), rad(330));
        path.arc(x + r, y - r, r, rad(220), rad(50));
        path.lineTo(x, y + r);
        path.closePath();
      }
    };
    Heart.className = "Heart";
  }
});

// packages/ag-charts-community/src/chart/marker/pin.ts
var Pin;
var init_pin = __esm({
  "packages/ag-charts-community/src/chart/marker/pin.ts"() {
    "use strict";
    init_marker();
    Pin = class extends Marker {
      updatePath() {
        const { path, x, y } = this;
        const s = this.size;
        const cx = 0.5;
        const cy = 1;
        path.clear();
        path.moveTo(x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);
        path.cubicCurveTo(
          x + (0.15625 - cx) * s,
          y + (0.151491 - cy) * s,
          x + (0.307741 - cx) * s,
          y + (0 - cy) * s,
          x + (0.5 - cx) * s,
          y + (0 - cy) * s
        );
        path.cubicCurveTo(
          x + (0.692259 - cx) * s,
          y + (0 - cy) * s,
          x + (0.84375 - cx) * s,
          y + (0.151491 - cy) * s,
          x + (0.84375 - cx) * s,
          y + (0.34375 - cy) * s
        );
        path.cubicCurveTo(
          x + (0.84375 - cx) * s,
          y + (0.493824 - cy) * s,
          x + (0.784625 - cx) * s,
          y + (0.600181 - cy) * s,
          x + (0.716461 - cx) * s,
          y + (0.695393 - cy) * s
        );
        path.cubicCurveTo(
          x + (0.699009 - cx) * s,
          y + (0.719769 - cy) * s,
          x + (0.681271 - cx) * s,
          y + (0.743104 - cy) * s,
          x + (0.663785 - cx) * s,
          y + (0.766105 - cy) * s
        );
        path.cubicCurveTo(
          x + (0.611893 - cx) * s,
          y + (0.834367 - cy) * s,
          x + (0.562228 - cx) * s,
          y + (0.899699 - cy) * s,
          x + (0.528896 - cx) * s,
          y + (0.980648 - cy) * s
        );
        path.cubicCurveTo(
          x + (0.524075 - cx) * s,
          y + (0.992358 - cy) * s,
          x + (0.512663 - cx) * s,
          y + (1 - cy) * s,
          x + (0.5 - cx) * s,
          y + (1 - cy) * s
        );
        path.cubicCurveTo(
          x + (0.487337 - cx) * s,
          y + (1 - cy) * s,
          x + (0.475925 - cx) * s,
          y + (0.992358 - cy) * s,
          x + (0.471104 - cx) * s,
          y + (0.980648 - cy) * s
        );
        path.cubicCurveTo(
          x + (0.487337 - cx) * s,
          y + (1 - cy) * s,
          x + (0.475925 - cx) * s,
          y + (0.992358 - cy) * s,
          x + (0.471104 - cx) * s,
          y + (0.980648 - cy) * s
        );
        path.cubicCurveTo(
          x + (0.437772 - cx) * s,
          y + (0.899699 - cy) * s,
          x + (0.388107 - cx) * s,
          y + (0.834367 - cy) * s,
          x + (0.336215 - cx) * s,
          y + (0.766105 - cy) * s
        );
        path.cubicCurveTo(
          x + (0.318729 - cx) * s,
          y + (0.743104 - cy) * s,
          x + (0.300991 - cx) * s,
          y + (0.719769 - cy) * s,
          x + (0.283539 - cx) * s,
          y + (0.695393 - cy) * s
        );
        path.cubicCurveTo(
          x + (0.215375 - cx) * s,
          y + (0.600181 - cy) * s,
          x + (0.15625 - cx) * s,
          y + (0.493824 - cy) * s,
          x + (0.15625 - cx) * s,
          y + (0.34375 - cy) * s
        );
        path.closePath();
      }
    };
    Pin.className = "MapPin";
    Pin.center = { x: 0.5, y: 1 };
  }
});

// packages/ag-charts-community/src/chart/marker/plus.ts
var _Plus, Plus;
var init_plus = __esm({
  "packages/ag-charts-community/src/chart/marker/plus.ts"() {
    "use strict";
    init_marker();
    _Plus = class _Plus extends Marker {
      updatePath() {
        const s = this.size / 3;
        super.applyPath(s, _Plus.moves);
      }
    };
    _Plus.className = "Plus";
    _Plus.moves = [
      { x: -0.5, y: -0.5, t: "move" },
      { x: 0, y: -1 },
      { x: 1, y: 0 },
      { x: 0, y: 1 },
      { x: 1, y: 0 },
      { x: 0, y: 1 },
      { x: -1, y: 0 },
      { x: 0, y: 1 },
      { x: -1, y: 0 },
      { x: 0, y: -1 },
      { x: -1, y: 0 },
      { x: 0, y: -1 }
    ];
    Plus = _Plus;
  }
});

// packages/ag-charts-community/src/chart/marker/square.ts
var Square;
var init_square = __esm({
  "packages/ag-charts-community/src/chart/marker/square.ts"() {
    "use strict";
    init_marker();
    Square = class extends Marker {
      updatePath() {
        const { path, x, y } = this;
        const hs = this.size / 2;
        path.clear();
        path.moveTo(this.align(x - hs), this.align(y - hs));
        path.lineTo(this.align(x + hs), this.align(y - hs));
        path.lineTo(this.align(x + hs), this.align(y + hs));
        path.lineTo(this.align(x - hs), this.align(y + hs));
        path.closePath();
      }
    };
    Square.className = "Square";
  }
});

// packages/ag-charts-community/src/chart/marker/star.ts
var Star;
var init_star = __esm({
  "packages/ag-charts-community/src/chart/marker/star.ts"() {
    "use strict";
    init_marker();
    Star = class extends Marker {
      updatePath() {
        const { x, y, path, size } = this;
        const spikes = 5;
        const innerRadius = size / 2;
        const rotation = Math.PI / 2;
        path.clear();
        for (let i = 0; i < spikes * 2; i++) {
          const radius = i % 2 === 0 ? size : innerRadius;
          const angle = i * Math.PI / spikes - rotation;
          const xCoordinate = x + Math.cos(angle) * radius;
          const yCoordinate = y + Math.sin(angle) * radius;
          path.lineTo(xCoordinate, yCoordinate);
        }
        path.closePath();
      }
    };
    Star.className = "Star";
  }
});

// packages/ag-charts-community/src/chart/marker/triangle.ts
var _Triangle, Triangle;
var init_triangle = __esm({
  "packages/ag-charts-community/src/chart/marker/triangle.ts"() {
    "use strict";
    init_marker();
    _Triangle = class _Triangle extends Marker {
      updatePath() {
        const s = this.size * 1.1;
        super.applyPath(s, _Triangle.moves);
      }
    };
    _Triangle.className = "Triangle";
    _Triangle.moves = [
      { x: 0, y: -0.48, t: "move" },
      { x: 0.5, y: 0.87 },
      { x: -1, y: 0 }
    ];
    Triangle = _Triangle;
  }
});

// packages/ag-charts-community/src/chart/marker/util.ts
function isMarkerShape(shape) {
  return typeof shape === "string" && MARKER_SUPPORTED_SHAPES.includes(shape);
}
function getMarker(shape = Square) {
  if (isMarkerShape(shape)) {
    return MARKER_SHAPES[shape];
  }
  if (typeof shape === "function") {
    return shape;
  }
  return Square;
}
var MARKER_SHAPES, MARKER_SUPPORTED_SHAPES;
var init_util = __esm({
  "packages/ag-charts-community/src/chart/marker/util.ts"() {
    "use strict";
    init_circle();
    init_cross();
    init_diamond();
    init_heart();
    init_pin();
    init_plus();
    init_square();
    init_star();
    init_triangle();
    MARKER_SHAPES = {
      circle: Circle,
      cross: Cross,
      diamond: Diamond,
      heart: Heart,
      pin: Pin,
      plus: Plus,
      square: Square,
      star: Star,
      triangle: Triangle
    };
    MARKER_SUPPORTED_SHAPES = Object.keys(MARKER_SHAPES);
  }
});

// packages/ag-charts-community/src/chart/series/dataModelSeries.ts
var DataModelSeries;
var init_dataModelSeries = __esm({
  "packages/ag-charts-community/src/chart/series/dataModelSeries.ts"() {
    "use strict";
    init_continuousScale();
    init_logger();
    init_number();
    init_chartAxisDirection();
    init_series();
    DataModelSeries = class extends Series {
      constructor() {
        super(...arguments);
        this.showFocusBox = true;
      }
      getScaleInformation({
        xScale,
        yScale
      }) {
        const isContinuousX = ContinuousScale.is(xScale);
        const isContinuousY = ContinuousScale.is(yScale);
        return { isContinuousX, isContinuousY, xScaleType: xScale == null ? void 0 : xScale.type, yScaleType: yScale == null ? void 0 : yScale.type };
      }
      getModulePropertyDefinitions() {
        var _a2, _b;
        const xScale = (_a2 = this.axes["x" /* X */]) == null ? void 0 : _a2.scale;
        const yScale = (_b = this.axes["y" /* Y */]) == null ? void 0 : _b.scale;
        return this.moduleMap.mapModules((mod2) => mod2.getPropertyDefinitions(this.getScaleInformation({ xScale, yScale }))).flat();
      }
      // Request data, but with message dispatching to series-options (modules).
      requestDataModel(dataController, data, opts) {
        return __async(this, null, function* () {
          opts.props.push(...this.getModulePropertyDefinitions());
          const { dataModel, processedData } = yield dataController.request(this.id, data != null ? data : [], opts);
          this.dataModel = dataModel;
          this.processedData = processedData;
          this.dispatch("data-processed", { dataModel, processedData });
          return { dataModel, processedData };
        });
      }
      isProcessedDataAnimatable() {
        var _a2, _b;
        const validationResults = (_b = (_a2 = this.processedData) == null ? void 0 : _a2.reduced) == null ? void 0 : _b.animationValidation;
        if (!validationResults) {
          return true;
        }
        const { orderedKeys, uniqueKeys } = validationResults;
        return orderedKeys && uniqueKeys;
      }
      checkProcessedDataAnimatable() {
        if (!this.isProcessedDataAnimatable()) {
          this.ctx.animationManager.skipCurrentBatch();
        }
      }
      pickFocus(opts) {
        return this.doPickFocus(opts, this);
      }
      // The legend behaves differently for Pie and Donut series. We need to use a seriesItemEnabled
      // array to determine whether a datum has been toggled on/off using the legend.
      doPickFocus(opts, derivedSeries) {
        const nodeData = this.getNodeData();
        if (nodeData === void 0 || nodeData.length === 0) {
          return void 0;
        }
        const { datumIndexDelta, seriesRect } = opts;
        const datumIndex = this.computeFocusDatumIndex(opts, nodeData, derivedSeries.seriesItemEnabled);
        if (datumIndex === void 0) {
          return void 0;
        }
        const { showFocusBox } = this;
        const datum = nodeData[datumIndex];
        const bbox = this.computeFocusBounds({ datumIndex, datumIndexDelta, seriesRect });
        if (bbox !== void 0) {
          return { bbox, showFocusBox, datum, datumIndex };
        }
      }
      computeFocusDatumIndex(opts, nodeData, seriesItemEnabled) {
        if (seriesItemEnabled && nodeData.length !== seriesItemEnabled.length) {
          Logger.error(
            `invalid state: nodeData.length (${nodeData.length} !== seriesItemEnabled.length (${seriesItemEnabled == null ? void 0 : seriesItemEnabled.length})`
          );
        }
        const isDatumEnabled = (datumIndex2) => {
          const nodeDatum = nodeData[datumIndex2];
          return (nodeDatum.missing === void 0 || nodeDatum.missing === false) && (seriesItemEnabled === void 0 || seriesItemEnabled[datumIndex2]);
        };
        const searchBackward = (datumIndex2) => {
          while (datumIndex2 >= 0 && !isDatumEnabled(datumIndex2)) {
            datumIndex2--;
          }
          return datumIndex2 === -1 ? void 0 : datumIndex2;
        };
        const searchForward = (datumIndex2) => {
          while (datumIndex2 < nodeData.length && !isDatumEnabled(datumIndex2)) {
            datumIndex2++;
          }
          return datumIndex2 === nodeData.length ? void 0 : datumIndex2;
        };
        let datumIndex;
        const clampedIndex = clamp(0, opts.datumIndex, nodeData.length - 1);
        if (opts.datumIndexDelta < 0) {
          datumIndex = searchBackward(clampedIndex);
        } else if (opts.datumIndexDelta > 0) {
          datumIndex = searchForward(clampedIndex);
        } else {
          datumIndex != null ? datumIndex : datumIndex = searchForward(clampedIndex);
          datumIndex != null ? datumIndex : datumIndex = searchBackward(clampedIndex);
        }
        if (datumIndex === void 0) {
          if (opts.datumIndexDelta === 0) {
            return void 0;
          } else {
            return opts.datumIndex - opts.datumIndexDelta;
          }
        } else {
          return datumIndex;
        }
      }
    };
  }
});

// packages/ag-charts-community/src/chart/series/seriesProperties.ts
var SeriesItemHighlightStyle, SeriesHighlightStyle, TextHighlightStyle, HighlightStyle, SeriesProperties;
var init_seriesProperties = __esm({
  "packages/ag-charts-community/src/chart/series/seriesProperties.ts"() {
    "use strict";
    init_properties();
    init_validation();
    SeriesItemHighlightStyle = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.fill = "rgba(255,255,255, 0.33)";
        this.stroke = `rgba(0, 0, 0, 0.4)`;
        this.strokeWidth = 2;
      }
    };
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], SeriesItemHighlightStyle.prototype, "fill", 2);
    __decorateClass([
      Validate(RATIO, { optional: true })
    ], SeriesItemHighlightStyle.prototype, "fillOpacity", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], SeriesItemHighlightStyle.prototype, "stroke", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], SeriesItemHighlightStyle.prototype, "strokeWidth", 2);
    __decorateClass([
      Validate(RATIO, { optional: true })
    ], SeriesItemHighlightStyle.prototype, "strokeOpacity", 2);
    __decorateClass([
      Validate(LINE_DASH, { optional: true })
    ], SeriesItemHighlightStyle.prototype, "lineDash", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], SeriesItemHighlightStyle.prototype, "lineDashOffset", 2);
    SeriesHighlightStyle = class extends BaseProperties {
    };
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], SeriesHighlightStyle.prototype, "strokeWidth", 2);
    __decorateClass([
      Validate(RATIO, { optional: true })
    ], SeriesHighlightStyle.prototype, "dimOpacity", 2);
    __decorateClass([
      Validate(BOOLEAN, { optional: true })
    ], SeriesHighlightStyle.prototype, "enabled", 2);
    TextHighlightStyle = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.color = "black";
      }
    };
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], TextHighlightStyle.prototype, "color", 2);
    HighlightStyle = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.item = new SeriesItemHighlightStyle();
        this.series = new SeriesHighlightStyle();
        this.text = new TextHighlightStyle();
      }
    };
    __decorateClass([
      Validate(OBJECT)
    ], HighlightStyle.prototype, "item", 2);
    __decorateClass([
      Validate(OBJECT)
    ], HighlightStyle.prototype, "series", 2);
    __decorateClass([
      Validate(OBJECT)
    ], HighlightStyle.prototype, "text", 2);
    SeriesProperties = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.visible = true;
        this.showInLegend = true;
        this.cursor = "default";
        this.nodeClickRange = "exact";
        this.highlightStyle = new HighlightStyle();
      }
    };
    __decorateClass([
      Validate(STRING, { optional: true })
    ], SeriesProperties.prototype, "id", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], SeriesProperties.prototype, "visible", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], SeriesProperties.prototype, "showInLegend", 2);
    __decorateClass([
      Validate(STRING)
    ], SeriesProperties.prototype, "cursor", 2);
    __decorateClass([
      Validate(INTERACTION_RANGE)
    ], SeriesProperties.prototype, "nodeClickRange", 2);
    __decorateClass([
      Validate(OBJECT)
    ], SeriesProperties.prototype, "highlightStyle", 2);
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts
var DEFAULT_CARTESIAN_DIRECTION_KEYS, DEFAULT_CARTESIAN_DIRECTION_NAMES, CartesianSeriesNodeEvent, CartesianSeriesProperties, CartesianSeries;
var init_cartesianSeries = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts"() {
    "use strict";
    init_resetMotion();
    init_states();
    init_continuousScale();
    init_logScale();
    init_bbox();
    init_group();
    init_selection();
    init_path();
    init_text();
    init_quadtree();
    init_debug();
    init_type_guards();
    init_validation();
    init_categoryAxis();
    init_chartAxisDirection();
    init_layers();
    init_util();
    init_dataModelSeries();
    init_series();
    init_seriesProperties();
    DEFAULT_CARTESIAN_DIRECTION_KEYS = {
      ["x" /* X */]: ["xKey"],
      ["y" /* Y */]: ["yKey"]
    };
    DEFAULT_CARTESIAN_DIRECTION_NAMES = {
      ["x" /* X */]: ["xName"],
      ["y" /* Y */]: ["yName"]
    };
    CartesianSeriesNodeEvent = class extends SeriesNodeEvent {
      constructor(type, nativeEvent, datum, series) {
        super(type, nativeEvent, datum, series);
        this.xKey = series.properties.xKey;
        this.yKey = series.properties.yKey;
      }
    };
    CartesianSeriesProperties = class extends SeriesProperties {
    };
    __decorateClass([
      Validate(STRING, { optional: true })
    ], CartesianSeriesProperties.prototype, "legendItemName", 2);
    CartesianSeries = class extends DataModelSeries {
      constructor(_a2) {
        var _b = _a2, {
          pathsPerSeries = 1,
          hasMarkers = false,
          hasHighlightedLabels = false,
          pathsZIndexSubOrderOffset = [],
          datumSelectionGarbageCollection = true,
          markerSelectionGarbageCollection = true,
          animationAlwaysUpdateSelections = false,
          animationResetFns,
          directionKeys,
          directionNames
        } = _b, otherOpts = __objRest(_b, [
          "pathsPerSeries",
          "hasMarkers",
          "hasHighlightedLabels",
          "pathsZIndexSubOrderOffset",
          "datumSelectionGarbageCollection",
          "markerSelectionGarbageCollection",
          "animationAlwaysUpdateSelections",
          "animationResetFns",
          "directionKeys",
          "directionNames"
        ]);
        super(__spreadValues({
          directionKeys,
          directionNames,
          canHaveAxes: true
        }, otherOpts));
        this.NodeEvent = CartesianSeriesNodeEvent;
        this.dataNodeGroup = this.contentGroup.appendChild(
          new Group({
            name: `${this.id}-series-dataNodes`,
            zIndex: 4 /* SERIES_LAYER_ZINDEX */,
            zIndexSubOrder: this.getGroupZIndexSubOrder("data")
          })
        );
        this.markerGroup = this.contentGroup.appendChild(
          new Group({
            name: `${this.id}-series-markers`,
            zIndex: 4 /* SERIES_LAYER_ZINDEX */,
            zIndexSubOrder: this.getGroupZIndexSubOrder("marker")
          })
        );
        this.labelGroup = this.contentGroup.appendChild(
          new Group({
            name: `${this.id}-series-labels`,
            zIndex: 8 /* SERIES_LABEL_ZINDEX */,
            zIndexSubOrder: this.getGroupZIndexSubOrder("labels")
          })
        );
        this.labelSelection = Selection.select(this.labelGroup, Text);
        this.highlightSelection = Selection.select(
          this.highlightNode,
          () => this.opts.hasMarkers ? this.markerFactory() : this.nodeFactory()
        );
        this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);
        this.annotationSelections = /* @__PURE__ */ new Set();
        this.minRectsCache = {
          dirtyNodeData: true
        };
        this.debug = Debug.create();
        if (!directionKeys || !directionNames)
          throw new Error(`Unable to initialise series type ${this.type}`);
        this.opts = {
          pathsPerSeries,
          hasMarkers,
          hasHighlightedLabels,
          pathsZIndexSubOrderOffset,
          directionKeys,
          directionNames,
          animationResetFns,
          animationAlwaysUpdateSelections,
          datumSelectionGarbageCollection,
          markerSelectionGarbageCollection
        };
        this.paths = [];
        for (let index = 0; index < pathsPerSeries; index++) {
          this.paths[index] = new Path();
          this.paths[index].zIndex = 4 /* SERIES_LAYER_ZINDEX */;
          this.paths[index].zIndexSubOrder = this.getGroupZIndexSubOrder("paths", index);
          this.contentGroup.appendChild(this.paths[index]);
        }
        this.datumSelection = Selection.select(
          this.dataNodeGroup,
          () => this.nodeFactory(),
          datumSelectionGarbageCollection
        );
        this.markerSelection = Selection.select(
          this.markerGroup,
          () => this.markerFactory(),
          markerSelectionGarbageCollection
        );
        this.animationState = new StateMachine(
          "empty",
          {
            empty: {
              update: {
                target: "ready",
                action: (data) => this.animateEmptyUpdateReady(data)
              },
              reset: "empty",
              skip: "ready",
              disable: "disabled"
            },
            ready: {
              updateData: "waiting",
              clear: "clearing",
              highlight: (data) => this.animateReadyHighlight(data),
              highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),
              resize: (data) => this.animateReadyResize(data),
              reset: "empty",
              skip: "ready",
              disable: "disabled"
            },
            waiting: {
              update: {
                target: "ready",
                action: (data) => this.animateWaitingUpdateReady(data)
              },
              reset: "empty",
              skip: "ready",
              disable: "disabled"
            },
            disabled: {
              update: (data) => this.resetAllAnimation(data),
              reset: "empty"
            },
            clearing: {
              update: {
                target: "empty",
                action: (data) => this.animateClearingUpdateEmpty(data)
              },
              reset: "empty",
              skip: "ready"
            }
          },
          () => this.checkProcessedDataAnimatable()
        );
      }
      get contextNodeData() {
        return this._contextNodeData;
      }
      getNodeData() {
        var _a2;
        return (_a2 = this.contextNodeData) == null ? void 0 : _a2.nodeData;
      }
      resetAnimation(phase) {
        if (phase === "initial") {
          this.animationState.transition("reset");
        } else if (phase === "ready") {
          this.animationState.transition("skip");
        } else if (phase === "disabled") {
          this.animationState.transition("disable");
        }
      }
      addChartEventListeners() {
        this.destroyFns.push(
          this.ctx.chartEventManager.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
          this.ctx.chartEventManager.addListener(
            "legend-item-double-click",
            (event) => this.onLegendItemDoubleClick(event)
          )
        );
      }
      destroy() {
        super.destroy();
        this._contextNodeData = void 0;
      }
      update(_0) {
        return __async(this, arguments, function* ({ seriesRect }) {
          var _a2, _b;
          const { visible, _contextNodeData: previousContextData } = this;
          const series = (_b = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight()) == null ? void 0 : _b.series;
          const seriesHighlighted = series === this;
          const resize = this.checkResize(seriesRect);
          const highlightItems = yield this.updateHighlightSelection(seriesHighlighted);
          yield this.updateSelections(visible);
          yield this.updateNodes(highlightItems, seriesHighlighted, visible);
          const animationData = this.getAnimationData(seriesRect, previousContextData);
          if (!animationData)
            return;
          if (resize) {
            this.animationState.transition("resize", animationData);
          }
          this.animationState.transition("update", animationData);
        });
      }
      updateSelections(anySeriesItemEnabled) {
        return __async(this, null, function* () {
          var _a2, _b;
          const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();
          if (!anySeriesItemEnabled && animationSkipUpdate) {
            return;
          }
          if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {
            return;
          }
          if (this.nodeDataRefresh) {
            this.nodeDataRefresh = false;
            this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);
            this.markQuadtreeDirty();
            this._contextNodeData = yield this.createNodeData();
            const animationValid = this.isProcessedDataAnimatable();
            if (this._contextNodeData) {
              (_b = (_a2 = this._contextNodeData).animationValid) != null ? _b : _a2.animationValid = animationValid;
            }
            this.minRectsCache.dirtyNodeData = true;
            const { dataModel, processedData } = this;
            if (dataModel !== void 0 && processedData !== void 0) {
              this.dispatch("data-update", { dataModel, processedData });
            }
          }
          yield this.updateSeriesSelections();
        });
      }
      updateSeriesSelections(seriesHighlighted) {
        return __async(this, null, function* () {
          const { datumSelection, labelSelection, markerSelection, paths } = this;
          const contextData = this._contextNodeData;
          if (!contextData)
            return;
          const { nodeData, labelData, itemId } = contextData;
          yield this.updatePaths({ seriesHighlighted, itemId, contextData, paths });
          this.datumSelection = yield this.updateDatumSelection({ nodeData, datumSelection });
          this.labelSelection = yield this.updateLabelSelection({ labelData, labelSelection });
          if (this.opts.hasMarkers) {
            this.markerSelection = yield this.updateMarkerSelection({ nodeData, markerSelection });
          }
        });
      }
      markerFactory() {
        const MarkerShape = getMarker();
        return new MarkerShape();
      }
      getGroupZIndexSubOrder(type, subIndex = 0) {
        var _a2;
        const result = super.getGroupZIndexSubOrder(type, subIndex);
        if (type === "paths") {
          const [superFn] = result;
          const pathOffset = (_a2 = this.opts.pathsZIndexSubOrderOffset[subIndex]) != null ? _a2 : 0;
          result[0] = isFunction(superFn) ? () => Number(superFn()) + pathOffset : Number(superFn) + pathOffset;
        }
        return result;
      }
      updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {
        return __async(this, null, function* () {
          var _a2;
          const {
            highlightSelection,
            highlightLabelSelection,
            opts: { hasMarkers, hasHighlightedLabels }
          } = this;
          const animationEnabled = !this.ctx.animationManager.isSkipped();
          const visible = this.visible && this._contextNodeData != null && anySeriesItemEnabled;
          this.rootGroup.visible = animationEnabled || visible;
          this.contentGroup.visible = animationEnabled || visible;
          this.highlightGroup.visible = (animationEnabled || visible) && seriesHighlighted;
          const opacity = this.getOpacity();
          if (hasMarkers) {
            yield this.updateMarkerNodes({
              markerSelection: highlightSelection,
              isHighlight: true
            });
            this.animationState.transition("highlightMarkers", highlightSelection);
          } else {
            yield this.updateDatumNodes({
              datumSelection: highlightSelection,
              isHighlight: true
            });
            this.animationState.transition("highlight", highlightSelection);
          }
          if (hasHighlightedLabels) {
            yield this.updateLabelNodes({ labelSelection: highlightLabelSelection });
          }
          const { dataNodeGroup, markerGroup, datumSelection, labelSelection, markerSelection, paths, labelGroup } = this;
          const { itemId } = (_a2 = this.contextNodeData) != null ? _a2 : {};
          dataNodeGroup.opacity = opacity;
          dataNodeGroup.visible = animationEnabled || visible;
          labelGroup.visible = visible;
          if (hasMarkers) {
            markerGroup.opacity = opacity;
            markerGroup.zIndex = dataNodeGroup.zIndex >= 4 /* SERIES_LAYER_ZINDEX */ ? dataNodeGroup.zIndex : dataNodeGroup.zIndex + 1;
            markerGroup.visible = visible;
          }
          if (labelGroup) {
            labelGroup.opacity = opacity;
          }
          yield this.updatePathNodes({
            seriesHighlighted,
            itemId,
            paths,
            opacity,
            visible,
            animationEnabled
          });
          if (!dataNodeGroup.visible) {
            return;
          }
          yield this.updateDatumNodes({ datumSelection, highlightedItems, isHighlight: false });
          yield this.updateLabelNodes({ labelSelection });
          if (hasMarkers) {
            yield this.updateMarkerNodes({ markerSelection, isHighlight: false });
          }
        });
      }
      getHighlightLabelData(labelData, highlightedItem) {
        const labelItems = labelData.filter(
          (ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId
        );
        return labelItems.length === 0 ? void 0 : labelItems;
      }
      getHighlightData(_nodeData, highlightedItem) {
        return highlightedItem ? [highlightedItem] : void 0;
      }
      updateHighlightSelection(seriesHighlighted) {
        return __async(this, null, function* () {
          var _a2;
          const { highlightSelection, highlightLabelSelection, _contextNodeData: contextNodeData } = this;
          if (!contextNodeData)
            return;
          const highlightedDatum = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight();
          const item = seriesHighlighted && (highlightedDatum == null ? void 0 : highlightedDatum.datum) ? highlightedDatum : void 0;
          let labelItems;
          let highlightItems;
          if (item != null) {
            const labelsEnabled = this.isLabelEnabled();
            const { labelData, nodeData } = contextNodeData;
            highlightItems = this.getHighlightData(nodeData, item);
            labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : void 0;
          }
          this.highlightSelection = yield this.updateHighlightSelectionItem({
            items: highlightItems,
            highlightSelection
          });
          this.highlightLabelSelection = yield this.updateHighlightSelectionLabel({
            items: labelItems,
            highlightLabelSelection
          });
          return highlightItems;
        });
      }
      markQuadtreeDirty() {
        this.quadtree = void 0;
      }
      *datumNodesIter() {
        for (const { node } of this.datumSelection) {
          if (node.datum.missing === true)
            continue;
          yield node;
        }
      }
      getQuadTree() {
        if (this.quadtree === void 0) {
          const { width, height } = this.ctx.scene.canvas;
          const canvasRect = new BBox(0, 0, width, height);
          this.quadtree = new QuadtreeNearest(100, 10, canvasRect);
          this.initQuadTree(this.quadtree);
        }
        return this.quadtree;
      }
      initQuadTree(_quadtree) {
      }
      pickNodeExactShape(point) {
        var _a2;
        const result = super.pickNodeExactShape(point);
        if (result) {
          return result;
        }
        const { x, y } = point;
        const {
          opts: { hasMarkers }
        } = this;
        let match;
        const { dataNodeGroup, markerGroup } = this;
        match = dataNodeGroup.pickNode(x, y);
        if (!match && hasMarkers) {
          match = markerGroup == null ? void 0 : markerGroup.pickNode(x, y);
        }
        if (match && match.datum.missing !== true) {
          return { datum: match.datum, distance: 0 };
        }
        for (const mod2 of this.moduleMap.modules()) {
          const { datum } = (_a2 = mod2.pickNodeExact(point)) != null ? _a2 : {};
          if (datum == null)
            continue;
          if ((datum == null ? void 0 : datum.missing) === true)
            continue;
          return { datum, distance: 0 };
        }
      }
      pickNodeClosestDatum(point) {
        var _a2, _b;
        const { x, y } = point;
        const { axes, rootGroup, _contextNodeData: contextNodeData } = this;
        if (!contextNodeData)
          return;
        const xAxis = axes["x" /* X */];
        const yAxis = axes["y" /* Y */];
        const hitPoint = rootGroup.transformPoint(x, y);
        let minDistance = Infinity;
        let closestDatum;
        for (const datum of contextNodeData.nodeData) {
          const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;
          if (isNaN(datumX) || isNaN(datumY)) {
            continue;
          }
          const isInRange = (xAxis == null ? void 0 : xAxis.inRange(datumX)) && (yAxis == null ? void 0 : yAxis.inRange(datumY));
          if (!isInRange) {
            continue;
          }
          const distance2 = Math.max(__pow(hitPoint.x - datumX, 2) + __pow(hitPoint.y - datumY, 2), 0);
          if (distance2 < minDistance) {
            minDistance = distance2;
            closestDatum = datum;
          }
        }
        for (const mod2 of this.moduleMap.modules()) {
          const modPick = mod2.pickNodeNearest(point);
          if (modPick !== void 0 && modPick.distanceSquared < minDistance) {
            minDistance = modPick.distanceSquared;
            closestDatum = modPick.datum;
            break;
          }
        }
        if (closestDatum) {
          const distance2 = Math.max(Math.sqrt(minDistance) - ((_b = (_a2 = closestDatum.point) == null ? void 0 : _a2.size) != null ? _b : 0), 0);
          return { datum: closestDatum, distance: distance2 };
        }
      }
      pickNodeMainAxisFirst(point, requireCategoryAxis) {
        var _a2, _b, _c, _d;
        const { x, y } = point;
        const { axes, rootGroup, _contextNodeData: contextNodeData } = this;
        if (!contextNodeData)
          return;
        const xAxis = axes["x" /* X */];
        const yAxis = axes["y" /* Y */];
        const directions2 = [xAxis, yAxis].filter((a) => a instanceof CategoryAxis).map((a) => a.direction);
        if (requireCategoryAxis && directions2.length === 0) {
          return;
        }
        const [primaryDirection = "x" /* X */] = directions2;
        const hitPoint = rootGroup.transformPoint(x, y);
        const hitPointCoords = primaryDirection === "x" /* X */ ? [hitPoint.x, hitPoint.y] : [hitPoint.y, hitPoint.x];
        const minDistance = [Infinity, Infinity];
        let closestDatum;
        for (const datum of contextNodeData.nodeData) {
          const { x: datumX = NaN, y: datumY = NaN } = (_b = (_a2 = datum.point) != null ? _a2 : datum.midPoint) != null ? _b : {};
          if (isNaN(datumX) || isNaN(datumY) || datum.missing === true) {
            continue;
          }
          const isInRange = (xAxis == null ? void 0 : xAxis.inRange(datumX)) && (yAxis == null ? void 0 : yAxis.inRange(datumY));
          if (!isInRange) {
            continue;
          }
          const datumPoint = primaryDirection === "x" /* X */ ? [datumX, datumY] : [datumY, datumX];
          let newMinDistance = true;
          for (let i = 0; i < datumPoint.length; i++) {
            const dist = Math.abs(datumPoint[i] - hitPointCoords[i]);
            if (dist > minDistance[i]) {
              newMinDistance = false;
              break;
            }
            if (dist < minDistance[i]) {
              minDistance[i] = dist;
              minDistance.fill(Infinity, i + 1, minDistance.length);
            }
          }
          if (newMinDistance) {
            closestDatum = datum;
          }
        }
        if (closestDatum) {
          let closestDistanceSquared = Math.max(
            __pow(minDistance[0], 2) + __pow(minDistance[1], 2) - ((_d = (_c = closestDatum.point) == null ? void 0 : _c.size) != null ? _d : 0),
            0
          );
          for (const mod2 of this.moduleMap.modules()) {
            const modPick = mod2.pickNodeMainAxisFirst(point);
            if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {
              closestDatum = modPick.datum;
              closestDistanceSquared = modPick.distanceSquared;
              break;
            }
          }
          return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };
        }
      }
      onLegendItemClick(event) {
        const { legendItemName } = this.properties;
        const { enabled, itemId, series } = event;
        const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
        if (series.id === this.id || matchedLegendItemName) {
          this.toggleSeriesItem(itemId, enabled);
        }
      }
      onLegendItemDoubleClick(event) {
        const { enabled, itemId, series, numVisibleItems } = event;
        const { legendItemName } = this.properties;
        const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
        if (series.id === this.id || matchedLegendItemName) {
          this.toggleSeriesItem(itemId, true);
        } else if (enabled && numVisibleItems === 1) {
          this.toggleSeriesItem(itemId, true);
        } else {
          this.toggleSeriesItem(itemId, false);
        }
      }
      isPathOrSelectionDirty() {
        return false;
      }
      getLabelData() {
        return [];
      }
      shouldFlipXY() {
        return false;
      }
      /**
       * Get the minimum bounding box that contains any adjacent two nodes. The axes are treated independently, so this
       * may not represent the same two points for both directions. The dimensions represent the greatest distance
       * between any two adjacent nodes.
       */
      getMinRects(width, height) {
        const { dirtyNodeData, sizeCache, minRect, minVisibleRect } = this.minRectsCache;
        const newSizeCache = JSON.stringify({ width, height });
        const dirtySize = newSizeCache !== sizeCache;
        if (!dirtySize && !dirtyNodeData && minRect && minVisibleRect) {
          return { minRect, minVisibleRect };
        }
        const rects = this.computeMinRects(width, height);
        this.minRectsCache = {
          dirtyNodeData: false,
          sizeCache: newSizeCache,
          minRect: rects == null ? void 0 : rects.minRect,
          minVisibleRect: rects == null ? void 0 : rects.minVisibleRect
        };
        return rects;
      }
      computeMinRects(width, height) {
        var _a2, _b;
        const context = this._contextNodeData;
        if (!(context == null ? void 0 : context.nodeData.length)) {
          return;
        }
        const { nodeData } = context;
        const minRectXs = Array(nodeData.length);
        const minRectYs = Array(nodeData.length);
        for (const [i, { midPoint }] of nodeData.entries()) {
          minRectXs[i] = (_a2 = midPoint == null ? void 0 : midPoint.x) != null ? _a2 : 0;
          minRectYs[i] = (_b = midPoint == null ? void 0 : midPoint.y) != null ? _b : 0;
        }
        minRectXs.sort((a, b) => a - b);
        minRectYs.sort((a, b) => a - b);
        let zeroX, widthX, zeroY, heightY;
        let maxWidth = 0;
        let maxHeight = 0;
        for (let i = 1; i < nodeData.length; i++) {
          if (minRectXs[i] >= 0)
            zeroX != null ? zeroX : zeroX = i;
          if (minRectXs[i] > width)
            widthX != null ? widthX : widthX = i;
          if (minRectYs[i] >= 0)
            zeroY != null ? zeroY : zeroY = i;
          if (minRectYs[i] > height)
            heightY != null ? heightY : heightY = i;
          maxWidth = Math.max(maxWidth, minRectXs[i] - minRectXs[i - 1]);
          maxHeight = Math.max(maxHeight, minRectYs[i] - minRectYs[i - 1]);
        }
        widthX != null ? widthX : widthX = nodeData.length;
        heightY != null ? heightY : heightY = nodeData.length;
        const minVisibleRectXs = zeroX != null && widthX != null ? minRectXs.slice(zeroX, widthX) : [];
        const minVisibleRectYs = zeroY != null && heightY != null ? minRectYs.slice(zeroY, heightY) : [];
        let maxVisibleWidth = 0;
        let maxVisibleHeight = 0;
        for (let i = 1; i < Math.max(minVisibleRectXs.length, minVisibleRectYs.length); i++) {
          const x1 = minVisibleRectXs[i];
          const x2 = minVisibleRectXs[i - 1];
          const y1 = minVisibleRectYs[i];
          const y2 = minVisibleRectYs[i - 1];
          if (x1 != null && x2 != null) {
            maxVisibleWidth = Math.max(maxVisibleWidth, x1 - x2);
          }
          if (y1 != null && y2 != null) {
            maxVisibleHeight = Math.max(maxVisibleHeight, y1 - y2);
          }
        }
        const minRect = new BBox(0, 0, maxWidth, maxHeight);
        const minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);
        return { minRect, minVisibleRect };
      }
      updateHighlightSelectionItem(opts) {
        const {
          opts: { hasMarkers }
        } = this;
        const { items, highlightSelection } = opts;
        const nodeData = items != null ? items : [];
        if (hasMarkers) {
          const markerSelection = highlightSelection;
          return this.updateMarkerSelection({ nodeData, markerSelection });
        } else {
          return this.updateDatumSelection({
            nodeData,
            datumSelection: highlightSelection
          });
        }
      }
      updateHighlightSelectionLabel(opts) {
        var _a2;
        return this.updateLabelSelection({
          labelData: (_a2 = opts.items) != null ? _a2 : [],
          labelSelection: opts.highlightLabelSelection
        });
      }
      updateDatumSelection(opts) {
        return __async(this, null, function* () {
          return opts.datumSelection;
        });
      }
      updateDatumNodes(_opts) {
        return __async(this, null, function* () {
        });
      }
      updateMarkerSelection(opts) {
        return __async(this, null, function* () {
          return opts.markerSelection;
        });
      }
      updateMarkerNodes(_opts) {
        return __async(this, null, function* () {
        });
      }
      updatePaths(opts) {
        return __async(this, null, function* () {
          opts.paths.forEach((p) => p.visible = false);
        });
      }
      updatePathNodes(opts) {
        return __async(this, null, function* () {
          const { paths, opacity, visible } = opts;
          for (const path of paths) {
            path.opacity = opacity;
            path.visible = visible;
          }
        });
      }
      resetAllAnimation(data) {
        var _a2, _b, _c;
        const { path, datum, label, marker } = (_b = (_a2 = this.opts) == null ? void 0 : _a2.animationResetFns) != null ? _b : {};
        this.ctx.animationManager.stopByAnimationGroupId(this.id);
        if (path) {
          data.paths.forEach((paths) => {
            resetMotion([paths], path);
          });
        }
        if (datum) {
          resetMotion([data.datumSelection], datum);
        }
        if (label) {
          resetMotion([data.labelSelection], label);
        }
        if (marker && this.opts.hasMarkers) {
          resetMotion([data.markerSelection], marker);
        }
        if (((_c = data.contextData) == null ? void 0 : _c.animationValid) === false) {
          this.ctx.animationManager.skipCurrentBatch();
        }
      }
      animateEmptyUpdateReady(data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation(data);
      }
      animateWaitingUpdateReady(data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation(data);
      }
      animateReadyHighlight(data) {
        var _a2, _b;
        const { datum } = (_b = (_a2 = this.opts) == null ? void 0 : _a2.animationResetFns) != null ? _b : {};
        if (datum) {
          resetMotion([data], datum);
        }
      }
      animateReadyHighlightMarkers(data) {
        var _a2, _b;
        const { marker } = (_b = (_a2 = this.opts) == null ? void 0 : _a2.animationResetFns) != null ? _b : {};
        if (marker) {
          resetMotion([data], marker);
        }
      }
      animateReadyResize(data) {
        this.resetAllAnimation(data);
      }
      animateClearingUpdateEmpty(data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation(data);
      }
      animationTransitionClear() {
        const animationData = this.getAnimationData();
        if (!animationData)
          return;
        this.animationState.transition("clear", animationData);
      }
      getAnimationData(seriesRect, previousContextData) {
        const { _contextNodeData: contextData } = this;
        if (!contextData)
          return;
        const animationData = {
          datumSelection: this.datumSelection,
          markerSelection: this.markerSelection,
          labelSelection: this.labelSelection,
          annotationSelections: [...this.annotationSelections],
          contextData,
          previousContextData,
          paths: this.paths,
          seriesRect
        };
        return animationData;
      }
      calculateScaling() {
        const result = {};
        for (const direction of Object.values(ChartAxisDirection)) {
          const axis = this.axes[direction];
          if (!axis)
            continue;
          if (axis.scale instanceof LogScale) {
            const { range: range4, domain } = axis.scale;
            result[direction] = {
              type: "log",
              convert: (d) => axis.scale.convert(d),
              domain: [domain[0], domain[1]],
              range: [range4[0], range4[1]]
            };
          } else if (axis.scale instanceof ContinuousScale) {
            const { range: range4 } = axis.scale;
            const domain = axis.scale.getDomain();
            result[direction] = {
              type: "continuous",
              domain: [domain[0], domain[1]],
              range: [range4[0], range4[1]]
            };
          } else if (axis.scale) {
            const { domain } = axis.scale;
            result[direction] = {
              type: "category",
              domain,
              range: domain.map((d) => axis.scale.convert(d))
            };
          }
        }
        return result;
      }
    };
  }
});

// packages/ag-charts-community/src/chart/cartesianChart.ts
var directions, _CartesianChart, CartesianChart;
var init_cartesianChart = __esm({
  "packages/ag-charts-community/src/chart/cartesianChart.ts"() {
    "use strict";
    init_fromToMotion();
    init_angle();
    init_logger();
    init_object();
    init_categoryAxis();
    init_groupedCategoryAxis();
    init_chart();
    init_chartAxisDirection();
    init_cartesianSeries();
    directions = ["top", "right", "bottom", "left"];
    _CartesianChart = class _CartesianChart extends Chart {
      constructor(options, resources) {
        super(options, resources);
        /** Integrated Charts feature state - not used in Standalone Charts. */
        this.paired = true;
        this.firstSeriesTranslation = true;
        this._lastCrossLineIds = void 0;
        this._lastAxisWidths = {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0
        };
        this._lastClipSeries = false;
        this._lastVisibility = {
          crossLines: true,
          series: true
        };
      }
      onAxisChange(newValue, oldValue) {
        super.onAxisChange(newValue, oldValue);
        this.zoomManager.updateAxes(newValue);
      }
      destroySeries(series) {
        super.destroySeries(series);
        this.firstSeriesTranslation = true;
      }
      performLayout() {
        return __async(this, null, function* () {
          const shrinkRect = yield __superGet(_CartesianChart.prototype, this, "performLayout").call(this);
          const { firstSeriesTranslation, seriesRoot, annotationRoot, highlightRoot } = this;
          const { animationRect, seriesRect, visibility, clipSeries } = this.updateAxes(shrinkRect);
          this.seriesRoot.visible = visibility.series;
          this.seriesRect = seriesRect;
          this.animationRect = animationRect;
          const { x, y } = seriesRect;
          if (firstSeriesTranslation) {
            for (const group2 of [seriesRoot, annotationRoot, highlightRoot]) {
              group2.translationX = Math.floor(x);
              group2.translationY = Math.floor(y);
            }
            this.firstSeriesTranslation = false;
          } else {
            const { translationX, translationY } = seriesRoot;
            staticFromToMotion(
              this.id,
              "seriesRect",
              this.ctx.animationManager,
              [seriesRoot, highlightRoot, annotationRoot],
              { translationX, translationY },
              { translationX: Math.floor(x), translationY: Math.floor(y) },
              { phase: "update" }
            );
          }
          const seriesPaddedRect = seriesRect.clone().grow(this.seriesArea.padding);
          this.hoverRect = seriesPaddedRect;
          const clipRect = this.seriesArea.clip || clipSeries ? seriesPaddedRect : void 0;
          seriesRoot.setClipRectInGroupCoordinateSpace(clipRect);
          highlightRoot.setClipRectInGroupCoordinateSpace(clipRect);
          annotationRoot.setClipRectInGroupCoordinateSpace(clipRect);
          this.ctx.layoutService.dispatchLayoutComplete({
            type: "layout-complete",
            chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },
            clipSeries,
            series: {
              rect: seriesRect,
              paddedRect: seriesPaddedRect,
              visible: visibility.series,
              shouldFlipXY: this.shouldFlipXY()
            },
            axes: this.axes.map((axis) => __spreadValues({ id: axis.id }, axis.getLayoutState()))
          });
          const modulePromises = this.modulesManager.mapModules((m) => {
            var _a2;
            return (_a2 = m.performCartesianLayout) == null ? void 0 : _a2.call(m, { seriesRect });
          });
          yield Promise.all(modulePromises);
          return shrinkRect;
        });
      }
      updateAxes(inputShrinkRect) {
        var _a2;
        const crossLineIds = this.axes.flatMap((axis) => {
          var _a3;
          return (_a3 = axis.crossLines) != null ? _a3 : [];
        }).map((crossLine) => crossLine.id);
        const axesValid = this._lastCrossLineIds != null && this._lastCrossLineIds.length === crossLineIds.length && this._lastCrossLineIds.every((id, index) => crossLineIds[index] === id);
        let axisWidths;
        let clipSeries;
        let visibility;
        if (axesValid) {
          axisWidths = __spreadValues({}, this._lastAxisWidths);
          clipSeries = this._lastClipSeries;
          visibility = __spreadValues({}, this._lastVisibility);
        } else {
          axisWidths = { top: 0, bottom: 0, left: 0, right: 0 };
          clipSeries = false;
          visibility = { crossLines: true, series: true };
          this._lastCrossLineIds = crossLineIds;
        }
        const liveAxisWidths = new Set(this.axes.map((a) => a.position));
        for (const position of Object.keys(axisWidths)) {
          if (!liveAxisWidths.has(position)) {
            delete axisWidths[position];
          }
        }
        const stableOutputs = (otherAxisWidths, otherClipSeries, otherVisibility) => {
          if (Object.keys(otherAxisWidths).some((k) => axisWidths[k] == null)) {
            return false;
          }
          return visibility.crossLines === otherVisibility.crossLines && visibility.series === otherVisibility.series && // Check for existing axis positions and equality.
          Object.entries(axisWidths).every(([p, w]) => {
            const otherW = otherAxisWidths[p];
            if (w != null || otherW != null) {
              return w === otherW;
            }
            return true;
          }) && clipSeries === otherClipSeries;
        };
        const ceilValues = (records) => mapValues(records, (value) => {
          if (value && Math.abs(value) === Infinity) {
            return 0;
          }
          return value != null ? Math.ceil(value) : value;
        });
        let lastPassAxisWidths = {};
        let lastPassVisibility = {};
        let lastPassClipSeries = false;
        let seriesRect = (_a2 = this.seriesRect) == null ? void 0 : _a2.clone();
        let count = 0;
        let primaryTickCounts = {};
        do {
          Object.assign(axisWidths, lastPassAxisWidths);
          clipSeries = lastPassClipSeries;
          Object.assign(visibility, lastPassVisibility);
          const result = this.updateAxesPass(axisWidths, inputShrinkRect.clone(), seriesRect);
          lastPassAxisWidths = ceilValues(result.axisWidths);
          lastPassVisibility = result.visibility;
          lastPassClipSeries = result.clipSeries;
          seriesRect = result.seriesRect;
          primaryTickCounts = result.primaryTickCounts;
          if (count++ > 10) {
            Logger.warn("unable to find stable axis layout.");
            break;
          }
        } while (!stableOutputs(lastPassAxisWidths, lastPassClipSeries, lastPassVisibility));
        this.axes.forEach((axis) => {
          axis.update(primaryTickCounts[axis.direction]);
        });
        const clipRectPadding = 5;
        this.axes.forEach((axis) => {
          axis.setCrossLinesVisible(visibility.crossLines);
          if (!seriesRect) {
            return;
          }
          axis.clipGrid(
            seriesRect.x,
            seriesRect.y,
            seriesRect.width + clipRectPadding,
            seriesRect.height + clipRectPadding
          );
          switch (axis.position) {
            case "left":
            case "right":
              axis.clipTickLines(
                inputShrinkRect.x,
                seriesRect.y,
                inputShrinkRect.width + clipRectPadding,
                seriesRect.height + clipRectPadding
              );
              break;
            case "top":
            case "bottom":
              axis.clipTickLines(
                seriesRect.x,
                inputShrinkRect.y,
                seriesRect.width + clipRectPadding,
                inputShrinkRect.height + clipRectPadding
              );
              break;
          }
        });
        this._lastAxisWidths = axisWidths;
        this._lastVisibility = visibility;
        return { seriesRect, animationRect: inputShrinkRect, visibility, clipSeries };
      }
      updateAxesPass(axisWidths, bounds, lastPassSeriesRect) {
        const visited = {};
        const newAxisWidths = {};
        const visibility = {
          series: true,
          crossLines: true
        };
        let clipSeries = false;
        const primaryTickCounts = {};
        const paddedBounds = this.applySeriesPadding(bounds);
        const crossLinePadding = lastPassSeriesRect ? this.buildCrossLinePadding(axisWidths) : {};
        const axisBound = this.buildAxisBound(paddedBounds, axisWidths, crossLinePadding, visibility);
        const seriesRect = this.buildSeriesRect(axisBound, axisWidths);
        this.axes.forEach((axis) => {
          var _a2, _b;
          const { position = "left" } = axis;
          const {
            clipSeries: newClipSeries,
            axisThickness,
            axisOffset
          } = this.calculateAxisDimensions({
            axis,
            seriesRect,
            paddedBounds,
            axisWidths,
            newAxisWidths,
            primaryTickCounts,
            clipSeries,
            addInterAxisPadding: ((_a2 = visited[position]) != null ? _a2 : 0) > 0
          });
          visited[position] = ((_b = visited[position]) != null ? _b : 0) + 1;
          clipSeries = clipSeries || newClipSeries;
          this.positionAxis({
            axis,
            axisBound,
            axisOffset,
            axisThickness,
            axisWidths,
            primaryTickCounts,
            seriesRect
          });
        });
        return { clipSeries, seriesRect, axisWidths: newAxisWidths, visibility, primaryTickCounts };
      }
      buildCrossLinePadding(axisWidths) {
        var _a2;
        const crossLinePadding = {};
        this.axes.forEach((axis) => {
          if (axis.crossLines) {
            axis.crossLines.forEach((crossLine) => {
              var _a3;
              (_a3 = crossLine.calculatePadding) == null ? void 0 : _a3.call(crossLine, crossLinePadding);
            });
          }
        });
        for (const [side, padding = 0] of Object.entries(crossLinePadding)) {
          crossLinePadding[side] = Math.max(padding - ((_a2 = axisWidths[side]) != null ? _a2 : 0), 0);
        }
        return crossLinePadding;
      }
      applySeriesPadding(bounds) {
        const paddedRect = bounds.clone();
        const reversedAxes = this.axes.slice().reverse();
        directions.forEach((dir) => {
          const padding = this.seriesArea.padding[dir];
          const axis = reversedAxes.find((a) => a.position === dir);
          if (axis) {
            axis.seriesAreaPadding = padding;
          } else {
            paddedRect.shrink(padding, dir);
          }
        });
        return paddedRect;
      }
      buildAxisBound(bounds, axisWidths, crossLinePadding, visibility) {
        var _a2, _b, _c, _d;
        const result = bounds.clone();
        const { top = 0, right = 0, bottom = 0, left = 0 } = crossLinePadding;
        const horizontalPadding = left + right;
        const verticalPadding = top + bottom;
        const totalWidth = ((_a2 = axisWidths.left) != null ? _a2 : 0) + ((_b = axisWidths.right) != null ? _b : 0) + horizontalPadding;
        const totalHeight = ((_c = axisWidths.top) != null ? _c : 0) + ((_d = axisWidths.bottom) != null ? _d : 0) + verticalPadding;
        if (result.width <= totalWidth || result.height <= totalHeight) {
          visibility.crossLines = false;
          visibility.series = false;
          return result;
        }
        result.x += left;
        result.y += top;
        result.width -= horizontalPadding;
        result.height -= verticalPadding;
        return result;
      }
      buildSeriesRect(axisBound, axisWidths) {
        const result = axisBound.clone();
        const { top, bottom, left, right } = axisWidths;
        result.x += left != null ? left : 0;
        result.y += top != null ? top : 0;
        result.width -= (left != null ? left : 0) + (right != null ? right : 0);
        result.height -= (top != null ? top : 0) + (bottom != null ? bottom : 0);
        result.width = Math.max(0, result.width);
        result.height = Math.max(0, result.height);
        return result;
      }
      clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {
        const { x, y, width, height } = seriesRect;
        const clampBounds = [x, y, x + width, y + height];
        const compareTo = clampBounds[(dimension === "x" ? 0 : 1) + (direction === 1 ? 0 : 2)];
        const clampFn = direction === 1 ? Math.min : Math.max;
        return clampFn(value, compareTo);
      }
      calculateAxisDimensions(opts) {
        var _a2, _b, _c, _d;
        const { axis, seriesRect, paddedBounds, axisWidths, newAxisWidths, primaryTickCounts, addInterAxisPadding } = opts;
        let { clipSeries } = opts;
        const { position = "left", direction } = axis;
        const isCategory = axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis;
        const isLeftRight = position === "left" || position === "right";
        const axisOffset = (_a2 = newAxisWidths[position]) != null ? _a2 : 0;
        const { min, max } = this.ctx.zoomManager.getAxisZoom(axis.id);
        if (isLeftRight) {
          if (isCategory) {
            axis.range = [0, seriesRect.height];
            axis.visibleRange = [1 - max, 1 - min];
          } else {
            axis.range = [seriesRect.height, 0];
            axis.visibleRange = [min, max];
          }
          axis.gridLength = seriesRect.width;
        } else {
          axis.range = [0, seriesRect.width];
          axis.visibleRange = [min, max];
          axis.gridLength = seriesRect.height;
        }
        let primaryTickCount = axis.nice ? primaryTickCounts[direction] : void 0;
        const isVertical = direction === "y" /* Y */;
        const paddedBoundsCoefficient = 0.3;
        if (axis.thickness) {
          axis.maxThickness = axis.thickness;
        } else {
          axis.maxThickness = (isVertical ? paddedBounds.width : paddedBounds.height) * paddedBoundsCoefficient;
        }
        const layout = axis.calculateLayout(primaryTickCount);
        primaryTickCount = layout.primaryTickCount;
        (_b = primaryTickCounts[direction]) != null ? _b : primaryTickCounts[direction] = primaryTickCount;
        clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);
        let axisThickness;
        if (axis.thickness != null && axis.thickness > 0) {
          axisThickness = axis.thickness;
        } else {
          const { bbox } = layout;
          axisThickness = isVertical ? bbox.width : bbox.height;
        }
        const axisPadding = 15;
        if (addInterAxisPadding) {
          axisThickness += axisPadding;
        }
        axisThickness = Math.ceil(axisThickness);
        newAxisWidths[position] = ((_c = newAxisWidths[position]) != null ? _c : 0) + axisThickness;
        axis.gridPadding = ((_d = axisWidths[position]) != null ? _d : 0) - newAxisWidths[position];
        return { clipSeries, axisThickness, axisOffset, primaryTickCount };
      }
      positionAxis(opts) {
        var _a2, _b, _c, _d;
        const { axis, axisBound, axisWidths, seriesRect, axisOffset, axisThickness } = opts;
        const { position } = axis;
        switch (position) {
          case "top":
            axis.translation.x = axisBound.x + ((_a2 = axisWidths.left) != null ? _a2 : 0);
            axis.translation.y = this.clampToOutsideSeriesRect(
              seriesRect,
              axisBound.y + 1 + axisOffset + axisThickness,
              "y",
              1
            );
            break;
          case "bottom":
            axis.translation.x = axisBound.x + ((_b = axisWidths.left) != null ? _b : 0);
            axis.translation.y = this.clampToOutsideSeriesRect(
              seriesRect,
              axisBound.y + axisBound.height + 1 - axisThickness - axisOffset,
              "y",
              -1
            );
            break;
          case "left":
            axis.translation.y = axisBound.y + ((_c = axisWidths.top) != null ? _c : 0);
            axis.translation.x = this.clampToOutsideSeriesRect(
              seriesRect,
              axisBound.x + axisOffset + axisThickness,
              "x",
              1
            );
            break;
          case "right":
            axis.translation.y = axisBound.y + ((_d = axisWidths.top) != null ? _d : 0);
            axis.translation.x = this.clampToOutsideSeriesRect(
              seriesRect,
              axisBound.x + axisBound.width - axisThickness - axisOffset,
              "x",
              -1
            );
            break;
        }
        axis.updatePosition({ rotation: toRadians(axis.rotation), sideFlag: axis.label.getSideFlag() });
      }
      shouldFlipXY() {
        return !this.series.some((series) => !(series instanceof CartesianSeries && series.shouldFlipXY()));
      }
    };
    _CartesianChart.className = "CartesianChart";
    _CartesianChart.type = "cartesian";
    CartesianChart = _CartesianChart;
  }
});

// packages/ag-charts-community/src/chart/chartProxy.ts
var _AgChartInstanceProxy, AgChartInstanceProxy;
var init_chartProxy = __esm({
  "packages/ag-charts-community/src/chart/chartProxy.ts"() {
    "use strict";
    init_json();
    init_proxy();
    _AgChartInstanceProxy = class _AgChartInstanceProxy {
      static isInstance(x) {
        var _a2;
        if (x instanceof _AgChartInstanceProxy) {
          return true;
        }
        if (((_a2 = x.constructor) == null ? void 0 : _a2.name) === "AgChartInstanceProxy" && x.chart != null) {
          return true;
        }
        return x.chart != null && this.validateImplementation(x);
      }
      static validateImplementation(x) {
        var _a2;
        const chartProps = ["getOptions", "destroy"];
        const signatureProps = Object.keys((_a2 = Object.getPrototypeOf(x)) != null ? _a2 : {});
        return chartProps.every((prop) => signatureProps.includes(prop));
      }
      constructor(chart) {
        this.chart = chart;
      }
      getOptions() {
        return deepClone(this.chart.getOptions());
      }
      resetAnimations() {
        this.chart.resetAnimations();
      }
      skipAnimations() {
        this.chart.skipAnimations();
      }
      destroy() {
        this.chart.destroy();
      }
    };
    _AgChartInstanceProxy.chartInstances = /* @__PURE__ */ new WeakMap();
    __decorateClass([
      ActionOnSet({
        oldValue(chart) {
          _AgChartInstanceProxy.chartInstances.delete(chart);
        },
        newValue(chart) {
          _AgChartInstanceProxy.chartInstances.set(chart, this);
        }
      })
    ], _AgChartInstanceProxy.prototype, "chart", 2);
    AgChartInstanceProxy = _AgChartInstanceProxy;
  }
});

// packages/ag-charts-community/src/scale/linearScale.ts
var LinearScale;
var init_linearScale = __esm({
  "packages/ag-charts-community/src/scale/linearScale.ts"() {
    "use strict";
    init_numberFormat();
    init_ticks();
    init_continuousScale();
    LinearScale = class extends ContinuousScale {
      constructor() {
        super([0, 1], [0, 1]);
        this.type = "number";
      }
      toDomain(d) {
        return d;
      }
      ticks() {
        var _a2;
        const count = (_a2 = this.tickCount) != null ? _a2 : ContinuousScale.defaultTickCount;
        if (!this.domain || this.domain.length < 2 || count < 1 || this.domain.some((d) => !isFinite(d))) {
          return [];
        }
        this.refresh();
        const [d0, d1] = this.getDomain();
        const { interval } = this;
        if (interval) {
          const step = Math.abs(interval);
          const availableRange = this.getPixelRange();
          if (!isDenseInterval({ start: d0, stop: d1, interval: step, availableRange })) {
            return range(d0, d1, step);
          }
        }
        return ticks_default(d0, d1, count, this.minTickCount, this.maxTickCount);
      }
      update() {
        if (!this.domain || this.domain.length < 2) {
          return;
        }
        if (this.nice) {
          this.updateNiceDomain();
        }
      }
      getTickStep(start, stop) {
        var _a2, _b;
        const count = (_a2 = this.tickCount) != null ? _a2 : ContinuousScale.defaultTickCount;
        return (_b = this.interval) != null ? _b : tickStep(start, stop, count, this.minTickCount, this.maxTickCount);
      }
      /**
       * Extends the domain so that it starts and ends on nice round values.
       */
      updateNiceDomain() {
        var _a2;
        const count = (_a2 = this.tickCount) != null ? _a2 : ContinuousScale.defaultTickCount;
        if (count < 1) {
          this.niceDomain = [...this.domain];
          return;
        }
        let [start, stop] = this.domain;
        if (count === 1) {
          [start, stop] = singleTickDomain(start, stop);
        } else {
          const roundStart = start > stop ? Math.ceil : Math.floor;
          const roundStop = stop < start ? Math.floor : Math.ceil;
          const maxAttempts = 4;
          for (let i = 0; i < maxAttempts; i++) {
            const prev0 = start;
            const prev1 = stop;
            const step = this.getTickStep(start, stop);
            const [d0, d1] = this.domain;
            if (step >= 1) {
              start = roundStart(d0 / step) * step;
              stop = roundStop(d1 / step) * step;
            } else {
              const s = 1 / step;
              start = roundStart(d0 * s) / s;
              stop = roundStop(d1 * s) / s;
            }
            if (start === prev0 && stop === prev1) {
              break;
            }
          }
        }
        this.niceDomain = [start, stop];
      }
      tickFormat({ ticks: specifiedTicks, specifier }) {
        return tickFormat(specifiedTicks != null ? specifiedTicks : this.ticks(), specifier);
      }
    };
  }
});

// packages/ag-charts-community/src/util/secondaryAxisTicks.ts
function calculateNiceSecondaryAxis(domain, primaryTickCount, reverse) {
  let [start, stop] = findMinMax(domain);
  start = calculateNiceStart(Math.floor(start), stop, primaryTickCount);
  const step = getTickStep(start, stop, primaryTickCount);
  const segments = primaryTickCount - 1;
  stop = start + segments * step;
  const d = reverse ? [stop, start] : [start, stop];
  const ticks = getTicks(start, step, primaryTickCount);
  return [d, ticks];
}
function calculateNiceStart(a, b, count) {
  const rawStep = Math.abs(b - a) / (count - 1);
  const order = Math.floor(Math.log10(rawStep));
  const magnitude2 = Math.pow(10, order);
  return Math.floor(a / magnitude2) * magnitude2;
}
function getTicks(start, step, count) {
  const stepPower = Math.floor(Math.log10(step));
  const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;
  const f = Math.pow(10, fractionDigits);
  const ticks = createNumericTicks(fractionDigits);
  for (let i = 0; i < count; i++) {
    const tick = start + step * i;
    ticks[i] = Math.round(tick * f) / f;
  }
  return ticks;
}
function getTickStep(start, stop, count) {
  const segments = count - 1;
  const rawStep = (stop - start) / segments;
  return calculateNextNiceStep(rawStep);
}
function calculateNextNiceStep(rawStep) {
  const order = Math.floor(Math.log10(rawStep));
  const magnitude2 = Math.pow(10, order);
  const step = rawStep / magnitude2 * 10;
  if (step > 0 && step <= 1) {
    return magnitude2 / 10;
  }
  if (step > 1 && step <= 2) {
    return 2 * magnitude2 / 10;
  }
  if (step > 1 && step <= 5) {
    return 5 * magnitude2 / 10;
  }
  if (step > 5 && step <= 10) {
    return 10 * magnitude2 / 10;
  }
  if (step > 10 && step <= 20) {
    return 20 * magnitude2 / 10;
  }
  if (step > 20 && step <= 40) {
    return 40 * magnitude2 / 10;
  }
  if (step > 40 && step <= 50) {
    return 50 * magnitude2 / 10;
  }
  if (step > 50 && step <= 100) {
    return 100 * magnitude2 / 10;
  }
  return step;
}
var init_secondaryAxisTicks = __esm({
  "packages/ag-charts-community/src/util/secondaryAxisTicks.ts"() {
    "use strict";
    init_number();
    init_ticks();
  }
});

// packages/ag-charts-community/src/chart/axis/numberAxis.ts
var NumberAxisTick, NumberAxis;
var init_numberAxis = __esm({
  "packages/ag-charts-community/src/chart/axis/numberAxis.ts"() {
    "use strict";
    init_linearScale();
    init_array();
    init_default();
    init_secondaryAxisTicks();
    init_validation();
    init_axisTick();
    init_cartesianAxis();
    NumberAxisTick = class extends AxisTick {
      constructor() {
        super(...arguments);
        this.minSpacing = NaN;
        this.maxSpacing = NaN;
      }
    };
    __decorateClass([
      Validate(MIN_SPACING),
      Default(NaN)
    ], NumberAxisTick.prototype, "minSpacing", 2);
    __decorateClass([
      Validate(MAX_SPACING),
      Default(NaN)
    ], NumberAxisTick.prototype, "maxSpacing", 2);
    NumberAxis = class extends CartesianAxis {
      constructor(moduleCtx, scale2 = new LinearScale()) {
        super(moduleCtx, scale2);
        this.min = NaN;
        this.max = NaN;
      }
      normaliseDataDomain(d) {
        const { min, max } = this;
        const { extent: extent6, clipped } = normalisedExtentWithMetadata(d, min, max);
        return { domain: extent6, clipped };
      }
      createTick() {
        return new NumberAxisTick();
      }
      updateSecondaryAxisTicks(primaryTickCount) {
        if (this.dataDomain == null) {
          throw new Error("AG Charts - dataDomain not calculated, cannot perform tick calculation.");
        }
        if (this.dataDomain.domain.length === 0)
          return [];
        const [d, ticks] = calculateNiceSecondaryAxis(this.dataDomain.domain, primaryTickCount != null ? primaryTickCount : 0, this.reverse);
        this.scale.nice = false;
        this.scale.domain = d;
        this.scale.update();
        return ticks;
      }
      formatDatum(datum) {
        if (typeof datum === "number") {
          return datum.toFixed(2);
        } else {
          return String(datum);
        }
      }
    };
    NumberAxis.className = "NumberAxis";
    NumberAxis.type = "number";
    __decorateClass([
      Validate(AND(NUMBER_OR_NAN, LESS_THAN("max"))),
      Default(NaN)
    ], NumberAxis.prototype, "min", 2);
    __decorateClass([
      Validate(AND(NUMBER_OR_NAN, GREATER_THAN("min"))),
      Default(NaN)
    ], NumberAxis.prototype, "max", 2);
  }
});

// packages/ag-charts-community/src/chart/axis/logAxis.ts
var NON_ZERO_NUMBER, LogAxis;
var init_logAxis = __esm({
  "packages/ag-charts-community/src/chart/axis/logAxis.ts"() {
    "use strict";
    init_logScale();
    init_array();
    init_default();
    init_logger();
    init_type_guards();
    init_validation();
    init_numberAxis();
    NON_ZERO_NUMBER = predicateWithMessage((value) => isNumber(value) && value !== 0, "a non-zero number");
    LogAxis = class extends NumberAxis {
      constructor(moduleCtx) {
        super(moduleCtx, new LogScale());
        this.min = NaN;
        this.max = NaN;
      }
      normaliseDataDomain(d) {
        const { min, max } = this;
        const { extent: extent6, clipped } = normalisedExtentWithMetadata(d, min, max);
        const isInverted = extent6[0] > extent6[1];
        const crossesZero = extent6[0] < 0 && extent6[1] > 0;
        const hasZeroExtent = extent6[0] === 0 && extent6[1] === 0;
        const invalidDomain = isInverted || crossesZero || hasZeroExtent;
        if (invalidDomain) {
          if (crossesZero) {
            Logger.warn(
              `the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`
            );
          } else if (hasZeroExtent) {
            Logger.warn(`the data domain has 0 extent, no data is rendered.`);
          }
        }
        if (extent6[0] === 0) {
          extent6[0] = 1;
        }
        if (extent6[1] === 0) {
          extent6[1] = -1;
        }
        return { domain: extent6, clipped };
      }
      set base(value) {
        this.scale.base = value;
      }
      get base() {
        return this.scale.base;
      }
    };
    LogAxis.className = "LogAxis";
    LogAxis.type = "log";
    __decorateClass([
      Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, LESS_THAN("max"))),
      Default(NaN)
    ], LogAxis.prototype, "min", 2);
    __decorateClass([
      Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, GREATER_THAN("min"))),
      Default(NaN)
    ], LogAxis.prototype, "max", 2);
  }
});

// packages/ag-charts-community/src/chart/axis/timeAxis.ts
var TimeAxisTick, TimeAxis;
var init_timeAxis = __esm({
  "packages/ag-charts-community/src/chart/axis/timeAxis.ts"() {
    "use strict";
    init_timeScale();
    init_array();
    init_default();
    init_validation();
    init_axisTick();
    init_cartesianAxis();
    TimeAxisTick = class extends AxisTick {
      constructor() {
        super(...arguments);
        this.minSpacing = NaN;
        this.maxSpacing = NaN;
      }
    };
    __decorateClass([
      Validate(MIN_SPACING),
      Default(NaN)
    ], TimeAxisTick.prototype, "minSpacing", 2);
    __decorateClass([
      Validate(MAX_SPACING),
      Default(NaN)
    ], TimeAxisTick.prototype, "maxSpacing", 2);
    TimeAxis = class extends CartesianAxis {
      constructor(moduleCtx) {
        super(moduleCtx, new TimeScale());
        this.min = void 0;
        this.max = void 0;
        this.refreshScale();
      }
      normaliseDataDomain(d) {
        var _a2;
        let { min, max } = this;
        let clipped = false;
        if (typeof min === "number") {
          min = new Date(min);
        }
        if (typeof max === "number") {
          max = new Date(max);
        }
        if (d.length > 2) {
          d = ((_a2 = extent(d)) != null ? _a2 : [0, 1e3]).map((x) => new Date(x));
        }
        if (min instanceof Date) {
          clipped || (clipped = min > d[0]);
          d = [min, d[1]];
        }
        if (max instanceof Date) {
          clipped || (clipped = max < d[1]);
          d = [d[0], max];
        }
        if (d[0] > d[1]) {
          d = [];
        }
        return { domain: d, clipped };
      }
      createTick() {
        return new TimeAxisTick();
      }
      onLabelFormatChange(ticks, domain, format2) {
        if (format2) {
          super.onLabelFormatChange(ticks, domain, format2);
        } else {
          this.labelFormatter = this.scale.tickFormat({ ticks, domain });
        }
      }
      calculatePadding() {
        return [0, 0];
      }
      formatDatum(datum) {
        var _a2;
        const formatter = this.scale.tickFormat({
          specifier: "%m/%d/%y, %H:%M:%S"
        });
        return (_a2 = this.moduleCtx.callbackCache.call(formatter, datum)) != null ? _a2 : String(datum);
      }
    };
    TimeAxis.className = "TimeAxis";
    TimeAxis.type = "time";
    __decorateClass([
      Validate(AND(DATE_OR_DATETIME_MS, LESS_THAN("max")), { optional: true })
    ], TimeAxis.prototype, "min", 2);
    __decorateClass([
      Validate(AND(DATE_OR_DATETIME_MS, GREATER_THAN("min")), { optional: true })
    ], TimeAxis.prototype, "max", 2);
  }
});

// packages/ag-charts-community/src/scene/shape/rect.ts
var epsilon, cornerEdges, drawCorner, insetCornerRadiusRect, Rect;
var init_rect = __esm({
  "packages/ag-charts-community/src/scene/shape/rect.ts"() {
    "use strict";
    init_bbox();
    init_extendedPath2D();
    init_path();
    init_shape();
    epsilon = 1e-6;
    cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius) => {
      let leadingClipped = false;
      let trailingClipped = false;
      let leading0 = trailingInset - Math.sqrt(Math.max(__pow(cornerRadius, 2) - __pow(leadingInset, 2), 0));
      let leading1 = 0;
      let trailing0 = 0;
      let trailing1 = leadingInset - Math.sqrt(Math.max(__pow(cornerRadius, 2) - __pow(trailingInset, 2), 0));
      if (leading0 > leadingEdge) {
        leadingClipped = true;
        leading0 = leadingEdge;
        leading1 = leadingInset - Math.sqrt(Math.max(__pow(cornerRadius, 2) - __pow(trailingInset - leadingEdge, 2)));
      } else if (leading0 < epsilon) {
        leading0 = 0;
      }
      if (trailing1 > trailingEdge) {
        trailingClipped = true;
        trailing0 = trailingInset - Math.sqrt(Math.max(__pow(cornerRadius, 2) - __pow(leadingInset - trailingEdge, 2)));
        trailing1 = trailingEdge;
      } else if (trailing1 < epsilon) {
        trailing1 = 0;
      }
      return { leading0, leading1, trailing0, trailing1, leadingClipped, trailingClipped };
    };
    drawCorner = (path, { x0, y0, x1, y1, cx, cy }, cornerRadius, move) => {
      if (move) {
        path.moveTo(x0, y0);
      }
      if (x0 !== x1 || y0 !== y1) {
        const r0 = Math.atan2(y0 - cy, x0 - cx);
        const r1 = Math.atan2(y1 - cy, x1 - cx);
        path.arc(cx, cy, cornerRadius, r0, r1);
      } else {
        path.lineTo(x0, y0);
      }
    };
    insetCornerRadiusRect = (path, x, y, width, height, cornerRadii, clipBBox) => {
      let {
        topLeft: topLeftCornerRadius,
        topRight: topRightCornerRadius,
        bottomRight: bottomRightCornerRadius,
        bottomLeft: bottomLeftCornerRadius
      } = cornerRadii;
      const maxVerticalCornerRadius = Math.max(
        topLeftCornerRadius + bottomLeftCornerRadius,
        topRightCornerRadius + bottomRightCornerRadius
      );
      const maxHorizontalCornerRadius = Math.max(
        topLeftCornerRadius + topRightCornerRadius,
        bottomLeftCornerRadius + bottomRightCornerRadius
      );
      if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {
        if (clipBBox == null) {
          path.rect(x, y, width, height);
        } else {
          path.rect(clipBBox.x, clipBBox.y, clipBBox.width, clipBBox.height);
        }
        return;
      } else if (clipBBox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {
        path.roundRect(x, y, width, height, topLeftCornerRadius);
        return;
      }
      if (width < 0) {
        x += width;
        width = Math.abs(width);
      }
      if (height < 0) {
        y += height;
        height = Math.abs(height);
      }
      if (width <= 0 || height <= 0)
        return;
      if (clipBBox == null) {
        clipBBox = new BBox(x, y, width, height);
      } else {
        const x0 = Math.max(x, clipBBox.x);
        const x1 = Math.min(x + width, clipBBox.x + clipBBox.width);
        const y0 = Math.max(y, clipBBox.y);
        const y1 = Math.min(y + height, clipBBox.y + clipBBox.height);
        clipBBox = new BBox(x0, y0, x1 - x0, y1 - y0);
      }
      const borderScale = Math.max(maxVerticalCornerRadius / height, maxHorizontalCornerRadius / width, 1);
      if (borderScale > 1) {
        topLeftCornerRadius /= borderScale;
        topRightCornerRadius /= borderScale;
        bottomRightCornerRadius /= borderScale;
        bottomLeftCornerRadius /= borderScale;
      }
      let drawTopLeftCorner = true;
      let drawTopRightCorner = true;
      let drawBottomRightCorner = true;
      let drawBottomLeftCorner = true;
      let topLeftCorner;
      let topRightCorner;
      let bottomRightCorner;
      let bottomLeftCorner;
      if (drawTopLeftCorner) {
        const nodes = cornerEdges(
          clipBBox.height,
          clipBBox.width,
          Math.max(x + topLeftCornerRadius - clipBBox.x, 0),
          Math.max(y + topLeftCornerRadius - clipBBox.y, 0),
          topLeftCornerRadius
        );
        if (nodes.leadingClipped)
          drawBottomLeftCorner = false;
        if (nodes.trailingClipped)
          drawTopRightCorner = false;
        const x0 = Math.max(clipBBox.x + nodes.leading1, clipBBox.x);
        const y0 = Math.max(clipBBox.y + nodes.leading0, clipBBox.y);
        const x1 = Math.max(clipBBox.x + nodes.trailing1, clipBBox.x);
        const y1 = Math.max(clipBBox.y + nodes.trailing0, clipBBox.y);
        const cx = x + topLeftCornerRadius;
        const cy = y + topLeftCornerRadius;
        topLeftCorner = { x0, y0, x1, y1, cx, cy };
      }
      if (drawTopRightCorner) {
        const nodes = cornerEdges(
          clipBBox.width,
          clipBBox.height,
          Math.max(y + topRightCornerRadius - clipBBox.y, 0),
          Math.max(clipBBox.x + clipBBox.width - (x + width - topRightCornerRadius), 0),
          topRightCornerRadius
        );
        if (nodes.leadingClipped)
          drawTopLeftCorner = false;
        if (nodes.trailingClipped)
          drawBottomRightCorner = false;
        const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading0, clipBBox.x + clipBBox.width);
        const y0 = Math.max(clipBBox.y + nodes.leading1, clipBBox.y);
        const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing0, clipBBox.x + clipBBox.width);
        const y1 = Math.max(clipBBox.y + nodes.trailing1, clipBBox.y);
        const cx = x + width - topRightCornerRadius;
        const cy = y + topRightCornerRadius;
        topRightCorner = { x0, y0, x1, y1, cx, cy };
      }
      if (drawBottomRightCorner) {
        const nodes = cornerEdges(
          clipBBox.height,
          clipBBox.width,
          Math.max(clipBBox.x + clipBBox.width - (x + width - bottomRightCornerRadius), 0),
          Math.max(clipBBox.y + clipBBox.height - (y + height - bottomRightCornerRadius), 0),
          bottomRightCornerRadius
        );
        if (nodes.leadingClipped)
          drawTopRightCorner = false;
        if (nodes.trailingClipped)
          drawBottomLeftCorner = false;
        const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading1, clipBBox.x + clipBBox.width);
        const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading0, clipBBox.y + clipBBox.height);
        const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing1, clipBBox.x + clipBBox.width);
        const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing0, clipBBox.y + clipBBox.height);
        const cx = x + width - bottomRightCornerRadius;
        const cy = y + height - bottomRightCornerRadius;
        bottomRightCorner = { x0, y0, x1, y1, cx, cy };
      }
      if (drawBottomLeftCorner) {
        const nodes = cornerEdges(
          clipBBox.width,
          clipBBox.height,
          Math.max(clipBBox.y + clipBBox.height - (y + height - bottomLeftCornerRadius), 0),
          Math.max(x + bottomLeftCornerRadius - clipBBox.x, 0),
          bottomLeftCornerRadius
        );
        if (nodes.leadingClipped)
          drawBottomRightCorner = false;
        if (nodes.trailingClipped)
          drawTopLeftCorner = false;
        const x0 = Math.max(clipBBox.x + nodes.leading0, clipBBox.x);
        const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading1, clipBBox.y + clipBBox.height);
        const x1 = Math.max(clipBBox.x + nodes.trailing0, clipBBox.x);
        const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing1, clipBBox.y + clipBBox.height);
        const cx = x + bottomLeftCornerRadius;
        const cy = y + height - bottomLeftCornerRadius;
        bottomLeftCorner = { x0, y0, x1, y1, cx, cy };
      }
      let didMove = false;
      if (drawTopLeftCorner && topLeftCorner != null) {
        drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);
        didMove || (didMove = true);
      }
      if (drawTopRightCorner && topRightCorner != null) {
        drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);
        didMove || (didMove = true);
      }
      if (drawBottomRightCorner && bottomRightCorner != null) {
        drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);
        didMove || (didMove = true);
      }
      if (drawBottomLeftCorner && bottomLeftCorner != null) {
        drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);
        didMove || (didMove = true);
      }
      path.closePath();
    };
    Rect = class extends Path {
      constructor() {
        super(...arguments);
        this.borderPath = new ExtendedPath2D();
        this.x = 0;
        this.y = 0;
        this.width = 10;
        this.height = 10;
        this.topLeftCornerRadius = 0;
        this.topRightCornerRadius = 0;
        this.bottomRightCornerRadius = 0;
        this.bottomLeftCornerRadius = 0;
        this.clipBBox = void 0;
        this.crisp = false;
        this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;
        this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;
        this.hittester = super.isPointInPath;
        this.distanceCalculator = super.distanceSquared;
        /**
         * When the rectangle's width or height is less than a pixel
         * and crisp mode is on, the rectangle will still fit into the pixel,
         * but will be less opaque to make an effect of holding less space.
         */
        this.microPixelEffectOpacity = 1;
      }
      set cornerRadius(cornerRadius) {
        this.topLeftCornerRadius = cornerRadius;
        this.topRightCornerRadius = cornerRadius;
        this.bottomRightCornerRadius = cornerRadius;
        this.bottomLeftCornerRadius = cornerRadius;
      }
      isDirtyPath() {
        return this.lastUpdatePathStrokeWidth !== this.strokeWidth || Boolean(this.path.isDirty() || this.borderPath.isDirty());
      }
      updatePath() {
        var _a2, _b, _c;
        const {
          path,
          borderPath,
          crisp,
          topLeftCornerRadius: topLeft,
          topRightCornerRadius: topRight,
          bottomRightCornerRadius: bottomRight,
          bottomLeftCornerRadius: bottomLeft
        } = this;
        let { x, y, width: w, height: h, strokeWidth, clipBBox } = this;
        const pixelRatio = (_b = (_a2 = this.layerManager) == null ? void 0 : _a2.canvas.pixelRatio) != null ? _b : 1;
        const pixelSize = 1 / pixelRatio;
        let microPixelEffectOpacity = 1;
        path.clear(true);
        borderPath.clear(true);
        if (crisp) {
          if (w <= pixelSize) {
            microPixelEffectOpacity *= w / pixelSize;
          }
          if (h <= pixelSize) {
            microPixelEffectOpacity *= h / pixelSize;
          }
          w = this.align(x, w);
          h = this.align(y, h);
          x = this.align(x);
          y = this.align(y);
          clipBBox = clipBBox != null ? new BBox(
            this.align(clipBBox.x),
            this.align(clipBBox.y),
            this.align(clipBBox.x, clipBBox.width),
            this.align(clipBBox.y, clipBBox.height)
          ) : void 0;
        }
        if (strokeWidth) {
          if (w < pixelSize) {
            const lx = x + pixelSize / 2;
            borderPath.moveTo(lx, y);
            borderPath.lineTo(lx, y + h);
            strokeWidth = pixelSize;
            this.borderClipPath = void 0;
          } else if (h < pixelSize) {
            const ly = y + pixelSize / 2;
            borderPath.moveTo(x, ly);
            borderPath.lineTo(x + w, ly);
            strokeWidth = pixelSize;
            this.borderClipPath = void 0;
          } else if (strokeWidth < w && strokeWidth < h) {
            const halfStrokeWidth = strokeWidth / 2;
            x += halfStrokeWidth;
            y += halfStrokeWidth;
            w -= strokeWidth;
            h -= strokeWidth;
            const adjustedClipBBox = clipBBox == null ? void 0 : clipBBox.clone().shrink(halfStrokeWidth);
            const cornerRadii = {
              topLeft: topLeft > 0 ? topLeft - strokeWidth : 0,
              topRight: topRight > 0 ? topRight - strokeWidth : 0,
              bottomRight: bottomRight > 0 ? bottomRight - strokeWidth : 0,
              bottomLeft: bottomLeft > 0 ? bottomLeft - strokeWidth : 0
            };
            this.borderClipPath = void 0;
            if (w > 0 && h > 0 && (adjustedClipBBox == null || (adjustedClipBBox == null ? void 0 : adjustedClipBBox.width) > 0 && (adjustedClipBBox == null ? void 0 : adjustedClipBBox.height) > 0)) {
              insetCornerRadiusRect(path, x, y, w, h, cornerRadii, adjustedClipBBox);
              insetCornerRadiusRect(borderPath, x, y, w, h, cornerRadii, adjustedClipBBox);
            }
          } else {
            this.borderClipPath = (_c = this.borderClipPath) != null ? _c : new ExtendedPath2D();
            this.borderClipPath.clear(true);
            this.borderClipPath.rect(x, y, w, h);
            borderPath.rect(x, y, w, h);
          }
        } else {
          const cornerRadii = { topLeft, topRight, bottomRight, bottomLeft };
          this.borderClipPath = void 0;
          insetCornerRadiusRect(path, x, y, w, h, cornerRadii, clipBBox);
        }
        if ([topLeft, topRight, bottomRight, bottomLeft].every((r) => r === 0)) {
          this.hittester = (hitX, hitY) => {
            const point = this.transformPoint(hitX, hitY);
            return this.getCachedBBox().containsPoint(point.x, point.y);
          };
          this.distanceSquared = (hitX, hitY) => this.getCachedBBox().distanceSquared(hitX, hitY);
        } else {
          this.hittester = super.isPointInPath;
          this.distanceCalculator = super.distanceSquared;
        }
        this.effectiveStrokeWidth = strokeWidth;
        this.lastUpdatePathStrokeWidth = strokeWidth;
        this.microPixelEffectOpacity = microPixelEffectOpacity;
      }
      computeBBox() {
        var _a2;
        const { x, y, width, height, clipBBox } = this;
        return (_a2 = clipBBox == null ? void 0 : clipBBox.clone()) != null ? _a2 : new BBox(x, y, width, height);
      }
      isPointInPath(x, y) {
        return this.hittester(x, y);
      }
      get midPoint() {
        return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
      }
      distanceSquared(x, y) {
        return this.distanceCalculator(x, y);
      }
      applyFillAlpha(ctx) {
        const { fillOpacity, microPixelEffectOpacity, opacity } = this;
        ctx.globalAlpha *= opacity * fillOpacity * microPixelEffectOpacity;
      }
      renderStroke(ctx) {
        const { stroke, effectiveStrokeWidth } = this;
        if (stroke && effectiveStrokeWidth) {
          const { globalAlpha } = ctx;
          const {
            strokeOpacity,
            lineDash,
            lineDashOffset,
            lineCap,
            lineJoin,
            borderPath,
            borderClipPath,
            opacity,
            microPixelEffectOpacity
          } = this;
          if (borderClipPath) {
            ctx.clip(borderClipPath.getPath2D());
          }
          ctx.strokeStyle = stroke;
          ctx.globalAlpha *= opacity * strokeOpacity * microPixelEffectOpacity;
          ctx.lineWidth = effectiveStrokeWidth;
          if (lineDash) {
            ctx.setLineDash(lineDash);
          }
          if (lineDashOffset) {
            ctx.lineDashOffset = lineDashOffset;
          }
          if (lineCap) {
            ctx.lineCap = lineCap;
          }
          if (lineJoin) {
            ctx.lineJoin = lineJoin;
          }
          ctx.stroke(borderPath.getPath2D());
          ctx.globalAlpha = globalAlpha;
        }
      }
    };
    Rect.className = "Rect";
    __decorateClass([
      ScenePathChangeDetection()
    ], Rect.prototype, "x", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Rect.prototype, "y", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Rect.prototype, "width", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Rect.prototype, "height", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Rect.prototype, "topLeftCornerRadius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Rect.prototype, "topRightCornerRadius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Rect.prototype, "bottomRightCornerRadius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Rect.prototype, "bottomLeftCornerRadius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Rect.prototype, "clipBBox", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Rect.prototype, "crisp", 2);
  }
});

// packages/ag-charts-community/src/chart/background/background.ts
var Background;
var init_background = __esm({
  "packages/ag-charts-community/src/chart/background/background.ts"() {
    "use strict";
    init_module();
    init_group();
    init_rect();
    init_proxy();
    init_validation();
    init_layers();
    Background = class extends BaseModuleInstance {
      constructor(ctx) {
        super();
        this.node = new Group({ name: "background", zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */ });
        this.rectNode = new Rect();
        this.visible = true;
        this.fill = "white";
        this.node.appendChild(this.rectNode);
        this.destroyFns.push(
          ctx.scene.attachNode(this.node),
          ctx.layoutService.addListener("layout-complete", (e) => this.onLayoutComplete(e))
        );
      }
      onLayoutComplete(e) {
        const { width, height } = e.chart;
        this.rectNode.width = width;
        this.rectNode.height = height;
      }
    };
    __decorateClass([
      Validate(BOOLEAN),
      ProxyPropertyOnWrite("node", "visible")
    ], Background.prototype, "visible", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true }),
      ProxyPropertyOnWrite("rectNode", "fill")
    ], Background.prototype, "fill", 2);
    __decorateClass([
      Validate(OBJECT, { optional: true })
    ], Background.prototype, "image", 2);
  }
});

// packages/ag-charts-community/src/chart/background/backgroundModule.ts
var BackgroundModule;
var init_backgroundModule = __esm({
  "packages/ag-charts-community/src/chart/background/backgroundModule.ts"() {
    "use strict";
    init_background();
    BackgroundModule = {
      type: "root",
      optionsKey: "background",
      packageType: "community",
      chartTypes: ["cartesian", "polar", "hierarchy", "topology"],
      instanceConstructor: Background
    };
  }
});

// packages/ag-charts-community/src/chart/gridLayout.ts
function gridLayout({
  orientation,
  bboxes,
  maxHeight,
  maxWidth,
  itemPaddingY = 0,
  itemPaddingX = 0,
  forceResult = false
}) {
  const horizontal = orientation === "horizontal";
  const primary = {
    max: horizontal ? maxWidth : maxHeight,
    fn: horizontal ? (b) => b.width : (b) => b.height,
    padding: horizontal ? itemPaddingX : itemPaddingY
  };
  const secondary = {
    max: horizontal ? maxHeight : maxWidth,
    fn: horizontal ? (b) => b.height : (b) => b.width,
    padding: horizontal ? itemPaddingY : itemPaddingX
  };
  let processedBBoxCount = 0;
  const rawPages = [];
  while (processedBBoxCount < bboxes.length) {
    const unprocessedBBoxes = bboxes.slice(processedBBoxCount);
    const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);
    if (!result) {
      return;
    }
    processedBBoxCount += result.processedBBoxCount;
    rawPages.push(result.pageIndices);
  }
  return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);
}
function processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {
  const minGuess = 1;
  let startingGuess = estimateStartingGuess(bboxes, primary);
  if (startingGuess < minGuess) {
    if (!forceResult) {
      return;
    }
    startingGuess = minGuess;
  }
  let guess = startingGuess;
  while (guess >= minGuess) {
    const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);
    if (pageIndices == null && guess <= minGuess) {
      return;
    }
    if (pageIndices == null) {
      guess--;
      continue;
    }
    if (typeof pageIndices === "number") {
      if (pageIndices <= minGuess) {
        return;
      }
      guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;
      guess--;
      continue;
    }
    const processedBBoxCount = pageIndices.length * pageIndices[0].length;
    return { processedBBoxCount, pageIndices };
  }
}
function calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {
  var _a2;
  const result = [];
  let sumSecondary = 0;
  let currentMaxSecondary = 0;
  let currentPrimaryIndices = [];
  const maxPrimaryValues = [];
  for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {
    const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;
    if (primaryValueIdx === 0) {
      sumSecondary += currentMaxSecondary;
      currentMaxSecondary = 0;
      if (currentPrimaryIndices.length > 0) {
        result.push(currentPrimaryIndices);
      }
      currentPrimaryIndices = [];
    }
    const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;
    maxPrimaryValues[primaryValueIdx] = Math.max((_a2 = maxPrimaryValues[primaryValueIdx]) != null ? _a2 : 0, primaryValue);
    currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);
    const currentSecondaryDimension = sumSecondary + currentMaxSecondary;
    const returnResult = !forceResult || result.length > 0;
    if (currentSecondaryDimension > secondary.max && returnResult) {
      currentPrimaryIndices = [];
      break;
    }
    const sumPrimary = maxPrimaryValues.reduce((sum2, next) => sum2 + next, 0);
    if (sumPrimary > primary.max && !forceResult) {
      if (maxPrimaryValues.length < primaryCount) {
        return maxPrimaryValues.length;
      }
      return;
    }
    currentPrimaryIndices.push(bboxIndex + indexOffset);
  }
  if (currentPrimaryIndices.length > 0) {
    result.push(currentPrimaryIndices);
  }
  return result.length > 0 ? result : void 0;
}
function buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {
  let maxPageWidth = 0;
  let maxPageHeight = 0;
  const pages = rawPages.map((indices) => {
    if (orientation === "horizontal") {
      indices = transpose(indices);
    }
    let endIndex = 0;
    const columns = indices.map((colIndices) => {
      const colBBoxes = colIndices.map((bboxIndex) => {
        endIndex = Math.max(bboxIndex, endIndex);
        return bboxes[bboxIndex];
      });
      let columnHeight = 0;
      let columnWidth = 0;
      colBBoxes.forEach((bbox) => {
        columnHeight += bbox.height + itemPaddingY;
        columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);
      });
      return {
        indices: colIndices,
        bboxes: colBBoxes,
        columnHeight: Math.ceil(columnHeight),
        columnWidth: Math.ceil(columnWidth)
      };
    });
    let pageWidth = 0;
    let pageHeight = 0;
    columns.forEach((column) => {
      pageWidth += column.columnWidth;
      pageHeight = Math.max(pageHeight, column.columnHeight);
    });
    maxPageWidth = Math.max(pageWidth, maxPageWidth);
    maxPageHeight = Math.max(pageHeight, maxPageHeight);
    return {
      columns,
      startIndex: indices[0][0],
      endIndex,
      pageWidth,
      pageHeight
    };
  });
  return { pages, maxPageWidth, maxPageHeight };
}
function transpose(data) {
  const result = [];
  for (const _ of data[0]) {
    result.push([]);
  }
  data.forEach((innerData, dataIdx) => {
    innerData.forEach((item, itemIdx) => {
      result[itemIdx][dataIdx] = item;
    });
  });
  return result;
}
function estimateStartingGuess(bboxes, primary) {
  const n = bboxes.length;
  let primarySum = 0;
  for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {
    primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;
    if (primarySum > primary.max) {
      const ratio = n / bboxIndex;
      if (ratio < 2) {
        return Math.ceil(n / 2);
      }
      return bboxIndex;
    }
  }
  return n;
}
var init_gridLayout = __esm({
  "packages/ag-charts-community/src/chart/gridLayout.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/markerLabel.ts
var MarkerLabel;
var init_markerLabel = __esm({
  "packages/ag-charts-community/src/chart/markerLabel.ts"() {
    "use strict";
    init_group();
    init_line();
    init_text();
    init_proxy();
    init_square();
    MarkerLabel = class extends Group {
      constructor() {
        super({ name: "markerLabelGroup" });
        this.label = new Text();
        this.line = new Line();
        this._marker = new Square();
        this._markerSize = 15;
        this._spacing = 8;
        const { marker, label, line } = this;
        label.textBaseline = "middle";
        label.fontSize = 12;
        label.fontFamily = "Verdana, sans-serif";
        label.fill = "black";
        label.y = 1;
        this.append([line, marker, label]);
        this.update();
      }
      set marker(value) {
        if (this._marker !== value) {
          this.removeChild(this._marker);
          this._marker = value;
          this.appendChild(value);
          this.update();
        }
      }
      get marker() {
        return this._marker;
      }
      set markerSize(value) {
        if (this._markerSize !== value) {
          this._markerSize = value;
          this.update();
        }
      }
      get markerSize() {
        return this._markerSize;
      }
      set spacing(value) {
        if (this._spacing !== value) {
          this._spacing = value;
          this.update();
        }
      }
      get spacing() {
        return this._spacing;
      }
      setSeriesStrokeOffset(xOff) {
        const offset4 = this.marker.size / 2 + xOff;
        this.line.x1 = -offset4;
        this.line.x2 = offset4;
        this.line.y1 = 0;
        this.line.y2 = 0;
        this.line.markDirtyTransform();
        this.update();
      }
      update() {
        const { markerSize } = this;
        const center = this.marker.constructor.center;
        this.marker.size = markerSize;
        this.marker.x = (center.x - 0.5) * markerSize;
        this.marker.y = (center.y - 0.5) * markerSize;
        const lineEnd = this.line.visible ? this.line.x2 : -Infinity;
        const markerEnd = markerSize / 2;
        this.label.x = Math.max(lineEnd, markerEnd) + this.spacing;
      }
      render(renderCtx) {
        this.marker.opacity = this.opacity;
        this.label.opacity = this.opacity;
        this.line.opacity = this.opacity;
        super.render(renderCtx);
      }
    };
    MarkerLabel.className = "MarkerLabel";
    __decorateClass([
      ProxyPropertyOnWrite("label")
    ], MarkerLabel.prototype, "text", 2);
    __decorateClass([
      ProxyPropertyOnWrite("label")
    ], MarkerLabel.prototype, "fontStyle", 2);
    __decorateClass([
      ProxyPropertyOnWrite("label")
    ], MarkerLabel.prototype, "fontWeight", 2);
    __decorateClass([
      ProxyPropertyOnWrite("label")
    ], MarkerLabel.prototype, "fontSize", 2);
    __decorateClass([
      ProxyPropertyOnWrite("label")
    ], MarkerLabel.prototype, "fontFamily", 2);
    __decorateClass([
      ProxyPropertyOnWrite("label", "fill")
    ], MarkerLabel.prototype, "color", 2);
    __decorateClass([
      ProxyPropertyOnWrite("marker", "fill")
    ], MarkerLabel.prototype, "markerFill", 2);
    __decorateClass([
      ProxyPropertyOnWrite("marker", "stroke")
    ], MarkerLabel.prototype, "markerStroke", 2);
    __decorateClass([
      ProxyPropertyOnWrite("marker", "strokeWidth")
    ], MarkerLabel.prototype, "markerStrokeWidth", 2);
    __decorateClass([
      ProxyPropertyOnWrite("marker", "fillOpacity")
    ], MarkerLabel.prototype, "markerFillOpacity", 2);
    __decorateClass([
      ProxyPropertyOnWrite("marker", "strokeOpacity")
    ], MarkerLabel.prototype, "markerStrokeOpacity", 2);
    __decorateClass([
      ProxyPropertyOnWrite("marker", "visible")
    ], MarkerLabel.prototype, "markerVisible", 2);
    __decorateClass([
      ProxyPropertyOnWrite("line", "stroke")
    ], MarkerLabel.prototype, "lineStroke", 2);
    __decorateClass([
      ProxyPropertyOnWrite("line", "strokeWidth")
    ], MarkerLabel.prototype, "lineStrokeWidth", 2);
    __decorateClass([
      ProxyPropertyOnWrite("line", "strokeOpacity")
    ], MarkerLabel.prototype, "lineStrokeOpacity", 2);
    __decorateClass([
      ProxyPropertyOnWrite("line", "lineDash")
    ], MarkerLabel.prototype, "lineLineDash", 2);
    __decorateClass([
      ProxyPropertyOnWrite("line", "visible")
    ], MarkerLabel.prototype, "lineVisible", 2);
  }
});

// packages/ag-charts-community/src/chart/pagination/pagination.ts
var PaginationLabel, PaginationMarkerStyle, PaginationMarker, Pagination;
var init_pagination = __esm({
  "packages/ag-charts-community/src/chart/pagination/pagination.ts"() {
    "use strict";
    init_group();
    init_text();
    init_id();
    init_number();
    init_properties();
    init_proxy();
    init_validation();
    init_chartUpdateType();
    init_triangle();
    init_util();
    PaginationLabel = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.color = "black";
        this.fontStyle = void 0;
        this.fontWeight = void 0;
        this.fontSize = 12;
        this.fontFamily = "Verdana, sans-serif";
      }
    };
    __decorateClass([
      Validate(COLOR_STRING)
    ], PaginationLabel.prototype, "color", 2);
    __decorateClass([
      Validate(FONT_STYLE, { optional: true })
    ], PaginationLabel.prototype, "fontStyle", 2);
    __decorateClass([
      Validate(FONT_WEIGHT2, { optional: true })
    ], PaginationLabel.prototype, "fontWeight", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], PaginationLabel.prototype, "fontSize", 2);
    __decorateClass([
      Validate(STRING)
    ], PaginationLabel.prototype, "fontFamily", 2);
    PaginationMarkerStyle = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.size = 15;
        this.fill = void 0;
        this.fillOpacity = void 0;
        this.stroke = void 0;
        this.strokeWidth = 1;
        this.strokeOpacity = 1;
      }
    };
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], PaginationMarkerStyle.prototype, "size", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], PaginationMarkerStyle.prototype, "fill", 2);
    __decorateClass([
      Validate(RATIO, { optional: true })
    ], PaginationMarkerStyle.prototype, "fillOpacity", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], PaginationMarkerStyle.prototype, "stroke", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], PaginationMarkerStyle.prototype, "strokeWidth", 2);
    __decorateClass([
      Validate(RATIO)
    ], PaginationMarkerStyle.prototype, "strokeOpacity", 2);
    PaginationMarker = class extends BaseProperties {
      constructor(parent) {
        super();
        this.parent = parent;
        this.shape = Triangle;
        this.size = 15;
        this.padding = 8;
      }
    };
    __decorateClass([
      ActionOnSet({
        changeValue() {
          if (this.parent.marker === this) {
            this.parent.onMarkerShapeChange();
          }
        }
      })
    ], PaginationMarker.prototype, "shape", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], PaginationMarker.prototype, "size", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], PaginationMarker.prototype, "padding", 2);
    Pagination = class extends BaseProperties {
      constructor(chartUpdateCallback, pageUpdateCallback, regionManager, cursorManager) {
        super();
        this.chartUpdateCallback = chartUpdateCallback;
        this.pageUpdateCallback = pageUpdateCallback;
        this.regionManager = regionManager;
        this.cursorManager = cursorManager;
        this.id = createId(this);
        this.marker = new PaginationMarker(this);
        this.activeStyle = new PaginationMarkerStyle();
        this.inactiveStyle = new PaginationMarkerStyle();
        this.highlightStyle = new PaginationMarkerStyle();
        this.label = new PaginationLabel();
        this.group = new Group({ name: "pagination" });
        this.labelNode = new Text();
        this.destroyFns = [];
        this.totalPages = 0;
        this.currentPage = 0;
        this.translationX = 0;
        this.translationY = 0;
        this.nextButtonDisabled = false;
        this.previousButtonDisabled = false;
        this._visible = true;
        this._enabled = true;
        this._orientation = "vertical";
        this._nextButton = new Triangle();
        this._previousButton = new Triangle();
        this.labelNode.setProperties({
          textBaseline: "middle",
          fontSize: 12,
          fontFamily: "Verdana, sans-serif",
          fill: "black",
          y: 1
        });
        this.group.append([this.nextButton, this.previousButton, this.labelNode]);
        const region = this.regionManager.addRegion("pagination", this.group);
        this.destroyFns.push(
          region.addListener("click", (event) => this.onPaginationClick(event)),
          region.addListener("hover", (event) => this.onPaginationMouseMove(event))
        );
        this.update();
        this.updateMarkers();
      }
      destroy() {
        this.destroyFns.forEach((f) => f());
      }
      set visible(value) {
        this._visible = value;
        this.updateGroupVisibility();
      }
      get visible() {
        return this._visible;
      }
      set enabled(value) {
        this._enabled = value;
        this.updateGroupVisibility();
      }
      get enabled() {
        return this._enabled;
      }
      updateGroupVisibility() {
        this.group.visible = this.enabled && this.visible;
      }
      set orientation(value) {
        this._orientation = value;
        switch (value) {
          case "horizontal": {
            this.previousButton.rotation = -Math.PI / 2;
            this.nextButton.rotation = Math.PI / 2;
            break;
          }
          case "vertical":
          default: {
            this.previousButton.rotation = 0;
            this.nextButton.rotation = Math.PI;
          }
        }
      }
      get orientation() {
        return this._orientation;
      }
      set nextButton(value) {
        if (this._nextButton !== value) {
          this.group.removeChild(this._nextButton);
          this._nextButton = value;
          this.group.appendChild(value);
        }
      }
      get nextButton() {
        return this._nextButton;
      }
      set previousButton(value) {
        if (this._previousButton !== value) {
          this.group.removeChild(this._previousButton);
          this._previousButton = value;
          this.group.appendChild(value);
        }
      }
      get previousButton() {
        return this._previousButton;
      }
      update() {
        this.updateLabel();
        this.updatePositions();
        this.enableOrDisableButtons();
      }
      updatePositions() {
        this.group.translationX = this.translationX;
        this.group.translationY = this.translationY;
        this.updateLabelPosition();
        this.updateNextButtonPosition();
      }
      updateLabelPosition() {
        const { size: markerSize, padding: markerPadding } = this.marker;
        this.nextButton.size = markerSize;
        this.previousButton.size = markerSize;
        this.labelNode.x = markerSize / 2 + markerPadding;
      }
      updateNextButtonPosition() {
        const labelBBox = this.labelNode.computeBBox();
        this.nextButton.translationX = labelBBox.x + labelBBox.width + this.marker.size / 2 + this.marker.padding;
      }
      updateLabel() {
        const {
          currentPage,
          totalPages: pages,
          labelNode,
          label: { color, fontStyle, fontWeight, fontSize, fontFamily }
        } = this;
        labelNode.text = `${currentPage + 1} / ${pages}`;
        labelNode.fill = color;
        labelNode.fontStyle = fontStyle;
        labelNode.fontWeight = fontWeight;
        labelNode.fontSize = fontSize;
        labelNode.fontFamily = fontFamily;
      }
      updateMarkers() {
        const {
          nextButton,
          previousButton,
          nextButtonDisabled,
          previousButtonDisabled,
          activeStyle,
          inactiveStyle,
          highlightStyle,
          highlightActive
        } = this;
        const buttonStyle = (button, disabled) => {
          if (disabled) {
            return inactiveStyle;
          } else if (button === highlightActive) {
            return highlightStyle;
          }
          return activeStyle;
        };
        this.updateMarker(nextButton, buttonStyle("next", nextButtonDisabled));
        this.updateMarker(previousButton, buttonStyle("previous", previousButtonDisabled));
      }
      updateMarker(marker, style) {
        var _a2;
        const { size } = this.marker;
        marker.size = size;
        marker.fill = style.fill;
        marker.fillOpacity = (_a2 = style.fillOpacity) != null ? _a2 : 1;
        marker.stroke = style.stroke;
        marker.strokeWidth = style.strokeWidth;
        marker.strokeOpacity = style.strokeOpacity;
      }
      enableOrDisableButtons() {
        const { currentPage, totalPages } = this;
        const zeroPagesToDisplay = totalPages === 0;
        const onLastPage = currentPage === totalPages - 1;
        const onFirstPage = currentPage === 0;
        this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;
        this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;
      }
      nextButtonContainsPoint(offsetX, offsetY) {
        return !this.nextButtonDisabled && this.nextButton.containsPoint(offsetX, offsetY);
      }
      previousButtonContainsPoint(offsetX, offsetY) {
        return !this.previousButtonDisabled && this.previousButton.containsPoint(offsetX, offsetY);
      }
      clickNext() {
        this.incrementPage();
        this.onPaginationChanged();
      }
      clickPrevious() {
        this.decrementPage();
        this.onPaginationChanged();
      }
      setPage(pageNumber) {
        pageNumber = clamp(0, pageNumber, this.totalPages - 1);
        if (this.currentPage !== pageNumber) {
          this.currentPage = pageNumber;
          this.onPaginationChanged();
        }
      }
      onPaginationClick(event) {
        const { offsetX, offsetY } = event;
        if (this.nextButtonContainsPoint(offsetX, offsetY)) {
          this.clickNext();
          event.consume();
        } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {
          this.clickPrevious();
          event.consume();
        }
      }
      onPaginationMouseMove(event) {
        const { offsetX, offsetY } = event;
        if (this.nextButtonContainsPoint(offsetX, offsetY)) {
          this.cursorManager.updateCursor(this.id, "pointer");
          this.highlightActive = "next";
        } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {
          this.cursorManager.updateCursor(this.id, "pointer");
          this.highlightActive = "previous";
        } else {
          this.cursorManager.updateCursor(this.id);
          this.highlightActive = void 0;
        }
        this.updateMarkers();
        this.chartUpdateCallback(6 /* SCENE_RENDER */);
      }
      onPaginationChanged() {
        this.pageUpdateCallback(this.currentPage);
      }
      incrementPage() {
        this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);
      }
      decrementPage() {
        this.currentPage = Math.max(this.currentPage - 1, 0);
      }
      onMarkerShapeChange() {
        const Marker2 = getMarker(this.marker.shape || Triangle);
        this.previousButton = new Marker2();
        this.nextButton = new Marker2();
        this.updatePositions();
        this.updateMarkers();
        this.chartUpdateCallback(6 /* SCENE_RENDER */);
      }
      attachPagination(node) {
        node.append(this.group);
      }
      computeBBox() {
        return this.group.computeBBox();
      }
    };
    Pagination.className = "Pagination";
    __decorateClass([
      Validate(OBJECT)
    ], Pagination.prototype, "marker", 2);
    __decorateClass([
      Validate(OBJECT)
    ], Pagination.prototype, "activeStyle", 2);
    __decorateClass([
      Validate(OBJECT)
    ], Pagination.prototype, "inactiveStyle", 2);
    __decorateClass([
      Validate(OBJECT)
    ], Pagination.prototype, "highlightStyle", 2);
    __decorateClass([
      Validate(OBJECT)
    ], Pagination.prototype, "label", 2);
  }
});

// packages/ag-charts-community/src/chart/legend.ts
var LegendLabel, LegendMarker, LegendLine, LegendItem, LegendListeners, Legend;
var init_legend = __esm({
  "packages/ag-charts-community/src/chart/legend.ts"() {
    "use strict";
    init_bbox();
    init_group();
    init_node();
    init_selection();
    init_text();
    init_id();
    init_logger();
    init_number();
    init_properties();
    init_proxy();
    init_validation();
    init_chartUpdateType();
    init_gridLayout();
    init_interactionManager();
    init_keyboardUtil();
    init_layers();
    init_util();
    init_markerLabel();
    init_pagination();
    init_tooltip();
    LegendLabel = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.maxLength = void 0;
        this.color = "black";
        this.fontStyle = void 0;
        this.fontWeight = void 0;
        this.fontSize = 12;
        this.fontFamily = "Verdana, sans-serif";
        this.formatter = void 0;
      }
    };
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], LegendLabel.prototype, "maxLength", 2);
    __decorateClass([
      Validate(COLOR_STRING)
    ], LegendLabel.prototype, "color", 2);
    __decorateClass([
      Validate(FONT_STYLE, { optional: true })
    ], LegendLabel.prototype, "fontStyle", 2);
    __decorateClass([
      Validate(FONT_WEIGHT2, { optional: true })
    ], LegendLabel.prototype, "fontWeight", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], LegendLabel.prototype, "fontSize", 2);
    __decorateClass([
      Validate(STRING)
    ], LegendLabel.prototype, "fontFamily", 2);
    __decorateClass([
      Validate(FUNCTION, { optional: true })
    ], LegendLabel.prototype, "formatter", 2);
    LegendMarker = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.size = 15;
        this.padding = 8;
        this.enabled = true;
      }
    };
    __decorateClass([
      ObserveChanges((target) => {
        var _a2;
        return (_a2 = target.parent) == null ? void 0 : _a2.onMarkerShapeChange();
      })
    ], LegendMarker.prototype, "shape", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], LegendMarker.prototype, "size", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], LegendMarker.prototype, "padding", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], LegendMarker.prototype, "strokeWidth", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], LegendMarker.prototype, "enabled", 2);
    LegendLine = class extends BaseProperties {
    };
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], LegendLine.prototype, "strokeWidth", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], LegendLine.prototype, "length", 2);
    LegendItem = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.paddingX = 16;
        this.paddingY = 8;
        this.toggleSeriesVisible = true;
        this.showSeriesStroke = false;
        this.marker = new LegendMarker();
        this.label = new LegendLabel();
        this.line = new LegendLine();
      }
    };
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], LegendItem.prototype, "maxWidth", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], LegendItem.prototype, "paddingX", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], LegendItem.prototype, "paddingY", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], LegendItem.prototype, "toggleSeriesVisible", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], LegendItem.prototype, "showSeriesStroke", 2);
    __decorateClass([
      Validate(OBJECT)
    ], LegendItem.prototype, "marker", 2);
    __decorateClass([
      Validate(OBJECT)
    ], LegendItem.prototype, "label", 2);
    __decorateClass([
      Validate(OBJECT)
    ], LegendItem.prototype, "line", 2);
    LegendListeners = class extends BaseProperties {
    };
    __decorateClass([
      Validate(FUNCTION, { optional: true })
    ], LegendListeners.prototype, "legendItemClick", 2);
    __decorateClass([
      Validate(FUNCTION, { optional: true })
    ], LegendListeners.prototype, "legendItemDoubleClick", 2);
    Legend = class extends BaseProperties {
      constructor(ctx) {
        super();
        this.ctx = ctx;
        this.id = createId(this);
        this.group = new Group({ name: "legend", layer: true, zIndex: 11 /* LEGEND_ZINDEX */ });
        this.itemSelection = Selection.select(this.group, MarkerLabel);
        this.oldSize = [0, 0];
        this.pages = [];
        this.maxPageSize = [0, 0];
        /** Item index to track on re-pagination, so current page updates appropriately. */
        this.paginationTrackingIndex = 0;
        this.truncatedItems = /* @__PURE__ */ new Set();
        this._data = [];
        this.item = new LegendItem();
        this.listeners = new LegendListeners();
        this.enabled = true;
        this.position = "bottom";
        this.spacing = 20;
        this.characterWidths = /* @__PURE__ */ new Map();
        this.destroyFns = [];
        this.size = [0, 0];
        this._visible = true;
        this.focus = { mode: "item", index: 0 };
        this.item.marker.parent = this;
        this.pagination = new Pagination(
          (type) => ctx.updateService.update(type),
          (page) => this.updatePageNumber(page),
          ctx.regionManager,
          ctx.cursorManager
        );
        this.pagination.attachPagination(this.group);
        this.item.marker.parent = this;
        const animationState = 16 /* Default */ | 1 /* Animation */;
        const region = ctx.regionManager.addRegionFromProperties({
          name: "legend",
          bboxproviders: [this.group],
          canInteraction: () => this.enabled && this.group.visible
        });
        this.destroyFns.push(
          region.addListener("click", (e) => this.checkLegendClick(e), animationState),
          region.addListener("dblclick", (e) => this.checkLegendDoubleClick(e), animationState),
          region.addListener("hover", (e) => this.handleLegendMouseMove(e)),
          region.addListener("leave", (e) => this.handleLegendMouseExit(e), animationState),
          region.addListener("enter", (e) => this.handleLegendMouseEnter(e), animationState),
          region.addListener("blur", (e) => this.onBlur(e)),
          region.addListener("tab", (e) => this.onTab(e)),
          region.addListener("tab-start", (e) => this.onTabStart(e)),
          region.addListener("nav-vert", (e) => this.onNav(e)),
          region.addListener("nav-hori", (e) => this.onNav(e)),
          region.addListener("submit", (e) => this.onSubmit(e)),
          ctx.layoutService.addListener("start-layout", (e) => this.positionLegend(e.shrinkRect)),
          () => this.detachLegend()
        );
      }
      set data(value) {
        this._data = value;
        this.updateGroupVisibility();
      }
      get data() {
        return this._data;
      }
      destroy() {
        this.destroyFns.forEach((f) => f());
        this.pagination.destroy();
      }
      onMarkerShapeChange() {
        this.itemSelection.clear();
        this.group.markDirty(this.group, 2 /* MINOR */);
      }
      getOrientation() {
        if (this.orientation !== void 0) {
          return this.orientation;
        }
        switch (this.position) {
          case "right":
          case "left":
            return "vertical";
          case "bottom":
          case "top":
            return "horizontal";
        }
      }
      getCharacterWidths(font) {
        const { characterWidths } = this;
        if (characterWidths.has(font)) {
          return characterWidths.get(font);
        }
        const cw = {
          "...": Text.getTextSize("...", font).width
        };
        characterWidths.set(font, cw);
        return cw;
      }
      set visible(value) {
        this._visible = value;
        this.updateGroupVisibility();
      }
      get visible() {
        return this._visible;
      }
      updateGroupVisibility() {
        this.group.visible = this.enabled && this.visible && this.data.length > 0;
      }
      attachLegend(scene) {
        scene.appendChild(this.group);
      }
      detachLegend() {
        var _a2;
        (_a2 = this.group.parent) == null ? void 0 : _a2.removeChild(this.group);
      }
      getItemLabel(datum) {
        const {
          ctx: { callbackCache }
        } = this;
        const { formatter } = this.item.label;
        if (formatter) {
          return callbackCache.call(formatter, {
            itemId: datum.itemId,
            value: datum.label.text,
            seriesId: datum.seriesId
          });
        }
        return datum.label.text;
      }
      /**
       * The method is given the desired size of the legend, which only serves as a hint.
       * The vertically oriented legend will take as much horizontal space as needed, but will
       * respect the height constraints, and the horizontal legend will take as much vertical
       * space as needed in an attempt not to exceed the given width.
       * After the layout is done, the {@link size} will contain the actual size of the legend.
       * If the actual size is not the same as the previous actual size, the legend will fire
       * the 'layoutChange' event to communicate that another layout is needed, and the above
       * process should be repeated.
       * @param width
       * @param height
       */
      calcLayout(width, height) {
        const {
          paddingX,
          paddingY,
          label,
          maxWidth,
          marker: { size: markerSize, padding: markerPadding, shape: markerShape },
          label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily },
          line: itemLine,
          showSeriesStroke
        } = this.item;
        const data = [...this.data];
        if (this.reverseOrder) {
          data.reverse();
        }
        this.itemSelection.update(data);
        const bboxes = [];
        const font = getFont(label);
        const itemMaxWidthPercentage = 0.8;
        const maxItemWidth = maxWidth != null ? maxWidth : width * itemMaxWidthPercentage;
        const paddedMarkerWidth = markerSize + markerPadding + paddingX;
        this.itemSelection.each((markerLabel, datum) => {
          var _a2, _b, _c;
          const Marker2 = getMarker(markerShape != null ? markerShape : datum.marker.shape);
          const markerEnabled = (_a2 = datum.marker.enabled) != null ? _a2 : this.item.marker.enabled;
          if (!(markerLabel.marker && markerLabel.marker instanceof Marker2)) {
            markerLabel.marker = new Marker2();
          }
          markerLabel.markerSize = markerSize;
          markerLabel.spacing = markerPadding;
          markerLabel.fontStyle = fontStyle;
          markerLabel.fontWeight = fontWeight;
          markerLabel.fontSize = fontSize;
          markerLabel.fontFamily = fontFamily;
          const id = (_b = datum.itemId) != null ? _b : datum.id;
          const labelText = this.getItemLabel(datum);
          const text = (labelText != null ? labelText : "<unknown>").replace(/\r?\n/g, " ");
          markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedMarkerWidth, font, id);
          if (showSeriesStroke && datum.line !== void 0) {
            markerLabel.lineVisible = true;
            markerLabel.markerVisible = markerEnabled;
            markerLabel.setSeriesStrokeOffset((_c = itemLine.length) != null ? _c : 5);
          } else {
            markerLabel.lineVisible = false;
            markerLabel.markerVisible = true;
          }
          bboxes.push(markerLabel.computeBBox());
        });
        width = Math.max(1, width);
        height = Math.max(1, height);
        if (!isFinite(width)) {
          return false;
        }
        const size = this.size;
        const oldSize = this.oldSize;
        size[0] = width;
        size[1] = height;
        if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
          oldSize[0] = size[0];
          oldSize[1] = size[1];
        }
        const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width, height);
        this.pages = pages;
        this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];
        const pageNumber = this.pagination.currentPage;
        const page = this.pages[pageNumber];
        if (this.pages.length < 1 || !page) {
          this.visible = false;
          return;
        }
        this.visible = true;
        this.updatePositions(pageNumber);
        this.update();
      }
      truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, font, id) {
        const ellipsis2 = `...`;
        const textChars = text.split("");
        let addEllipsis = false;
        if (text.length > maxCharLength) {
          text = `${text.substring(0, maxCharLength)}`;
          addEllipsis = true;
        }
        const labelWidth = Math.floor(paddedMarkerWidth + Text.getTextSize(text, font).width);
        if (labelWidth > maxItemWidth) {
          let truncatedText = "";
          const characterWidths = this.getCharacterWidths(font);
          let cumulativeWidth = paddedMarkerWidth + characterWidths[ellipsis2];
          for (const char of textChars) {
            if (!characterWidths[char]) {
              characterWidths[char] = Text.getTextSize(char, font).width;
            }
            cumulativeWidth += characterWidths[char];
            if (cumulativeWidth > maxItemWidth) {
              break;
            }
            truncatedText += char;
          }
          text = truncatedText;
          addEllipsis = true;
        }
        if (addEllipsis) {
          text += ellipsis2;
          this.truncatedItems.add(id);
        } else {
          this.truncatedItems.delete(id);
        }
        return text;
      }
      updatePagination(bboxes, width, height) {
        const orientation = this.getOrientation();
        const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);
        this.pagination.orientation = orientation;
        this.pagination.translationX = 0;
        this.pagination.translationY = 0;
        const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(
          bboxes,
          width,
          height
        );
        const newCurrentPage = pages.findIndex((p) => p.endIndex >= trackingIndex);
        this.pagination.currentPage = clamp(0, newCurrentPage, pages.length - 1);
        const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;
        const paginationComponentPadding = 8;
        const legendItemsWidth = maxPageWidth - itemPaddingX;
        const legendItemsHeight = maxPageHeight - itemPaddingY;
        let paginationX = 0;
        let paginationY = -paginationBBox.y - this.item.marker.size / 2;
        if (paginationVertical) {
          paginationY += legendItemsHeight + paginationComponentPadding;
        } else {
          paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;
          paginationY += (legendItemsHeight - paginationBBox.height) / 2;
        }
        this.pagination.translationX = paginationX;
        this.pagination.translationY = paginationY;
        this.pagination.update();
        this.pagination.updateMarkers();
        return {
          maxPageHeight,
          maxPageWidth,
          pages
        };
      }
      calculatePagination(bboxes, width, height) {
        var _a2, _b, _c;
        const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;
        const orientation = this.getOrientation();
        const paginationVertical = ["left", "right"].includes(this.position);
        let paginationBBox = this.pagination.computeBBox();
        let lastPassPaginationBBox = new BBox(0, 0, 0, 0);
        let pages = [];
        let maxPageWidth = 0;
        let maxPageHeight = 0;
        let count = 0;
        const stableOutput = (bbox) => {
          return bbox.width === paginationBBox.width && bbox.height === paginationBBox.height;
        };
        const forceResult = this.maxWidth !== void 0 && this.maxHeight !== void 0;
        do {
          if (count++ > 10) {
            Logger.warn("unable to find stable legend layout.");
            break;
          }
          paginationBBox = lastPassPaginationBBox;
          const maxWidth = width - (paginationVertical ? 0 : paginationBBox.width);
          const maxHeight = height - (paginationVertical ? paginationBBox.height : 0);
          const layout = gridLayout({
            orientation,
            bboxes,
            maxHeight,
            maxWidth,
            itemPaddingY,
            itemPaddingX,
            forceResult
          });
          pages = (_a2 = layout == null ? void 0 : layout.pages) != null ? _a2 : [];
          maxPageWidth = (_b = layout == null ? void 0 : layout.maxPageWidth) != null ? _b : 0;
          maxPageHeight = (_c = layout == null ? void 0 : layout.maxPageHeight) != null ? _c : 0;
          const totalPages = pages.length;
          this.pagination.visible = totalPages > 1;
          this.pagination.totalPages = totalPages;
          this.pagination.update();
          lastPassPaginationBBox = this.pagination.computeBBox();
          if (!this.pagination.visible) {
            break;
          }
        } while (!stableOutput(lastPassPaginationBBox));
        return { maxPageWidth, maxPageHeight, pages, paginationBBox, paginationVertical };
      }
      getPageItemCount(pageNumber) {
        let count = 0;
        for (const col of this.pages[pageNumber].columns) {
          count += col.indices.length;
        }
        return count;
      }
      getNodeIndexFromFocusIndex() {
        const { index } = this.focus;
        const page = this.pages[this.pagination.currentPage];
        let itemCount = 0;
        for (const col of page.columns) {
          if (index < itemCount + col.indices.length) {
            return col.indices[index - itemCount];
          } else {
            itemCount += col.indices.length;
          }
        }
        return -1;
      }
      updatePositions(pageNumber = 0) {
        const {
          item: { paddingY },
          itemSelection,
          pages
        } = this;
        if (pages.length < 1 || !pages[pageNumber]) {
          return;
        }
        const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];
        let x = 0;
        let y = 0;
        const columnCount = columns.length;
        const rowCount = columns[0].indices.length;
        const horizontal = this.getOrientation() === "horizontal";
        const itemHeight = columns[0].bboxes[0].height + paddingY;
        const rowSumColumnWidths = [];
        itemSelection.each((markerLabel, _, i) => {
          var _a2, _b;
          if (i < visibleStart || i > visibleEnd) {
            markerLabel.visible = false;
            return;
          }
          const pageIndex = i - visibleStart;
          let columnIndex = 0;
          let rowIndex = 0;
          if (horizontal) {
            columnIndex = pageIndex % columnCount;
            rowIndex = Math.floor(pageIndex / columnCount);
          } else {
            columnIndex = Math.floor(pageIndex / rowCount);
            rowIndex = pageIndex % rowCount;
          }
          markerLabel.visible = true;
          const column = columns[columnIndex];
          if (!column) {
            return;
          }
          y = itemHeight * rowIndex;
          x = (_a2 = rowSumColumnWidths[rowIndex]) != null ? _a2 : 0;
          rowSumColumnWidths[rowIndex] = ((_b = rowSumColumnWidths[rowIndex]) != null ? _b : 0) + column.columnWidth;
          markerLabel.translationX = Math.floor(x);
          markerLabel.translationY = Math.floor(y);
        });
      }
      updatePageNumber(pageNumber) {
        const { pages } = this;
        const { startIndex, endIndex } = pages[pageNumber];
        if (startIndex === 0) {
          this.paginationTrackingIndex = 0;
        } else if (pageNumber === pages.length - 1) {
          this.paginationTrackingIndex = endIndex;
        } else {
          this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);
        }
        this.pagination.update();
        this.pagination.updateMarkers();
        this.updatePositions(pageNumber);
        this.ctx.updateService.update(6 /* SCENE_RENDER */);
      }
      update() {
        const {
          label: { color },
          marker: itemMarker,
          line: itemLine,
          showSeriesStroke
        } = this.item;
        this.itemSelection.each((markerLabel, datum) => {
          var _a2, _b;
          const marker = datum.marker;
          markerLabel.markerFill = marker.fill;
          markerLabel.markerStroke = marker.stroke;
          markerLabel.markerStrokeWidth = (_a2 = itemMarker.strokeWidth) != null ? _a2 : Math.min(2, marker.strokeWidth);
          markerLabel.markerFillOpacity = marker.fillOpacity;
          markerLabel.markerStrokeOpacity = marker.strokeOpacity;
          markerLabel.opacity = datum.enabled ? 1 : 0.5;
          markerLabel.color = color;
          const { line } = datum;
          if (showSeriesStroke && line !== void 0) {
            markerLabel.lineStroke = line.stroke;
            markerLabel.lineStrokeOpacity = line.strokeOpacity;
            markerLabel.lineStrokeWidth = (_b = itemLine.strokeWidth) != null ? _b : Math.min(2, line.strokeWidth);
            markerLabel.lineLineDash = line.lineDash;
          }
        });
      }
      getDatumForPoint(x, y) {
        const visibleChildBBoxes = [];
        const closestLeftTop = { dist: Infinity, datum: void 0 };
        for (const child of this.group.children) {
          if (!child.visible)
            continue;
          if (!(child instanceof MarkerLabel))
            continue;
          const childBBox = child.computeBBox();
          childBBox.grow(this.item.paddingX / 2, "horizontal");
          childBBox.grow(this.item.paddingY / 2, "vertical");
          if (childBBox.containsPoint(x, y)) {
            return child.datum;
          }
          const distX = x - childBBox.x - this.item.paddingX / 2;
          const distY = y - childBBox.y - this.item.paddingY / 2;
          const dist = __pow(distX, 2) + __pow(distY, 2);
          const toTheLeftTop = distX >= 0 && distY >= 0;
          if (toTheLeftTop && dist < closestLeftTop.dist) {
            closestLeftTop.dist = dist;
            closestLeftTop.datum = child.datum;
          }
          visibleChildBBoxes.push(childBBox);
        }
        const pageBBox = BBox.merge(visibleChildBBoxes);
        if (!pageBBox.containsPoint(x, y)) {
          return;
        }
        return closestLeftTop.datum;
      }
      computePagedBBox() {
        const actualBBox = this.group.computeBBox();
        if (this.pages.length <= 1) {
          return actualBBox;
        }
        const [maxPageWidth, maxPageHeight] = this.maxPageSize;
        actualBBox.height = Math.max(maxPageHeight, actualBBox.height);
        actualBBox.width = Math.max(maxPageWidth, actualBBox.width);
        return actualBBox;
      }
      checkLegendClick(event) {
        const datum = this.getDatumForPoint(event.offsetX, event.offsetY);
        if (this.doClick(datum)) {
          event.consume();
        }
      }
      doClick(datum) {
        const {
          listeners: { legendItemClick },
          ctx: { chartService, highlightManager },
          item: { toggleSeriesVisible },
          preventHidingAll
        } = this;
        if (!datum) {
          return false;
        }
        const { id, itemId, enabled } = datum;
        const series = chartService.series.find((s) => s.id === id);
        if (!series) {
          return false;
        }
        let newEnabled = enabled;
        if (toggleSeriesVisible) {
          newEnabled = !enabled;
          if (preventHidingAll && !newEnabled) {
            const numVisibleItems = chartService.series.flatMap((s) => s.getLegendData("category")).filter((d) => d.enabled).length;
            if (numVisibleItems < 2) {
              newEnabled = true;
            }
          }
          const status = newEnabled ? "visible" : "hidden";
          this.ctx.ariaAnnouncementService.announceValue(`${status}`);
          this.ctx.chartEventManager.legendItemClick(series, itemId, newEnabled, datum.legendItemName);
        }
        if (newEnabled) {
          highlightManager.updateHighlight(this.id, {
            series,
            itemId,
            datum: void 0
          });
        } else {
          highlightManager.updateHighlight(this.id);
        }
        this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });
        legendItemClick == null ? void 0 : legendItemClick({ type: "click", enabled: newEnabled, itemId, seriesId: series.id });
        return true;
      }
      checkLegendDoubleClick(event) {
        var _a2;
        const {
          listeners: { legendItemDoubleClick },
          ctx: { chartService },
          item: { toggleSeriesVisible }
        } = this;
        if (chartService.mode === "integrated") {
          return;
        }
        const datum = this.getDatumForPoint(event.offsetX, event.offsetY);
        if (!datum) {
          return;
        }
        const { id, itemId, seriesId } = datum;
        const series = chartService.series.find((s) => s.id === id);
        if (!series) {
          return;
        }
        event.consume();
        if (toggleSeriesVisible) {
          const legendData = chartService.series.flatMap((s) => s.getLegendData("category"));
          const numVisibleItems = legendData.filter((d) => d.enabled).length;
          const clickedItem = legendData.find((d) => d.itemId === itemId && d.seriesId === seriesId);
          this.ctx.chartEventManager.legendItemDoubleClick(
            series,
            itemId,
            (_a2 = clickedItem == null ? void 0 : clickedItem.enabled) != null ? _a2 : false,
            numVisibleItems,
            clickedItem == null ? void 0 : clickedItem.legendItemName
          );
        }
        this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });
        legendItemDoubleClick == null ? void 0 : legendItemDoubleClick({ type: "dblclick", enabled: true, itemId, seriesId: series.id });
      }
      handleLegendMouseMove(event) {
        if (!this.enabled) {
          return;
        }
        const { offsetX, offsetY } = event;
        event.consume();
        const datum = this.getDatumForPoint(offsetX, offsetY);
        this.doHover(event, datum);
      }
      doHover(event, datum) {
        var _a2;
        const {
          item: { toggleSeriesVisible },
          listeners
        } = this;
        if (event === void 0 || datum === void 0) {
          this.ctx.cursorManager.updateCursor(this.id);
          this.ctx.highlightManager.updateHighlight(this.id);
          return;
        }
        const series = datum ? this.ctx.chartService.series.find((s) => s.id === (datum == null ? void 0 : datum.id)) : void 0;
        if (datum && this.truncatedItems.has((_a2 = datum.itemId) != null ? _a2 : datum.id)) {
          const { offsetX, offsetY } = event;
          this.ctx.tooltipManager.updateTooltip(
            this.id,
            { offsetX, offsetY, lastPointerEvent: event, showArrow: false },
            toTooltipHtml({ content: this.getItemLabel(datum) })
          );
        } else {
          this.ctx.tooltipManager.removeTooltip(this.id);
        }
        if (toggleSeriesVisible || listeners.legendItemClick != null || listeners.legendItemDoubleClick != null) {
          this.ctx.cursorManager.updateCursor(this.id, "pointer");
        }
        if ((datum == null ? void 0 : datum.enabled) && series) {
          this.ctx.highlightManager.updateHighlight(this.id, {
            series,
            itemId: datum == null ? void 0 : datum.itemId,
            datum: void 0
          });
        } else {
          this.ctx.highlightManager.updateHighlight(this.id);
        }
      }
      handleLegendMouseExit(_event) {
        this.doMouseExit();
      }
      doMouseExit() {
        this.ctx.cursorManager.updateCursor(this.id);
        this.ctx.tooltipManager.removeTooltip(this.id);
        if (this.ctx.interactionManager.getState() === 16 /* Default */) {
          this.ctx.highlightManager.updateHighlight(this.id);
        }
      }
      handleLegendMouseEnter(event) {
        const {
          enabled,
          item: { toggleSeriesVisible: toggle },
          listeners: { legendItemClick: clickListener, legendItemDoubleClick: dblclickListener }
        } = this;
        const datum = this.getDatumForPoint(event.offsetX, event.offsetY);
        if (enabled && datum !== void 0 && (toggle || clickListener != null || dblclickListener != null)) {
          this.ctx.cursorManager.updateCursor(this.id, "pointer");
        }
      }
      onBlur(_event) {
        this.doMouseExit();
        this.focus.mode = "item";
        this.ctx.regionManager.updateFocusIndicatorRect(void 0);
      }
      onTab(event) {
        this.updateFocus();
        event.consume();
      }
      onTabStart(event) {
        if (!this.pagination.visible || !this.pagination.enabled)
          return;
        const consumeTabStart = (newMode) => {
          this.focus.mode = newMode;
          this.updateFocus();
          event.consume();
        };
        if (this.focus.mode === "item" && event.delta === 1) {
          this.focus.index = this.pagination.currentPage === 0 ? 1 : 0;
          consumeTabStart("page");
        } else if (this.focus.mode === "page" && event.delta === -1) {
          this.focus.index = 0;
          consumeTabStart("item");
        }
      }
      onNav(event) {
        if (this.focus.mode === "item") {
          const newIndex = this.focus.index + event.delta;
          const pageItemCount = this.getPageItemCount(this.pagination.currentPage);
          this.focus.index = clamp(-1, newIndex, pageItemCount);
          this.updateFocus();
          event.consume();
        } else if (this.focus.mode === "page") {
          if (event.delta < 0)
            this.focus.index = 0;
          if (event.delta > 0)
            this.focus.index = 1;
          this.updateFocus();
          event.consume();
        }
      }
      onSubmit(_event) {
        if (this.focus.mode === "item") {
          this.doClick(this.getFocusedItem().datum);
        } else if (this.focus.mode === "page") {
          if (this.focus.index === 0)
            this.pagination.clickPrevious();
          if (this.focus.index === 1)
            this.pagination.clickNext();
          this.ctx.ariaAnnouncementService.announceValue(
            `Legend page ${this.pagination.currentPage + 1} of ${this.pages.length}`
          );
        }
      }
      maybeChangeFocusPage() {
        const oldPage = this.pagination.currentPage;
        const oldPageItemCount = this.getPageItemCount(oldPage);
        if (this.focus.index === -1) {
          this.pagination.setPage(oldPage - 1);
        } else if (this.focus.index === oldPageItemCount) {
          this.pagination.setPage(oldPage + 1);
        } else {
          return;
        }
        const { currentPage } = this.pagination;
        if (oldPage === currentPage) {
          this.focus.index = clamp(0, this.focus.index, oldPageItemCount - 1);
        } else if (this.focus.index === -1) {
          this.focus.index = this.getPageItemCount(currentPage) - 1;
        } else {
          this.focus.index = 0;
        }
      }
      getFocusedItem() {
        if (this.focus.mode !== "item") {
          Logger.error(`getFocusedItem() should be called only when focus.mode is 'item'`);
          return { nodeIndex: -1, node: void 0, datum: void 0 };
        }
        this.maybeChangeFocusPage();
        const nodeIndex = this.getNodeIndexFromFocusIndex();
        if (nodeIndex < 0) {
          Logger.error(`Cannot access negative nodeIndex ${nodeIndex}`);
          return { nodeIndex: -1, node: void 0, datum: void 0 };
        }
        const node = this.itemSelection.nodes()[nodeIndex];
        const data = this.data;
        let datum;
        if (nodeIndex < data.length) {
          datum = this.data[nodeIndex];
        } else {
          Logger.error(`Cannot access datum[${nodeIndex}]`);
        }
        return { nodeIndex, node, datum };
      }
      updateFocus() {
        const { focus, pagination } = this;
        if (focus.mode === "item") {
          const { nodeIndex, node, datum } = this.getFocusedItem();
          if (datum === void 0)
            return;
          const bbox = node == null ? void 0 : node.computeTransformedBBox();
          this.doHover(makeKeyboardPointerEvent(this.ctx.regionManager, { bbox, showFocusBox: true }), datum);
          const label = datum && this.getItemLabel(datum);
          if (label) {
            const visibility = datum.enabled ? "visible" : "hidden";
            this.ctx.ariaAnnouncementService.announceValue(
              `Legend item ${nodeIndex + 1} of ${this.data.length}, ${label}, ${visibility}`
            );
          }
        } else if (focus.mode === "page") {
          const button = focus.index === 0 ? pagination.previousButton : pagination.nextButton;
          this.ctx.regionManager.updateFocusIndicatorRect(button.computeTransformedBBox());
          const value = ["Previous legend page", "Next legend page"][focus.index];
          this.ctx.ariaAnnouncementService.announceValue(`${value}, button`);
        }
      }
      positionLegend(shrinkRect) {
        const newShrinkRect = shrinkRect.clone();
        if (!this.enabled || !this.data.length) {
          return { shrinkRect: newShrinkRect };
        }
        const [legendWidth, legendHeight] = this.calculateLegendDimensions(shrinkRect);
        this.group.translationX = 0;
        this.group.translationY = 0;
        this.calcLayout(legendWidth, legendHeight);
        const legendBBox = this.computePagedBBox();
        const calculateTranslationPerpendicularDimension = () => {
          switch (this.position) {
            case "top":
            case "left":
              return 0;
            case "bottom":
              return shrinkRect.height - legendBBox.height;
            case "right":
            default:
              return shrinkRect.width - legendBBox.width;
          }
        };
        if (this.visible) {
          let translationX;
          let translationY;
          switch (this.position) {
            case "top":
            case "bottom":
              translationX = (shrinkRect.width - legendBBox.width) / 2;
              translationY = calculateTranslationPerpendicularDimension();
              newShrinkRect.shrink(legendBBox.height, this.position);
              break;
            case "left":
            case "right":
            default:
              translationX = calculateTranslationPerpendicularDimension();
              translationY = (shrinkRect.height - legendBBox.height) / 2;
              newShrinkRect.shrink(legendBBox.width, this.position);
          }
          this.group.translationX = Math.floor(-legendBBox.x + shrinkRect.x + translationX);
          this.group.translationY = Math.floor(-legendBBox.y + shrinkRect.y + translationY);
        }
        if (this.visible && this.enabled && this.data.length) {
          const legendPadding = this.spacing;
          newShrinkRect.shrink(legendPadding, this.position);
          const legendPositionedBBox = legendBBox.clone();
          legendPositionedBBox.x += this.group.translationX;
          legendPositionedBBox.y += this.group.translationY;
        }
        return { shrinkRect: newShrinkRect };
      }
      calculateLegendDimensions(shrinkRect) {
        const { width, height } = shrinkRect;
        const aspectRatio = width / height;
        const maxCoefficient = 0.5;
        const minHeightCoefficient = 0.2;
        const minWidthCoefficient = 0.25;
        let legendWidth, legendHeight;
        switch (this.position) {
          case "top":
          case "bottom":
            const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;
            legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : width;
            legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : Math.round(height * heightCoefficient);
            break;
          case "left":
          case "right":
          default:
            const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;
            legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : Math.round(width * widthCoefficient);
            legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : height;
        }
        return [legendWidth, legendHeight];
      }
    };
    Legend.className = "Legend";
    __decorateClass([
      Validate(OBJECT)
    ], Legend.prototype, "pagination", 2);
    __decorateClass([
      Validate(OBJECT)
    ], Legend.prototype, "item", 2);
    __decorateClass([
      Validate(OBJECT)
    ], Legend.prototype, "listeners", 2);
    __decorateClass([
      ObserveChanges((target) => target.updateGroupVisibility()),
      Validate(BOOLEAN)
    ], Legend.prototype, "enabled", 2);
    __decorateClass([
      Validate(POSITION2)
    ], Legend.prototype, "position", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], Legend.prototype, "maxWidth", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], Legend.prototype, "maxHeight", 2);
    __decorateClass([
      Validate(BOOLEAN, { optional: true })
    ], Legend.prototype, "reverseOrder", 2);
    __decorateClass([
      Validate(UNION(["horizontal", "vertical"], "an orientation"), { optional: true })
    ], Legend.prototype, "orientation", 2);
    __decorateClass([
      Validate(BOOLEAN, { optional: true })
    ], Legend.prototype, "preventHidingAll", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], Legend.prototype, "spacing", 2);
  }
});

// packages/ag-charts-community/src/chart/legendModule.ts
var CommunityLegendModule;
var init_legendModule = __esm({
  "packages/ag-charts-community/src/chart/legendModule.ts"() {
    "use strict";
    init_legend();
    CommunityLegendModule = {
      type: "legend",
      optionsKey: "legend",
      identifier: "category",
      chartTypes: ["cartesian", "polar", "hierarchy", "topology"],
      instanceConstructor: Legend,
      packageType: "community"
    };
  }
});

// packages/ag-charts-community/src/chart/navigator/shapes/rangeHandle.ts
var RangeHandle;
var init_rangeHandle = __esm({
  "packages/ag-charts-community/src/chart/navigator/shapes/rangeHandle.ts"() {
    "use strict";
    init_bbox();
    init_path();
    init_validation();
    RangeHandle = class extends Path {
      constructor() {
        super(...arguments);
        this.zIndex = 3;
        this._fill = "#f2f2f2";
        this._stroke = "#999999";
        this._strokeWidth = 1;
        this._lineCap = "square";
        this._centerX = 0;
        this._centerY = 0;
        this._width = 8;
        this._gripLineGap = 2;
        this._gripLineLength = 8;
        this._height = 16;
      }
      set centerX(value) {
        if (this._centerX !== value) {
          this._centerX = value;
          this.dirtyPath = true;
        }
      }
      get centerX() {
        return this._centerX;
      }
      set centerY(value) {
        if (this._centerY !== value) {
          this._centerY = value;
          this.dirtyPath = true;
        }
      }
      get centerY() {
        return this._centerY;
      }
      set width(value) {
        if (this._width !== value) {
          this._width = value;
          this.dirtyPath = true;
        }
      }
      get width() {
        return this._width;
      }
      set gripLineGap(value) {
        if (this._gripLineGap !== value) {
          this._gripLineGap = value;
          this.dirtyPath = true;
        }
      }
      get gripLineGap() {
        return this._gripLineGap;
      }
      set gripLineLength(value) {
        if (this._gripLineLength !== value) {
          this._gripLineLength = value;
          this.dirtyPath = true;
        }
      }
      get gripLineLength() {
        return this._gripLineLength;
      }
      set height(value) {
        if (this._height !== value) {
          this._height = value;
          this.dirtyPath = true;
        }
      }
      get height() {
        return this._height;
      }
      layout(x, y) {
        this.centerX = x;
        this.centerY = y;
      }
      static align(minHandle, maxHandle, x, y, width, height, min, max) {
        const handlePixelAlign = minHandle.strokeWidth / 2;
        const minHandleX = minHandle.align(x + width * min) + handlePixelAlign;
        const maxHandleX = minHandleX + minHandle.align(x + width * min, width * (max - min)) - 2 * handlePixelAlign;
        const handleY = minHandle.align(y + height / 2) + handlePixelAlign;
        minHandle.layout(minHandleX, handleY);
        maxHandle.layout(maxHandleX, handleY);
      }
      computeBBox() {
        const { centerX, centerY, width, height } = this;
        const x = centerX - width / 2;
        const y = centerY - height / 2;
        return new BBox(x, y, width, height);
      }
      isPointInPath(x, y) {
        const point = this.transformPoint(x, y);
        const bbox = this.computeBBox();
        return bbox.containsPoint(point.x, point.y);
      }
      updatePath() {
        var _a2, _b, _c;
        const { centerX, centerY, path, strokeWidth, gripLineGap, gripLineLength } = this;
        const pixelRatio = (_c = (_b = (_a2 = this.layerManager) == null ? void 0 : _a2.canvas) == null ? void 0 : _b.pixelRatio) != null ? _c : 1;
        path.clear();
        const halfWidth = Math.floor(this.width / 2 * pixelRatio) / pixelRatio;
        const halfHeight = Math.floor(this.height / 2 * pixelRatio) / pixelRatio;
        path.moveTo(centerX - halfWidth, centerY - halfHeight);
        path.lineTo(centerX + halfWidth, centerY - halfHeight);
        path.lineTo(centerX + halfWidth, centerY + halfHeight);
        path.lineTo(centerX - halfWidth, centerY + halfHeight);
        path.closePath();
        const dx2 = Math.floor((gripLineGap + strokeWidth) / 2 * pixelRatio) / pixelRatio;
        const dy2 = Math.floor(gripLineLength / 2 * pixelRatio) / pixelRatio;
        path.moveTo(centerX - dx2, centerY - dy2);
        path.lineTo(centerX - dx2, centerY + dy2);
        path.moveTo(centerX + dx2, centerY - dy2);
        path.lineTo(centerX + dx2, centerY + dy2);
      }
    };
    RangeHandle.className = "RangeHandle";
    __decorateClass([
      Validate(COLOR_STRING)
    ], RangeHandle.prototype, "_fill", 2);
    __decorateClass([
      Validate(COLOR_STRING)
    ], RangeHandle.prototype, "_stroke", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], RangeHandle.prototype, "_strokeWidth", 2);
    __decorateClass([
      Validate(LINE_CAP)
    ], RangeHandle.prototype, "_lineCap", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], RangeHandle.prototype, "_width", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], RangeHandle.prototype, "_gripLineGap", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], RangeHandle.prototype, "_gripLineLength", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], RangeHandle.prototype, "_height", 2);
  }
});

// packages/ag-charts-community/src/chart/navigator/shapes/rangeMask.ts
var RangeMask;
var init_rangeMask = __esm({
  "packages/ag-charts-community/src/chart/navigator/shapes/rangeMask.ts"() {
    "use strict";
    init_bbox();
    init_path();
    RangeMask = class extends Path {
      constructor() {
        super(...arguments);
        this.zIndex = 2;
        this.x = 0;
        this.y = 0;
        this.width = 200;
        this.height = 30;
        this.min = 0;
        this.max = 1;
      }
      layout(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.dirtyPath = true;
      }
      update(min, max) {
        this.min = isNaN(min) ? this.min : min;
        this.max = isNaN(max) ? this.max : max;
        this.dirtyPath = true;
      }
      computeBBox() {
        const { x, y, width, height } = this;
        return new BBox(x, y, width, height);
      }
      computeVisibleRangeBBox() {
        const { x, y, width, height, min, max } = this;
        const minX = x + width * min;
        const maxX = x + width * max;
        return new BBox(minX, y, maxX - minX, height);
      }
      updatePath() {
        const { path, x, y, width, height, min, max, strokeWidth } = this;
        const pixelAlign = strokeWidth / 2;
        path.clear();
        const ax = this.align(x) + pixelAlign;
        const ay = this.align(y) + pixelAlign;
        const axw = ax + this.align(x, width) - 2 * pixelAlign;
        const ayh = ay + this.align(y, height) - 2 * pixelAlign;
        path.moveTo(ax, ay);
        path.lineTo(axw, ay);
        path.lineTo(axw, ayh);
        path.lineTo(ax, ayh);
        path.closePath();
        const minX = this.align(x + width * min) + pixelAlign;
        const maxX = minX + this.align(x + width * min, width * (max - min)) - 2 * pixelAlign;
        path.moveTo(minX, ay);
        path.lineTo(minX, ayh);
        path.lineTo(maxX, ayh);
        path.lineTo(maxX, ay);
        path.closePath();
      }
    };
    RangeMask.className = "RangeMask";
  }
});

// packages/ag-charts-community/src/chart/navigator/shapes/rangeSelector.ts
var RangeSelector;
var init_rangeSelector = __esm({
  "packages/ag-charts-community/src/chart/navigator/shapes/rangeSelector.ts"() {
    "use strict";
    init_bbox();
    init_group();
    init_layers();
    RangeSelector = class extends Group {
      constructor(children) {
        super({ name: "rangeSelectorGroup", layer: true, zIndex: 12 /* NAVIGATOR_ZINDEX */ });
        this.x = 0;
        this.y = 0;
        this.width = 200;
        this.height = 30;
        this.lOffset = 0;
        this.rOffset = 0;
        this.isContainerNode = true;
        this.background = new Group({ name: "navigator-background" });
        this.background.zIndex = 1;
        this.appendChild(this.background);
        this.append(children);
      }
      layout(x, y, width, height, lOffset, rOffset) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.lOffset = lOffset;
        this.rOffset = rOffset;
        this.background.translationX = x;
        this.background.translationY = y;
      }
      updateBackground(oldGroup, newGroup) {
        if (oldGroup != null) {
          this.background.removeChild(oldGroup);
        }
        if (newGroup != null) {
          this.background.appendChild(newGroup);
        }
      }
      computeBBox() {
        const { x, y, width, height, lOffset, rOffset } = this;
        return new BBox(x - lOffset, y, width + (lOffset + rOffset), height);
      }
    };
  }
});

// packages/ag-charts-community/src/chart/navigator/navigator.ts
var Navigator;
var init_navigator = __esm({
  "packages/ag-charts-community/src/chart/navigator/navigator.ts"() {
    "use strict";
    init_module();
    init_logger();
    init_number();
    init_proxy();
    init_validation();
    init_interactionManager();
    init_rangeHandle();
    init_rangeMask();
    init_rangeSelector();
    Navigator = class extends BaseModuleInstance {
      constructor(ctx) {
        super();
        this.ctx = ctx;
        this.miniChart = void 0;
        this.enabled = false;
        this.mask = new RangeMask();
        this.minHandle = new RangeHandle();
        this.maxHandle = new RangeHandle();
        this.height = 30;
        this.margin = 10;
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.rangeSelector = new RangeSelector([this.mask, this.minHandle, this.maxHandle]);
        this._min = 0;
        this._max = 1;
        this.minRange = 1e-3;
        const region = ctx.regionManager.addRegion("navigator", this.rangeSelector);
        const dragStates = 16 /* Default */ | 1 /* Animation */ | 8 /* ZoomDrag */;
        this.destroyFns.push(
          ctx.scene.attachNode(this.rangeSelector),
          region.addListener("hover", (event) => this.onHover(event), dragStates),
          region.addListener("drag-start", (event) => this.onDragStart(event), dragStates),
          region.addListener("drag", (event) => this.onDrag(event), dragStates),
          region.addListener("drag-end", () => this.onDragEnd(), dragStates),
          region.addListener("leave", (event) => this.onLeave(event), dragStates),
          ctx.zoomManager.addListener("zoom-change", (event) => this.onZoomChange(event))
        );
        this.updateGroupVisibility();
      }
      updateBackground(oldGroup, newGroup) {
        var _a2;
        (_a2 = this.rangeSelector) == null ? void 0 : _a2.updateBackground(oldGroup, newGroup);
      }
      updateGroupVisibility() {
        const { enabled } = this;
        if (this.rangeSelector == null || enabled === this.rangeSelector.visible)
          return;
        this.rangeSelector.visible = enabled;
        if (enabled) {
          this.updateZoom();
        } else {
          this.ctx.zoomManager.updateZoom("navigator");
        }
      }
      performLayout(_0) {
        return __async(this, arguments, function* ({ shrinkRect }) {
          if (this.enabled) {
            const navigatorTotalHeight = this.height + this.margin;
            shrinkRect.shrink(navigatorTotalHeight, "bottom");
            this.y = shrinkRect.y + shrinkRect.height + this.margin;
          } else {
            this.y = 0;
          }
          return { shrinkRect };
        });
      }
      performCartesianLayout(opts) {
        return __async(this, null, function* () {
          const { x, width } = opts.seriesRect;
          if (this.enabled) {
            const { y, height } = this;
            this.layoutNodes(x, y, width, height);
          }
          this.x = x;
          this.width = width;
        });
      }
      onHover(event) {
        if (!this.enabled)
          return;
        const { mask, minHandle, maxHandle } = this;
        const { offsetX, offsetY } = event;
        if (minHandle.containsPoint(offsetX, offsetY) || maxHandle.containsPoint(offsetX, offsetY)) {
          this.ctx.cursorManager.updateCursor("navigator", "ew-resize");
        } else if (mask.computeVisibleRangeBBox().containsPoint(offsetX, offsetY)) {
          this.ctx.cursorManager.updateCursor("navigator", "grab");
        } else {
          this.ctx.cursorManager.updateCursor("navigator");
        }
      }
      onDragStart(event) {
        if (!this.enabled)
          return;
        const { mask, minHandle, maxHandle, x, width, _min: min } = this;
        const { offsetX, offsetY } = event;
        if (minHandle.zIndex < maxHandle.zIndex) {
          if (maxHandle.containsPoint(offsetX, offsetY)) {
            this.dragging = "max";
          } else if (minHandle.containsPoint(offsetX, offsetY)) {
            this.dragging = "min";
          }
        } else if (minHandle.containsPoint(offsetX, offsetY)) {
          this.dragging = "min";
        } else if (maxHandle.containsPoint(offsetX, offsetY)) {
          this.dragging = "max";
        }
        if (this.dragging == null && mask.computeVisibleRangeBBox().containsPoint(offsetX, offsetY)) {
          this.dragging = "pan";
          this.panStart = (offsetX - x) / width - min;
        }
        if (this.dragging != null) {
          this.ctx.zoomManager.fireZoomPanStartEvent("navigator");
        }
      }
      onDrag(event) {
        if (!this.enabled || this.dragging == null)
          return;
        const { dragging, minRange, panStart, x, width } = this;
        let { _min: min, _max: max } = this;
        const { offsetX } = event;
        const ratio = (offsetX - x) / width;
        if (dragging === "min") {
          min = clamp(0, ratio, max - minRange);
        } else if (dragging === "max") {
          max = clamp(min + minRange, ratio, 1);
        } else if (dragging === "pan" && panStart != null) {
          const span = max - min;
          min = clamp(0, ratio - panStart, 1 - span);
          max = min + span;
        }
        this._min = min;
        this._max = max;
        this.updateZoom();
      }
      onDragEnd() {
        this.dragging = void 0;
      }
      onLeave(_event) {
        this.ctx.cursorManager.updateCursor("navigator");
      }
      onZoomChange(event) {
        const { x } = event;
        if (!x)
          return;
        this._min = x.min;
        this._max = x.max;
        this.updateNodes(x.min, x.max);
      }
      layoutNodes(x, y, width, height) {
        const { rangeSelector, mask, minHandle, maxHandle, _min: min, _max: max } = this;
        rangeSelector.layout(x, y, width, height, minHandle.width / 2, maxHandle.width / 2);
        mask.layout(x, y, width, height);
        RangeHandle.align(minHandle, maxHandle, x, y, width, height, min, max);
        if (min + (max - min) / 2 < 0.5) {
          minHandle.zIndex = 3;
          maxHandle.zIndex = 4;
        } else {
          minHandle.zIndex = 4;
          maxHandle.zIndex = 3;
        }
      }
      updateNodes(min, max) {
        this.mask.update(min, max);
      }
      updateZoom() {
        if (!this.enabled)
          return;
        const { _min: min, _max: max } = this;
        const zoom2 = this.ctx.zoomManager.getZoom();
        if (min == null || max == null)
          return;
        const warnOnConflict = (stateId) => {
          if (this.min == null && this.max == null)
            return;
          Logger.warnOnce(
            `Could not apply [navigator.min] or [navigator.max] as [${stateId}] has modified the initial zoom state.`
          );
        };
        return this.ctx.zoomManager.updateZoom("navigator", { x: { min, max }, y: zoom2 == null ? void 0 : zoom2.y }, false, warnOnConflict);
      }
    };
    __decorateClass([
      Validate(OBJECT, { optional: true })
    ], Navigator.prototype, "miniChart", 2);
    __decorateClass([
      Validate(BOOLEAN),
      ObserveChanges((target) => target.updateGroupVisibility())
    ], Navigator.prototype, "enabled", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], Navigator.prototype, "height", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], Navigator.prototype, "margin", 2);
    __decorateClass([
      ActionOnSet({
        newValue(min) {
          this._min = min;
          this.updateZoom();
        }
      }),
      Validate(AND(RATIO, LESS_THAN("max")), { optional: true })
    ], Navigator.prototype, "min", 2);
    __decorateClass([
      ActionOnSet({
        newValue(max) {
          this._max = max;
          this.updateZoom();
        }
      }),
      Validate(AND(RATIO, GREATER_THAN("min")), { optional: true })
    ], Navigator.prototype, "max", 2);
  }
});

// packages/ag-charts-community/src/chart/navigator/navigatorModule.ts
var NavigatorModule;
var init_navigatorModule = __esm({
  "packages/ag-charts-community/src/chart/navigator/navigatorModule.ts"() {
    "use strict";
    init_navigator();
    NavigatorModule = {
      type: "root",
      optionsKey: "navigator",
      packageType: "community",
      chartTypes: ["cartesian"],
      instanceConstructor: Navigator,
      themeTemplate: {
        navigator: {
          enabled: false,
          height: 30,
          mask: {
            fill: "#999999",
            stroke: "#999999",
            strokeWidth: 1,
            fillOpacity: 0.2
          },
          minHandle: {
            fill: "#f2f2f2",
            stroke: "#999999",
            strokeWidth: 1,
            width: 9,
            height: 16,
            gripLineGap: 1,
            gripLineLength: 8
          },
          maxHandle: {
            fill: "#f2f2f2",
            stroke: "#999999",
            strokeWidth: 1,
            width: 9,
            height: 16,
            gripLineGap: 1,
            gripLineLength: 8
          }
        }
      }
    };
  }
});

// packages/ag-charts-community/src/module/theme.ts
var singleSeriesPaletteFactory, markerPaletteFactory;
var init_theme = __esm({
  "packages/ag-charts-community/src/module/theme.ts"() {
    "use strict";
    singleSeriesPaletteFactory = ({ takeColors }) => {
      const {
        fills: [fill],
        strokes: [stroke]
      } = takeColors(1);
      return { fill, stroke };
    };
    markerPaletteFactory = (params) => {
      const { fill, stroke } = singleSeriesPaletteFactory(params);
      return { marker: { fill, stroke } };
    };
  }
});

// packages/ag-charts-community/src/motion/pathMotion.ts
function pathMotion(groupId, subId, animationManager, paths, fns) {
  const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;
  const animate = (phase, path, updateFn) => {
    animationManager.animate({
      id: `${groupId}_${subId}_${path.id}_${phase}`,
      groupId,
      from: 0,
      to: 1,
      ease: easeOut,
      collapsable: false,
      onUpdate(ratio, preInit) {
        if (preInit && phase !== "removed")
          return;
        path.path.clear(true);
        updateFn(ratio, path);
        path.checkPathDirty();
      },
      onStop() {
        if (phase !== "added")
          return;
        path.path.clear(true);
        updateFn(1, path);
        path.checkPathDirty();
      },
      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]
    });
  };
  for (const path of paths) {
    if (!animationManager.isSkipped()) {
      animate("removed", path, removePhaseFn);
      animate("updated", path, updatePhaseFn);
    }
    animate("added", path, addPhaseFn);
  }
}
var init_pathMotion = __esm({
  "packages/ag-charts-community/src/motion/pathMotion.ts"() {
    "use strict";
    init_easing();
    init_fromToMotion();
  }
});

// packages/ag-charts-community/src/util/sanitize.ts
function sanitizeHtml(text) {
  if (text == null) {
    return;
  } else if (text === "") {
    return "";
  }
  element != null ? element : element = createElement("div");
  element.textContent = String(text);
  return element.innerHTML;
}
var element;
var init_sanitize = __esm({
  "packages/ag-charts-community/src/util/sanitize.ts"() {
    "use strict";
    init_dom();
    element = null;
  }
});

// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts
function seriesLabelFadeInAnimation({ id }, subId, animationManager, ...labelSelections) {
  staticFromToMotion(
    id,
    subId,
    animationManager,
    labelSelections,
    { opacity: 0 },
    { opacity: 1 },
    { phase: "trailing" }
  );
}
function seriesLabelFadeOutAnimation({ id }, subId, animationManager, ...labelSelections) {
  staticFromToMotion(
    id,
    subId,
    animationManager,
    labelSelections,
    { opacity: 1 },
    { opacity: 0 },
    { phase: "remove" }
  );
}
function resetLabelFn(_node) {
  return { opacity: 1 };
}
var init_seriesLabelUtil = __esm({
  "packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts"() {
    "use strict";
    init_fromToMotion();
  }
});

// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts
var ChangeDetectableProperties;
var init_changeDetectableProperties = __esm({
  "packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts"() {
    "use strict";
    init_properties();
    init_changeDetectable();
    ChangeDetectableProperties = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this._dirty = 3 /* MAJOR */;
      }
      markDirty(_source, type = 1 /* TRIVIAL */) {
        if (this._dirty < type) {
          this._dirty = type;
        }
      }
      markClean(_opts) {
        this._dirty = 0 /* NONE */;
      }
      isDirty() {
        return this._dirty > 0 /* NONE */;
      }
    };
  }
});

// packages/ag-charts-community/src/scene/dropShadow.ts
var DropShadow;
var init_dropShadow = __esm({
  "packages/ag-charts-community/src/scene/dropShadow.ts"() {
    "use strict";
    init_validation();
    init_changeDetectable();
    init_node();
    init_changeDetectableProperties();
    DropShadow = class extends ChangeDetectableProperties {
      constructor() {
        super(...arguments);
        this.enabled = true;
        this.color = "rgba(0, 0, 0, 0.5)";
        this.xOffset = 0;
        this.yOffset = 0;
        this.blur = 5;
      }
    };
    __decorateClass([
      Validate(BOOLEAN),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], DropShadow.prototype, "enabled", 2);
    __decorateClass([
      Validate(COLOR_STRING),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], DropShadow.prototype, "color", 2);
    __decorateClass([
      Validate(NUMBER),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], DropShadow.prototype, "xOffset", 2);
    __decorateClass([
      Validate(NUMBER),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], DropShadow.prototype, "yOffset", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], DropShadow.prototype, "blur", 2);
  }
});

// packages/ag-charts-community/src/chart/series/seriesMarker.ts
var MARKER_SHAPE, SeriesMarker;
var init_seriesMarker = __esm({
  "packages/ag-charts-community/src/chart/series/seriesMarker.ts"() {
    "use strict";
    init_changeDetectable();
    init_changeDetectableProperties();
    init_validation();
    init_circle();
    init_marker();
    init_util();
    MARKER_SHAPE = predicateWithMessage(
      (value) => isMarkerShape(value) || typeof Marker === "function" && Object.create(value.prototype) instanceof Marker,
      `a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`
    );
    SeriesMarker = class extends ChangeDetectableProperties {
      constructor() {
        super(...arguments);
        this.enabled = true;
        this.shape = Circle;
        this.size = 6;
        this.fillOpacity = 1;
        this.strokeWidth = 1;
        this.strokeOpacity = 1;
      }
      getStyle() {
        const { size, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = this;
        return { size, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };
      }
      getDiameter() {
        return this.size + this.strokeWidth;
      }
    };
    __decorateClass([
      Validate(BOOLEAN),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], SeriesMarker.prototype, "enabled", 2);
    __decorateClass([
      Validate(MARKER_SHAPE),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], SeriesMarker.prototype, "shape", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], SeriesMarker.prototype, "size", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true }),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], SeriesMarker.prototype, "fill", 2);
    __decorateClass([
      Validate(RATIO),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], SeriesMarker.prototype, "fillOpacity", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true }),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], SeriesMarker.prototype, "stroke", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], SeriesMarker.prototype, "strokeWidth", 2);
    __decorateClass([
      Validate(RATIO),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], SeriesMarker.prototype, "strokeOpacity", 2);
    __decorateClass([
      Validate(FUNCTION, { optional: true }),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], SeriesMarker.prototype, "formatter", 2);
  }
});

// packages/ag-charts-community/src/chart/series/seriesTooltip.ts
var SeriesTooltipInteraction, SeriesTooltip;
var init_seriesTooltip = __esm({
  "packages/ag-charts-community/src/chart/series/seriesTooltip.ts"() {
    "use strict";
    init_properties();
    init_validation();
    init_tooltip();
    SeriesTooltipInteraction = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.enabled = false;
      }
    };
    __decorateClass([
      Validate(BOOLEAN)
    ], SeriesTooltipInteraction.prototype, "enabled", 2);
    SeriesTooltip = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.enabled = true;
        this.interaction = new SeriesTooltipInteraction();
        this.position = new TooltipPosition();
      }
      toTooltipHtml(defaults, params) {
        if (this.renderer) {
          return toTooltipHtml(this.renderer(params), defaults);
        }
        return toTooltipHtml(defaults);
      }
    };
    __decorateClass([
      Validate(BOOLEAN)
    ], SeriesTooltip.prototype, "enabled", 2);
    __decorateClass([
      Validate(BOOLEAN, { optional: true })
    ], SeriesTooltip.prototype, "showArrow", 2);
    __decorateClass([
      Validate(FUNCTION, { optional: true })
    ], SeriesTooltip.prototype, "renderer", 2);
    __decorateClass([
      Validate(OBJECT)
    ], SeriesTooltip.prototype, "interaction", 2);
    __decorateClass([
      Validate(OBJECT)
    ], SeriesTooltip.prototype, "position", 2);
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts
var AreaSeriesProperties;
var init_areaSeriesProperties = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts"() {
    "use strict";
    init_dropShadow();
    init_validation();
    init_label();
    init_seriesMarker();
    init_seriesTooltip();
    init_cartesianSeries();
    AreaSeriesProperties = class extends CartesianSeriesProperties {
      constructor() {
        super(...arguments);
        this.xName = void 0;
        this.fill = "#c16068";
        this.fillOpacity = 1;
        this.stroke = "#874349";
        this.strokeWidth = 2;
        this.strokeOpacity = 1;
        this.lineDash = [0];
        this.lineDashOffset = 0;
        this.shadow = new DropShadow();
        this.marker = new SeriesMarker();
        this.label = new Label();
        this.tooltip = new SeriesTooltip();
        this.connectMissingData = false;
      }
    };
    __decorateClass([
      Validate(STRING)
    ], AreaSeriesProperties.prototype, "xKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], AreaSeriesProperties.prototype, "xName", 2);
    __decorateClass([
      Validate(STRING)
    ], AreaSeriesProperties.prototype, "yKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], AreaSeriesProperties.prototype, "yName", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], AreaSeriesProperties.prototype, "normalizedTo", 2);
    __decorateClass([
      Validate(COLOR_STRING)
    ], AreaSeriesProperties.prototype, "fill", 2);
    __decorateClass([
      Validate(RATIO)
    ], AreaSeriesProperties.prototype, "fillOpacity", 2);
    __decorateClass([
      Validate(COLOR_STRING)
    ], AreaSeriesProperties.prototype, "stroke", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], AreaSeriesProperties.prototype, "strokeWidth", 2);
    __decorateClass([
      Validate(RATIO)
    ], AreaSeriesProperties.prototype, "strokeOpacity", 2);
    __decorateClass([
      Validate(LINE_DASH)
    ], AreaSeriesProperties.prototype, "lineDash", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], AreaSeriesProperties.prototype, "lineDashOffset", 2);
    __decorateClass([
      Validate(OBJECT)
    ], AreaSeriesProperties.prototype, "shadow", 2);
    __decorateClass([
      Validate(OBJECT)
    ], AreaSeriesProperties.prototype, "marker", 2);
    __decorateClass([
      Validate(OBJECT)
    ], AreaSeriesProperties.prototype, "label", 2);
    __decorateClass([
      Validate(OBJECT)
    ], AreaSeriesProperties.prototype, "tooltip", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], AreaSeriesProperties.prototype, "connectMissingData", 2);
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts
function markerFadeInAnimation({ id }, animationManager, status, ...markerSelections) {
  const params = { phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : "trailing" };
  staticFromToMotion(id, "markers", animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);
  markerSelections.forEach((s) => s.cleanup());
}
function markerScaleInAnimation({ id }, animationManager, ...markerSelections) {
  staticFromToMotion(
    id,
    "markers",
    animationManager,
    markerSelections,
    { scalingX: 0, scalingY: 0 },
    { scalingX: 1, scalingY: 1 },
    { phase: "initial" }
  );
  markerSelections.forEach((s) => s.cleanup());
}
function markerSwipeScaleInAnimation({ id, nodeDataDependencies }, animationManager, ...markerSelections) {
  const seriesWidth = nodeDataDependencies.seriesRectWidth;
  const fromFn = (_, datum) => {
    var _a2, _b;
    const x = (_b = (_a2 = datum.midPoint) == null ? void 0 : _a2.x) != null ? _b : seriesWidth;
    let delay = clamp(0, inverseEaseOut(x / seriesWidth), 1);
    if (isNaN(delay)) {
      delay = 0;
    }
    return { scalingX: 0, scalingY: 0, delay, duration: QUICK_TRANSITION, phase: "initial" };
  };
  const toFn = () => {
    return { scalingX: 1, scalingY: 1 };
  };
  fromToMotion(id, "markers", animationManager, markerSelections, { fromFn, toFn });
}
function resetMarkerFn(_node) {
  return { opacity: 1, scalingX: 1, scalingY: 1 };
}
function resetMarkerPositionFn(_node, datum) {
  var _a2, _b, _c, _d;
  return {
    translationX: (_b = (_a2 = datum.point) == null ? void 0 : _a2.x) != null ? _b : NaN,
    translationY: (_d = (_c = datum.point) == null ? void 0 : _c.y) != null ? _d : NaN
  };
}
function prepareMarkerAnimation(pairMap, parentStatus) {
  const readFirstPair = (xValue, type) => {
    const val = pairMap[type][xValue];
    return Array.isArray(val) ? val[0] : val;
  };
  const markerStatus = (datum) => {
    const { xValue } = datum;
    if (pairMap.moved[xValue]) {
      return { point: readFirstPair(xValue, "moved"), status: "updated" };
    } else if (pairMap.removed[xValue]) {
      return { point: readFirstPair(xValue, "removed"), status: "removed" };
    } else if (pairMap.added[xValue]) {
      return { point: readFirstPair(xValue, "added"), status: "added" };
    }
    return { status: "unknown" };
  };
  const fromFn = (marker, datum) => {
    var _a2, _b, _c, _d, _e, _f;
    const { status, point } = markerStatus(datum);
    if (status === "unknown")
      return { opacity: 0 };
    const defaults = {
      translationX: (_b = (_a2 = point == null ? void 0 : point.from) == null ? void 0 : _a2.x) != null ? _b : marker.translationX,
      translationY: (_d = (_c = point == null ? void 0 : point.from) == null ? void 0 : _c.y) != null ? _d : marker.translationY,
      opacity: marker.opacity,
      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
    };
    if (parentStatus === "added") {
      return __spreadProps(__spreadValues({}, defaults), {
        opacity: 0,
        translationX: (_e = point == null ? void 0 : point.to) == null ? void 0 : _e.x,
        translationY: (_f = point == null ? void 0 : point.to) == null ? void 0 : _f.y,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["added"]
      });
    }
    if (status === "added") {
      defaults.opacity = 0;
    }
    return defaults;
  };
  const toFn = (_marker, datum) => {
    var _a2, _b;
    const { status, point } = markerStatus(datum);
    if (status === "unknown")
      return { opacity: 0 };
    const defaults = {
      translationX: datum.point.x,
      translationY: datum.point.y,
      opacity: 1,
      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]
    };
    if (status === "removed" || parentStatus === "removed") {
      return __spreadProps(__spreadValues({}, defaults), {
        translationX: (_a2 = point == null ? void 0 : point.to) == null ? void 0 : _a2.x,
        translationY: (_b = point == null ? void 0 : point.to) == null ? void 0 : _b.y,
        opacity: 0,
        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING["removed"]
      });
    }
    return defaults;
  };
  return { fromFn, toFn };
}
function computeMarkerFocusBounds(series, { datumIndex }) {
  const nodeData = series.getNodeData();
  if (nodeData === void 0)
    return void 0;
  const datum = nodeData[datumIndex];
  if (datum === void 0 || datum.point === void 0)
    return void 0;
  const size = series.getFormattedMarkerStyle(datum).size;
  const radius = size / 2;
  const { x, y } = series.contentGroup.inverseTransformPoint(datum.point.x - radius, datum.point.y - radius);
  return new BBox(x, y, size, size);
}
var init_markerUtil = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts"() {
    "use strict";
    init_animation();
    init_fromToMotion();
    init_bbox();
    init_number();
    init_easing();
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts
function minMax(nodeData) {
  return nodeData.reduce(
    ({ min, max }, node) => {
      if (min == null || min.point.x > node.point.x) {
        min = node;
      }
      if (max == null || max.point.x < node.point.x) {
        max = node;
      }
      return { min, max };
    },
    {}
  );
}
function intersectionOnLine(a, b, targetX) {
  const m = (b.y - a.y) / (b.x - a.x);
  const y = (targetX - a.x) * m + a.y;
  return { x: targetX, y };
}
function backfillPathPoint(results, process, skip, processFn) {
  let prevMarkerIdx = -1, nextMarkerIdx = 0;
  const toProcess = [];
  while (nextMarkerIdx < results.length) {
    if (results[nextMarkerIdx].change === process) {
      toProcess.push(results[nextMarkerIdx]);
      nextMarkerIdx++;
      continue;
    }
    if (results[nextMarkerIdx].change === skip) {
      nextMarkerIdx++;
      continue;
    }
    if (toProcess.length > 0) {
      processFn(toProcess, prevMarkerIdx, nextMarkerIdx);
      toProcess.length = 0;
    }
    prevMarkerIdx = nextMarkerIdx;
    nextMarkerIdx++;
  }
  if (toProcess.length > 0) {
    processFn(toProcess, prevMarkerIdx, nextMarkerIdx);
  }
}
function backfillPathPointData(result, splitMode) {
  backfillPathPoint(result, "out", "in", (toProcess, sIdx, eIdx) => {
    var _a2, _b;
    if (sIdx === -1 && result[eIdx]) {
      toProcess.forEach((d) => d.to = result[eIdx].from);
    } else if (eIdx === result.length && result[sIdx]) {
      toProcess.forEach((d) => d.to = result[sIdx].from);
    } else if (splitMode === "intersect" && ((_a2 = result[sIdx]) == null ? void 0 : _a2.from) && ((_b = result[eIdx]) == null ? void 0 : _b.from)) {
      toProcess.forEach((d) => d.to = intersectionOnLine(result[sIdx].from, result[eIdx].from, d.from.x));
    } else {
      toProcess.forEach((d) => d.to = d.from);
    }
  });
  backfillPathPoint(result, "in", "out", (toProcess, sIdx, eIdx) => {
    var _a2, _b;
    if (sIdx === -1 && result[eIdx]) {
      toProcess.forEach((d) => d.from = result[eIdx].to);
    } else if (eIdx === result.length && result[sIdx]) {
      toProcess.forEach((d) => d.from = result[sIdx].to);
    } else if (splitMode === "intersect" && ((_a2 = result[sIdx]) == null ? void 0 : _a2.to) && ((_b = result[eIdx]) == null ? void 0 : _b.to)) {
      toProcess.forEach((d) => d.from = intersectionOnLine(result[sIdx].to, result[eIdx].to, d.to.x));
    } else {
      toProcess.forEach((d) => d.from = d.to);
    }
  });
}
function calculatePoint(from, to, ratio) {
  const x1 = isNaN(from.x) ? to.x : from.x;
  const y1 = isNaN(from.y) ? to.y : from.y;
  const xd = to.x - from.x;
  const yd = to.y - from.y;
  const xr = isNaN(xd) ? 0 : xd * ratio;
  const yr = isNaN(yd) ? 0 : yd * ratio;
  return {
    x: x1 + xr,
    y: y1 + yr
  };
}
function renderPartialPath(pairData, ratios, path) {
  const { path: linePath } = path;
  let previousTo;
  for (const data of pairData) {
    const { from, to } = data;
    const ratio = ratios[data.change];
    if (ratio == null || from == null || to == null)
      continue;
    const { x, y } = calculatePoint(from, to, ratio);
    if (data.moveTo === false) {
      linePath.lineTo(x, y);
    } else if (data.moveTo === true || !previousTo) {
      linePath.moveTo(x, y);
    } else if (previousTo) {
      const moveToRatio = data.moveTo === "in" ? ratio : 1 - ratio;
      const { x: midPointX, y: midPointY } = calculatePoint(previousTo, { x, y }, moveToRatio);
      linePath.lineTo(midPointX, midPointY);
      linePath.moveTo(x, y);
    }
    previousTo = { x, y };
  }
}
function pathSwipeInAnimation({ id, visible, nodeDataDependencies }, animationManager, ...paths) {
  const { seriesRectWidth: width, seriesRectHeight: height } = nodeDataDependencies;
  staticFromToMotion(
    id,
    "path_properties",
    animationManager,
    paths,
    { clipX: 0 },
    { clipX: width },
    {
      phase: "initial",
      start: { clipMode: "normal", clipY: height, visible },
      finish: { clipMode: void 0, visible }
    }
  );
}
function pathFadeInAnimation({ id }, subId, animationManager, phase = "add", ...selection) {
  staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, { phase });
}
function pathFadeOutAnimation({ id }, subId, animationManager, ...selection) {
  staticFromToMotion(id, subId, animationManager, selection, { opacity: 1 }, { opacity: 0 }, { phase: "remove" });
}
function buildResetPathFn(opts) {
  return (_node) => {
    return { opacity: opts.getOpacity(), clipScalingX: 1, clipMode: void 0 };
  };
}
function updateClipPath({ nodeDataDependencies }, path) {
  const toFinite = (value) => isFinite(value) ? value : 0;
  path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);
  path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);
}
var init_pathUtil = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts"() {
    "use strict";
    init_fromToMotion();
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/scaling.ts
function isContinuousScaling(scaling) {
  return scaling.type === "continuous" || scaling.type === "log";
}
function isCategoryScaling(scaling) {
  return scaling.type === "category";
}
function areEqual(a, b) {
  return a.domain.length === b.domain.length && a.range.length === b.range.length && a.domain.every((val, index) => val === b.domain[index]) && a.range.every((val, index) => val === b.range[index]);
}
function areScalingEqual(a, b) {
  if (a === void 0 || b === void 0) {
    return a !== void 0 || b !== void 0;
  }
  if (isContinuousScaling(a) && isContinuousScaling(b)) {
    return a.type === b.type && areEqual(a, b);
  }
  if (isCategoryScaling(a) && isCategoryScaling(b)) {
    return areEqual(a, b);
  }
  return false;
}
var init_scaling = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/scaling.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts
function scale(val, scaling) {
  if (!scaling)
    return NaN;
  if (val instanceof Date) {
    val = val.getTime();
  }
  if (scaling.type === "continuous" && typeof val === "number") {
    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);
    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];
  }
  if (scaling.type === "log" && typeof val === "number") {
    return scaling.convert(val);
  }
  const matchingIndex = scaling.domain.findIndex((d) => d === val);
  if (matchingIndex >= 0) {
    return scaling.range[matchingIndex];
  }
  return NaN;
}
function scalesChanged(newData, oldData) {
  return !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y);
}
function closeMatch(a, b) {
  const an = Number(a);
  const bn = Number(b);
  if (!isNaN(an) && !isNaN(bn)) {
    return Math.abs(bn - an) < 0.25;
  }
  return a === b;
}
function calculateMoveTo(from = false, to = false) {
  if (from === to) {
    return Boolean(from);
  }
  return from ? "in" : "out";
}
function pairContinuousData(newData, oldData, opts = {}) {
  var _a2, _b, _c, _d;
  const { backfillSplitMode = "intersect" } = opts;
  const toNewScale = (oldDatum) => {
    var _a3, _b2;
    return {
      x: scale((_a3 = oldDatum.xValue) != null ? _a3 : NaN, newData.scales.x),
      y: scale((_b2 = oldDatum.yValue) != null ? _b2 : NaN, newData.scales.y)
    };
  };
  const toOldScale = (newDatum) => {
    var _a3, _b2;
    return {
      x: scale((_a3 = newDatum.xValue) != null ? _a3 : NaN, oldData.scales.x),
      y: scale((_b2 = newDatum.yValue) != null ? _b2 : NaN, oldData.scales.y)
    };
  };
  const result = [];
  const resultMap = {
    added: {},
    moved: {},
    removed: {}
  };
  const pairUp = (from, to, xValue, change = "move") => {
    if (from && (isNaN(from.point.x) || isNaN(from.point.y))) {
      from = to;
    }
    const resultPoint = {
      from: from == null ? void 0 : from.point,
      to: to == null ? void 0 : to.point,
      moveTo: calculateMoveTo(from == null ? void 0 : from.point.moveTo, to == null ? void 0 : to.point.moveTo),
      change
    };
    if (change === "move") {
      resultMap.moved[xValue] = resultPoint;
      oldIdx++;
      newIdx++;
    } else if (change === "in") {
      resultMap.added[xValue] = resultPoint;
      newIdx++;
    } else if (change === "out") {
      resultMap.removed[xValue] = resultPoint;
      oldIdx++;
    }
    result.push(resultPoint);
  };
  const { min: minFromNode, max: maxFromNode } = minMax(oldData.nodeData);
  const { min: minToNode, max: maxToNode } = minMax(newData.nodeData);
  let oldIdx = 0;
  let newIdx = 0;
  while (oldIdx < oldData.nodeData.length || newIdx < newData.nodeData.length) {
    const from = oldData.nodeData[oldIdx];
    const to = newData.nodeData[newIdx];
    const fromShifted = from ? toNewScale(from) : void 0;
    const toUnshifted = to ? toOldScale(to) : void 0;
    const NA = void 0;
    if (fromShifted && closeMatch(fromShifted.x, to == null ? void 0 : to.point.x)) {
      pairUp(from, to, to.xValue, "move");
    } else if (fromShifted && fromShifted.x < ((_a2 = minToNode == null ? void 0 : minToNode.point.x) != null ? _a2 : -Infinity)) {
      pairUp(from, NA, from.xValue, "out");
    } else if (fromShifted && fromShifted.x > ((_b = maxToNode == null ? void 0 : maxToNode.point.x) != null ? _b : Infinity)) {
      pairUp(from, NA, from.xValue, "out");
    } else if (toUnshifted && toUnshifted.x < ((_c = minFromNode == null ? void 0 : minFromNode.point.x) != null ? _c : -Infinity)) {
      pairUp(NA, to, to.xValue, "in");
    } else if (toUnshifted && toUnshifted.x > ((_d = maxFromNode == null ? void 0 : maxFromNode.point.x) != null ? _d : Infinity)) {
      pairUp(NA, to, to.xValue, "in");
    } else if (fromShifted && fromShifted.x < (to == null ? void 0 : to.point.x)) {
      pairUp(from, NA, from.xValue, "out");
    } else if (toUnshifted && toUnshifted.x < (from == null ? void 0 : from.point.x)) {
      pairUp(NA, to, to.xValue, "in");
    } else if (from) {
      pairUp(from, NA, from.xValue, "out");
    } else if (to) {
      pairUp(NA, to, to.xValue, "in");
    } else {
      throw new Error("Unable to process points");
    }
  }
  backfillPathPointData(result, backfillSplitMode);
  return { result, resultMap };
}
function pairCategoryData(newData, oldData, diff8, opts = {}) {
  var _a2, _b, _c;
  const { backfillSplitMode = "intersect", multiDatum = false } = opts;
  const result = [];
  const resultMapSingle = {
    added: {},
    moved: {},
    removed: {}
  };
  const resultMapMulti = {
    added: {},
    moved: {},
    removed: {}
  };
  const pointResultMapping = {
    in: "added",
    move: "moved",
    out: "removed"
  };
  let previousResultPoint = void 0;
  let previousXValue = void 0;
  const addToResultMap = (xValue, newPoint) => {
    var _a3, _b2;
    const type = pointResultMapping[newPoint.change];
    if (multiDatum) {
      (_b2 = (_a3 = resultMapMulti[type])[xValue]) != null ? _b2 : _a3[xValue] = [];
      resultMapMulti[type][xValue].push(newPoint);
    } else {
      resultMapSingle[type][xValue] = newPoint;
    }
    previousResultPoint = newPoint;
    previousXValue = transformIntegratedCategoryValue(xValue);
  };
  let oldIndex = 0;
  let newIndex = 0;
  let isXUnordered = false;
  while (oldIndex < oldData.nodeData.length || newIndex < newData.nodeData.length) {
    const before = oldData.nodeData[oldIndex];
    const after = newData.nodeData[newIndex];
    const bXValue = transformIntegratedCategoryValue(before == null ? void 0 : before.xValue);
    const aXValue = transformIntegratedCategoryValue(after == null ? void 0 : after.xValue);
    let resultPoint;
    if (bXValue === aXValue) {
      resultPoint = {
        change: "move",
        moveTo: calculateMoveTo((_a2 = before.point.moveTo) != null ? _a2 : false, after.point.moveTo),
        from: before.point,
        to: after.point
      };
      addToResultMap(before == null ? void 0 : before.xValue, resultPoint);
      oldIndex++;
      newIndex++;
    } else if (diff8 == null ? void 0 : diff8.removed.has(String(bXValue))) {
      resultPoint = {
        change: "out",
        moveTo: (_b = before.point.moveTo) != null ? _b : false,
        from: before.point
      };
      addToResultMap(before == null ? void 0 : before.xValue, resultPoint);
      oldIndex++;
    } else if (diff8 == null ? void 0 : diff8.added.has(String(aXValue))) {
      resultPoint = {
        change: "in",
        moveTo: (_c = after.point.moveTo) != null ? _c : false,
        to: after.point
      };
      addToResultMap(after == null ? void 0 : after.xValue, resultPoint);
      newIndex++;
    } else if (multiDatum && previousResultPoint && previousXValue === bXValue) {
      resultPoint = __spreadValues({}, previousResultPoint);
      addToResultMap(before == null ? void 0 : before.xValue, resultPoint);
      oldIndex++;
    } else if (multiDatum && previousResultPoint && previousXValue === aXValue) {
      resultPoint = __spreadValues({}, previousResultPoint);
      addToResultMap(after == null ? void 0 : after.xValue, resultPoint);
      newIndex++;
    } else {
      isXUnordered = true;
      break;
    }
    result.push(resultPoint);
  }
  let previousX = -Infinity;
  isXUnordered || (isXUnordered = result.some((pathPoint) => {
    const { change: marker, to: { x = -Infinity } = {} } = pathPoint;
    if (marker === "out")
      return;
    const unordered = x < previousX;
    previousX = x;
    return unordered;
  }));
  if (isXUnordered) {
    return { result: void 0, resultMap: void 0 };
  }
  backfillPathPointData(result, backfillSplitMode);
  return { result, resultMap: multiDatum ? resultMapMulti : resultMapSingle };
}
function determinePathStatus(newData, oldData, pairData) {
  var _a2, _b, _c, _d;
  let status = "updated";
  const visible = (data) => {
    return data.visible;
  };
  if (!visible(oldData) && visible(newData)) {
    status = "added";
  } else if (visible(oldData) && !visible(newData)) {
    status = "removed";
  } else {
    for (let i = 0; i < pairData.length; i++) {
      if (pairData[i].change !== "move")
        break;
      if (((_a2 = pairData[i].from) == null ? void 0 : _a2.x) !== ((_b = pairData[i].to) == null ? void 0 : _b.x))
        break;
      if (((_c = pairData[i].from) == null ? void 0 : _c.y) !== ((_d = pairData[i].to) == null ? void 0 : _d.y))
        break;
      if (i === pairData.length - 1)
        return "no-op";
    }
  }
  return status;
}
function prepareLinePathPropertyAnimation(status, visibleToggleMode) {
  const phase = visibleToggleMode === "none" ? "updated" : status;
  const result = {
    fromFn: (_path) => {
      let mixin;
      if (status === "removed") {
        mixin = { finish: { visible: false } };
      } else if (status === "added") {
        mixin = { start: { visible: true } };
      } else {
        mixin = {};
      }
      return __spreadValues({ phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] }, mixin);
    },
    toFn: (_path) => {
      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] };
    }
  };
  if (visibleToggleMode === "fade") {
    return {
      fromFn: (path) => {
        const opacity = status === "added" ? 0 : path.opacity;
        return __spreadValues({ opacity }, result.fromFn(path));
      },
      toFn: (path) => {
        const opacity = status === "removed" ? 0 : 1;
        return __spreadValues({ opacity }, result.toFn(path));
      }
    };
  }
  return result;
}
function prepareLinePathAnimationFns(newData, oldData, pairData, visibleToggleMode, render) {
  const status = determinePathStatus(newData, oldData, pairData);
  const removePhaseFn = (ratio, path) => {
    render(pairData, { move: 0, out: ratio }, path);
  };
  const updatePhaseFn = (ratio, path) => {
    render(pairData, { move: ratio }, path);
  };
  const addPhaseFn = (ratio, path) => {
    render(pairData, { move: 1, in: ratio }, path);
  };
  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);
  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };
}
function prepareLinePathAnimation(newData, oldData, diff8) {
  var _a2, _b, _c;
  const isCategoryBased = ((_a2 = newData.scales.x) == null ? void 0 : _a2.type) === "category";
  const wasCategoryBased = ((_b = oldData.scales.x) == null ? void 0 : _b.type) === "category";
  if (isCategoryBased !== wasCategoryBased) {
    return;
  }
  const { result: pairData, resultMap: pairMap } = isCategoryBased ? pairCategoryData(newData, oldData, diff8) : pairContinuousData(newData, oldData);
  let status = "updated";
  if (oldData.visible && !newData.visible) {
    status = "removed";
  } else if (!oldData.visible && newData.visible) {
    status = "added";
  }
  if (pairData === void 0 || pairMap === void 0) {
    return;
  }
  const hasMotion = ((_c = diff8 == null ? void 0 : diff8.changed) != null ? _c : true) || scalesChanged(newData, oldData) || status !== "updated";
  const pathFns = prepareLinePathAnimationFns(newData, oldData, pairData, "fade", renderPartialPath);
  const marker = prepareMarkerAnimation(pairMap, status);
  return __spreadProps(__spreadValues({}, pathFns), { marker, hasMotion });
}
var init_lineUtil = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts"() {
    "use strict";
    init_fromToMotion();
    init_value();
    init_markerUtil();
    init_pathUtil();
    init_scaling();
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts
function splitFillPoints(context) {
  const { points, phantomPoints } = context.fillData;
  return { top: points, bottom: phantomPoints };
}
function prepPoints(key, ctx, points) {
  return {
    scales: ctx.scales,
    nodeData: points[key],
    visible: ctx.visible
  };
}
function pairFillCategoryData(newData, oldData, diff8) {
  const oldPoints = splitFillPoints(oldData);
  const newPoints = splitFillPoints(newData);
  const pairOpts = { multiDatum: true };
  return {
    top: pairCategoryData(
      prepPoints("top", newData, newPoints),
      prepPoints("top", oldData, oldPoints),
      diff8,
      pairOpts
    ),
    bottom: pairCategoryData(
      prepPoints("bottom", newData, newPoints),
      prepPoints("bottom", oldData, oldPoints),
      diff8,
      pairOpts
    )
  };
}
function pairFillContinuousData(newData, oldData) {
  const oldPoints = splitFillPoints(oldData);
  const newPoints = splitFillPoints(newData);
  return {
    top: pairContinuousData(prepPoints("top", newData, newPoints), prepPoints("top", oldData, oldPoints)),
    bottom: pairContinuousData(prepPoints("bottom", newData, newPoints), prepPoints("bottom", oldData, oldPoints))
  };
}
function prepareAreaPathAnimation(newData, oldData, diff8) {
  var _a2, _b;
  const isCategoryBased = ((_a2 = newData.scales.x) == null ? void 0 : _a2.type) === "category";
  const wasCategoryBased = ((_b = oldData.scales.x) == null ? void 0 : _b.type) === "category";
  if (isCategoryBased !== wasCategoryBased) {
    return;
  }
  let status = "updated";
  if (oldData.visible && !newData.visible) {
    status = "removed";
  } else if (!oldData.visible && newData.visible) {
    status = "added";
  }
  const prepareMarkerPairs = () => {
    if (isCategoryBased) {
      return pairCategoryData(newData, oldData, diff8, { backfillSplitMode: "static", multiDatum: true });
    }
    return pairContinuousData(newData, oldData, { backfillSplitMode: "static" });
  };
  const prepareFillPairs = () => {
    if (isCategoryBased) {
      return pairFillCategoryData(newData, oldData, diff8);
    }
    return pairFillContinuousData(newData, oldData);
  };
  const { resultMap: markerPairMap } = prepareMarkerPairs();
  const { top, bottom } = prepareFillPairs();
  if (markerPairMap === void 0 || top.result === void 0 || bottom.result === void 0) {
    return;
  }
  const pairData = [...top.result, ...bottom.result.reverse()];
  const stackVisible = oldData.stackVisible ? newData.stackVisible : false;
  const fadeMode = stackVisible ? "none" : "fade";
  const fill = prepareLinePathAnimationFns(newData, oldData, pairData, fadeMode, renderPartialPath);
  const marker = prepareMarkerAnimation(markerPairMap, status);
  return { status: fill.status, fill, marker };
}
var AreaSeriesTag;
var init_areaUtil = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts"() {
    "use strict";
    init_lineUtil();
    init_markerUtil();
    init_pathUtil();
    AreaSeriesTag = /* @__PURE__ */ ((AreaSeriesTag3) => {
      AreaSeriesTag3[AreaSeriesTag3["Fill"] = 0] = "Fill";
      AreaSeriesTag3[AreaSeriesTag3["Stroke"] = 1] = "Stroke";
      AreaSeriesTag3[AreaSeriesTag3["Marker"] = 2] = "Marker";
      AreaSeriesTag3[AreaSeriesTag3["Label"] = 3] = "Label";
      return AreaSeriesTag3;
    })(AreaSeriesTag || {});
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts
var AreaSeries;
var init_areaSeries = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts"() {
    "use strict";
    init_fromToMotion();
    init_pathMotion();
    init_resetMotion();
    init_group();
    init_node();
    init_array();
    init_function();
    init_object();
    init_sanitize();
    init_type_guards();
    init_value();
    init_logAxis();
    init_timeAxis();
    init_chartAxisDirection();
    init_dataModel();
    init_processors();
    init_util();
    init_tooltip();
    init_series();
    init_seriesLabelUtil();
    init_areaSeriesProperties();
    init_areaUtil();
    init_cartesianSeries();
    init_markerUtil();
    init_pathUtil();
    AreaSeries = class extends CartesianSeries {
      constructor(moduleCtx) {
        super({
          moduleCtx,
          directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
          directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
          pathsPerSeries: 2,
          pathsZIndexSubOrderOffset: [0, 1e3],
          hasMarkers: true,
          markerSelectionGarbageCollection: false,
          pickModes: [1 /* NEAREST_BY_MAIN_AXIS_FIRST */, 0 /* EXACT_SHAPE_MATCH */],
          animationResetFns: {
            path: buildResetPathFn({ getOpacity: () => this.getOpacity() }),
            label: resetLabelFn,
            marker: (node, datum) => __spreadValues(__spreadValues({}, resetMarkerFn(node)), resetMarkerPositionFn(node, datum))
          }
        });
        this.properties = new AreaSeriesProperties();
      }
      processData(dataController) {
        return __async(this, null, function* () {
          var _a2, _b;
          if (this.data == null || !this.properties.isValid()) {
            return;
          }
          const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;
          const { xKey, yKey, connectMissingData, normalizedTo } = this.properties;
          const animationEnabled = !this.ctx.animationManager.isSkipped();
          const xScale = (_a2 = this.axes["x" /* X */]) == null ? void 0 : _a2.scale;
          const yScale = (_b = this.axes["y" /* Y */]) == null ? void 0 : _b.scale;
          const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
          const ids = [
            `area-stack-${groupIndex}-yValues`,
            `area-stack-${groupIndex}-yValues-trailing`,
            `area-stack-${groupIndex}-yValues-prev`,
            `area-stack-${groupIndex}-yValues-trailing-prev`,
            `area-stack-${groupIndex}-yValues-marker`
          ];
          const extraProps = [];
          if (isDefined(normalizedTo)) {
            extraProps.push(normaliseGroupTo([ids[0], ids[1], ids[4]], normalizedTo, "range"));
            extraProps.push(normaliseGroupTo([ids[2], ids[3]], normalizedTo, "range"));
          }
          if (!isContinuousX && animationEnabled && this.processedData) {
            extraProps.push(diff(this.processedData));
          }
          if (animationEnabled) {
            extraProps.push(animationValidation());
          }
          const common = { invalidValue: null };
          if (connectMissingData && stackCount > 1) {
            common.invalidValue = 0;
          }
          if (!visible) {
            common.forceValue = 0;
          }
          yield this.requestDataModel(dataController, data, {
            props: [
              keyProperty(xKey, xScaleType, { id: "xValue" }),
              valueProperty(yKey, yScaleType, __spreadValues({ id: `yValueRaw` }, common)),
              ...groupAccumulativeValueProperty(
                yKey,
                "window",
                "current",
                __spreadProps(__spreadValues({
                  id: `yValueEnd`
                }, common), {
                  groupId: ids[0]
                }),
                yScaleType
              ),
              ...groupAccumulativeValueProperty(
                yKey,
                "window-trailing",
                "current",
                __spreadProps(__spreadValues({
                  id: `yValueStart`
                }, common), {
                  groupId: ids[1]
                }),
                yScaleType
              ),
              ...groupAccumulativeValueProperty(
                yKey,
                "window",
                "last",
                __spreadProps(__spreadValues({
                  id: `yValuePreviousEnd`
                }, common), {
                  groupId: ids[2]
                }),
                yScaleType
              ),
              ...groupAccumulativeValueProperty(
                yKey,
                "window-trailing",
                "last",
                __spreadProps(__spreadValues({
                  id: `yValuePreviousStart`
                }, common), {
                  groupId: ids[3]
                }),
                yScaleType
              ),
              ...groupAccumulativeValueProperty(
                yKey,
                "normal",
                "current",
                __spreadProps(__spreadValues({
                  id: `yValueCumulative`
                }, common), {
                  groupId: ids[4]
                }),
                yScaleType
              ),
              ...extraProps
            ],
            groupByKeys: true,
            groupByData: false
          });
          this.animationState.transition("updateData");
        });
      }
      getSeriesDomain(direction) {
        const { processedData, dataModel, axes } = this;
        if (!processedData || !dataModel || processedData.data.length === 0)
          return [];
        const xAxis = axes["x" /* X */];
        const yAxis = axes["y" /* Y */];
        const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
        const keys = dataModel.getDomain(this, `xValue`, "key", processedData);
        const yExtent = dataModel.getDomain(this, `yValueEnd`, "value", processedData);
        if (direction === "x" /* X */) {
          if ((keyDef == null ? void 0 : keyDef.def.type) === "key" && keyDef.def.valueType === "category") {
            return keys;
          }
          return fixNumericExtent(extent(keys), xAxis);
        } else if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {
          return fixNumericExtent(yExtent, yAxis);
        } else {
          const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];
          return fixNumericExtent(fixedYExtent, yAxis);
        }
      }
      createNodeData() {
        return __async(this, null, function* () {
          var _a2;
          const { axes, data, processedData: { data: groupedData } = {}, dataModel } = this;
          const xAxis = axes["x" /* X */];
          const yAxis = axes["y" /* Y */];
          if (!xAxis || !yAxis || !data || !dataModel || !this.properties.isValid()) {
            return;
          }
          const {
            yKey,
            xKey,
            marker,
            label,
            fill: seriesFill,
            stroke: seriesStroke,
            connectMissingData
          } = this.properties;
          const { scale: xScale } = xAxis;
          const { scale: yScale } = yAxis;
          const { isContinuousY } = this.getScaleInformation({ xScale, yScale });
          const xOffset = ((_a2 = xScale.bandwidth) != null ? _a2 : 0) / 2;
          const defs = dataModel.resolveProcessedDataDefsByIds(this, [
            `yValueStart`,
            `yValueEnd`,
            `yValueRaw`,
            `yValuePreviousStart`,
            `yValuePreviousEnd`,
            `yValueCumulative`
          ]);
          const createMovePoint = (plainPoint) => __spreadProps(__spreadValues({}, plainPoint), {
            point: __spreadProps(__spreadValues({}, plainPoint.point), { moveTo: true })
          });
          const createPathCoordinates = (xValue, lastYEnd, yEnd) => {
            const x = xScale.convert(xValue) + xOffset;
            const prevYCoordinate = yScale.convert(lastYEnd);
            const currYCoordinate = yScale.convert(yEnd);
            return [
              { point: { x, y: currYCoordinate }, yValue: yEnd, xValue },
              { point: { x, y: prevYCoordinate }, yValue: lastYEnd, xValue }
            ];
          };
          const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {
            let currY;
            if (isDefined(this.properties.normalizedTo) ? isContinuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {
              currY = yEnd;
            }
            return {
              x: xScale.convert(xDatum) + xOffset,
              y: yScale.convert(currY),
              size: marker.size
            };
          };
          const itemId = yKey;
          const labelData = [];
          const markerData = [];
          const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
          const context = {
            itemId,
            fillData: { itemId, points: [], phantomPoints: [] },
            strokeData: { itemId, points: [] },
            labelData,
            nodeData: markerData,
            scales: this.calculateScaling(),
            visible: this.visible,
            stackVisible: visibleSameStackCount > 0
          };
          const fillPoints = context.fillData.points;
          const fillPhantomPoints = context.fillData.phantomPoints;
          const strokePoints = context.strokeData.points;
          let datumIdx = -1;
          let lastXDatum;
          let lastYDatum = -Infinity;
          groupedData == null ? void 0 : groupedData.forEach((datumGroup) => {
            const {
              keys,
              keys: [xDatum],
              datum: datumArray,
              values: valuesArray
            } = datumGroup;
            valuesArray.forEach((values, valueIdx) => {
              var _a3, _b, _c;
              datumIdx++;
              const seriesDatum = datumArray[valueIdx];
              const dataValues = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });
              const { yValueRaw: yDatum, yValueCumulative } = dataValues;
              let { yValueStart, yValueEnd, yValuePreviousStart, yValuePreviousEnd } = dataValues;
              const validPoint = yDatum != null;
              const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);
              if (validPoint && marker) {
                markerData.push({
                  index: datumIdx,
                  series: this,
                  itemId,
                  datum: seriesDatum,
                  midPoint: { x: point.x, y: point.y },
                  cumulativeValue: yValueEnd,
                  yValue: yDatum,
                  xValue: xDatum,
                  yKey,
                  xKey,
                  point,
                  fill: (_a3 = marker.fill) != null ? _a3 : seriesFill,
                  stroke: (_b = marker.stroke) != null ? _b : seriesStroke,
                  strokeWidth: (_c = marker.strokeWidth) != null ? _c : this.getStrokeWidth(this.properties.strokeWidth)
                });
              }
              if (validPoint && label) {
                const labelText = this.getLabelText(
                  label,
                  {
                    value: yDatum,
                    datum: seriesDatum,
                    xKey,
                    yKey,
                    xName: this.properties.xName,
                    yName: this.properties.yName
                  },
                  (value) => isFiniteNumber(value) ? value.toFixed(2) : String(value)
                );
                labelData.push({
                  index: datumIdx,
                  series: this,
                  itemId: yKey,
                  datum: seriesDatum,
                  x: point.x,
                  y: point.y,
                  label: labelText ? {
                    text: labelText,
                    fontStyle: label.fontStyle,
                    fontWeight: label.fontWeight,
                    fontSize: label.fontSize,
                    fontFamily: label.fontFamily,
                    textAlign: "center",
                    textBaseline: "bottom",
                    fill: label.color
                  } : void 0
                });
              }
              const xValid = lastXDatum != null && xDatum != null;
              const yValid = lastYDatum != null && validPoint;
              if (!yValid) {
                yValueStart = yValueStart != null ? yValueStart : 0;
                yValueEnd = yValueStart != null ? yValueStart : 0;
                yValuePreviousStart = yValuePreviousStart != null ? yValuePreviousStart : 0;
                yValuePreviousEnd = yValuePreviousStart != null ? yValuePreviousStart : 0;
              }
              const [prevTop, prevBottom] = createPathCoordinates(lastXDatum, yValuePreviousStart, yValuePreviousEnd);
              const [top, bottom] = createPathCoordinates(xDatum, yValueStart, yValueEnd);
              if (xValid && (!connectMissingData || yValid)) {
                fillPoints.push(prevTop, top);
                fillPhantomPoints.push(prevBottom, bottom);
              }
              if (yValid && datumIdx > 0) {
                strokePoints.push(createMovePoint(prevTop), top);
              }
              lastXDatum = xDatum;
              lastYDatum = yDatum;
            });
          });
          if (strokePoints.length > 0) {
            strokePoints[0] = createMovePoint(strokePoints[0]);
          }
          return context;
        });
      }
      isPathOrSelectionDirty() {
        return this.properties.marker.isDirty();
      }
      markerFactory() {
        const { shape } = this.properties.marker;
        const MarkerShape = getMarker(shape);
        return new MarkerShape();
      }
      updatePathNodes(opts) {
        return __async(this, null, function* () {
          const { opacity, visible, animationEnabled } = opts;
          const [fill, stroke] = opts.paths;
          const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);
          stroke.setProperties({
            tag: 1 /* Stroke */,
            fill: void 0,
            lineJoin: stroke.lineCap = "round",
            pointerEvents: 1 /* None */,
            stroke: this.properties.stroke,
            strokeWidth,
            strokeOpacity: this.properties.strokeOpacity,
            lineDash: this.properties.lineDash,
            lineDashOffset: this.properties.lineDashOffset,
            opacity,
            visible
          });
          fill.setProperties({
            tag: 0 /* Fill */,
            stroke: void 0,
            lineJoin: "round",
            pointerEvents: 1 /* None */,
            fill: this.properties.fill,
            fillOpacity: this.properties.fillOpacity,
            lineDash: this.properties.lineDash,
            lineDashOffset: this.properties.lineDashOffset,
            strokeOpacity: this.properties.strokeOpacity,
            fillShadow: this.properties.shadow,
            opacity,
            visible: visible || animationEnabled,
            strokeWidth
          });
          updateClipPath(this, stroke);
          updateClipPath(this, fill);
        });
      }
      updatePaths(opts) {
        return __async(this, null, function* () {
          this.updateAreaPaths(opts.paths, opts.contextData);
        });
      }
      updateAreaPaths(paths, contextData) {
        this.updateFillPath(paths, contextData);
        this.updateStrokePath(paths, contextData);
      }
      updateFillPath(paths, contextData) {
        const { fillData } = contextData;
        const [fill] = paths;
        const { path: fillPath } = fill;
        fillPath.clear(true);
        let lastPoint;
        for (const { point } of iterate(fillData.points, iterateReverseArray(fillData.phantomPoints))) {
          if (point.moveTo) {
            fillPath.moveTo(point.x, point.y);
          } else if ((lastPoint == null ? void 0 : lastPoint.y) !== point.y) {
            if (lastPoint) {
              fillPath.lineTo(lastPoint.x, lastPoint.y);
            }
            fillPath.lineTo(point.x, point.y);
          }
          lastPoint = point;
        }
        if (lastPoint) {
          fillPath.lineTo(lastPoint.x, lastPoint.y);
        }
        fillPath.closePath();
        fill.checkPathDirty();
      }
      updateStrokePath(paths, contextData) {
        const { strokeData } = contextData;
        const [, stroke] = paths;
        const { path: strokePath } = stroke;
        strokePath.clear(true);
        for (const { point } of strokeData.points) {
          if (point.moveTo) {
            strokePath.moveTo(point.x, point.y);
          } else {
            strokePath.lineTo(point.x, point.y);
          }
        }
        stroke.checkPathDirty();
      }
      updateMarkerSelection(opts) {
        return __async(this, null, function* () {
          const { nodeData, markerSelection } = opts;
          if (this.properties.marker.isDirty()) {
            markerSelection.clear();
            markerSelection.cleanup();
          }
          return markerSelection.update(this.properties.marker.enabled ? nodeData : []);
        });
      }
      updateMarkerNodes(opts) {
        return __async(this, null, function* () {
          const { markerSelection, isHighlight: highlighted } = opts;
          const { xKey, yKey, marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, highlightStyle } = this.properties;
          const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {
            fill,
            stroke,
            strokeWidth,
            fillOpacity,
            strokeOpacity
          });
          markerSelection.each((node, datum) => {
            this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle);
          });
          if (!highlighted) {
            this.properties.marker.markClean();
          }
        });
      }
      updateLabelSelection(opts) {
        return __async(this, null, function* () {
          const { labelData, labelSelection } = opts;
          return labelSelection.update(labelData, (text) => {
            text.tag = 3 /* Label */;
          });
        });
      }
      updateLabelNodes(opts) {
        return __async(this, null, function* () {
          const { labelSelection } = opts;
          const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;
          labelSelection.each((text, datum) => {
            const { x, y, label } = datum;
            if (label && labelEnabled && this.visible) {
              text.fontStyle = fontStyle;
              text.fontWeight = fontWeight;
              text.fontSize = fontSize;
              text.fontFamily = fontFamily;
              text.textAlign = label.textAlign;
              text.textBaseline = label.textBaseline;
              text.text = label.text;
              text.x = x;
              text.y = y - 10;
              text.fill = color;
              text.visible = true;
            } else {
              text.visible = false;
            }
          });
        });
      }
      getTooltipHtml(nodeDatum) {
        const { id: seriesId, axes, dataModel } = this;
        const { xKey, xName, yName, tooltip, marker } = this.properties;
        const { yKey, xValue, yValue, datum, itemId } = nodeDatum;
        const xAxis = axes["x" /* X */];
        const yAxis = axes["y" /* Y */];
        if (!this.properties.isValid() || !(xAxis && yAxis && isFiniteNumber(yValue)) || !dataModel) {
          return EMPTY_TOOLTIP_CONTENT;
        }
        const xString = xAxis.formatDatum(xValue);
        const yString = yAxis.formatDatum(yValue);
        const title = sanitizeHtml(yName);
        const content = sanitizeHtml(xString + ": " + yString);
        const baseStyle = mergeDefaults({ fill: this.properties.fill }, marker.getStyle(), {
          stroke: this.properties.stroke,
          strokeWidth: this.properties.strokeWidth
        });
        const { fill: color } = this.getMarkerStyle(
          marker,
          { datum: nodeDatum, xKey, yKey, highlighted: false },
          baseStyle
        );
        return tooltip.toTooltipHtml(
          { title, content, backgroundColor: color },
          {
            datum,
            itemId,
            xKey,
            xName,
            yKey,
            yName,
            color,
            title,
            seriesId
          }
        );
      }
      getLegendData(legendType) {
        var _a2, _b, _c, _d;
        if (!((_a2 = this.data) == null ? void 0 : _a2.length) || !this.properties.isValid() || legendType !== "category") {
          return [];
        }
        const { yKey, yName, fill, stroke, fillOpacity, strokeOpacity, strokeWidth, lineDash, marker, visible } = this.properties;
        const useAreaFill = !marker.enabled || marker.fill === void 0;
        return [
          {
            legendType,
            id: this.id,
            itemId: yKey,
            seriesId: this.id,
            enabled: visible,
            label: {
              text: yName != null ? yName : yKey
            },
            marker: {
              shape: marker.shape,
              fill: useAreaFill ? fill : marker.fill,
              fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity,
              stroke: (_b = marker.stroke) != null ? _b : stroke,
              strokeOpacity: (_c = marker.strokeOpacity) != null ? _c : strokeOpacity,
              strokeWidth: (_d = marker.strokeWidth) != null ? _d : 0,
              enabled: marker.enabled || strokeWidth <= 0
            },
            line: {
              stroke,
              strokeOpacity,
              strokeWidth,
              lineDash
            }
          }
        ];
      }
      animateEmptyUpdateReady(animationData) {
        const { markerSelection, labelSelection, contextData, paths } = animationData;
        const { animationManager } = this.ctx;
        this.updateAreaPaths(paths, contextData);
        pathSwipeInAnimation(this, animationManager, ...paths);
        resetMotion([markerSelection], resetMarkerPositionFn);
        markerSwipeScaleInAnimation(this, animationManager, markerSelection);
        seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
      }
      animateReadyResize(animationData) {
        const { contextData, paths } = animationData;
        this.updateAreaPaths(paths, contextData);
        super.animateReadyResize(animationData);
      }
      animateWaitingUpdateReady(animationData) {
        var _a2, _b;
        const { animationManager } = this.ctx;
        const { markerSelection, labelSelection, contextData, paths, previousContextData } = animationData;
        const [fill, stroke] = paths;
        if (fill == null && stroke == null)
          return;
        super.resetAllAnimation(animationData);
        const update = () => {
          this.updateAreaPaths(paths, contextData);
          this.updateStrokePath(paths, contextData);
        };
        const skip = () => {
          animationManager.skipCurrentBatch();
          update();
        };
        if (contextData == null || previousContextData == null) {
          update();
          markerFadeInAnimation(this, animationManager, "added", markerSelection);
          pathFadeInAnimation(this, "fill_path_properties", animationManager, "add", fill);
          pathFadeInAnimation(this, "stroke", animationManager, "trailing", stroke);
          seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
          return;
        }
        const fns = prepareAreaPathAnimation(contextData, previousContextData, (_b = (_a2 = this.processedData) == null ? void 0 : _a2.reduced) == null ? void 0 : _b.diff);
        if (fns === void 0) {
          skip();
          return;
        } else if (fns.status === "no-op") {
          return;
        }
        markerFadeInAnimation(this, animationManager, void 0, markerSelection);
        fromToMotion(this.id, "fill_path_properties", animationManager, [fill], fns.fill.pathProperties);
        pathMotion(this.id, "fill_path_update", animationManager, [fill], fns.fill.path);
        this.updateStrokePath(paths, contextData);
        pathFadeInAnimation(this, "stroke", animationManager, "trailing", stroke);
        seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
      }
      isLabelEnabled() {
        return this.properties.label.enabled;
      }
      nodeFactory() {
        return new Group();
      }
      getFormattedMarkerStyle(datum) {
        const { xKey, yKey } = datum;
        return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });
      }
      computeFocusBounds(opts) {
        return computeMarkerFocusBounds(this, opts);
      }
    };
    AreaSeries.className = "AreaSeries";
    AreaSeries.type = "area";
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts
var AreaSeriesModule;
var init_areaSeriesModule = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts"() {
    "use strict";
    init_theme();
    init_constants();
    init_symbols();
    init_areaSeries();
    AreaSeriesModule = {
      type: "series",
      optionsKey: "series[]",
      packageType: "community",
      chartTypes: ["cartesian"],
      identifier: "area",
      instanceConstructor: AreaSeries,
      stackable: true,
      defaultAxes: [
        {
          type: "number" /* NUMBER */,
          position: "left" /* LEFT */
        },
        {
          type: "category" /* CATEGORY */,
          position: "bottom" /* BOTTOM */
        }
      ],
      themeTemplate: {
        series: {
          __extends__: EXTENDS_SERIES_DEFAULTS,
          nodeClickRange: "nearest",
          tooltip: { position: { type: "node" } },
          fillOpacity: 0.8,
          strokeOpacity: 1,
          strokeWidth: 0,
          lineDash: [0],
          lineDashOffset: 0,
          shadow: {
            enabled: false,
            color: DEFAULT_SHADOW_COLOUR,
            xOffset: 3,
            yOffset: 3,
            blur: 5
          },
          marker: {
            __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,
            enabled: false,
            fillOpacity: 1,
            strokeOpacity: 1,
            strokeWidth: 0
          },
          label: {
            enabled: false,
            fontSize: 12,
            fontFamily: DEFAULT_FONT_FAMILY,
            color: DEFAULT_LABEL_COLOUR
          }
        }
      },
      paletteFactory: (params) => {
        const { marker } = markerPaletteFactory(params);
        return { fill: marker.fill, stroke: marker.stroke, marker };
      }
    };
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/quadtreeUtil.ts
function* childrenIter(parent) {
  for (const node of parent.children) {
    yield node;
  }
}
function addHitTestersToQuadtree(quadtree, hitTesters) {
  for (const node of hitTesters) {
    const datum = node.datum;
    if (datum === void 0) {
      Logger.error("undefined datum");
    } else {
      quadtree.addValue(node, datum);
    }
  }
}
function findQuadtreeMatch(series, point) {
  const { x, y } = series.contentGroup.transformPoint(point.x, point.y);
  const { nearest, distanceSquared: distanceSquared2 } = series.getQuadTree().find(x, y);
  if (nearest !== void 0) {
    return { datum: nearest.value, distance: Math.sqrt(distanceSquared2) };
  }
  return void 0;
}
var init_quadtreeUtil = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/quadtreeUtil.ts"() {
    "use strict";
    init_logger();
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts
var AbstractBarSeriesProperties, AbstractBarSeries;
var init_abstractBarSeries = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts"() {
    "use strict";
    init_bandScale();
    init_continuousScale();
    init_validation();
    init_categoryAxis();
    init_groupedCategoryAxis();
    init_chartAxisDirection();
    init_cartesianSeries();
    init_quadtreeUtil();
    AbstractBarSeriesProperties = class extends CartesianSeriesProperties {
      constructor() {
        super(...arguments);
        this.direction = "vertical";
      }
    };
    __decorateClass([
      Validate(DIRECTION)
    ], AbstractBarSeriesProperties.prototype, "direction", 2);
    AbstractBarSeries = class extends CartesianSeries {
      constructor() {
        super(...arguments);
        /**
         * Used to get the position of bars within each group.
         */
        this.groupScale = new BandScale();
        this.smallestDataInterval = void 0;
      }
      getBandScalePadding() {
        return { inner: 0.2, outer: 0.1 };
      }
      shouldFlipXY() {
        return !this.isVertical();
      }
      isVertical() {
        return this.properties.direction === "vertical";
      }
      getBarDirection() {
        return this.shouldFlipXY() ? "x" /* X */ : "y" /* Y */;
      }
      getCategoryDirection() {
        return this.shouldFlipXY() ? "y" /* Y */ : "x" /* X */;
      }
      getValueAxis() {
        const direction = this.getBarDirection();
        return this.axes[direction];
      }
      getCategoryAxis() {
        const direction = this.getCategoryDirection();
        return this.axes[direction];
      }
      updateGroupScale(xAxis) {
        const {
          groupScale,
          smallestDataInterval,
          ctx: { seriesStateManager }
        } = this;
        const xScale = xAxis.scale;
        const xBandWidth = ContinuousScale.is(xScale) ? xScale.calcBandwidth(smallestDataInterval) : xScale.bandwidth;
        const domain = [];
        const { index: groupIndex, visibleGroupCount } = seriesStateManager.getVisiblePeerGroupIndex(this);
        for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {
          domain.push(String(groupIdx));
        }
        groupScale.domain = domain;
        groupScale.range = [0, xBandWidth != null ? xBandWidth : 0];
        if (xAxis instanceof CategoryAxis) {
          groupScale.paddingInner = xAxis.groupPaddingInner;
        } else if (xAxis instanceof GroupedCategoryAxis) {
          groupScale.padding = 0.1;
        } else {
          groupScale.padding = 0;
        }
        groupScale.round = groupScale.padding !== 0;
        const barWidth = groupScale.bandwidth >= 1 ? (
          // Pixel-rounded value for low-volume bar charts.
          groupScale.bandwidth
        ) : (
          // Handle high-volume bar charts gracefully.
          groupScale.rawBandwidth
        );
        return { barWidth, groupIndex };
      }
      resolveKeyDirection(direction) {
        if (this.getBarDirection() === "x" /* X */) {
          if (direction === "x" /* X */) {
            return "y" /* Y */;
          }
          return "x" /* X */;
        }
        return direction;
      }
      initQuadTree(quadtree) {
        addHitTestersToQuadtree(quadtree, this.datumNodesIter());
      }
      pickNodeClosestDatum(point) {
        return findQuadtreeMatch(this, point);
      }
    };
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts
var BarSeriesLabel, BarSeriesProperties;
var init_barSeriesProperties = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts"() {
    "use strict";
    init_dropShadow();
    init_validation();
    init_label();
    init_seriesTooltip();
    init_abstractBarSeries();
    BarSeriesLabel = class extends Label {
      constructor() {
        super(...arguments);
        this.placement = "inside";
      }
    };
    __decorateClass([
      Validate(PLACEMENT)
    ], BarSeriesLabel.prototype, "placement", 2);
    BarSeriesProperties = class extends AbstractBarSeriesProperties {
      constructor() {
        super(...arguments);
        this.fill = "#c16068";
        this.fillOpacity = 1;
        this.stroke = "#874349";
        this.strokeWidth = 1;
        this.strokeOpacity = 1;
        this.lineDash = [0];
        this.lineDashOffset = 0;
        this.cornerRadius = 0;
        this.shadow = new DropShadow();
        this.label = new BarSeriesLabel();
        this.tooltip = new SeriesTooltip();
      }
    };
    __decorateClass([
      Validate(STRING)
    ], BarSeriesProperties.prototype, "xKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], BarSeriesProperties.prototype, "xName", 2);
    __decorateClass([
      Validate(STRING)
    ], BarSeriesProperties.prototype, "yKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], BarSeriesProperties.prototype, "yName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], BarSeriesProperties.prototype, "stackGroup", 2);
    __decorateClass([
      Validate(NUMBER, { optional: true })
    ], BarSeriesProperties.prototype, "normalizedTo", 2);
    __decorateClass([
      Validate(COLOR_STRING)
    ], BarSeriesProperties.prototype, "fill", 2);
    __decorateClass([
      Validate(RATIO)
    ], BarSeriesProperties.prototype, "fillOpacity", 2);
    __decorateClass([
      Validate(COLOR_STRING)
    ], BarSeriesProperties.prototype, "stroke", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], BarSeriesProperties.prototype, "strokeWidth", 2);
    __decorateClass([
      Validate(RATIO)
    ], BarSeriesProperties.prototype, "strokeOpacity", 2);
    __decorateClass([
      Validate(LINE_DASH)
    ], BarSeriesProperties.prototype, "lineDash", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], BarSeriesProperties.prototype, "lineDashOffset", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], BarSeriesProperties.prototype, "cornerRadius", 2);
    __decorateClass([
      Validate(FUNCTION, { optional: true })
    ], BarSeriesProperties.prototype, "formatter", 2);
    __decorateClass([
      Validate(OBJECT, { optional: true })
    ], BarSeriesProperties.prototype, "shadow", 2);
    __decorateClass([
      Validate(OBJECT)
    ], BarSeriesProperties.prototype, "label", 2);
    __decorateClass([
      Validate(OBJECT)
    ], BarSeriesProperties.prototype, "tooltip", 2);
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts
function updateRect({ rect, config }) {
  const {
    crisp = true,
    fill,
    stroke,
    strokeWidth,
    fillOpacity,
    strokeOpacity,
    lineDash,
    lineDashOffset,
    fillShadow,
    cornerRadius = 0,
    topLeftCornerRadius = true,
    topRightCornerRadius = true,
    bottomRightCornerRadius = true,
    bottomLeftCornerRadius = true,
    visible = true
  } = config;
  rect.crisp = crisp;
  rect.fill = fill;
  rect.stroke = stroke;
  rect.strokeWidth = strokeWidth;
  rect.fillOpacity = fillOpacity;
  rect.strokeOpacity = strokeOpacity;
  rect.lineDash = lineDash;
  rect.lineDashOffset = lineDashOffset;
  rect.fillShadow = fillShadow;
  rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;
  rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;
  rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;
  rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;
  rect.visible = visible;
}
function getRectConfig(_a2) {
  var _b = _a2, {
    datum,
    isHighlighted,
    style,
    highlightStyle,
    formatter,
    seriesId,
    ctx: { callbackCache }
  } = _b, opts = __objRest(_b, [
    "datum",
    "isHighlighted",
    "style",
    "highlightStyle",
    "formatter",
    "seriesId",
    "ctx"
  ]);
  var _a3, _b2, _c, _d, _e, _f;
  const { fill, fillOpacity, stroke, strokeWidth } = mergeDefaults(isHighlighted && highlightStyle, style);
  const {
    strokeOpacity,
    fillShadow,
    lineDash,
    lineDashOffset,
    cornerRadius = 0,
    topLeftCornerRadius = true,
    topRightCornerRadius = true,
    bottomRightCornerRadius = true,
    bottomLeftCornerRadius = true
  } = style;
  let format2;
  if (formatter) {
    format2 = callbackCache.call(formatter, __spreadValues({
      datum: datum.datum,
      xKey: datum.xKey,
      fill,
      stroke,
      strokeWidth,
      cornerRadius,
      highlighted: isHighlighted,
      seriesId
    }, opts));
  }
  return {
    fill: (_a3 = format2 == null ? void 0 : format2.fill) != null ? _a3 : fill,
    stroke: (_b2 = format2 == null ? void 0 : format2.stroke) != null ? _b2 : stroke,
    strokeWidth: (_c = format2 == null ? void 0 : format2.strokeWidth) != null ? _c : strokeWidth,
    fillOpacity: (_d = format2 == null ? void 0 : format2.fillOpacity) != null ? _d : fillOpacity,
    strokeOpacity: (_e = format2 == null ? void 0 : format2.strokeOpacity) != null ? _e : strokeOpacity,
    lineDash,
    lineDashOffset,
    fillShadow,
    cornerRadius: (_f = format2 == null ? void 0 : format2.cornerRadius) != null ? _f : cornerRadius,
    topLeftCornerRadius,
    topRightCornerRadius,
    bottomRightCornerRadius,
    bottomLeftCornerRadius
  };
}
function checkCrisp(visibleRange = []) {
  const [visibleMin, visibleMax] = visibleRange;
  const isZoomed = visibleMin !== 0 || visibleMax !== 1;
  return !isZoomed;
}
function collapsedStartingBarPosition(isVertical, axes, mode) {
  const { startingX, startingY } = getStartingValues(isVertical, axes);
  const calculate = (datum, prevDatum) => {
    let x = isVertical ? datum.x : startingX;
    let y = isVertical ? startingY : datum.y;
    let width = isVertical ? datum.width : 0;
    let height = isVertical ? 0 : datum.height;
    const { opacity } = datum;
    if (prevDatum && (isNaN(x) || isNaN(y))) {
      ({ x, y } = prevDatum);
      width = isVertical ? prevDatum.width : 0;
      height = isVertical ? 0 : prevDatum.height;
      if (isVertical && !isDatumNegative(prevDatum)) {
        y += prevDatum.height;
      } else if (!isVertical && isDatumNegative(prevDatum)) {
        x += prevDatum.width;
      }
    }
    let clipBBox;
    if (datum.clipBBox == null) {
      clipBBox = void 0;
    } else if (isDatumNegative(datum)) {
      clipBBox = isVertical ? new BBox(x, y - height, width, height) : new BBox(x - width, y, width, height);
    } else {
      clipBBox = new BBox(x, y, width, height);
    }
    return { x, y, width, height, clipBBox, opacity };
  };
  return { isVertical, calculate, mode };
}
function midpointStartingBarPosition(isVertical, mode) {
  return {
    isVertical,
    calculate: (datum) => {
      return {
        x: isVertical ? datum.x : datum.x + datum.width / 2,
        y: isVertical ? datum.y + datum.height / 2 : datum.y,
        width: isVertical ? datum.width : 0,
        height: isVertical ? 0 : datum.height,
        clipBBox: datum.clipBBox,
        opacity: datum.opacity
      };
    },
    mode
  };
}
function prepareBarAnimationFunctions(initPos) {
  const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);
  const fromFn = (rect, datum, status) => {
    if (status === "updated" && isRemoved(datum)) {
      status = "removed";
    } else if (status === "updated" && isRemoved(rect.previousDatum)) {
      status = "added";
    }
    let source;
    if (status === "added" && rect.previousDatum == null && initPos.mode === "fade") {
      source = __spreadProps(__spreadValues({}, resetBarSelectionsFn(rect, datum)), { opacity: 0 });
    } else if (status === "unknown" || status === "added") {
      source = initPos.calculate(datum, rect.previousDatum);
    } else {
      source = {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        clipBBox: rect.clipBBox,
        opacity: rect.opacity
      };
    }
    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return __spreadProps(__spreadValues({}, source), { phase });
  };
  const toFn = (rect, datum, status) => {
    let source;
    if (status === "removed" && rect.datum == null && initPos.mode === "fade") {
      source = __spreadProps(__spreadValues({}, resetBarSelectionsFn(rect, datum)), { opacity: 0 });
    } else if (status === "removed" || isRemoved(datum)) {
      source = initPos.calculate(datum, rect.previousDatum);
    } else {
      source = {
        x: datum.x,
        y: datum.y,
        width: datum.width,
        height: datum.height,
        clipBBox: datum.clipBBox,
        opacity: datum.opacity
      };
    }
    return source;
  };
  return { toFn, fromFn };
}
function getStartingValues(isVertical, axes) {
  const axis = axes[isVertical ? "y" /* Y */ : "x" /* X */];
  let startingX = Infinity;
  let startingY = 0;
  if (!axis) {
    return { startingX, startingY };
  }
  if (isVertical) {
    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));
  } else {
    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));
  }
  return { startingX, startingY };
}
function resetBarSelectionsFn(_node, { x, y, width, height, clipBBox, opacity }) {
  return { x, y, width, height, clipBBox, opacity };
}
function computeBarFocusBounds(datum, barGroup, seriesRect) {
  if (datum === void 0)
    return void 0;
  const { x, y, width, height } = datum;
  return barGroup.inverseTransformBBox(new BBox(x, y, width, height)).clip(seriesRect);
}
var isDatumNegative;
var init_barUtil = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts"() {
    "use strict";
    init_fromToMotion();
    init_continuousScale();
    init_bbox();
    init_number();
    init_object();
    init_chartAxisDirection();
    isDatumNegative = (datum) => {
      var _a2;
      return isNegative((_a2 = datum.yValue) != null ? _a2 : 0);
    };
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/labelUtil.ts
function updateLabelNode(textNode, label, labelDatum) {
  if (label.enabled && labelDatum) {
    const { x, y, text, textAlign, textBaseline } = labelDatum;
    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;
    textNode.setProperties({
      visible: true,
      x,
      y,
      text,
      fill,
      fontStyle,
      fontWeight,
      fontSize,
      fontFamily,
      textAlign,
      textBaseline
    });
  } else {
    textNode.visible = false;
  }
}
function adjustLabelPlacement({
  isPositive,
  isVertical,
  placement,
  padding = 0,
  rect
}) {
  let x = rect.x + rect.width / 2;
  let y = rect.y + rect.height / 2;
  let textAlign = "center";
  let textBaseline = "middle";
  switch (placement) {
    case "start": {
      if (isVertical) {
        y = isPositive ? rect.y + rect.height + padding : rect.y - padding;
        textBaseline = isPositive ? "top" : "bottom";
      } else {
        x = isPositive ? rect.x - padding : rect.x + rect.width + padding;
        textAlign = isPositive ? "start" : "end";
      }
      break;
    }
    case "outside":
    case "end": {
      if (isVertical) {
        y = isPositive ? rect.y - padding : rect.y + rect.height + padding;
        textBaseline = isPositive ? "bottom" : "top";
      } else {
        x = isPositive ? rect.x + rect.width + padding : rect.x - padding;
        textAlign = isPositive ? "start" : "end";
      }
      break;
    }
  }
  return { x, y, textAlign, textBaseline };
}
var init_labelUtil = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/labelUtil.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts
var BarSeries;
var init_barSeries = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts"() {
    "use strict";
    init_fromToMotion();
    init_continuousScale();
    init_bbox();
    init_node();
    init_rect();
    init_array();
    init_sanitize();
    init_type_guards();
    init_logAxis();
    init_chartAxisDirection();
    init_dataModel();
    init_processors();
    init_tooltip();
    init_series();
    init_seriesLabelUtil();
    init_abstractBarSeries();
    init_barSeriesProperties();
    init_barUtil();
    init_barUtil();
    init_cartesianSeries();
    init_labelUtil();
    BarSeries = class extends AbstractBarSeries {
      constructor(moduleCtx) {
        super({
          moduleCtx,
          directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
          directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
          pickModes: [0 /* EXACT_SHAPE_MATCH */],
          pathsPerSeries: 0,
          hasHighlightedLabels: true,
          datumSelectionGarbageCollection: false,
          animationAlwaysUpdateSelections: true,
          animationResetFns: {
            datum: resetBarSelectionsFn,
            label: resetLabelFn
          }
        });
        this.properties = new BarSeriesProperties();
      }
      processData(dataController) {
        return __async(this, null, function* () {
          var _a2, _b, _c;
          if (!this.properties.isValid() || !this.data) {
            return;
          }
          const { seriesGrouping: { groupIndex = this.id } = {}, data = [] } = this;
          const { xKey, yKey, normalizedTo } = this.properties;
          const animationEnabled = !this.ctx.animationManager.isSkipped();
          const xScale = (_a2 = this.getCategoryAxis()) == null ? void 0 : _a2.scale;
          const yScale = (_b = this.getValueAxis()) == null ? void 0 : _b.scale;
          const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
          const stackGroupName = `bar-stack-${groupIndex}-yValues`;
          const stackGroupTrailingName = `${stackGroupName}-trailing`;
          const extraProps = [];
          if (isFiniteNumber(normalizedTo)) {
            extraProps.push(
              normaliseGroupTo([stackGroupName, stackGroupTrailingName], Math.abs(normalizedTo), "range")
            );
          }
          if (animationEnabled && this.processedData) {
            extraProps.push(diff(this.processedData));
          }
          if (animationEnabled) {
            extraProps.push(animationValidation());
          }
          const visibleProps = this.visible ? {} : { forceValue: 0 };
          const { processedData } = yield this.requestDataModel(dataController, data, {
            props: [
              keyProperty(xKey, xScaleType, { id: "xValue" }),
              valueProperty(yKey, yScaleType, __spreadValues({ id: `yValue-raw`, invalidValue: null }, visibleProps)),
              ...groupAccumulativeValueProperty(
                yKey,
                "normal",
                "current",
                __spreadValues({
                  id: `yValue-end`,
                  rangeId: `yValue-range`,
                  invalidValue: null,
                  missingValue: 0,
                  groupId: stackGroupName,
                  separateNegative: true
                }, visibleProps),
                yScaleType
              ),
              ...groupAccumulativeValueProperty(
                yKey,
                "trailing",
                "current",
                __spreadValues({
                  id: `yValue-start`,
                  invalidValue: null,
                  missingValue: 0,
                  groupId: stackGroupTrailingName,
                  separateNegative: true
                }, visibleProps),
                yScaleType
              ),
              ...isContinuousX ? [SMALLEST_KEY_INTERVAL] : [],
              ...extraProps
            ],
            groupByKeys: true,
            groupByData: false
          });
          this.smallestDataInterval = (_c = processedData.reduced) == null ? void 0 : _c.smallestKeyInterval;
          this.animationState.transition("updateData");
        });
      }
      getSeriesDomain(direction) {
        var _a2;
        const { processedData, dataModel, smallestDataInterval } = this;
        if (!processedData || !dataModel || processedData.data.length === 0)
          return [];
        const categoryAxis = this.getCategoryAxis();
        const valueAxis = this.getValueAxis();
        const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
        const keys = dataModel.getDomain(this, `xValue`, "key", processedData);
        const yExtent = dataModel.getDomain(this, `yValue-end`, "value", processedData);
        if (direction === this.getCategoryDirection()) {
          if ((keyDef == null ? void 0 : keyDef.def.type) === "key" && keyDef.def.valueType === "category") {
            return keys;
          }
          const scalePadding = isFiniteNumber(smallestDataInterval) ? smallestDataInterval * 0.5 : 0;
          const keysExtent = (_a2 = extent(keys)) != null ? _a2 : [NaN, NaN];
          const d0 = keysExtent[0] + -scalePadding;
          const d1 = keysExtent[1] + scalePadding;
          return fixNumericExtent([d0, d1], categoryAxis);
        } else if (this.getValueAxis() instanceof LogAxis) {
          return fixNumericExtent(yExtent, valueAxis);
        } else {
          const fixedYExtent = [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])];
          return fixNumericExtent(fixedYExtent, valueAxis);
        }
      }
      createNodeData() {
        return __async(this, null, function* () {
          const { dataModel } = this;
          const xAxis = this.getCategoryAxis();
          const yAxis = this.getValueAxis();
          if (!dataModel || !xAxis || !yAxis || !this.properties.isValid())
            return;
          const xScale = xAxis.scale;
          const yScale = yAxis.scale;
          const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius, legendItemName, label } = this.properties;
          const yReversed = yAxis.isReversed();
          const { barWidth, groupIndex } = this.updateGroupScale(xAxis);
          const barOffset = ContinuousScale.is(xScale) ? barWidth * -0.5 : 0;
          const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);
          const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-raw`);
          const yStartIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-start`);
          const yEndIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-end`);
          const yRangeIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-range`);
          const animationEnabled = !this.ctx.animationManager.isSkipped();
          const context = {
            itemId: yKey,
            nodeData: [],
            labelData: [],
            scales: this.calculateScaling(),
            visible: this.visible || animationEnabled
          };
          const { groupScale, processedData } = this;
          processedData == null ? void 0 : processedData.data.forEach(({ keys, datum: seriesDatum, values, aggValues }) => {
            values.forEach((value, valueIndex) => {
              var _a2;
              const xValue = keys[xIndex];
              const x = xScale.convert(xValue);
              const currY = +value[yEndIndex];
              const prevY = +value[yStartIndex];
              const yRawValue = value[yRawIndex];
              const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);
              const isUpward = isPositive !== yReversed;
              const yRange = (_a2 = aggValues == null ? void 0 : aggValues[yRangeIndex][isPositive ? 1 : 0]) != null ? _a2 : 0;
              const barX = x + groupScale.convert(String(groupIndex)) + barOffset;
              if (isNaN(currY))
                return;
              const y = yScale.convert(currY);
              const bottomY = yScale.convert(prevY);
              const barAlongX = this.getBarDirection() === "x" /* X */;
              const bboxHeight = yScale.convert(yRange);
              const bboxBottom = yScale.convert(0);
              const rect = {
                x: barAlongX ? Math.min(y, bottomY) : barX,
                y: barAlongX ? barX : Math.min(y, bottomY),
                width: barAlongX ? Math.abs(bottomY - y) : barWidth,
                height: barAlongX ? barWidth : Math.abs(bottomY - y)
              };
              const clipBBox = new BBox(rect.x, rect.y, rect.width, rect.height);
              const barRect = {
                x: barAlongX ? Math.min(bboxBottom, bboxHeight) : barX,
                y: barAlongX ? barX : Math.min(bboxBottom, bboxHeight),
                width: barAlongX ? Math.abs(bboxBottom - bboxHeight) : barWidth,
                height: barAlongX ? barWidth : Math.abs(bboxBottom - bboxHeight),
                clipBBox
              };
              const {
                fontStyle: labelFontStyle,
                fontWeight: labelFontWeight,
                fontSize: labelFontSize,
                fontFamily: labelFontFamily,
                color: labelColor,
                placement
              } = label;
              const labelText = this.getLabelText(
                this.properties.label,
                {
                  datum: seriesDatum[valueIndex],
                  value: yRawValue,
                  xKey,
                  yKey,
                  xName,
                  yName,
                  legendItemName
                },
                (v) => isFiniteNumber(v) ? v.toFixed(2) : String(v)
              );
              const labelDatum = labelText ? __spreadValues({
                text: labelText,
                fill: labelColor,
                fontStyle: labelFontStyle,
                fontWeight: labelFontWeight,
                fontSize: labelFontSize,
                fontFamily: labelFontFamily
              }, adjustLabelPlacement({
                isPositive,
                isVertical: !barAlongX,
                placement,
                rect
              })) : void 0;
              const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;
              const nodeData = {
                series: this,
                itemId: yKey,
                datum: seriesDatum[valueIndex],
                valueIndex,
                cumulativeValue: currY,
                xValue,
                yValue: yRawValue,
                yKey,
                xKey,
                capDefaults: {
                  lengthRatioMultiplier,
                  lengthMax: lengthRatioMultiplier
                },
                x: barRect.x,
                y: barRect.y,
                width: barRect.width,
                height: barRect.height,
                midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },
                fill,
                stroke,
                opacity: 1,
                strokeWidth,
                cornerRadius,
                topLeftCornerRadius: barAlongX !== isUpward,
                topRightCornerRadius: isUpward,
                bottomRightCornerRadius: barAlongX === isUpward,
                bottomLeftCornerRadius: !isUpward,
                clipBBox,
                label: labelDatum,
                missing: yRawValue == null
              };
              context.nodeData.push(nodeData);
              context.labelData.push(nodeData);
            });
          });
          return context;
        });
      }
      nodeFactory() {
        return new Rect();
      }
      updateDatumSelection(opts) {
        return __async(this, null, function* () {
          return opts.datumSelection.update(
            opts.nodeData,
            (rect) => {
              rect.tag = 0 /* Bar */;
            },
            (datum) => createDatumId(datum.xValue, datum.valueIndex)
          );
        });
      }
      updateDatumNodes(opts) {
        return __async(this, null, function* () {
          if (!this.properties.isValid()) {
            return;
          }
          const {
            yKey,
            stackGroup,
            fill,
            fillOpacity,
            stroke,
            strokeWidth,
            strokeOpacity,
            lineDash,
            lineDashOffset,
            formatter,
            shadow,
            highlightStyle: { item: itemHighlightStyle }
          } = this.properties;
          const xAxis = this.axes["x" /* X */];
          const crisp = checkCrisp(xAxis == null ? void 0 : xAxis.visibleRange);
          const categoryAlongX = this.getCategoryDirection() === "x" /* X */;
          opts.datumSelection.each((rect, datum) => {
            var _a2, _b, _c, _d;
            const style = {
              fill,
              stroke,
              fillOpacity,
              strokeOpacity,
              lineDash,
              lineDashOffset,
              fillShadow: shadow,
              strokeWidth: this.getStrokeWidth(strokeWidth),
              cornerRadius: datum.cornerRadius,
              topLeftCornerRadius: datum.topLeftCornerRadius,
              topRightCornerRadius: datum.topRightCornerRadius,
              bottomRightCornerRadius: datum.bottomRightCornerRadius,
              bottomLeftCornerRadius: datum.bottomLeftCornerRadius
            };
            const visible = categoryAlongX ? ((_b = (_a2 = datum.clipBBox) == null ? void 0 : _a2.width) != null ? _b : datum.width) > 0 : ((_d = (_c = datum.clipBBox) == null ? void 0 : _c.height) != null ? _d : datum.height) > 0;
            const config = getRectConfig({
              datum,
              ctx: this.ctx,
              seriesId: this.id,
              isHighlighted: opts.isHighlight,
              highlightStyle: itemHighlightStyle,
              yKey,
              style,
              formatter,
              stackGroup
            });
            config.crisp = crisp;
            config.visible = visible;
            updateRect({ rect, config });
          });
        });
      }
      updateLabelSelection(opts) {
        return __async(this, null, function* () {
          const data = this.isLabelEnabled() ? opts.labelData : [];
          return opts.labelSelection.update(data, (text) => {
            text.tag = 1 /* Label */;
            text.pointerEvents = 1 /* None */;
          });
        });
      }
      updateLabelNodes(opts) {
        return __async(this, null, function* () {
          opts.labelSelection.each((textNode, datum) => {
            updateLabelNode(textNode, this.properties.label, datum.label);
          });
        });
      }
      getTooltipHtml(nodeDatum) {
        var _a2;
        const {
          id: seriesId,
          processedData,
          ctx: { callbackCache }
        } = this;
        const xAxis = this.getCategoryAxis();
        const yAxis = this.getValueAxis();
        if (!processedData || !this.properties.isValid() || !xAxis || !yAxis) {
          return EMPTY_TOOLTIP_CONTENT;
        }
        const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, tooltip, formatter, stackGroup, legendItemName } = this.properties;
        const { xValue, yValue, datum, itemId } = nodeDatum;
        const xString = xAxis.formatDatum(xValue);
        const yString = yAxis.formatDatum(yValue);
        const title = sanitizeHtml(yName);
        const content = sanitizeHtml(xString + ": " + yString);
        let format2;
        if (formatter) {
          format2 = callbackCache.call(formatter, {
            seriesId,
            datum,
            xKey,
            yKey,
            stackGroup,
            fill,
            stroke,
            strokeWidth: this.getStrokeWidth(strokeWidth),
            highlighted: false
          });
        }
        const color = (_a2 = format2 == null ? void 0 : format2.fill) != null ? _a2 : fill;
        return tooltip.toTooltipHtml(
          { title, content, backgroundColor: color },
          __spreadValues({
            seriesId,
            itemId,
            datum,
            xKey,
            yKey,
            xName,
            yName,
            stackGroup,
            title,
            color,
            legendItemName
          }, this.getModuleTooltipParams())
        );
      }
      getLegendData(legendType) {
        var _a2, _b;
        const { showInLegend } = this.properties;
        if (legendType !== "category" || !((_a2 = this.data) == null ? void 0 : _a2.length) || !this.properties.isValid() || !showInLegend) {
          return [];
        }
        const { yKey, yName, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, legendItemName, visible } = this.properties;
        return [
          {
            legendType: "category",
            id: this.id,
            itemId: yKey,
            seriesId: this.id,
            enabled: visible,
            label: { text: (_b = legendItemName != null ? legendItemName : yName) != null ? _b : yKey },
            marker: { fill, fillOpacity, stroke, strokeWidth, strokeOpacity },
            legendItemName
          }
        ];
      }
      animateEmptyUpdateReady({ datumSelection, labelSelection, annotationSelections }) {
        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, "normal"));
        fromToMotion(this.id, "nodes", this.ctx.animationManager, [datumSelection], fns);
        seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
        seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
      }
      animateWaitingUpdateReady(data) {
        var _a2, _b, _c;
        const { datumSelection, labelSelection, annotationSelections, previousContextData } = data;
        this.ctx.animationManager.stopByAnimationGroupId(this.id);
        const dataDiff = (_b = (_a2 = this.processedData) == null ? void 0 : _a2.reduced) == null ? void 0 : _b.diff;
        const mode = previousContextData == null ? "fade" : "normal";
        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));
        fromToMotion(
          this.id,
          "nodes",
          this.ctx.animationManager,
          [datumSelection],
          fns,
          (_, datum) => createDatumId(datum.xValue, datum.valueIndex),
          dataDiff
        );
        const hasMotion = (_c = dataDiff == null ? void 0 : dataDiff.changed) != null ? _c : true;
        if (hasMotion) {
          seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
          seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
        }
      }
      isLabelEnabled() {
        return this.properties.label.enabled;
      }
      computeFocusBounds({ datumIndex, seriesRect }) {
        var _a2;
        const datumBox = (_a2 = this.contextNodeData) == null ? void 0 : _a2.nodeData[datumIndex].clipBBox;
        return computeBarFocusBounds(datumBox, this.contentGroup, seriesRect);
      }
    };
    BarSeries.className = "BarSeries";
    BarSeries.type = "bar";
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts
var BarSeriesModule;
var init_barSeriesModule = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts"() {
    "use strict";
    init_theme();
    init_constants();
    init_symbols();
    init_barSeries();
    BarSeriesModule = {
      type: "series",
      optionsKey: "series[]",
      packageType: "community",
      chartTypes: ["cartesian"],
      identifier: "bar",
      instanceConstructor: BarSeries,
      stackable: true,
      groupable: true,
      defaultAxes: [
        {
          type: "number" /* NUMBER */,
          position: "left" /* LEFT */
        },
        {
          type: "category" /* CATEGORY */,
          position: "bottom" /* BOTTOM */
        }
      ],
      swapDefaultAxesCondition: (series) => (series == null ? void 0 : series.direction) === "horizontal",
      themeTemplate: {
        series: {
          __extends__: EXTENDS_SERIES_DEFAULTS,
          direction: "vertical",
          fillOpacity: 1,
          strokeWidth: 0,
          lineDash: [0],
          lineDashOffset: 0,
          label: {
            enabled: false,
            fontWeight: "normal" /* NORMAL */,
            fontSize: 12,
            fontFamily: DEFAULT_FONT_FAMILY,
            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
            placement: "inside"
          },
          shadow: {
            enabled: false,
            color: DEFAULT_SHADOW_COLOUR,
            xOffset: 3,
            yOffset: 3,
            blur: 5
          }
        }
      },
      enterpriseThemeTemplate: {
        series: {
          errorBar: {
            cap: {
              lengthRatio: 0.3
            }
          }
        }
      },
      paletteFactory: singleSeriesPaletteFactory
    };
  }
});

// packages/ag-charts-community/src/scale/colorScale.ts
var convertColorStringToOklcha, interpolateOklch, ColorScale;
var init_colorScale = __esm({
  "packages/ag-charts-community/src/scale/colorScale.ts"() {
    "use strict";
    init_color();
    init_logger();
    init_number();
    init_invalidating();
    convertColorStringToOklcha = (v) => {
      const color = Color.fromString(v);
      const [l, c, h] = Color.RGBtoOKLCH(color.r, color.g, color.b);
      return { l, c, h, a: color.a };
    };
    interpolateOklch = (x, y, d) => {
      d = clamp(0, d, 1);
      let h;
      let c;
      if (Number.isNaN(x.h) && Number.isNaN(y.h)) {
        h = 0;
        c = 0;
      } else if (Number.isNaN(x.h)) {
        h = y.h;
        c = y.c;
      } else if (Number.isNaN(y.h)) {
        h = x.h;
        c = x.c;
      } else {
        const xH = x.h;
        let yH = y.h;
        const deltaH = y.h - x.h;
        if (deltaH > 180) {
          yH -= 360;
        } else if (deltaH < -180) {
          yH += 360;
        }
        h = xH * (1 - d) + yH * d;
        c = x.c * (1 - d) + y.c * d;
      }
      const l = x.l * (1 - d) + y.l * d;
      const a = x.a * (1 - d) + y.a * d;
      return Color.fromOKLCH(l, c, h, a);
    };
    ColorScale = class {
      constructor() {
        this.type = "color";
        this.invalid = true;
        this.domain = [0, 1];
        this.range = ["red", "blue"];
        this.parsedRange = this.range.map(convertColorStringToOklcha);
      }
      update() {
        const { domain, range: range4 } = this;
        if (domain.length < 2) {
          Logger.warnOnce("`colorDomain` should have at least 2 values.");
          if (domain.length === 0) {
            domain.push(0, 1);
          } else if (domain.length === 1) {
            domain.push(domain[0] + 1);
          }
        }
        for (let i = 1; i < domain.length; i++) {
          const a = domain[i - 1];
          const b = domain[i];
          if (a >= b) {
            Logger.warnOnce("`colorDomain` values should be supplied in ascending order.");
            domain.sort((a2, b2) => a2 - b2);
            break;
          }
        }
        if (range4.length < domain.length) {
          for (let i = range4.length; i < domain.length; i++) {
            range4.push(range4.length > 0 ? range4[0] : "black");
          }
        }
        this.parsedRange = this.range.map(convertColorStringToOklcha);
      }
      convert(x) {
        this.refresh();
        const { domain, range: range4, parsedRange } = this;
        const d0 = domain[0];
        const d1 = domain.at(-1);
        const r0 = range4[0];
        const r1 = range4[range4.length - 1];
        if (x <= d0) {
          return r0;
        }
        if (x >= d1) {
          return r1;
        }
        let index;
        let q;
        if (domain.length === 2) {
          const t = (x - d0) / (d1 - d0);
          const step = 1 / (range4.length - 1);
          index = range4.length <= 2 ? 0 : Math.min(Math.floor(t * (range4.length - 1)), range4.length - 2);
          q = (t - index * step) / step;
        } else {
          for (index = 0; index < domain.length - 2; index++) {
            if (x < domain[index + 1]) {
              break;
            }
          }
          const a = domain[index];
          const b = domain[index + 1];
          q = (x - a) / (b - a);
        }
        const c0 = parsedRange[index];
        const c1 = parsedRange[index + 1];
        return interpolateOklch(c0, c1, q).toRgbaString();
      }
      refresh() {
        if (!this.invalid)
          return;
        this.invalid = false;
        this.update();
        if (this.invalid) {
          Logger.warnOnce("Expected update to not invalidate scale");
        }
      }
    };
    __decorateClass([
      Invalidating
    ], ColorScale.prototype, "domain", 2);
    __decorateClass([
      Invalidating
    ], ColorScale.prototype, "range", 2);
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts
var BubbleSeriesMarker, BubbleSeriesLabel, BubbleSeriesProperties;
var init_bubbleSeriesProperties = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts"() {
    "use strict";
    init_changeDetectable();
    init_validation();
    init_label();
    init_seriesMarker();
    init_seriesTooltip();
    init_cartesianSeries();
    BubbleSeriesMarker = class extends SeriesMarker {
      constructor() {
        super(...arguments);
        this.maxSize = 30;
      }
    };
    __decorateClass([
      Validate(POSITIVE_NUMBER),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], BubbleSeriesMarker.prototype, "maxSize", 2);
    __decorateClass([
      Validate(NUMBER_ARRAY, { optional: true }),
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], BubbleSeriesMarker.prototype, "domain", 2);
    BubbleSeriesLabel = class extends Label {
      constructor() {
        super(...arguments);
        this.placement = "top";
      }
    };
    __decorateClass([
      Validate(LABEL_PLACEMENT)
    ], BubbleSeriesLabel.prototype, "placement", 2);
    BubbleSeriesProperties = class extends CartesianSeriesProperties {
      constructor() {
        super(...arguments);
        this.colorRange = ["#ffff00", "#00ff00", "#0000ff"];
        this.marker = new BubbleSeriesMarker();
        this.label = new BubbleSeriesLabel();
        this.tooltip = new SeriesTooltip();
      }
    };
    __decorateClass([
      Validate(STRING)
    ], BubbleSeriesProperties.prototype, "xKey", 2);
    __decorateClass([
      Validate(STRING)
    ], BubbleSeriesProperties.prototype, "yKey", 2);
    __decorateClass([
      Validate(STRING)
    ], BubbleSeriesProperties.prototype, "sizeKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], BubbleSeriesProperties.prototype, "labelKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], BubbleSeriesProperties.prototype, "colorKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], BubbleSeriesProperties.prototype, "xName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], BubbleSeriesProperties.prototype, "yName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], BubbleSeriesProperties.prototype, "sizeName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], BubbleSeriesProperties.prototype, "labelName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], BubbleSeriesProperties.prototype, "colorName", 2);
    __decorateClass([
      Validate(NUMBER_ARRAY, { optional: true })
    ], BubbleSeriesProperties.prototype, "colorDomain", 2);
    __decorateClass([
      Validate(COLOR_STRING_ARRAY)
    ], BubbleSeriesProperties.prototype, "colorRange", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], BubbleSeriesProperties.prototype, "title", 2);
    __decorateClass([
      Validate(OBJECT)
    ], BubbleSeriesProperties.prototype, "marker", 2);
    __decorateClass([
      Validate(OBJECT)
    ], BubbleSeriesProperties.prototype, "label", 2);
    __decorateClass([
      Validate(OBJECT)
    ], BubbleSeriesProperties.prototype, "tooltip", 2);
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts
var BubbleSeriesNodeEvent, BubbleSeries;
var init_bubbleSeries = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts"() {
    "use strict";
    init_colorScale();
    init_linearScale();
    init_group();
    init_text();
    init_array();
    init_object();
    init_sanitize();
    init_chartAxisDirection();
    init_dataModel();
    init_processors();
    init_util();
    init_tooltip();
    init_series();
    init_seriesLabelUtil();
    init_bubbleSeriesProperties();
    init_cartesianSeries();
    init_markerUtil();
    BubbleSeriesNodeEvent = class extends CartesianSeriesNodeEvent {
      constructor(type, nativeEvent, datum, series) {
        super(type, nativeEvent, datum, series);
        this.sizeKey = series.properties.sizeKey;
      }
    };
    BubbleSeries = class extends CartesianSeries {
      constructor(moduleCtx) {
        super({
          moduleCtx,
          directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
          directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
          pickModes: [
            2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,
            3 /* NEAREST_NODE */,
            0 /* EXACT_SHAPE_MATCH */
          ],
          pathsPerSeries: 0,
          hasMarkers: true,
          markerSelectionGarbageCollection: false,
          animationResetFns: {
            label: resetLabelFn,
            marker: resetMarkerFn
          }
        });
        this.NodeEvent = BubbleSeriesNodeEvent;
        this.properties = new BubbleSeriesProperties();
        this.sizeScale = new LinearScale();
        this.colorScale = new ColorScale();
      }
      processData(dataController) {
        return __async(this, null, function* () {
          var _a2, _b, _c, _d;
          if (!this.properties.isValid() || this.data == null || !this.visible)
            return;
          const xScale = (_a2 = this.axes["x" /* X */]) == null ? void 0 : _a2.scale;
          const yScale = (_b = this.axes["y" /* Y */]) == null ? void 0 : _b.scale;
          const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
          const colorScaleType = this.colorScale.type;
          const sizeScaleType = this.sizeScale.type;
          const { xKey, yKey, sizeKey, labelKey, colorDomain, colorRange, colorKey, marker } = this.properties;
          const { dataModel, processedData } = yield this.requestDataModel(dataController, this.data, {
            props: [
              keyProperty(xKey, xScaleType, { id: "xKey-raw" }),
              keyProperty(yKey, yScaleType, { id: "yKey-raw" }),
              ...labelKey ? [keyProperty(labelKey, "band", { id: `labelKey-raw` })] : [],
              valueProperty(xKey, xScaleType, { id: `xValue` }),
              valueProperty(yKey, yScaleType, { id: `yValue` }),
              valueProperty(sizeKey, sizeScaleType, { id: `sizeValue` }),
              ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],
              ...labelKey ? [valueProperty(labelKey, "band", { id: `labelValue` })] : []
            ]
          });
          const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);
          const processedSize = (_c = processedData.domain.values[sizeKeyIdx]) != null ? _c : [];
          this.sizeScale.domain = marker.domain ? marker.domain : processedSize;
          if (colorKey) {
            const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);
            this.colorScale.domain = (_d = colorDomain != null ? colorDomain : processedData.domain.values[colorKeyIdx]) != null ? _d : [];
            this.colorScale.range = colorRange;
            this.colorScale.update();
          }
          this.animationState.transition("updateData");
        });
      }
      getSeriesDomain(direction) {
        const { dataModel, processedData } = this;
        if (!processedData || !dataModel)
          return [];
        const id = direction === "x" /* X */ ? `xValue` : `yValue`;
        const dataDef = dataModel.resolveProcessedDataDefById(this, id);
        const domain = dataModel.getDomain(this, id, "value", processedData);
        if ((dataDef == null ? void 0 : dataDef.def.type) === "value" && (dataDef == null ? void 0 : dataDef.def.valueType) === "category") {
          return domain;
        }
        const axis = this.axes[direction];
        return fixNumericExtent(extent(domain), axis);
      }
      createNodeData() {
        return __async(this, null, function* () {
          var _a2, _b, _c;
          const { axes, dataModel, processedData, colorScale, sizeScale } = this;
          const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, label, colorKey, marker, visible } = this.properties;
          const markerShape = getMarker(marker.shape);
          const { placement } = label;
          const xAxis = axes["x" /* X */];
          const yAxis = axes["y" /* Y */];
          if (!(dataModel && processedData && visible && xAxis && yAxis)) {
            return;
          }
          const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);
          const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);
          const sizeDataIdx = sizeKey ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : -1;
          const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;
          const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;
          const xScale = xAxis.scale;
          const yScale = yAxis.scale;
          const xOffset = ((_a2 = xScale.bandwidth) != null ? _a2 : 0) / 2;
          const yOffset = ((_b = yScale.bandwidth) != null ? _b : 0) / 2;
          const nodeData = [];
          sizeScale.range = [marker.size, marker.maxSize];
          const font = label.getFont();
          for (const { values, datum } of (_c = processedData.data) != null ? _c : []) {
            const xDatum = values[xDataIdx];
            const yDatum = values[yDataIdx];
            const x = xScale.convert(xDatum) + xOffset;
            const y = yScale.convert(yDatum) + yOffset;
            const labelText = this.getLabelText(label, {
              value: labelKey ? values[labelDataIdx] : yDatum,
              datum,
              xKey,
              yKey,
              sizeKey,
              labelKey,
              xName,
              yName,
              sizeName,
              labelName
            });
            const size = Text.getTextSize(String(labelText), font);
            const markerSize = sizeKey ? sizeScale.convert(values[sizeDataIdx]) : marker.size;
            const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;
            nodeData.push({
              series: this,
              itemId: yKey,
              yKey,
              xKey,
              datum,
              xValue: xDatum,
              yValue: yDatum,
              sizeValue: values[sizeDataIdx],
              point: { x, y, size: markerSize },
              midPoint: { x, y },
              fill,
              label: __spreadValues({ text: labelText }, size),
              marker: markerShape,
              placement
            });
          }
          return {
            itemId: yKey,
            nodeData,
            labelData: nodeData,
            scales: this.calculateScaling(),
            visible: this.visible
          };
        });
      }
      isPathOrSelectionDirty() {
        return this.properties.marker.isDirty();
      }
      getLabelData() {
        var _a2, _b;
        return (_b = (_a2 = this.contextNodeData) == null ? void 0 : _a2.labelData) != null ? _b : [];
      }
      markerFactory() {
        const { shape } = this.properties.marker;
        const MarkerShape = getMarker(shape);
        return new MarkerShape();
      }
      updateMarkerSelection(opts) {
        return __async(this, null, function* () {
          const { nodeData, markerSelection } = opts;
          if (this.properties.marker.isDirty()) {
            markerSelection.clear();
            markerSelection.cleanup();
          }
          const data = this.properties.marker.enabled ? nodeData : [];
          return markerSelection.update(
            data,
            void 0,
            (datum) => createDatumId([datum.xValue, datum.yValue, datum.label.text])
          );
        });
      }
      updateMarkerNodes(opts) {
        return __async(this, null, function* () {
          const { markerSelection, isHighlight: highlighted } = opts;
          const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;
          const baseStyle = mergeDefaults(highlighted && this.properties.highlightStyle.item, marker.getStyle());
          this.sizeScale.range = [marker.size, marker.maxSize];
          markerSelection.each((node, datum) => {
            this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, sizeKey, labelKey }, baseStyle);
          });
          if (!highlighted) {
            this.properties.marker.markClean();
          }
        });
      }
      updateLabelSelection(opts) {
        return __async(this, null, function* () {
          var _a2, _b;
          const placedLabels = this.properties.label.enabled ? (_b = (_a2 = this.chart) == null ? void 0 : _a2.placeLabels().get(this)) != null ? _b : [] : [];
          return opts.labelSelection.update(
            placedLabels.map((v) => __spreadProps(__spreadValues({}, v.datum), {
              point: {
                x: v.x,
                y: v.y,
                size: v.datum.point.size
              }
            }))
          );
        });
      }
      updateLabelNodes(opts) {
        return __async(this, null, function* () {
          const { label } = this.properties;
          opts.labelSelection.each((text, datum) => {
            var _a2, _b, _c, _d;
            text.text = datum.label.text;
            text.fill = label.color;
            text.x = (_b = (_a2 = datum.point) == null ? void 0 : _a2.x) != null ? _b : 0;
            text.y = (_d = (_c = datum.point) == null ? void 0 : _c.y) != null ? _d : 0;
            text.fontStyle = label.fontStyle;
            text.fontWeight = label.fontWeight;
            text.fontSize = label.fontSize;
            text.fontFamily = label.fontFamily;
            text.textAlign = "left";
            text.textBaseline = "top";
          });
        });
      }
      getTooltipHtml(nodeDatum) {
        var _a2;
        const xAxis = this.axes["x" /* X */];
        const yAxis = this.axes["y" /* Y */];
        if (!this.properties.isValid() || !xAxis || !yAxis) {
          return EMPTY_TOOLTIP_CONTENT;
        }
        const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, marker, tooltip } = this.properties;
        const title = (_a2 = this.properties.title) != null ? _a2 : yName;
        const baseStyle = mergeDefaults(
          { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },
          marker.getStyle()
        );
        const { fill: color = "gray" } = this.getMarkerStyle(
          marker,
          { datum: nodeDatum, highlighted: false, xKey, yKey, sizeKey, labelKey },
          baseStyle
        );
        const {
          datum,
          xValue,
          yValue,
          sizeValue,
          label: { text: labelText },
          itemId
        } = nodeDatum;
        const xString = sanitizeHtml(xAxis.formatDatum(xValue));
        const yString = sanitizeHtml(yAxis.formatDatum(yValue));
        let content = `<b>${sanitizeHtml(xName != null ? xName : xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName != null ? yName : yKey)}</b>: ${yString}`;
        if (sizeKey) {
          content += `<br><b>${sanitizeHtml(sizeName != null ? sizeName : sizeKey)}</b>: ${sanitizeHtml(String(sizeValue))}`;
        }
        if (labelKey) {
          content = `<b>${sanitizeHtml(labelName != null ? labelName : labelKey)}</b>: ${sanitizeHtml(labelText)}<br>` + content;
        }
        return tooltip.toTooltipHtml(
          { title, content, backgroundColor: color },
          {
            datum,
            itemId,
            xKey,
            xName,
            yKey,
            yName,
            sizeKey,
            sizeName,
            labelKey,
            labelName,
            title,
            color,
            seriesId: this.id
          }
        );
      }
      getLegendData() {
        var _a2, _b;
        if (!((_a2 = this.data) == null ? void 0 : _a2.length) || !this.properties.isValid()) {
          return [];
        }
        const { yKey, yName, title, marker, visible } = this.properties;
        const { shape, fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;
        return [
          {
            legendType: "category",
            id: this.id,
            itemId: yKey,
            seriesId: this.id,
            enabled: visible,
            label: {
              text: (_b = title != null ? title : yName) != null ? _b : yKey
            },
            marker: {
              shape,
              fill: fill != null ? fill : "rgba(0, 0, 0, 0)",
              stroke: stroke != null ? stroke : "rgba(0, 0, 0, 0)",
              fillOpacity: fillOpacity != null ? fillOpacity : 1,
              strokeOpacity: strokeOpacity != null ? strokeOpacity : 1,
              strokeWidth: strokeWidth != null ? strokeWidth : 0
            }
          }
        ];
      }
      animateEmptyUpdateReady({ markerSelection, labelSelection }) {
        markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);
        seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
      }
      isLabelEnabled() {
        return this.properties.label.enabled;
      }
      nodeFactory() {
        return new Group();
      }
      getFormattedMarkerStyle(datum) {
        const { xKey, yKey, sizeKey, labelKey } = this.properties;
        return this.getMarkerStyle(this.properties.marker, {
          datum,
          xKey,
          yKey,
          sizeKey,
          labelKey,
          highlighted: false
        });
      }
      computeFocusBounds(opts) {
        return computeMarkerFocusBounds(this, opts);
      }
    };
    BubbleSeries.className = "BubbleSeries";
    BubbleSeries.type = "bubble";
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts
var BubbleSeriesModule;
var init_bubbleSeriesModule = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts"() {
    "use strict";
    init_theme();
    init_constants();
    init_symbols();
    init_bubbleSeries();
    BubbleSeriesModule = {
      type: "series",
      optionsKey: "series[]",
      packageType: "community",
      chartTypes: ["cartesian"],
      identifier: "bubble",
      instanceConstructor: BubbleSeries,
      defaultAxes: [
        {
          type: "number" /* NUMBER */,
          position: "bottom" /* BOTTOM */
        },
        {
          type: "number" /* NUMBER */,
          position: "left" /* LEFT */
        }
      ],
      themeTemplate: {
        series: {
          __extends__: EXTENDS_SERIES_DEFAULTS,
          tooltip: { position: { type: "node" } },
          marker: {
            __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,
            maxSize: 30,
            fillOpacity: 0.8
          },
          label: {
            enabled: false,
            fontSize: 12,
            fontFamily: DEFAULT_FONT_FAMILY,
            color: DEFAULT_LABEL_COLOUR
          }
        }
      },
      paletteFactory: markerPaletteFactory
    };
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts
var HistogramSeriesProperties;
var init_histogramSeriesProperties = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts"() {
    "use strict";
    init_dropShadow();
    init_validation();
    init_label();
    init_seriesTooltip();
    init_cartesianSeries();
    HistogramSeriesProperties = class extends CartesianSeriesProperties {
      constructor() {
        super(...arguments);
        this.fillOpacity = 1;
        this.strokeWidth = 1;
        this.strokeOpacity = 1;
        this.lineDash = [0];
        this.lineDashOffset = 0;
        this.cornerRadius = 0;
        this.areaPlot = false;
        this.aggregation = "sum";
        this.shadow = new DropShadow();
        this.label = new Label();
        this.tooltip = new SeriesTooltip();
      }
    };
    __decorateClass([
      Validate(STRING)
    ], HistogramSeriesProperties.prototype, "xKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], HistogramSeriesProperties.prototype, "yKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], HistogramSeriesProperties.prototype, "xName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], HistogramSeriesProperties.prototype, "yName", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], HistogramSeriesProperties.prototype, "fill", 2);
    __decorateClass([
      Validate(RATIO)
    ], HistogramSeriesProperties.prototype, "fillOpacity", 2);
    __decorateClass([
      Validate(COLOR_STRING, { optional: true })
    ], HistogramSeriesProperties.prototype, "stroke", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], HistogramSeriesProperties.prototype, "strokeWidth", 2);
    __decorateClass([
      Validate(RATIO)
    ], HistogramSeriesProperties.prototype, "strokeOpacity", 2);
    __decorateClass([
      Validate(LINE_DASH)
    ], HistogramSeriesProperties.prototype, "lineDash", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], HistogramSeriesProperties.prototype, "lineDashOffset", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], HistogramSeriesProperties.prototype, "cornerRadius", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], HistogramSeriesProperties.prototype, "areaPlot", 2);
    __decorateClass([
      Validate(ARRAY, { optional: true })
    ], HistogramSeriesProperties.prototype, "bins", 2);
    __decorateClass([
      Validate(UNION(["count", "sum", "mean"], "a histogram aggregation"))
    ], HistogramSeriesProperties.prototype, "aggregation", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], HistogramSeriesProperties.prototype, "binCount", 2);
    __decorateClass([
      Validate(OBJECT)
    ], HistogramSeriesProperties.prototype, "shadow", 2);
    __decorateClass([
      Validate(OBJECT)
    ], HistogramSeriesProperties.prototype, "label", 2);
    __decorateClass([
      Validate(OBJECT)
    ], HistogramSeriesProperties.prototype, "tooltip", 2);
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts
var defaultBinCount, HistogramSeries;
var init_histogramSeries = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts"() {
    "use strict";
    init_fromToMotion();
    init_node();
    init_rect();
    init_sanitize();
    init_ticks();
    init_type_guards();
    init_chartAxisDirection();
    init_aggregateFunctions();
    init_dataModel();
    init_processors();
    init_tooltip();
    init_series();
    init_seriesLabelUtil();
    init_barUtil();
    init_cartesianSeries();
    init_histogramSeriesProperties();
    init_quadtreeUtil();
    defaultBinCount = 10;
    HistogramSeries = class extends CartesianSeries {
      constructor(moduleCtx) {
        super({
          moduleCtx,
          directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
          directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
          pickModes: [0 /* EXACT_SHAPE_MATCH */],
          datumSelectionGarbageCollection: false,
          animationResetFns: {
            datum: resetBarSelectionsFn,
            label: resetLabelFn
          }
        });
        this.properties = new HistogramSeriesProperties();
        this.calculatedBins = [];
      }
      // During processData phase, used to unify different ways of the user specifying
      // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].
      deriveBins(xDomain) {
        const binStarts = ticks_default(xDomain[0], xDomain[1], defaultBinCount);
        const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);
        const [firstBinEnd] = binStarts;
        const expandStartToBin = (n) => [n, n + binSize];
        return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];
      }
      calculateNiceBins(domain, binCount) {
        const startGuess = Math.floor(domain[0]);
        const stop = domain[1];
        const segments = binCount || 1;
        const { start, binSize } = this.calculateNiceStart(startGuess, stop, segments);
        return this.getBins(start, stop, binSize, segments);
      }
      getBins(start, stop, step, count) {
        const bins = [];
        const precision = this.calculatePrecision(step);
        for (let i = 0; i < count; i++) {
          const a = Math.round((start + i * step) * precision) / precision;
          let b = Math.round((start + (i + 1) * step) * precision) / precision;
          if (i === count - 1) {
            b = Math.max(b, stop);
          }
          bins[i] = [a, b];
        }
        return bins;
      }
      calculatePrecision(step) {
        let precision = 10;
        if (isFinite(step) && step > 0) {
          while (step < 1) {
            precision *= 10;
            step *= 10;
          }
        }
        return precision;
      }
      calculateNiceStart(a, b, segments) {
        const binSize = Math.abs(b - a) / segments;
        const order = Math.floor(Math.log10(binSize));
        const magnitude2 = Math.pow(10, order);
        const start = Math.floor(a / magnitude2) * magnitude2;
        return {
          start,
          binSize
        };
      }
      processData(dataController) {
        return __async(this, null, function* () {
          var _a2, _b;
          if (!this.visible) {
            this.processedData = void 0;
            this.animationState.transition("updateData");
          }
          const { xKey, yKey, areaPlot, aggregation } = this.properties;
          const xScale = (_a2 = this.axes["x" /* X */]) == null ? void 0 : _a2.scale;
          const yScale = (_b = this.axes["y" /* Y */]) == null ? void 0 : _b.scale;
          const { xScaleType, yScaleType } = this.getScaleInformation({ yScale, xScale });
          const props = [keyProperty(xKey, xScaleType), SORT_DOMAIN_GROUPS];
          if (yKey) {
            let aggProp = groupCount("groupAgg");
            if (aggregation === "count") {
            } else if (aggregation === "sum") {
              aggProp = groupSum("groupAgg");
            } else if (aggregation === "mean") {
              aggProp = groupAverage("groupAgg");
            }
            if (areaPlot) {
              aggProp = area("groupAgg", aggProp);
            }
            props.push(valueProperty(yKey, yScaleType, { invalidValue: void 0 }), aggProp);
          } else {
            let aggProp = groupCount("groupAgg");
            if (areaPlot) {
              aggProp = area("groupAgg", aggProp);
            }
            props.push(aggProp);
          }
          const groupByFn = (dataSet) => {
            var _a3;
            const xExtent = fixNumericExtent(dataSet.domain.keys[0]);
            if (xExtent.length === 0) {
              dataSet.domain.groups = [];
              return () => [];
            }
            const bins = isNumber(this.properties.binCount) ? this.calculateNiceBins(xExtent, this.properties.binCount) : (_a3 = this.properties.bins) != null ? _a3 : this.deriveBins(xExtent);
            const binCount = bins.length;
            this.calculatedBins = [...bins];
            return (item) => {
              const xValue = item.keys[0];
              for (let i = 0; i < binCount; i++) {
                const nextBin = bins[i];
                if (xValue >= nextBin[0] && xValue < nextBin[1]) {
                  return nextBin;
                }
                if (i === binCount - 1 && xValue <= nextBin[1]) {
                  return nextBin;
                }
              }
              return [];
            };
          };
          if (!this.ctx.animationManager.isSkipped() && this.processedData) {
            props.push(diff(this.processedData, false));
          }
          yield this.requestDataModel(dataController, this.data, { props, groupByFn });
          this.animationState.transition("updateData");
        });
      }
      getSeriesDomain(direction) {
        var _a2, _b, _c, _d;
        const { processedData, dataModel } = this;
        if (!processedData || !dataModel || !this.calculatedBins.length)
          return [];
        const yDomain = dataModel.getDomain(this, `groupAgg`, "aggregate", processedData);
        const xDomainMin = (_a2 = this.calculatedBins) == null ? void 0 : _a2[0][0];
        const xDomainMax = (_d = this.calculatedBins) == null ? void 0 : _d[((_c = (_b = this.calculatedBins) == null ? void 0 : _b.length) != null ? _c : 0) - 1][1];
        if (direction === "x" /* X */) {
          return fixNumericExtent([xDomainMin, xDomainMax]);
        }
        return fixNumericExtent(yDomain);
      }
      createNodeData() {
        return __async(this, null, function* () {
          var _a2;
          const {
            id: seriesId,
            axes,
            processedData,
            ctx: { callbackCache }
          } = this;
          const xAxis = axes["x" /* X */];
          const yAxis = axes["y" /* Y */];
          if (!xAxis || !yAxis) {
            return;
          }
          const { scale: xScale } = xAxis;
          const { scale: yScale } = yAxis;
          const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius } = this.properties;
          const {
            formatter: labelFormatter = (params) => String(params.value),
            fontStyle: labelFontStyle,
            fontWeight: labelFontWeight,
            fontSize: labelFontSize,
            fontFamily: labelFontFamily,
            color: labelColor
          } = this.properties.label;
          const nodeData = [];
          const context = {
            itemId: (_a2 = this.properties.yKey) != null ? _a2 : this.id,
            nodeData,
            labelData: nodeData,
            scales: this.calculateScaling(),
            animationValid: true,
            visible: this.visible
          };
          if (!this.visible || !processedData || processedData.type !== "grouped")
            return context;
          processedData.data.forEach((group2) => {
            var _a3;
            const {
              aggValues: [[negativeAgg, positiveAgg]] = [[0, 0]],
              datum,
              datum: { length: frequency },
              keys: domain,
              keys: [xDomainMin, xDomainMax]
            } = group2;
            const xMinPx = xScale.convert(xDomainMin);
            const xMaxPx = xScale.convert(xDomainMax);
            const total = negativeAgg + positiveAgg;
            const yZeroPx = yScale.convert(0);
            const yMaxPx = yScale.convert(total);
            const w = Math.abs(xMaxPx - xMinPx);
            const h = Math.abs(yMaxPx - yZeroPx);
            const x = Math.min(xMinPx, xMaxPx);
            const y = Math.min(yZeroPx, yMaxPx);
            let selectionDatumLabel = void 0;
            if (total !== 0) {
              selectionDatumLabel = {
                text: (_a3 = callbackCache.call(labelFormatter, {
                  value: total,
                  datum,
                  seriesId,
                  xKey,
                  yKey,
                  xName,
                  yName
                })) != null ? _a3 : String(total),
                fontStyle: labelFontStyle,
                fontWeight: labelFontWeight,
                fontSize: labelFontSize,
                fontFamily: labelFontFamily,
                fill: labelColor,
                x: x + w / 2,
                y: y + h / 2
              };
            }
            const nodeMidPoint = {
              x: x + w / 2,
              y: y + h / 2
            };
            const yAxisReversed = yAxis.isReversed();
            nodeData.push({
              series: this,
              datum,
              // required by SeriesNodeDatum, but might not make sense here
              // since each selection is an aggregation of multiple data.
              aggregatedValue: total,
              frequency,
              domain,
              yKey,
              xKey,
              x,
              y,
              xValue: xMinPx,
              yValue: yMaxPx,
              width: w,
              height: h,
              midPoint: nodeMidPoint,
              fill,
              stroke,
              cornerRadius,
              topLeftCornerRadius: !yAxisReversed,
              topRightCornerRadius: !yAxisReversed,
              bottomRightCornerRadius: yAxisReversed,
              bottomLeftCornerRadius: yAxisReversed,
              opacity: 1,
              strokeWidth,
              label: selectionDatumLabel
            });
          });
          nodeData.sort((a, b) => a.x - b.x);
          return context;
        });
      }
      nodeFactory() {
        return new Rect();
      }
      updateDatumSelection(opts) {
        return __async(this, null, function* () {
          const { nodeData, datumSelection } = opts;
          return datumSelection.update(
            nodeData,
            (rect) => {
              rect.tag = 0 /* Bin */;
              rect.crisp = true;
            },
            (datum) => datum.domain.join("_")
          );
        });
      }
      updateDatumNodes(opts) {
        return __async(this, null, function* () {
          const { isHighlight: isDatumHighlighted } = opts;
          const {
            fillOpacity: seriesFillOpacity,
            strokeOpacity,
            lineDash,
            lineDashOffset,
            shadow,
            highlightStyle: {
              item: {
                fill: highlightedFill,
                fillOpacity: highlightFillOpacity = seriesFillOpacity,
                stroke: highlightedStroke,
                strokeWidth: highlightedDatumStrokeWidth
              }
            }
          } = this.properties;
          opts.datumSelection.each((rect, datum, index) => {
            var _a2, _b;
            const {
              cornerRadius,
              topLeftCornerRadius,
              topRightCornerRadius,
              bottomRightCornerRadius,
              bottomLeftCornerRadius
            } = datum;
            const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== void 0 ? highlightedDatumStrokeWidth : datum.strokeWidth;
            const fillOpacity = isDatumHighlighted ? highlightFillOpacity : seriesFillOpacity;
            rect.fill = (_a2 = isDatumHighlighted ? highlightedFill : void 0) != null ? _a2 : datum.fill;
            rect.stroke = (_b = isDatumHighlighted ? highlightedStroke : void 0) != null ? _b : datum.stroke;
            rect.fillOpacity = fillOpacity;
            rect.strokeOpacity = strokeOpacity;
            rect.strokeWidth = strokeWidth;
            rect.lineDash = lineDash;
            rect.lineDashOffset = lineDashOffset;
            rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;
            rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;
            rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;
            rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;
            rect.fillShadow = shadow;
            rect.zIndex = isDatumHighlighted ? Series.highlightedZIndex : index;
            rect.visible = datum.height > 0;
          });
        });
      }
      updateLabelSelection(opts) {
        return __async(this, null, function* () {
          const { labelData, labelSelection } = opts;
          return labelSelection.update(labelData, (text) => {
            text.tag = 1 /* Label */;
            text.pointerEvents = 1 /* None */;
            text.textAlign = "center";
            text.textBaseline = "middle";
          });
        });
      }
      updateLabelNodes(opts) {
        return __async(this, null, function* () {
          const labelEnabled = this.isLabelEnabled();
          opts.labelSelection.each((text, datum) => {
            const label = datum.label;
            if (label && labelEnabled) {
              text.text = label.text;
              text.x = label.x;
              text.y = label.y;
              text.fontStyle = label.fontStyle;
              text.fontWeight = label.fontWeight;
              text.fontSize = label.fontSize;
              text.fontFamily = label.fontFamily;
              text.fill = label.fill;
              text.visible = true;
            } else {
              text.visible = false;
            }
          });
        });
      }
      initQuadTree(quadtree) {
        addHitTestersToQuadtree(quadtree, childrenIter(this.contentGroup.children[0]));
      }
      pickNodeClosestDatum(point) {
        return findQuadtreeMatch(this, point);
      }
      getTooltipHtml(nodeDatum) {
        const xAxis = this.axes["x" /* X */];
        const yAxis = this.axes["y" /* Y */];
        if (!this.properties.isValid() || !xAxis || !yAxis) {
          return EMPTY_TOOLTIP_CONTENT;
        }
        const { xKey, yKey, xName, yName, fill: color, aggregation, tooltip } = this.properties;
        const {
          aggregatedValue,
          frequency,
          domain: [rangeMin, rangeMax],
          itemId
        } = nodeDatum;
        const title = `${sanitizeHtml(xName != null ? xName : xKey)}: ${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`;
        let content = yKey ? `<b>${sanitizeHtml(yName != null ? yName : yKey)} (${aggregation})</b>: ${yAxis.formatDatum(aggregatedValue)}<br>` : "";
        content += `<b>Frequency</b>: ${frequency}`;
        const defaults = {
          title,
          backgroundColor: color,
          content
        };
        return tooltip.toTooltipHtml(defaults, {
          datum: {
            data: nodeDatum.datum,
            aggregatedValue: nodeDatum.aggregatedValue,
            domain: nodeDatum.domain,
            frequency: nodeDatum.frequency
          },
          itemId,
          xKey,
          xName,
          yKey,
          yName,
          color,
          title,
          seriesId: this.id
        });
      }
      getLegendData(legendType) {
        var _a2, _b;
        if (!((_a2 = this.data) == null ? void 0 : _a2.length) || legendType !== "category") {
          return [];
        }
        const { xKey, yName, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, visible } = this.properties;
        return [
          {
            legendType: "category",
            id: this.id,
            itemId: xKey,
            seriesId: this.id,
            enabled: visible,
            label: {
              text: (_b = yName != null ? yName : xKey) != null ? _b : "Frequency"
            },
            marker: {
              fill: fill != null ? fill : "rgba(0, 0, 0, 0)",
              stroke: stroke != null ? stroke : "rgba(0, 0, 0, 0)",
              fillOpacity,
              strokeOpacity,
              strokeWidth
            }
          }
        ];
      }
      animateEmptyUpdateReady({ datumSelection, labelSelection }) {
        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, "normal"));
        fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], fns);
        seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
      }
      animateWaitingUpdateReady(data) {
        var _a2, _b;
        const dataDiff = (_b = (_a2 = this.processedData) == null ? void 0 : _a2.reduced) == null ? void 0 : _b.diff;
        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, "normal"));
        fromToMotion(
          this.id,
          "datums",
          this.ctx.animationManager,
          [data.datumSelection],
          fns,
          (_, datum) => createDatumId(datum.domain),
          dataDiff
        );
        seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, data.labelSelection);
      }
      isLabelEnabled() {
        return this.properties.label.enabled;
      }
      computeFocusBounds({ datumIndex, seriesRect }) {
        var _a2;
        return computeBarFocusBounds((_a2 = this.contextNodeData) == null ? void 0 : _a2.nodeData[datumIndex], this.contentGroup, seriesRect);
      }
    };
    HistogramSeries.className = "HistogramSeries";
    HistogramSeries.type = "histogram";
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts
var HistogramSeriesModule;
var init_histogramSeriesModule = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts"() {
    "use strict";
    init_constants();
    init_symbols();
    init_histogramSeries();
    HistogramSeriesModule = {
      type: "series",
      optionsKey: "series[]",
      packageType: "community",
      chartTypes: ["cartesian"],
      identifier: "histogram",
      instanceConstructor: HistogramSeries,
      defaultAxes: [
        {
          type: "number" /* NUMBER */,
          position: "bottom" /* BOTTOM */
        },
        {
          type: "number" /* NUMBER */,
          position: "left" /* LEFT */
        }
      ],
      themeTemplate: {
        series: {
          __extends__: EXTENDS_SERIES_DEFAULTS,
          strokeWidth: 1,
          fillOpacity: 1,
          strokeOpacity: 1,
          lineDash: [0],
          lineDashOffset: 0,
          label: {
            enabled: false,
            fontSize: 12,
            fontFamily: DEFAULT_FONT_FAMILY,
            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR
          },
          shadow: {
            enabled: false,
            color: DEFAULT_SHADOW_COLOUR,
            xOffset: 3,
            yOffset: 3,
            blur: 5
          }
        }
      },
      paletteFactory: ({ takeColors }) => {
        const {
          fills: [fill],
          strokes: [stroke]
        } = takeColors(1);
        return { fill, stroke };
      }
    };
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts
var LineSeriesProperties;
var init_lineSeriesProperties = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts"() {
    "use strict";
    init_validation();
    init_label();
    init_seriesMarker();
    init_seriesTooltip();
    init_cartesianSeries();
    LineSeriesProperties = class extends CartesianSeriesProperties {
      constructor() {
        super(...arguments);
        this.stroke = "#874349";
        this.strokeWidth = 2;
        this.strokeOpacity = 1;
        this.lineDash = [0];
        this.lineDashOffset = 0;
        this.marker = new SeriesMarker();
        this.label = new Label();
        this.tooltip = new SeriesTooltip();
        this.connectMissingData = false;
      }
    };
    __decorateClass([
      Validate(STRING)
    ], LineSeriesProperties.prototype, "xKey", 2);
    __decorateClass([
      Validate(STRING)
    ], LineSeriesProperties.prototype, "yKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], LineSeriesProperties.prototype, "xName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], LineSeriesProperties.prototype, "yName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], LineSeriesProperties.prototype, "title", 2);
    __decorateClass([
      Validate(COLOR_STRING)
    ], LineSeriesProperties.prototype, "stroke", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], LineSeriesProperties.prototype, "strokeWidth", 2);
    __decorateClass([
      Validate(RATIO)
    ], LineSeriesProperties.prototype, "strokeOpacity", 2);
    __decorateClass([
      Validate(LINE_DASH)
    ], LineSeriesProperties.prototype, "lineDash", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], LineSeriesProperties.prototype, "lineDashOffset", 2);
    __decorateClass([
      Validate(OBJECT)
    ], LineSeriesProperties.prototype, "marker", 2);
    __decorateClass([
      Validate(OBJECT)
    ], LineSeriesProperties.prototype, "label", 2);
    __decorateClass([
      Validate(OBJECT)
    ], LineSeriesProperties.prototype, "tooltip", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], LineSeriesProperties.prototype, "connectMissingData", 2);
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts
var LineSeries;
var init_lineSeries = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts"() {
    "use strict";
    init_fromToMotion();
    init_pathMotion();
    init_resetMotion();
    init_group();
    init_node();
    init_array();
    init_object();
    init_sanitize();
    init_type_guards();
    init_chartAxisDirection();
    init_dataModel();
    init_processors();
    init_util();
    init_tooltip();
    init_series();
    init_seriesLabelUtil();
    init_cartesianSeries();
    init_lineSeriesProperties();
    init_lineUtil();
    init_markerUtil();
    init_pathUtil();
    LineSeries = class extends CartesianSeries {
      constructor(moduleCtx) {
        super({
          moduleCtx,
          directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
          directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
          hasMarkers: true,
          pickModes: [
            2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,
            3 /* NEAREST_NODE */,
            0 /* EXACT_SHAPE_MATCH */
          ],
          markerSelectionGarbageCollection: false,
          animationResetFns: {
            path: buildResetPathFn({ getOpacity: () => this.getOpacity() }),
            label: resetLabelFn,
            marker: (node, datum) => __spreadValues(__spreadValues({}, resetMarkerFn(node)), resetMarkerPositionFn(node, datum))
          }
        });
        this.properties = new LineSeriesProperties();
      }
      processData(dataController) {
        return __async(this, null, function* () {
          var _a2, _b;
          if (!this.properties.isValid() || this.data == null) {
            return;
          }
          const { xKey, yKey } = this.properties;
          const animationEnabled = !this.ctx.animationManager.isSkipped();
          const xScale = (_a2 = this.axes["x" /* X */]) == null ? void 0 : _a2.scale;
          const yScale = (_b = this.axes["y" /* Y */]) == null ? void 0 : _b.scale;
          const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
          const props = [];
          if (!isContinuousX) {
            props.push(keyProperty(xKey, xScaleType, { id: "xKey" }));
          }
          if (animationEnabled) {
            props.push(animationValidation(isContinuousX ? ["xValue"] : void 0));
            if (this.processedData) {
              props.push(diff(this.processedData));
            }
          }
          props.push(
            valueProperty(xKey, xScaleType, { id: "xValue" }),
            valueProperty(yKey, yScaleType, { id: "yValue", invalidValue: void 0 })
          );
          yield this.requestDataModel(dataController, this.data, { props });
          this.animationState.transition("updateData");
        });
      }
      getSeriesDomain(direction) {
        const { axes, dataModel, processedData } = this;
        if (!processedData || !dataModel)
          return [];
        const xAxis = axes["x" /* X */];
        const yAxis = axes["y" /* Y */];
        const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
        if (direction === "x" /* X */) {
          const domain = dataModel.getDomain(this, `xValue`, "value", processedData);
          if ((xDef == null ? void 0 : xDef.def.type) === "value" && xDef.def.valueType === "category") {
            return domain;
          }
          return fixNumericExtent(extent(domain), xAxis);
        } else {
          const domain = dataModel.getDomain(this, `yValue`, "value", processedData);
          return fixNumericExtent(domain, yAxis);
        }
      }
      createNodeData() {
        return __async(this, null, function* () {
          var _a2, _b, _c;
          const { processedData, dataModel, axes } = this;
          const xAxis = axes["x" /* X */];
          const yAxis = axes["y" /* Y */];
          if (!processedData || !dataModel || !xAxis || !yAxis) {
            return;
          }
          const { xKey, yKey, xName, yName, marker, label, connectMissingData, legendItemName } = this.properties;
          const xScale = xAxis.scale;
          const yScale = yAxis.scale;
          const xOffset = ((_a2 = xScale.bandwidth) != null ? _a2 : 0) / 2;
          const yOffset = ((_b = yScale.bandwidth) != null ? _b : 0) / 2;
          const nodeData = [];
          const size = marker.enabled ? marker.size : 0;
          const xIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);
          const yIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);
          let moveTo = true;
          let nextPoint;
          for (let i = 0; i < processedData.data.length; i++) {
            const { datum, values } = nextPoint != null ? nextPoint : processedData.data[i];
            const xDatum = values[xIdx];
            const yDatum = values[yIdx];
            if (yDatum === void 0) {
              moveTo = !connectMissingData;
            } else {
              const x = xScale.convert(xDatum) + xOffset;
              if (isNaN(x)) {
                moveTo = !connectMissingData;
                nextPoint = void 0;
                continue;
              }
              nextPoint = ((_c = processedData.data[i + 1]) == null ? void 0 : _c.values[yIdx]) === void 0 ? void 0 : processedData.data[i + 1];
              const y = yScale.convert(yDatum) + yOffset;
              const labelText = this.getLabelText(
                label,
                { value: yDatum, datum, xKey, yKey, xName, yName, legendItemName },
                (value) => isFiniteNumber(value) ? value.toFixed(2) : String(value)
              );
              nodeData.push({
                series: this,
                datum,
                yKey,
                xKey,
                point: { x, y, moveTo, size },
                midPoint: { x, y },
                yValue: yDatum,
                xValue: xDatum,
                capDefaults: { lengthRatioMultiplier: this.properties.marker.getDiameter(), lengthMax: Infinity },
                label: labelText ? {
                  text: labelText,
                  fontStyle: label.fontStyle,
                  fontWeight: label.fontWeight,
                  fontSize: label.fontSize,
                  fontFamily: label.fontFamily,
                  textAlign: "center",
                  textBaseline: "bottom",
                  fill: label.color
                } : void 0
              });
              moveTo = false;
            }
          }
          return {
            itemId: yKey,
            nodeData,
            labelData: nodeData,
            scales: this.calculateScaling(),
            visible: this.visible
          };
        });
      }
      isPathOrSelectionDirty() {
        return this.properties.marker.isDirty();
      }
      markerFactory() {
        const { shape } = this.properties.marker;
        const MarkerShape = getMarker(shape);
        return new MarkerShape();
      }
      updatePathNodes(opts) {
        return __async(this, null, function* () {
          const {
            paths: [lineNode],
            opacity,
            visible,
            animationEnabled
          } = opts;
          lineNode.setProperties({
            fill: void 0,
            lineJoin: "round",
            pointerEvents: 1 /* None */,
            opacity,
            stroke: this.properties.stroke,
            strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),
            strokeOpacity: this.properties.strokeOpacity,
            lineDash: this.properties.lineDash,
            lineDashOffset: this.properties.lineDashOffset
          });
          if (!animationEnabled) {
            lineNode.visible = visible;
          }
          updateClipPath(this, lineNode);
        });
      }
      updateMarkerSelection(opts) {
        return __async(this, null, function* () {
          let { nodeData } = opts;
          const { markerSelection } = opts;
          const { shape, enabled } = this.properties.marker;
          nodeData = shape && enabled ? nodeData : [];
          if (this.properties.marker.isDirty()) {
            markerSelection.clear();
            markerSelection.cleanup();
          }
          return markerSelection.update(nodeData, void 0, (datum) => createDatumId(datum.xValue));
        });
      }
      updateMarkerNodes(opts) {
        return __async(this, null, function* () {
          const { markerSelection, isHighlight: highlighted } = opts;
          const { xKey, yKey, stroke, strokeWidth, strokeOpacity, marker, highlightStyle } = this.properties;
          const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {
            stroke,
            strokeWidth,
            strokeOpacity
          });
          const applyTranslation = this.ctx.animationManager.isSkipped();
          markerSelection.each((node, datum) => {
            this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, { applyTranslation });
          });
          if (!highlighted) {
            marker.markClean();
          }
        });
      }
      updateLabelSelection(opts) {
        return __async(this, null, function* () {
          return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);
        });
      }
      updateLabelNodes(opts) {
        return __async(this, null, function* () {
          const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;
          opts.labelSelection.each((text, datum) => {
            const { point, label } = datum;
            if (datum && label && enabled) {
              text.fontStyle = fontStyle;
              text.fontWeight = fontWeight;
              text.fontSize = fontSize;
              text.fontFamily = fontFamily;
              text.textAlign = label.textAlign;
              text.textBaseline = label.textBaseline;
              text.text = label.text;
              text.x = point.x;
              text.y = point.y - 10;
              text.fill = color;
              text.visible = true;
            } else {
              text.visible = false;
            }
          });
        });
      }
      getTooltipHtml(nodeDatum) {
        var _a2;
        const xAxis = this.axes["x" /* X */];
        const yAxis = this.axes["y" /* Y */];
        if (!this.properties.isValid() || !xAxis || !yAxis) {
          return EMPTY_TOOLTIP_CONTENT;
        }
        const { xKey, yKey, xName, yName, strokeWidth, marker, tooltip } = this.properties;
        const { datum, xValue, yValue, itemId } = nodeDatum;
        const xString = xAxis.formatDatum(xValue);
        const yString = yAxis.formatDatum(yValue);
        const title = sanitizeHtml((_a2 = this.properties.title) != null ? _a2 : yName);
        const content = sanitizeHtml(xString + ": " + yString);
        const baseStyle = mergeDefaults({ fill: marker.stroke }, marker.getStyle(), { strokeWidth });
        const { fill: color } = this.getMarkerStyle(
          marker,
          { datum: nodeDatum, xKey, yKey, highlighted: false },
          baseStyle
        );
        return tooltip.toTooltipHtml(
          { title, content, backgroundColor: color },
          __spreadValues({
            datum,
            itemId,
            xKey,
            xName,
            yKey,
            yName,
            title,
            color,
            seriesId: this.id
          }, this.getModuleTooltipParams())
        );
      }
      getLegendData(legendType) {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        if (!(((_a2 = this.data) == null ? void 0 : _a2.length) && this.properties.isValid() && legendType === "category")) {
          return [];
        }
        const { yKey, yName, stroke, strokeOpacity, strokeWidth, lineDash, title, marker, visible, legendItemName } = this.properties;
        const color0 = "rgba(0, 0, 0, 0)";
        return [
          {
            legendType: "category",
            id: this.id,
            itemId: yKey,
            legendItemName,
            seriesId: this.id,
            enabled: visible,
            label: {
              text: (_c = (_b = legendItemName != null ? legendItemName : title) != null ? _b : yName) != null ? _c : yKey
            },
            marker: {
              shape: marker.shape,
              fill: (_d = marker.fill) != null ? _d : color0,
              stroke: (_f = (_e = marker.stroke) != null ? _e : stroke) != null ? _f : color0,
              fillOpacity: (_g = marker.fillOpacity) != null ? _g : 1,
              strokeOpacity: (_i = (_h = marker.strokeOpacity) != null ? _h : strokeOpacity) != null ? _i : 1,
              strokeWidth: (_j = marker.strokeWidth) != null ? _j : 0,
              enabled: marker.enabled
            },
            line: {
              stroke: stroke != null ? stroke : color0,
              strokeOpacity,
              strokeWidth,
              lineDash
            }
          }
        ];
      }
      updatePaths(opts) {
        return __async(this, null, function* () {
          this.updateLinePaths(opts.paths, opts.contextData);
        });
      }
      updateLinePaths(paths, contextData) {
        const { nodeData } = contextData;
        const [lineNode] = paths;
        const { path: linePath } = lineNode;
        linePath.clear(true);
        for (const data of nodeData) {
          if (data.point.moveTo) {
            linePath.moveTo(data.point.x, data.point.y);
          } else {
            linePath.lineTo(data.point.x, data.point.y);
          }
        }
        lineNode.checkPathDirty();
      }
      animateEmptyUpdateReady(animationData) {
        const { markerSelection, labelSelection, annotationSelections, contextData, paths } = animationData;
        const { animationManager } = this.ctx;
        this.updateLinePaths(paths, contextData);
        pathSwipeInAnimation(this, animationManager, ...paths);
        resetMotion([markerSelection], resetMarkerPositionFn);
        markerSwipeScaleInAnimation(this, animationManager, markerSelection);
        seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelection);
        seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
      }
      animateReadyResize(animationData) {
        const { contextData, paths } = animationData;
        this.updateLinePaths(paths, contextData);
        super.animateReadyResize(animationData);
      }
      animateWaitingUpdateReady(animationData) {
        var _a2, _b;
        const { animationManager } = this.ctx;
        const {
          markerSelection: markerSelections,
          labelSelection: labelSelections,
          annotationSelections,
          contextData,
          paths,
          previousContextData
        } = animationData;
        const [path] = paths;
        super.resetAllAnimation(animationData);
        const update = () => {
          this.updateLinePaths(paths, contextData);
        };
        const skip = () => {
          animationManager.skipCurrentBatch();
          update();
        };
        if (contextData == null || previousContextData == null) {
          update();
          markerFadeInAnimation(this, animationManager, "added", markerSelections);
          pathFadeInAnimation(this, "path_properties", animationManager, "add", path);
          seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
          seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
          return;
        }
        const fns = prepareLinePathAnimation(contextData, previousContextData, (_b = (_a2 = this.processedData) == null ? void 0 : _a2.reduced) == null ? void 0 : _b.diff);
        if (fns === void 0) {
          skip();
          return;
        } else if (fns.status === "no-op") {
          return;
        }
        markerFadeInAnimation(this, animationManager, void 0, markerSelections);
        fromToMotion(this.id, "path_properties", animationManager, [path], fns.pathProperties);
        pathMotion(this.id, "path_update", animationManager, [path], fns.path);
        if (fns.hasMotion) {
          seriesLabelFadeInAnimation(this, "labels", animationManager, labelSelections);
          seriesLabelFadeInAnimation(this, "annotations", animationManager, ...annotationSelections);
        }
      }
      isLabelEnabled() {
        return this.properties.label.enabled;
      }
      getBandScalePadding() {
        return { inner: 1, outer: 0.1 };
      }
      nodeFactory() {
        return new Group();
      }
      getFormattedMarkerStyle(datum) {
        const { xKey, yKey } = this.properties;
        return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });
      }
      computeFocusBounds(opts) {
        return computeMarkerFocusBounds(this, opts);
      }
    };
    LineSeries.className = "LineSeries";
    LineSeries.type = "line";
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts
var LineSeriesModule;
var init_lineSeriesModule = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts"() {
    "use strict";
    init_theme();
    init_constants();
    init_symbols();
    init_lineSeries();
    LineSeriesModule = {
      type: "series",
      optionsKey: "series[]",
      packageType: "community",
      chartTypes: ["cartesian"],
      identifier: "line",
      instanceConstructor: LineSeries,
      defaultAxes: [
        {
          type: "number" /* NUMBER */,
          position: "left" /* LEFT */
        },
        {
          type: "category" /* CATEGORY */,
          position: "bottom" /* BOTTOM */
        }
      ],
      themeTemplate: {
        series: {
          __extends__: EXTENDS_SERIES_DEFAULTS,
          tooltip: { position: { type: "node" } },
          strokeWidth: 2,
          strokeOpacity: 1,
          lineDash: [0],
          lineDashOffset: 0,
          marker: {
            __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,
            fillOpacity: 1,
            strokeOpacity: 1,
            strokeWidth: 0
          },
          label: {
            enabled: false,
            fontSize: 12,
            fontFamily: DEFAULT_FONT_FAMILY,
            color: DEFAULT_LABEL_COLOUR
          }
        }
      },
      enterpriseThemeTemplate: {
        series: {
          errorBar: {
            cap: {
              lengthRatio: 1
            }
          }
        }
      },
      paletteFactory: (params) => {
        const { marker } = markerPaletteFactory(params);
        return { stroke: marker.fill, marker };
      }
    };
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesProperties.ts
var ScatterSeriesLabel, ScatterSeriesProperties;
var init_scatterSeriesProperties = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesProperties.ts"() {
    "use strict";
    init_validation();
    init_label();
    init_seriesMarker();
    init_seriesTooltip();
    init_cartesianSeries();
    ScatterSeriesLabel = class extends Label {
      constructor() {
        super(...arguments);
        this.placement = "top";
      }
    };
    __decorateClass([
      Validate(LABEL_PLACEMENT)
    ], ScatterSeriesLabel.prototype, "placement", 2);
    ScatterSeriesProperties = class extends CartesianSeriesProperties {
      constructor() {
        super(...arguments);
        this.colorRange = ["#ffff00", "#00ff00", "#0000ff"];
        this.marker = new SeriesMarker();
        this.label = new ScatterSeriesLabel();
        this.tooltip = new SeriesTooltip();
      }
    };
    __decorateClass([
      Validate(STRING)
    ], ScatterSeriesProperties.prototype, "xKey", 2);
    __decorateClass([
      Validate(STRING)
    ], ScatterSeriesProperties.prototype, "yKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], ScatterSeriesProperties.prototype, "labelKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], ScatterSeriesProperties.prototype, "colorKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], ScatterSeriesProperties.prototype, "xName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], ScatterSeriesProperties.prototype, "yName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], ScatterSeriesProperties.prototype, "labelName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], ScatterSeriesProperties.prototype, "colorName", 2);
    __decorateClass([
      Validate(NUMBER_ARRAY, { optional: true })
    ], ScatterSeriesProperties.prototype, "colorDomain", 2);
    __decorateClass([
      Validate(COLOR_STRING_ARRAY)
    ], ScatterSeriesProperties.prototype, "colorRange", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], ScatterSeriesProperties.prototype, "title", 2);
    __decorateClass([
      Validate(OBJECT)
    ], ScatterSeriesProperties.prototype, "marker", 2);
    __decorateClass([
      Validate(OBJECT)
    ], ScatterSeriesProperties.prototype, "label", 2);
    __decorateClass([
      Validate(OBJECT)
    ], ScatterSeriesProperties.prototype, "tooltip", 2);
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts
var ScatterSeries;
var init_scatterSeries = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts"() {
    "use strict";
    init_colorScale();
    init_group();
    init_node();
    init_text();
    init_array();
    init_object();
    init_sanitize();
    init_chartAxisDirection();
    init_dataModel();
    init_util();
    init_tooltip();
    init_series();
    init_seriesLabelUtil();
    init_cartesianSeries();
    init_markerUtil();
    init_scatterSeriesProperties();
    ScatterSeries = class extends CartesianSeries {
      constructor(moduleCtx) {
        super({
          moduleCtx,
          directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,
          directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,
          pickModes: [
            2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,
            3 /* NEAREST_NODE */,
            0 /* EXACT_SHAPE_MATCH */
          ],
          pathsPerSeries: 0,
          hasMarkers: true,
          markerSelectionGarbageCollection: false,
          animationResetFns: {
            marker: resetMarkerFn,
            label: resetLabelFn
          }
        });
        this.properties = new ScatterSeriesProperties();
        this.colorScale = new ColorScale();
      }
      processData(dataController) {
        return __async(this, null, function* () {
          var _a2, _b, _c;
          if (!this.properties.isValid() || this.data == null || !this.visible)
            return;
          const xScale = (_a2 = this.axes["x" /* X */]) == null ? void 0 : _a2.scale;
          const yScale = (_b = this.axes["y" /* Y */]) == null ? void 0 : _b.scale;
          const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
          const colorScaleType = this.colorScale.type;
          const { xKey, yKey, labelKey, colorKey, colorDomain, colorRange } = this.properties;
          const { dataModel, processedData } = yield this.requestDataModel(dataController, this.data, {
            props: [
              keyProperty(xKey, xScaleType, { id: "xKey-raw" }),
              keyProperty(yKey, yScaleType, { id: "yKey-raw" }),
              ...labelKey ? [keyProperty(labelKey, "band", { id: `labelKey-raw` })] : [],
              valueProperty(xKey, xScaleType, { id: `xValue` }),
              valueProperty(yKey, yScaleType, { id: `yValue` }),
              ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],
              ...labelKey ? [valueProperty(labelKey, "band", { id: `labelValue` })] : []
            ]
          });
          if (colorKey) {
            const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);
            this.colorScale.domain = (_c = colorDomain != null ? colorDomain : processedData.domain.values[colorKeyIdx]) != null ? _c : [];
            this.colorScale.range = colorRange;
            this.colorScale.update();
          }
          this.animationState.transition("updateData");
        });
      }
      getSeriesDomain(direction) {
        const { dataModel, processedData } = this;
        if (!processedData || !dataModel)
          return [];
        const id = direction === "x" /* X */ ? `xValue` : `yValue`;
        const dataDef = dataModel.resolveProcessedDataDefById(this, id);
        const domain = dataModel.getDomain(this, id, "value", processedData);
        if ((dataDef == null ? void 0 : dataDef.def.type) === "value" && (dataDef == null ? void 0 : dataDef.def.valueType) === "category") {
          return domain;
        }
        const axis = this.axes[direction];
        return fixNumericExtent(extent(domain), axis);
      }
      createNodeData() {
        return __async(this, null, function* () {
          var _a2, _b, _c;
          const { axes, dataModel, processedData, colorScale } = this;
          const { xKey, yKey, labelKey, colorKey, xName, yName, labelName, marker, label, visible } = this.properties;
          const { placement } = label;
          const markerShape = getMarker(marker.shape);
          const xAxis = axes["x" /* X */];
          const yAxis = axes["y" /* Y */];
          if (!(dataModel && processedData && visible && xAxis && yAxis)) {
            return;
          }
          const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);
          const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);
          const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;
          const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;
          const xScale = xAxis.scale;
          const yScale = yAxis.scale;
          const xOffset = ((_a2 = xScale.bandwidth) != null ? _a2 : 0) / 2;
          const yOffset = ((_b = yScale.bandwidth) != null ? _b : 0) / 2;
          const nodeData = [];
          const font = label.getFont();
          for (const { values, datum } of (_c = processedData.data) != null ? _c : []) {
            const xDatum = values[xDataIdx];
            const yDatum = values[yDataIdx];
            const x = xScale.convert(xDatum) + xOffset;
            const y = yScale.convert(yDatum) + yOffset;
            const labelText = this.getLabelText(label, {
              value: labelKey ? values[labelDataIdx] : yDatum,
              datum,
              xKey,
              yKey,
              labelKey,
              xName,
              yName,
              labelName
            });
            const size = Text.getTextSize(labelText, font);
            const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;
            nodeData.push({
              series: this,
              itemId: yKey,
              yKey,
              xKey,
              datum,
              xValue: xDatum,
              yValue: yDatum,
              capDefaults: { lengthRatioMultiplier: marker.getDiameter(), lengthMax: Infinity },
              point: { x, y, size: marker.size },
              midPoint: { x, y },
              fill,
              label: __spreadValues({ text: labelText }, size),
              marker: markerShape,
              placement
            });
          }
          return {
            itemId: yKey,
            nodeData,
            labelData: nodeData,
            scales: this.calculateScaling(),
            visible: this.visible
          };
        });
      }
      isPathOrSelectionDirty() {
        return this.properties.marker.isDirty();
      }
      getLabelData() {
        var _a2, _b;
        return (_b = (_a2 = this.contextNodeData) == null ? void 0 : _a2.labelData) != null ? _b : [];
      }
      markerFactory() {
        const { shape } = this.properties.marker;
        const MarkerShape = getMarker(shape);
        return new MarkerShape();
      }
      updateMarkerSelection(opts) {
        return __async(this, null, function* () {
          const { nodeData, markerSelection } = opts;
          if (this.properties.marker.isDirty()) {
            markerSelection.clear();
            markerSelection.cleanup();
          }
          return markerSelection.update(this.properties.marker.enabled ? nodeData : []);
        });
      }
      updateMarkerNodes(opts) {
        return __async(this, null, function* () {
          const { markerSelection, isHighlight: highlighted } = opts;
          const { xKey, yKey, labelKey, marker, highlightStyle } = this.properties;
          const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle());
          markerSelection.each((node, datum) => {
            this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, labelKey }, baseStyle);
          });
          if (!highlighted) {
            marker.markClean();
          }
        });
      }
      updateLabelSelection(opts) {
        return __async(this, null, function* () {
          var _a2, _b;
          const placedLabels = this.isLabelEnabled() ? (_b = (_a2 = this.chart) == null ? void 0 : _a2.placeLabels().get(this)) != null ? _b : [] : [];
          return opts.labelSelection.update(
            placedLabels.map(({ datum, x, y }) => __spreadProps(__spreadValues({}, datum), {
              point: { x, y, size: datum.point.size },
              placement: "top"
            })),
            (text) => {
              text.pointerEvents = 1 /* None */;
            }
          );
        });
      }
      updateLabelNodes(opts) {
        return __async(this, null, function* () {
          const { label } = this.properties;
          opts.labelSelection.each((text, datum) => {
            var _a2, _b, _c, _d;
            text.text = datum.label.text;
            text.fill = label.color;
            text.x = (_b = (_a2 = datum.point) == null ? void 0 : _a2.x) != null ? _b : 0;
            text.y = (_d = (_c = datum.point) == null ? void 0 : _c.y) != null ? _d : 0;
            text.fontStyle = label.fontStyle;
            text.fontWeight = label.fontWeight;
            text.fontSize = label.fontSize;
            text.fontFamily = label.fontFamily;
            text.textAlign = "left";
            text.textBaseline = "top";
          });
        });
      }
      getTooltipHtml(nodeDatum) {
        const xAxis = this.axes["x" /* X */];
        const yAxis = this.axes["y" /* Y */];
        if (!this.properties.isValid() || !xAxis || !yAxis) {
          return EMPTY_TOOLTIP_CONTENT;
        }
        const { xKey, yKey, labelKey, xName, yName, labelName, title = yName, marker, tooltip } = this.properties;
        const { datum, xValue, yValue, label, itemId } = nodeDatum;
        const baseStyle = mergeDefaults(
          { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },
          marker.getStyle()
        );
        const { fill: color = "gray" } = this.getMarkerStyle(
          marker,
          { datum: nodeDatum, highlighted: false, xKey, yKey, labelKey },
          baseStyle
        );
        const xString = sanitizeHtml(xAxis.formatDatum(xValue));
        const yString = sanitizeHtml(yAxis.formatDatum(yValue));
        let content = `<b>${sanitizeHtml(xName != null ? xName : xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName != null ? yName : yKey)}</b>: ${yString}`;
        if (labelKey) {
          content = `<b>${sanitizeHtml(labelName != null ? labelName : labelKey)}</b>: ${sanitizeHtml(label.text)}<br>` + content;
        }
        return tooltip.toTooltipHtml(
          { title, content, backgroundColor: color },
          __spreadValues({
            datum,
            itemId,
            xKey,
            xName,
            yKey,
            yName,
            labelKey,
            labelName,
            title,
            color,
            seriesId: this.id
          }, this.getModuleTooltipParams())
        );
      }
      getLegendData(legendType) {
        var _a2, _b, _c, _d, _e, _f;
        const { yKey, yName, title, marker, visible } = this.properties;
        const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;
        if (!((_a2 = this.data) == null ? void 0 : _a2.length) || !this.properties.isValid() || legendType !== "category") {
          return [];
        }
        return [
          {
            legendType: "category",
            id: this.id,
            itemId: yKey,
            seriesId: this.id,
            enabled: visible,
            label: {
              text: (_b = title != null ? title : yName) != null ? _b : yKey
            },
            marker: {
              shape: marker.shape,
              fill: (_d = (_c = marker.fill) != null ? _c : fill) != null ? _d : "rgba(0, 0, 0, 0)",
              stroke: (_f = (_e = marker.stroke) != null ? _e : stroke) != null ? _f : "rgba(0, 0, 0, 0)",
              fillOpacity: fillOpacity != null ? fillOpacity : 1,
              strokeOpacity: strokeOpacity != null ? strokeOpacity : 1,
              strokeWidth: strokeWidth != null ? strokeWidth : 0
            }
          }
        ];
      }
      animateEmptyUpdateReady(data) {
        const { markerSelection, labelSelection, annotationSelections } = data;
        markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);
        seriesLabelFadeInAnimation(this, "labels", this.ctx.animationManager, labelSelection);
        seriesLabelFadeInAnimation(this, "annotations", this.ctx.animationManager, ...annotationSelections);
      }
      isLabelEnabled() {
        return this.properties.label.enabled;
      }
      nodeFactory() {
        return new Group();
      }
      getFormattedMarkerStyle(datum) {
        const { xKey, yKey, labelKey } = this.properties;
        return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, labelKey, highlighted: true });
      }
      computeFocusBounds(opts) {
        return computeMarkerFocusBounds(this, opts);
      }
    };
    ScatterSeries.className = "ScatterSeries";
    ScatterSeries.type = "scatter";
  }
});

// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts
var ScatterSeriesModule;
var init_scatterSeriesModule = __esm({
  "packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts"() {
    "use strict";
    init_theme();
    init_constants();
    init_symbols();
    init_scatterSeries();
    ScatterSeriesModule = {
      type: "series",
      optionsKey: "series[]",
      packageType: "community",
      chartTypes: ["cartesian"],
      identifier: "scatter",
      instanceConstructor: ScatterSeries,
      defaultAxes: [
        {
          type: "number" /* NUMBER */,
          position: "bottom" /* BOTTOM */
        },
        {
          type: "number" /* NUMBER */,
          position: "left" /* LEFT */
        }
      ],
      themeTemplate: {
        series: {
          __extends__: EXTENDS_SERIES_DEFAULTS,
          tooltip: { position: { type: "node" } },
          marker: {
            __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,
            fillOpacity: 0.8
          },
          label: {
            enabled: false,
            fontSize: 12,
            fontFamily: DEFAULT_FONT_FAMILY,
            color: DEFAULT_LABEL_COLOUR
          }
        }
      },
      enterpriseThemeTemplate: {
        series: {
          errorBar: {
            cap: {
              lengthRatio: 1
            }
          }
        }
      },
      paletteFactory: markerPaletteFactory
    };
  }
});

// packages/ag-charts-community/src/scene/sectorBox.ts
var SectorBox;
var init_sectorBox = __esm({
  "packages/ag-charts-community/src/scene/sectorBox.ts"() {
    "use strict";
    init_interpolating();
    SectorBox = class _SectorBox {
      constructor(startAngle, endAngle, innerRadius, outerRadius) {
        this.startAngle = startAngle;
        this.endAngle = endAngle;
        this.innerRadius = innerRadius;
        this.outerRadius = outerRadius;
      }
      clone() {
        const { startAngle, endAngle, innerRadius, outerRadius } = this;
        return new _SectorBox(startAngle, endAngle, innerRadius, outerRadius);
      }
      [interpolate](other, d) {
        return new _SectorBox(
          this.startAngle * (1 - d) + other.startAngle * d,
          this.endAngle * (1 - d) + other.endAngle * d,
          this.innerRadius * (1 - d) + other.innerRadius * d,
          this.outerRadius * (1 - d) + other.outerRadius * d
        );
      }
    };
  }
});

// packages/ag-charts-community/src/scene/util/sector.ts
function isPointInSector(x, y, sector) {
  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
  const { innerRadius, outerRadius } = sector;
  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {
    return false;
  }
  const startAngle = normalizeAngle180(sector.startAngle);
  const endAngle = normalizeAngle180(sector.endAngle);
  const angle = Math.atan2(y, x);
  return startAngle < endAngle ? angle <= endAngle && angle >= startAngle : angle <= endAngle && angle >= -Math.PI || angle >= startAngle && angle <= Math.PI;
}
function lineCollidesSector(line, sector) {
  const { startAngle, endAngle, innerRadius, outerRadius } = sector;
  const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };
  const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };
  const innerStart = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };
  const innerEnd = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };
  return segmentIntersection(
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y,
    outerStart.x,
    outerStart.y,
    innerStart.x,
    innerStart.y
  ) || segmentIntersection(
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y,
    outerEnd.x,
    outerEnd.y,
    innerEnd.x,
    innerEnd.y
  ) || arcIntersections(
    0,
    0,
    outerRadius,
    startAngle,
    endAngle,
    true,
    line.start.x,
    line.start.y,
    line.end.x,
    line.end.y
  );
}
function boxCollidesSector(box, sector) {
  const topLeft = { x: box.x, y: box.y };
  const topRight = { x: box.x + box.width, y: box.y };
  const bottomLeft = { x: box.x, y: box.y + box.height };
  const bottomRight = { x: box.x + box.width, y: box.y + box.height };
  return lineCollidesSector({ start: topLeft, end: topRight }, sector) || lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector);
}
function radiiScalingFactor(r, sweep, a, b) {
  if (a === 0 && b === 0)
    return 0;
  const fs1 = Math.asin(Math.abs(1 * a) / (r + 1 * a)) + Math.asin(Math.abs(1 * b) / (r + 1 * b)) - sweep;
  if (fs1 < 0)
    return 1;
  let start = 0;
  let end = 1;
  for (let i = 0; i < 8; i += 1) {
    const s = (start + end) / 2;
    const fs = Math.asin(Math.abs(s * a) / (r + s * a)) + Math.asin(Math.abs(s * b) / (r + s * b)) - sweep;
    if (fs < 0) {
      start = s;
    } else {
      end = s;
    }
  }
  return start;
}
function clockwiseAngle(angle, relativeToStartAngle) {
  if (angleBetween(angle, relativeToStartAngle) < delta) {
    return relativeToStartAngle;
  } else {
    return normalizeAngle360(angle - relativeToStartAngle) + relativeToStartAngle;
  }
}
function clockwiseAngles(startAngle, endAngle, relativeToStartAngle = 0) {
  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;
  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);
  startAngle = clockwiseAngle(startAngle, relativeToStartAngle);
  endAngle = startAngle + sweepAngle;
  return { startAngle, endAngle };
}
function arcRadialLineIntersectionAngle(cx, cy, r, startAngle, endAngle, clipAngle) {
  const sinA = Math.sin(clipAngle);
  const cosA = Math.cos(clipAngle);
  const c = __pow(cx, 2) + __pow(cy, 2) - __pow(r, 2);
  let p0x = NaN;
  let p0y = NaN;
  let p1x = NaN;
  let p1y = NaN;
  if (cosA > 0.5) {
    const tanA = sinA / cosA;
    const a = 1 + __pow(tanA, 2);
    const b = -2 * (cx + cy * tanA);
    const d = __pow(b, 2) - 4 * a * c;
    if (d < 0)
      return;
    const x0 = (-b + Math.sqrt(d)) / (2 * a);
    const x1 = (-b - Math.sqrt(d)) / (2 * a);
    p0x = x0;
    p0y = x0 * tanA;
    p1x = x1;
    p1y = x1 * tanA;
  } else {
    const cotA = cosA / sinA;
    const a = 1 + __pow(cotA, 2);
    const b = -2 * (cy + cx * cotA);
    const d = __pow(b, 2) - 4 * a * c;
    if (d < 0)
      return;
    const y0 = (-b + Math.sqrt(d)) / (2 * a);
    const y1 = (-b - Math.sqrt(d)) / (2 * a);
    p0x = y0 * cotA;
    p0y = y0;
    p1x = y1 * cotA;
    p1y = y1;
  }
  const normalisedX = cosA;
  const normalisedY = sinA;
  const p0DotNormalized = p0x * normalisedX + p0y * normalisedY;
  const p1DotNormalized = p1x * normalisedX + p1y * normalisedY;
  const a0 = p0DotNormalized > 0 ? clockwiseAngle(Math.atan2(p0y - cy, p0x - cx), startAngle) : NaN;
  const a1 = p1DotNormalized > 0 ? clockwiseAngle(Math.atan2(p1y - cy, p1x - cx), startAngle) : NaN;
  if (a0 >= startAngle && a0 <= endAngle) {
    return a0;
  } else if (a1 >= startAngle && a1 <= endAngle) {
    return a1;
  }
}
function arcCircleIntersectionAngle(cx, cy, r, startAngle, endAngle, circleR) {
  const d = Math.hypot(cx, cy);
  const d1 = (__pow(d, 2) - __pow(r, 2) + __pow(circleR, 2)) / (2 * d);
  const d2 = d - d1;
  const theta = Math.atan2(cy, cx);
  const deltaTheta = Math.acos(-d2 / r);
  const a0 = clockwiseAngle(theta + deltaTheta, startAngle);
  const a1 = clockwiseAngle(theta - deltaTheta, startAngle);
  if (a0 >= startAngle && a0 <= endAngle) {
    return a0;
  } else if (a1 >= startAngle && a1 <= endAngle) {
    return a1;
  }
}
var delta;
var init_sector = __esm({
  "packages/ag-charts-community/src/scene/util/sector.ts"() {
    "use strict";
    init_angle();
    init_intersection();
    delta = 1e-6;
  }
});

// packages/ag-charts-community/src/scene/shape/sector.ts
var Arc, Sector;
var init_sector2 = __esm({
  "packages/ag-charts-community/src/scene/shape/sector.ts"() {
    "use strict";
    init_bbox();
    init_sectorBox();
    init_sector();
    init_path();
    Arc = class {
      constructor(cx, cy, r, a0, a1) {
        this.cx = cx;
        this.cy = cy;
        this.r = r;
        this.a0 = a0;
        this.a1 = a1;
        if (this.a0 >= this.a1) {
          this.a0 = NaN;
          this.a1 = NaN;
        }
      }
      isValid() {
        return Number.isFinite(this.a0) && Number.isFinite(this.a1);
      }
      pointAt(a) {
        return {
          x: this.cx + this.r * Math.cos(a),
          y: this.cy + this.r * Math.sin(a)
        };
      }
      clipStart(a) {
        if (a == null || !this.isValid() || a < this.a0)
          return;
        this.a0 = a;
        if (Number.isNaN(a) || this.a0 >= this.a1) {
          this.a0 = NaN;
          this.a1 = NaN;
        }
      }
      clipEnd(a) {
        if (a == null || !this.isValid() || a > this.a1)
          return;
        this.a1 = a;
        if (Number.isNaN(a) || this.a0 >= this.a1) {
          this.a0 = NaN;
          this.a1 = NaN;
        }
      }
    };
    Sector = class extends Path {
      constructor() {
        super(...arguments);
        this.centerX = 0;
        this.centerY = 0;
        this.innerRadius = 10;
        this.outerRadius = 20;
        this.startAngle = 0;
        this.endAngle = Math.PI * 2;
        this.clipSector = void 0;
        this.concentricEdgeInset = 0;
        this.radialEdgeInset = 0;
        this.startOuterCornerRadius = 0;
        this.endOuterCornerRadius = 0;
        this.startInnerCornerRadius = 0;
        this.endInnerCornerRadius = 0;
      }
      set inset(value) {
        this.concentricEdgeInset = value;
        this.radialEdgeInset = value;
      }
      set cornerRadius(value) {
        this.startOuterCornerRadius = value;
        this.endOuterCornerRadius = value;
        this.startInnerCornerRadius = value;
        this.endInnerCornerRadius = value;
      }
      computeBBox() {
        const radius = this.outerRadius;
        return new BBox(this.centerX - radius, this.centerY - radius, radius * 2, radius * 2);
      }
      normalizedRadii() {
        const { concentricEdgeInset } = this;
        return {
          innerRadius: Math.max(Math.min(this.innerRadius, this.outerRadius) + concentricEdgeInset, 0),
          outerRadius: Math.max(Math.max(this.innerRadius, this.outerRadius) - concentricEdgeInset, 0)
        };
      }
      normalizedClipSector() {
        const { clipSector } = this;
        if (clipSector == null)
          return;
        const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
        const { innerRadius, outerRadius } = this.normalizedRadii();
        const clipAngles = clockwiseAngles(clipSector.startAngle, clipSector.endAngle, startAngle);
        return new SectorBox(
          Math.max(startAngle, clipAngles.startAngle),
          Math.min(endAngle, clipAngles.endAngle),
          Math.max(innerRadius, clipSector.innerRadius),
          Math.min(outerRadius, clipSector.outerRadius)
        );
      }
      getAngleOffset(radius) {
        return radius > 0 ? this.radialEdgeInset / radius : 0;
      }
      arc(r, angleSweep, a0, a1, outerArc, innerArc, start, inner) {
        if (r <= 0)
          return;
        const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
        const { innerRadius, outerRadius } = this.normalizedRadii();
        const clipSector = this.normalizedClipSector();
        if (inner && innerRadius <= 0)
          return;
        const innerAngleOffset = this.getAngleOffset(innerRadius);
        const outerAngleOffset = this.getAngleOffset(outerRadius);
        const angleOffset = inner ? this.getAngleOffset(innerRadius + r) : this.getAngleOffset(outerRadius - r);
        const angle = start ? startAngle + angleOffset + angleSweep : endAngle - angleOffset - angleSweep;
        const radius = inner ? innerRadius + r : outerRadius - r;
        const cx = radius * Math.cos(angle);
        const cy = radius * Math.sin(angle);
        if (clipSector != null) {
          const delta3 = 1e-6;
          if (!start && !(angle >= startAngle - delta3 && angle <= clipSector.endAngle - delta3))
            return;
          if (start && !(angle >= clipSector.startAngle + delta3 && angle <= endAngle - delta3))
            return;
          if (inner && !(radius >= clipSector.innerRadius - delta3))
            return;
          if (!inner && !(radius <= clipSector.outerRadius + delta3))
            return;
        }
        const arc = new Arc(cx, cy, r, a0, a1);
        if (clipSector != null) {
          if (inner) {
            arc.clipStart(
              arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle - innerAngleOffset)
            );
            arc.clipEnd(
              arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle + innerAngleOffset)
            );
          } else {
            arc.clipStart(
              arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle + outerAngleOffset)
            );
            arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle - outerAngleOffset));
          }
          let circleClipStart;
          let circleClipEnd;
          if (start) {
            circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);
            circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);
          } else {
            circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);
            circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);
          }
          arc.clipStart(circleClipStart);
          arc.clipEnd(circleClipEnd);
          if (circleClipStart != null) {
            const { x: x2, y: y2 } = arc.pointAt(circleClipStart);
            const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);
            if (start) {
              innerArc == null ? void 0 : innerArc.clipStart(theta2);
            } else {
              outerArc.clipEnd(theta2);
            }
          }
          if (circleClipEnd != null) {
            const { x: x2, y: y2 } = arc.pointAt(circleClipEnd);
            const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);
            if (start) {
              outerArc.clipStart(theta2);
            } else {
              innerArc == null ? void 0 : innerArc.clipEnd(theta2);
            }
          }
        }
        if (clipSector != null) {
          const { x: x2, y: y2 } = arc.pointAt((arc.a0 + arc.a1) / 2);
          if (!isPointInSector(x2, y2, clipSector))
            return;
        }
        const { x, y } = arc.pointAt(start === inner ? arc.a0 : arc.a1);
        const theta = clockwiseAngle(Math.atan2(y, x), startAngle);
        const radialArc = inner ? innerArc : outerArc;
        if (start) {
          radialArc == null ? void 0 : radialArc.clipStart(theta);
        } else {
          radialArc == null ? void 0 : radialArc.clipEnd(theta);
        }
        return arc;
      }
      updatePath() {
        var _a2, _b, _c, _d, _e;
        const delta3 = 1e-6;
        const { path, centerX, centerY, concentricEdgeInset, radialEdgeInset } = this;
        let { startOuterCornerRadius, endOuterCornerRadius, startInnerCornerRadius, endInnerCornerRadius } = this;
        const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);
        const { innerRadius, outerRadius } = this.normalizedRadii();
        const clipSector = this.normalizedClipSector();
        const sweepAngle = endAngle - startAngle;
        const fullPie = sweepAngle >= 2 * Math.PI - delta3;
        path.clear();
        if (((_a2 = clipSector == null ? void 0 : clipSector.startAngle) != null ? _a2 : startAngle) === ((_b = clipSector == null ? void 0 : clipSector.endAngle) != null ? _b : endAngle)) {
          return;
        } else if (fullPie && this.clipSector == null && startOuterCornerRadius === 0 && endOuterCornerRadius === 0 && startInnerCornerRadius === 0 && endInnerCornerRadius === 0) {
          path.moveTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));
          path.arc(centerX, centerY, outerRadius, startAngle, endAngle);
          if (innerRadius > concentricEdgeInset) {
            path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));
            path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
          }
          path.closePath();
          return;
        }
        const innerAngleOffset = this.getAngleOffset(innerRadius);
        const outerAngleOffset = this.getAngleOffset(outerRadius);
        const outerAngleExceeded = sweepAngle < 2 * outerAngleOffset;
        if (outerAngleExceeded)
          return;
        const hasInnerSweep = ((_c = clipSector == null ? void 0 : clipSector.innerRadius) != null ? _c : innerRadius) > concentricEdgeInset;
        const innerAngleExceeded = innerRadius < concentricEdgeInset || sweepAngle < 2 * innerAngleOffset;
        const radialLength = outerRadius - innerRadius;
        const maxRadialLength = Math.max(
          startOuterCornerRadius,
          startInnerCornerRadius,
          endOuterCornerRadius,
          endInnerCornerRadius
        );
        const initialScalingFactor = maxRadialLength > 0 ? Math.min(radialLength / maxRadialLength, 1) : 1;
        startOuterCornerRadius *= initialScalingFactor;
        endOuterCornerRadius *= initialScalingFactor;
        startInnerCornerRadius *= initialScalingFactor;
        endInnerCornerRadius *= initialScalingFactor;
        const outerScalingFactor = radiiScalingFactor(
          outerRadius,
          sweepAngle - 2 * outerAngleOffset,
          -startOuterCornerRadius,
          -endOuterCornerRadius
        );
        startOuterCornerRadius *= outerScalingFactor;
        endOuterCornerRadius *= outerScalingFactor;
        if (!innerAngleExceeded && hasInnerSweep) {
          const innerScalingFactor = radiiScalingFactor(
            innerRadius,
            sweepAngle - 2 * innerAngleOffset,
            startInnerCornerRadius,
            endInnerCornerRadius
          );
          startInnerCornerRadius *= innerScalingFactor;
          endInnerCornerRadius *= innerScalingFactor;
        } else {
          startInnerCornerRadius = 0;
          endInnerCornerRadius = 0;
        }
        const maxCombinedRadialLength = Math.max(
          startOuterCornerRadius + startInnerCornerRadius,
          endOuterCornerRadius + endInnerCornerRadius
        );
        const edgesScalingFactor = maxCombinedRadialLength > 0 ? Math.min(radialLength / maxCombinedRadialLength, 1) : 1;
        startOuterCornerRadius *= edgesScalingFactor;
        endOuterCornerRadius *= edgesScalingFactor;
        startInnerCornerRadius *= edgesScalingFactor;
        endInnerCornerRadius *= edgesScalingFactor;
        let startOuterCornerRadiusAngleSweep = 0;
        let endOuterCornerRadiusAngleSweep = 0;
        const startOuterCornerRadiusSweep = startOuterCornerRadius / (outerRadius - startOuterCornerRadius);
        const endOuterCornerRadiusSweep = endOuterCornerRadius / (outerRadius - endOuterCornerRadius);
        if (startOuterCornerRadiusSweep >= 0 && startOuterCornerRadiusSweep < 1 - delta3) {
          startOuterCornerRadiusAngleSweep = Math.asin(startOuterCornerRadiusSweep);
        } else {
          startOuterCornerRadiusAngleSweep = sweepAngle / 2;
          const maxStartOuterCornerRadius = outerRadius / (1 / Math.sin(startOuterCornerRadiusAngleSweep) + 1);
          startOuterCornerRadius = Math.min(maxStartOuterCornerRadius, startOuterCornerRadius);
        }
        if (endOuterCornerRadiusSweep >= 0 && endOuterCornerRadiusSweep < 1 - delta3) {
          endOuterCornerRadiusAngleSweep = Math.asin(endOuterCornerRadiusSweep);
        } else {
          endOuterCornerRadiusAngleSweep = sweepAngle / 2;
          const maxEndOuterCornerRadius = outerRadius / (1 / Math.sin(endOuterCornerRadiusAngleSweep) + 1);
          endOuterCornerRadius = Math.min(maxEndOuterCornerRadius, endOuterCornerRadius);
        }
        const startInnerCornerRadiusAngleSweep = Math.asin(
          startInnerCornerRadius / (innerRadius + startInnerCornerRadius)
        );
        const endInnerCornerRadiusAngleSweep = Math.asin(endInnerCornerRadius / (innerRadius + endInnerCornerRadius));
        const outerArcRadius = (_d = clipSector == null ? void 0 : clipSector.outerRadius) != null ? _d : outerRadius;
        const outerArcRadiusOffset = this.getAngleOffset(outerArcRadius);
        const outerArc = new Arc(
          0,
          0,
          outerArcRadius,
          startAngle + outerArcRadiusOffset,
          endAngle - outerArcRadiusOffset
        );
        const innerArcRadius = (_e = clipSector == null ? void 0 : clipSector.innerRadius) != null ? _e : innerRadius;
        const innerArcRadiusOffset = this.getAngleOffset(innerArcRadius);
        const innerArc = hasInnerSweep ? new Arc(0, 0, innerArcRadius, startAngle + innerArcRadiusOffset, endAngle - innerArcRadiusOffset) : void 0;
        if (clipSector != null) {
          outerArc.clipStart(clipSector.startAngle);
          outerArc.clipEnd(clipSector.endAngle);
          innerArc == null ? void 0 : innerArc.clipStart(clipSector.startAngle);
          innerArc == null ? void 0 : innerArc.clipEnd(clipSector.endAngle);
        }
        const startOuterArc = this.arc(
          startOuterCornerRadius,
          startOuterCornerRadiusAngleSweep,
          startAngle - Math.PI * 0.5,
          startAngle + startOuterCornerRadiusAngleSweep,
          outerArc,
          innerArc,
          true,
          false
        );
        const endOuterArc = this.arc(
          endOuterCornerRadius,
          endOuterCornerRadiusAngleSweep,
          endAngle - endOuterCornerRadiusAngleSweep,
          endAngle + Math.PI * 0.5,
          outerArc,
          innerArc,
          false,
          false
        );
        const endInnerArc = this.arc(
          endInnerCornerRadius,
          endInnerCornerRadiusAngleSweep,
          endAngle + Math.PI * 0.5,
          endAngle + Math.PI - endInnerCornerRadiusAngleSweep,
          outerArc,
          innerArc,
          false,
          true
        );
        const startInnerArc = this.arc(
          startInnerCornerRadius,
          startInnerCornerRadiusAngleSweep,
          startAngle + Math.PI + startInnerCornerRadiusAngleSweep,
          startAngle + Math.PI * 1.5,
          outerArc,
          innerArc,
          true,
          true
        );
        if (innerAngleExceeded) {
          const x = sweepAngle < Math.PI * 0.5 ? radialEdgeInset * (1 + Math.cos(sweepAngle)) / Math.sin(sweepAngle) : NaN;
          let r;
          if (x > 0 && x < outerRadius) {
            r = Math.max(Math.hypot(radialEdgeInset, x), innerRadius);
          } else {
            r = innerRadius;
          }
          const midAngle = startAngle + sweepAngle * 0.5;
          path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));
        } else if ((startInnerArc == null ? void 0 : startInnerArc.isValid()) === true) {
          const { x, y } = startInnerArc.pointAt(startInnerArc.a1);
          path.moveTo(centerX + x, centerY + y);
        } else if ((innerArc == null ? void 0 : innerArc.isValid()) === true) {
          const { x, y } = innerArc.pointAt(innerArc.a0);
          path.moveTo(centerX + x, centerY + y);
        } else {
          const midAngle = startAngle + sweepAngle / 2;
          const cx = innerRadius * Math.cos(midAngle);
          const cy = innerRadius * Math.sin(midAngle);
          path.moveTo(centerX + cx, centerY + cy);
        }
        if ((startOuterArc == null ? void 0 : startOuterArc.isValid()) === true) {
          const { cx, cy, r, a0, a1 } = startOuterArc;
          path.arc(centerX + cx, centerY + cy, r, a0, a1);
        }
        if (outerArc.isValid()) {
          const { r, a0, a1 } = outerArc;
          path.arc(centerX, centerY, r, a0, a1);
        }
        if ((endOuterArc == null ? void 0 : endOuterArc.isValid()) === true) {
          const { cx, cy, r, a0, a1 } = endOuterArc;
          path.arc(centerX + cx, centerY + cy, r, a0, a1);
        }
        if (!innerAngleExceeded) {
          if ((endInnerArc == null ? void 0 : endInnerArc.isValid()) === true) {
            const { cx, cy, r, a0, a1 } = endInnerArc;
            path.arc(centerX + cx, centerY + cy, r, a0, a1);
          }
          if ((innerArc == null ? void 0 : innerArc.isValid()) === true) {
            const { r, a0, a1 } = innerArc;
            path.arc(centerX, centerY, r, a1, a0, true);
          }
          if ((startInnerArc == null ? void 0 : startInnerArc.isValid()) === true) {
            const { cx, cy, r, a0, a1 } = startInnerArc;
            path.arc(centerX + cx, centerY + cy, r, a0, a1);
          }
        }
        path.closePath();
      }
      isPointInPath(x, y) {
        var _a2;
        const point = this.transformPoint(x, y);
        const { startAngle, endAngle, innerRadius, outerRadius } = (_a2 = this.clipSector) != null ? _a2 : this;
        return isPointInSector(point.x, point.y, {
          startAngle,
          endAngle,
          innerRadius: Math.min(innerRadius, outerRadius),
          outerRadius: Math.max(innerRadius, outerRadius)
        });
      }
    };
    Sector.className = "Sector";
    __decorateClass([
      ScenePathChangeDetection()
    ], Sector.prototype, "centerX", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Sector.prototype, "centerY", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Sector.prototype, "innerRadius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Sector.prototype, "outerRadius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Sector.prototype, "startAngle", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Sector.prototype, "endAngle", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Sector.prototype, "clipSector", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Sector.prototype, "concentricEdgeInset", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Sector.prototype, "radialEdgeInset", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Sector.prototype, "startOuterCornerRadius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Sector.prototype, "endOuterCornerRadius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Sector.prototype, "startInnerCornerRadius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Sector.prototype, "endInnerCornerRadius", 2);
  }
});

// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts
var DonutTitle, DonutInnerLabel, DonutInnerCircle, DonutSeriesCalloutLabel, DonutSeriesSectorLabel, DonutSeriesCalloutLine, DonutSeriesProperties;
var init_donutSeriesProperties = __esm({
  "packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts"() {
    "use strict";
    init_dropShadow();
    init_logger();
    init_properties();
    init_validation();
    init_caption();
    init_label();
    init_defaultColors();
    init_seriesProperties();
    init_seriesTooltip();
    DonutTitle = class extends Caption {
      constructor() {
        super(...arguments);
        this.showInLegend = false;
      }
    };
    __decorateClass([
      Validate(BOOLEAN)
    ], DonutTitle.prototype, "showInLegend", 2);
    DonutInnerLabel = class extends Label {
      constructor() {
        super(...arguments);
        this.margin = 2;
      }
      set(properties, _reset) {
        return super.set(properties);
      }
    };
    __decorateClass([
      Validate(STRING)
    ], DonutInnerLabel.prototype, "text", 2);
    __decorateClass([
      Validate(NUMBER)
    ], DonutInnerLabel.prototype, "margin", 2);
    DonutInnerCircle = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.fill = "transparent";
        this.fillOpacity = 1;
      }
    };
    __decorateClass([
      Validate(COLOR_STRING)
    ], DonutInnerCircle.prototype, "fill", 2);
    __decorateClass([
      Validate(RATIO)
    ], DonutInnerCircle.prototype, "fillOpacity", 2);
    DonutSeriesCalloutLabel = class extends Label {
      constructor() {
        super(...arguments);
        this.offset = 3;
        this.minAngle = 0;
        this.minSpacing = 4;
        this.maxCollisionOffset = 50;
        this.avoidCollisions = true;
      }
    };
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], DonutSeriesCalloutLabel.prototype, "offset", 2);
    __decorateClass([
      Validate(DEGREE)
    ], DonutSeriesCalloutLabel.prototype, "minAngle", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], DonutSeriesCalloutLabel.prototype, "minSpacing", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], DonutSeriesCalloutLabel.prototype, "maxCollisionOffset", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], DonutSeriesCalloutLabel.prototype, "avoidCollisions", 2);
    DonutSeriesSectorLabel = class extends Label {
      constructor() {
        super(...arguments);
        this.positionOffset = 0;
        this.positionRatio = 0.5;
      }
    };
    __decorateClass([
      Validate(NUMBER)
    ], DonutSeriesSectorLabel.prototype, "positionOffset", 2);
    __decorateClass([
      Validate(RATIO)
    ], DonutSeriesSectorLabel.prototype, "positionRatio", 2);
    DonutSeriesCalloutLine = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.length = 10;
        this.strokeWidth = 1;
      }
    };
    __decorateClass([
      Validate(COLOR_STRING_ARRAY, { optional: true })
    ], DonutSeriesCalloutLine.prototype, "colors", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], DonutSeriesCalloutLine.prototype, "length", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], DonutSeriesCalloutLine.prototype, "strokeWidth", 2);
    DonutSeriesProperties = class extends SeriesProperties {
      constructor() {
        super(...arguments);
        this.fills = Object.values(DEFAULT_FILLS);
        this.strokes = Object.values(DEFAULT_STROKES);
        this.fillOpacity = 1;
        this.strokeOpacity = 1;
        this.lineDash = [0];
        this.lineDashOffset = 0;
        this.cornerRadius = 0;
        this.rotation = 0;
        this.outerRadiusOffset = 0;
        this.outerRadiusRatio = 1;
        this.strokeWidth = 1;
        this.sectorSpacing = void 0;
        this.innerLabels = new PropertiesArray(DonutInnerLabel);
        this.title = new DonutTitle();
        this.innerCircle = new DonutInnerCircle();
        this.shadow = new DropShadow();
        this.calloutLabel = new DonutSeriesCalloutLabel();
        this.sectorLabel = new DonutSeriesSectorLabel();
        this.calloutLine = new DonutSeriesCalloutLine();
        this.tooltip = new SeriesTooltip();
        this.__BACKGROUND_COLOR_DO_NOT_USE = void 0;
      }
      isValid() {
        const superIsValid = super.isValid();
        if (this.innerRadiusRatio == null && this.innerRadiusOffset == null) {
          Logger.warnOnce(
            "Either an [innerRadiusRatio] or an [innerRadiusOffset] must be set to render a donut series."
          );
          return false;
        }
        return superIsValid;
      }
    };
    __decorateClass([
      Validate(STRING)
    ], DonutSeriesProperties.prototype, "angleKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], DonutSeriesProperties.prototype, "angleName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], DonutSeriesProperties.prototype, "radiusKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], DonutSeriesProperties.prototype, "radiusName", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], DonutSeriesProperties.prototype, "radiusMin", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], DonutSeriesProperties.prototype, "radiusMax", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], DonutSeriesProperties.prototype, "calloutLabelKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], DonutSeriesProperties.prototype, "calloutLabelName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], DonutSeriesProperties.prototype, "sectorLabelKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], DonutSeriesProperties.prototype, "sectorLabelName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], DonutSeriesProperties.prototype, "legendItemKey", 2);
    __decorateClass([
      Validate(COLOR_STRING_ARRAY)
    ], DonutSeriesProperties.prototype, "fills", 2);
    __decorateClass([
      Validate(COLOR_STRING_ARRAY)
    ], DonutSeriesProperties.prototype, "strokes", 2);
    __decorateClass([
      Validate(RATIO)
    ], DonutSeriesProperties.prototype, "fillOpacity", 2);
    __decorateClass([
      Validate(RATIO)
    ], DonutSeriesProperties.prototype, "strokeOpacity", 2);
    __decorateClass([
      Validate(LINE_DASH)
    ], DonutSeriesProperties.prototype, "lineDash", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], DonutSeriesProperties.prototype, "lineDashOffset", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], DonutSeriesProperties.prototype, "cornerRadius", 2);
    __decorateClass([
      Validate(FUNCTION, { optional: true })
    ], DonutSeriesProperties.prototype, "formatter", 2);
    __decorateClass([
      Validate(DEGREE)
    ], DonutSeriesProperties.prototype, "rotation", 2);
    __decorateClass([
      Validate(NUMBER)
    ], DonutSeriesProperties.prototype, "outerRadiusOffset", 2);
    __decorateClass([
      Validate(RATIO)
    ], DonutSeriesProperties.prototype, "outerRadiusRatio", 2);
    __decorateClass([
      Validate(NUMBER, { optional: true })
    ], DonutSeriesProperties.prototype, "innerRadiusOffset", 2);
    __decorateClass([
      Validate(RATIO, { optional: true })
    ], DonutSeriesProperties.prototype, "innerRadiusRatio", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], DonutSeriesProperties.prototype, "strokeWidth", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], DonutSeriesProperties.prototype, "sectorSpacing", 2);
    __decorateClass([
      Validate(OBJECT_ARRAY)
    ], DonutSeriesProperties.prototype, "innerLabels", 2);
    __decorateClass([
      Validate(OBJECT)
    ], DonutSeriesProperties.prototype, "title", 2);
    __decorateClass([
      Validate(OBJECT)
    ], DonutSeriesProperties.prototype, "innerCircle", 2);
    __decorateClass([
      Validate(OBJECT)
    ], DonutSeriesProperties.prototype, "shadow", 2);
    __decorateClass([
      Validate(OBJECT)
    ], DonutSeriesProperties.prototype, "calloutLabel", 2);
    __decorateClass([
      Validate(OBJECT)
    ], DonutSeriesProperties.prototype, "sectorLabel", 2);
    __decorateClass([
      Validate(OBJECT)
    ], DonutSeriesProperties.prototype, "calloutLine", 2);
    __decorateClass([
      Validate(OBJECT)
    ], DonutSeriesProperties.prototype, "tooltip", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], DonutSeriesProperties.prototype, "__BACKGROUND_COLOR_DO_NOT_USE", 2);
  }
});

// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts
function preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {
  const scale2 = [scaleFn.convert(0), scaleFn.convert(1)];
  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];
  const rotation = Math.PI / -2 + toRadians(rotationDegrees);
  const phase = initialLoad ? "initial" : "update";
  const scaleToNewRadius = ({ radius }) => {
    return { innerRadius: scale2[0], outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius };
  };
  const scaleToOldRadius = ({ radius }) => {
    return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };
  };
  const fromFn = (sect, datum, status, { prevFromProps }) => {
    var _a2, _b, _c, _d, _e, _f;
    let { startAngle, endAngle, innerRadius, outerRadius } = sect;
    let { fill, stroke } = datum.sectorFormat;
    if (status === "unknown" || status === "added" && !prevFromProps) {
      startAngle = rotation;
      endAngle = rotation;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
    } else if (status === "added" && prevFromProps) {
      startAngle = (_a2 = prevFromProps.endAngle) != null ? _a2 : rotation;
      endAngle = (_b = prevFromProps.endAngle) != null ? _b : rotation;
      innerRadius = (_c = prevFromProps.innerRadius) != null ? _c : datum.innerRadius;
      outerRadius = (_d = prevFromProps.outerRadius) != null ? _d : datum.outerRadius;
    }
    if (status === "added" && !initialLoad) {
      const radii = scaleToOldRadius(datum);
      innerRadius = radii.innerRadius;
      outerRadius = radii.outerRadius;
    }
    if (status === "updated") {
      fill = (_e = sect.fill) != null ? _e : fill;
      stroke = (_f = sect.stroke) != null ? _f : stroke;
    }
    return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke, phase };
  };
  const toFn = (_sect, datum, status, { prevLive }) => {
    var _a2, _b;
    let { startAngle, endAngle, innerRadius, outerRadius } = datum;
    const { stroke, fill } = datum.sectorFormat;
    if (status === "removed" && prevLive) {
      startAngle = (_a2 = prevLive.datum) == null ? void 0 : _a2.endAngle;
      endAngle = (_b = prevLive.datum) == null ? void 0 : _b.endAngle;
    } else if (status === "removed" && !prevLive) {
      startAngle = rotation;
      endAngle = rotation;
    }
    if (status === "removed") {
      const radii = scaleToNewRadius(datum);
      innerRadius = radii.innerRadius;
      outerRadius = radii.outerRadius;
    }
    return { startAngle, endAngle, outerRadius, innerRadius, stroke, fill };
  };
  const innerCircleFromFn = (node, _) => {
    var _a2, _b, _c;
    return { size: (_c = (_b = (_a2 = node.previousDatum) == null ? void 0 : _a2.radius) != null ? _b : node.size) != null ? _c : 0, phase };
  };
  const innerCircleToFn = (_, datum) => {
    var _a2;
    return { size: (_a2 = datum.radius) != null ? _a2 : 0 };
  };
  return { nodes: { toFn, fromFn }, innerCircle: { fromFn: innerCircleFromFn, toFn: innerCircleToFn } };
}
function resetPieSelectionsFn(_node, datum) {
  return {
    startAngle: datum.startAngle,
    endAngle: datum.endAngle,
    innerRadius: datum.innerRadius,
    outerRadius: datum.outerRadius,
    fill: datum.sectorFormat.fill,
    stroke: datum.sectorFormat.stroke
  };
}
function pickByMatchingAngle(series, point) {
  const dy2 = point.y - series.centerY;
  const dx2 = point.x - series.centerX;
  const angle = Math.atan2(dy2, dx2);
  const sectors = series.getItemNodes();
  for (const sector of sectors) {
    if (sector.datum.missing === true)
      continue;
    if (isBetweenAngles(angle, sector.startAngle, sector.endAngle)) {
      const radius = Math.sqrt(dx2 * dx2 + dy2 * dy2);
      let distance2 = 0;
      if (radius < sector.innerRadius) {
        distance2 = sector.innerRadius - radius;
      } else if (radius > sector.outerRadius) {
        distance2 = radius - sector.outerRadius;
      }
      return { datum: sector.datum, distance: distance2 };
    }
  }
  return void 0;
}
function computeSectorFocusBounds(series, opts) {
  const nodeData = series.getNodeData();
  if (nodeData === void 0)
    return void 0;
  const { centerX, centerY } = series;
  const datum = nodeData[opts.datumIndex];
  const pointVars = [
    { radius: datum.innerRadius, angle: datum.startAngle },
    { radius: datum.innerRadius, angle: datum.endAngle },
    { radius: datum.outerRadius, angle: datum.startAngle },
    { radius: datum.outerRadius, angle: datum.endAngle }
  ];
  const rightAngles = [0, Math.PI / 2, Math.PI, 3 * Math.PI / 2];
  for (const rightAngle of rightAngles) {
    if (isBetweenAngles(rightAngle, datum.startAngle, datum.endAngle)) {
      pointVars.push({ radius: datum.outerRadius, angle: rightAngle });
    }
  }
  const points = pointVars.map(({ radius, angle }) => displacePointFromVector(centerX, centerY, radius, angle));
  const xs = points.map((p) => p.x);
  const ys = points.map((p) => p.y);
  const x = Math.min(...xs);
  const y = Math.min(...ys);
  const width = Math.max(...xs) - x;
  const height = Math.max(...ys) - y;
  return new BBox(x, y, width, height);
}
var init_pieUtil = __esm({
  "packages/ag-charts-community/src/chart/series/polar/pieUtil.ts"() {
    "use strict";
    init_bbox();
    init_angle();
  }
});

// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts
var PolarSeries;
var init_polarSeries = __esm({
  "packages/ag-charts-community/src/chart/series/polar/polarSeries.ts"() {
    "use strict";
    init_resetMotion();
    init_states();
    init_group();
    init_selection();
    init_text();
    init_chartAxisDirection();
    init_dataModelSeries();
    init_series();
    PolarSeries = class extends DataModelSeries {
      constructor(_a2) {
        var _b = _a2, {
          useLabelLayer = false,
          pickModes = [0 /* EXACT_SHAPE_MATCH */],
          canHaveAxes = false,
          animationResetFns
        } = _b, opts = __objRest(_b, [
          "useLabelLayer",
          "pickModes",
          "canHaveAxes",
          "animationResetFns"
        ]);
        super(__spreadProps(__spreadValues({}, opts), {
          useLabelLayer,
          pickModes,
          contentGroupVirtual: false,
          directionKeys: {
            ["x" /* X */]: ["angleKey"],
            ["y" /* Y */]: ["radiusKey"]
          },
          directionNames: {
            ["x" /* X */]: ["angleName"],
            ["y" /* Y */]: ["radiusName"]
          },
          canHaveAxes
        }));
        this.itemGroup = this.contentGroup.appendChild(new Group());
        this.nodeData = [];
        this.itemSelection = Selection.select(
          this.itemGroup,
          () => this.nodeFactory(),
          false
        );
        this.labelSelection = Selection.select(this.labelGroup, Text, false);
        this.highlightSelection = Selection.select(
          this.highlightGroup,
          () => this.nodeFactory()
        );
        /**
         * The center of the polar series (for example, the center of a pie).
         * If the polar chart has multiple series, all of them will have their
         * center set to the same value as a result of the polar chart layout.
         * The center coordinates are not supposed to be set by the user.
         */
        this.centerX = 0;
        this.centerY = 0;
        /**
         * The maximum radius the series can use.
         * This value is set automatically as a result of the polar chart layout
         * and is not supposed to be set by the user.
         */
        this.radius = 0;
        this.showFocusBox = false;
        this.itemGroup.zIndexSubOrder = [() => this._declarationOrder, 1];
        this.animationResetFns = animationResetFns;
        this.animationState = new StateMachine(
          "empty",
          {
            empty: {
              update: {
                target: "ready",
                action: (data) => this.animateEmptyUpdateReady(data)
              },
              reset: "empty",
              skip: "ready"
            },
            ready: {
              updateData: "waiting",
              clear: "clearing",
              highlight: (data) => this.animateReadyHighlight(data),
              highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),
              resize: (data) => this.animateReadyResize(data),
              reset: "empty",
              skip: "ready"
            },
            waiting: {
              update: {
                target: "ready",
                action: (data) => this.animateWaitingUpdateReady(data)
              },
              reset: "empty",
              skip: "ready"
            },
            clearing: {
              update: {
                target: "empty",
                action: (data) => this.animateClearingUpdateEmpty(data)
              },
              reset: "empty",
              skip: "ready"
            }
          },
          () => this.checkProcessedDataAnimatable()
        );
      }
      getItemNodes() {
        return this.itemGroup.children;
      }
      getNodeData() {
        return this.nodeData;
      }
      resetAnimation(phase) {
        if (phase === "initial") {
          this.animationState.transition("reset");
        } else if (phase === "ready") {
          this.animationState.transition("skip");
        }
      }
      getLabelData() {
        return [];
      }
      computeLabelsBBox(_options, _seriesRect) {
        return null;
      }
      resetAllAnimation() {
        var _a2;
        const { item, label } = (_a2 = this.animationResetFns) != null ? _a2 : {};
        this.ctx.animationManager.stopByAnimationGroupId(this.id);
        if (item) {
          resetMotion([this.itemSelection, this.highlightSelection], item);
        }
        if (label) {
          resetMotion([this.labelSelection], label);
        }
        this.itemSelection.cleanup();
        this.labelSelection.cleanup();
        this.highlightSelection.cleanup();
      }
      animateEmptyUpdateReady(_data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation();
      }
      animateWaitingUpdateReady(_data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation();
      }
      animateReadyHighlight(_data) {
        var _a2;
        const { item } = (_a2 = this.animationResetFns) != null ? _a2 : {};
        if (item) {
          resetMotion([this.highlightSelection], item);
        }
      }
      animateReadyHighlightMarkers(_data) {
      }
      animateReadyResize(_data) {
        this.resetAllAnimation();
      }
      animateClearingUpdateEmpty(_data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation();
      }
      animationTransitionClear() {
        this.animationState.transition("clear", this.getAnimationData());
      }
      getAnimationData(seriesRect) {
        return { seriesRect };
      }
    };
  }
});

// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts
var DonutSeriesNodeEvent, DonutSeries;
var init_donutSeries = __esm({
  "packages/ag-charts-community/src/chart/series/polar/donutSeries.ts"() {
    "use strict";
    init_fromToMotion();
    init_linearScale();
    init_bbox();
    init_group();
    init_node();
    init_selection();
    init_line();
    init_sector2();
    init_text();
    init_sector();
    init_angle();
    init_json();
    init_logger();
    init_number();
    init_object();
    init_sanitize();
    init_type_guards();
    init_chartAxisDirection();
    init_dataModel();
    init_processors();
    init_layers();
    init_circle();
    init_tooltip();
    init_series();
    init_series();
    init_seriesLabelUtil();
    init_donutSeriesProperties();
    init_pieUtil();
    init_polarSeries();
    DonutSeriesNodeEvent = class extends SeriesNodeEvent {
      constructor(type, nativeEvent, datum, series) {
        super(type, nativeEvent, datum, series);
        this.angleKey = series.properties.angleKey;
        this.radiusKey = series.properties.radiusKey;
        this.calloutLabelKey = series.properties.calloutLabelKey;
        this.sectorLabelKey = series.properties.sectorLabelKey;
      }
    };
    DonutSeries = class extends PolarSeries {
      constructor(moduleCtx) {
        super({
          moduleCtx,
          pickModes: [0 /* EXACT_SHAPE_MATCH */],
          useLabelLayer: true,
          animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }
        });
        this.properties = new DonutSeriesProperties();
        this.previousRadiusScale = new LinearScale();
        this.radiusScale = new LinearScale();
        // The group node that contains the background graphics.
        this.backgroundGroup = this.rootGroup.appendChild(
          new Group({
            name: `${this.id}-background`,
            layer: true,
            zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */
          })
        );
        // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.
        this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));
        this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());
        this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Circle());
        this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));
        // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.
        this.seriesItemEnabled = [];
        this.surroundingRadius = void 0;
        this.NodeEvent = DonutSeriesNodeEvent;
        this.angleScale = new LinearScale();
        this.angleScale.domain = [0, 1];
        this.angleScale.range = [-Math.PI, Math.PI].map((angle) => angle + Math.PI / 2);
        const pieCalloutLabels = new Group({ name: "pieCalloutLabels" });
        const pieSectorLabels = new Group({ name: "pieSectorLabels" });
        const innerLabels = new Group({ name: "innerLabels" });
        this.labelGroup.append(pieCalloutLabels);
        this.labelGroup.append(pieSectorLabels);
        this.labelGroup.append(innerLabels);
        this.calloutLabelSelection = Selection.select(pieCalloutLabels, Group);
        this.sectorLabelSelection = Selection.select(pieSectorLabels, Text);
        this.innerLabelsSelection = Selection.select(innerLabels, Text);
        this.innerCircleSelection = Selection.select(this.innerCircleGroup, Circle);
      }
      addChartEventListeners() {
        var _a2;
        this.destroyFns.push(
          (_a2 = this.ctx.chartEventManager) == null ? void 0 : _a2.addListener("legend-item-click", (event) => this.onLegendItemClick(event))
        );
      }
      get visible() {
        return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.some((visible) => visible));
      }
      nodeFactory() {
        return new Sector();
      }
      getSeriesDomain(direction) {
        if (direction === "x" /* X */) {
          return this.angleScale.domain;
        } else {
          return this.radiusScale.domain;
        }
      }
      processData(dataController) {
        return __async(this, null, function* () {
          var _a2, _b, _c, _d, _e;
          if (this.data == null || !this.properties.isValid()) {
            return;
          }
          let { data } = this;
          const { visible, seriesItemEnabled } = this;
          const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
          const animationEnabled = !this.ctx.animationManager.isSkipped();
          const extraKeyProps = [];
          const extraProps = [];
          if (legendItemKey) {
            extraKeyProps.push(keyProperty(legendItemKey, "band", { id: `legendItemKey` }));
          } else if (calloutLabelKey) {
            extraKeyProps.push(keyProperty(calloutLabelKey, "band", { id: `calloutLabelKey` }));
          } else if (sectorLabelKey) {
            extraKeyProps.push(keyProperty(sectorLabelKey, "band", { id: `sectorLabelKey` }));
          }
          const radiusScaleType = this.radiusScale.type;
          const angleScaleType = this.radiusScale.type;
          if (radiusKey) {
            extraProps.push(
              rangedValueProperty(radiusKey, {
                id: "radiusValue",
                min: (_a2 = this.properties.radiusMin) != null ? _a2 : 0,
                max: this.properties.radiusMax
              }),
              valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),
              // Raw value pass-through.
              normalisePropertyTo(
                { id: "radiusValue" },
                [0, 1],
                1,
                (_b = this.properties.radiusMin) != null ? _b : 0,
                this.properties.radiusMax
              )
            );
          }
          if (calloutLabelKey) {
            extraProps.push(valueProperty(calloutLabelKey, "band", { id: `calloutLabelValue` }));
          }
          if (sectorLabelKey) {
            extraProps.push(valueProperty(sectorLabelKey, "band", { id: `sectorLabelValue` }));
          }
          if (legendItemKey) {
            extraProps.push(valueProperty(legendItemKey, "band", { id: `legendItemValue` }));
          }
          if (animationEnabled && this.processedData && extraKeyProps.length > 0) {
            extraProps.push(diff(this.processedData));
          }
          extraProps.push(animationValidation());
          data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : __spreadProps(__spreadValues({}, d), { [angleKey]: 0 }));
          yield this.requestDataModel(dataController, data, {
            props: [
              ...extraKeyProps,
              accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),
              valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),
              // Raw value pass-through.
              normalisePropertyTo({ id: "angleValue" }, [0, 1], 0, 0),
              ...extraProps
            ]
          });
          for (const valueDef of (_e = (_d = (_c = this.processedData) == null ? void 0 : _c.defs) == null ? void 0 : _d.values) != null ? _e : []) {
            const { id, missing, property } = valueDef;
            const missCount = getMissCount(this, missing);
            if (id !== "angleRaw" && missCount > 0) {
              Logger.warnOnce(
                `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? "s" : ""}`
              );
            }
          }
          this.animationState.transition("updateData");
        });
      }
      maybeRefreshNodeData() {
        return __async(this, null, function* () {
          var _a2;
          if (!this.nodeDataRefresh)
            return;
          const { nodeData = [] } = (_a2 = yield this.createNodeData()) != null ? _a2 : {};
          this.nodeData = nodeData;
          this.nodeDataRefresh = false;
        });
      }
      getProcessedDataIndexes(dataModel) {
        const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);
        const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : -1;
        const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : -1;
        const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : -1;
        const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : -1;
        return { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx };
      }
      createNodeData() {
        return __async(this, null, function* () {
          const { id: seriesId, processedData, dataModel, angleScale } = this;
          const { rotation, innerRadiusRatio } = this.properties;
          if (!this.properties.isValid()) {
            this.zerosumOuterRing.visible = true;
            this.zerosumInnerRing.visible = true;
            return { itemId: seriesId, nodeData: [], labelData: [] };
          }
          if (!processedData || !dataModel || processedData.type !== "ungrouped")
            return;
          const { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);
          let currentStart = 0;
          let sum2 = 0;
          const nodeData = processedData.data.map((group2, index) => {
            var _a2;
            const { datum, values } = group2;
            const currentValue = values[angleIdx];
            const startAngle = angleScale.convert(currentStart) + toRadians(rotation);
            currentStart = currentValue;
            sum2 += currentValue;
            const endAngle = angleScale.convert(currentStart) + toRadians(rotation);
            const span = Math.abs(endAngle - startAngle);
            const midAngle = startAngle + span / 2;
            const angleValue = values[angleIdx + 1];
            const radius = radiusIdx >= 0 ? (_a2 = values[radiusIdx]) != null ? _a2 : 1 : 1;
            const radiusValue = radiusIdx >= 0 ? values[radiusIdx + 1] : void 0;
            const legendItemValue = legendItemIdx >= 0 ? values[legendItemIdx] : void 0;
            const labels = this.getLabels(
              datum,
              midAngle,
              span,
              true,
              values[calloutLabelIdx],
              values[sectorLabelIdx],
              legendItemValue
            );
            const sectorFormat = this.getSectorFormat(datum, index, false);
            return __spreadValues({
              itemId: index,
              series: this,
              datum,
              index,
              angleValue,
              midAngle,
              midCos: Math.cos(midAngle),
              midSin: Math.sin(midAngle),
              startAngle,
              endAngle,
              sectorFormat,
              radiusValue,
              radius,
              innerRadius: Math.max(this.radiusScale.convert(0), 0),
              outerRadius: Math.max(this.radiusScale.convert(radius), 0),
              legendItemValue
            }, labels);
          });
          this.zerosumOuterRing.visible = sum2 === 0;
          this.zerosumInnerRing.visible = sum2 === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;
          return { itemId: seriesId, nodeData, labelData: nodeData };
        });
      }
      getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {
        const { calloutLabel, sectorLabel, legendItemKey } = this.properties;
        const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;
        const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;
        if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {
          return {};
        }
        const labelFormatterParams = {
          datum,
          angleKey: this.properties.angleKey,
          angleName: this.properties.angleName,
          radiusKey: this.properties.radiusKey,
          radiusName: this.properties.radiusName,
          calloutLabelKey: this.properties.calloutLabelKey,
          calloutLabelName: this.properties.calloutLabelName,
          sectorLabelKey: this.properties.sectorLabelKey,
          sectorLabelName: this.properties.sectorLabelName,
          legendItemKey: this.properties.legendItemKey
        };
        const result = {};
        if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {
          result.calloutLabel = __spreadProps(__spreadValues({}, this.getTextAlignment(midAngle)), {
            text: this.getLabelText(calloutLabel, __spreadProps(__spreadValues({}, labelFormatterParams), {
              value: calloutLabelValue
            })),
            hidden: false,
            collisionTextAlign: void 0,
            collisionOffsetY: 0,
            box: void 0
          });
        }
        if (sectorLabelKey) {
          result.sectorLabel = {
            text: this.getLabelText(sectorLabel, __spreadProps(__spreadValues({}, labelFormatterParams), {
              value: sectorLabelValue
            }))
          };
        }
        if (legendItemKey != null && legendItemValue != null) {
          result.legendItem = { key: legendItemKey, text: legendItemValue };
        }
        return result;
      }
      getTextAlignment(midAngle) {
        const quadrantTextOpts = [
          { textAlign: "center", textBaseline: "bottom" },
          { textAlign: "left", textBaseline: "middle" },
          { textAlign: "center", textBaseline: "hanging" },
          { textAlign: "right", textBaseline: "middle" }
        ];
        const midAngle180 = normalizeAngle180(midAngle);
        const quadrantStart = -0.75 * Math.PI;
        const quadrantOffset = midAngle180 - quadrantStart;
        const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));
        const quadrantIndex = mod(quadrant, quadrantTextOpts.length);
        return quadrantTextOpts[quadrantIndex];
      }
      getSectorFormat(datum, formatIndex, highlight) {
        var _a2, _b, _c, _d, _e;
        const { callbackCache, highlightManager } = this.ctx;
        const { angleKey, radiusKey, fills, strokes, formatter, sectorSpacing, __BACKGROUND_COLOR_DO_NOT_USE } = this.properties;
        const highlightedDatum = highlightManager.getActiveHighlight();
        const isDatumHighlighted = highlight && (highlightedDatum == null ? void 0 : highlightedDatum.series) === this && formatIndex === highlightedDatum.itemId;
        let defaultStroke = strokes[formatIndex % strokes.length];
        if (sectorSpacing == null && defaultStroke == null) {
          defaultStroke = __BACKGROUND_COLOR_DO_NOT_USE;
        }
        const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = mergeDefaults(
          isDatumHighlighted && this.properties.highlightStyle.item,
          {
            fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,
            fillOpacity: this.properties.fillOpacity,
            stroke: defaultStroke,
            strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),
            strokeOpacity: this.getOpacity()
          }
        );
        let format2;
        if (formatter) {
          format2 = callbackCache.call(formatter, {
            datum,
            angleKey,
            radiusKey,
            fill,
            stroke,
            fills,
            strokes,
            strokeWidth,
            highlighted: isDatumHighlighted,
            seriesId: this.id
          });
        }
        return {
          fill: (_a2 = format2 == null ? void 0 : format2.fill) != null ? _a2 : fill,
          fillOpacity: (_b = format2 == null ? void 0 : format2.fillOpacity) != null ? _b : fillOpacity,
          stroke: (_c = format2 == null ? void 0 : format2.stroke) != null ? _c : stroke,
          strokeWidth: (_d = format2 == null ? void 0 : format2.strokeWidth) != null ? _d : strokeWidth,
          strokeOpacity: (_e = format2 == null ? void 0 : format2.strokeOpacity) != null ? _e : strokeOpacity
        };
      }
      getInnerRadius() {
        const { radius } = this;
        const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;
        const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;
        if (innerRadius === radius || innerRadius < 0) {
          return 0;
        }
        return innerRadius;
      }
      getOuterRadius() {
        const { outerRadiusRatio, outerRadiusOffset } = this.properties;
        return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);
      }
      updateRadiusScale(resize) {
        const newRange = [this.getInnerRadius(), this.getOuterRadius()];
        this.radiusScale.range = newRange;
        if (resize) {
          this.previousRadiusScale.range = newRange;
        }
        this.nodeData = this.nodeData.map((_a2) => {
          var _b = _a2, { radius } = _b, d = __objRest(_b, ["radius"]);
          return __spreadProps(__spreadValues({}, d), {
            radius,
            innerRadius: Math.max(this.radiusScale.convert(0), 0),
            outerRadius: Math.max(this.radiusScale.convert(radius), 0)
          });
        });
      }
      getTitleTranslationY() {
        var _a2, _b;
        const outerRadius = Math.max(0, this.radiusScale.range[1]);
        if (outerRadius === 0) {
          return NaN;
        }
        const spacing = (_b = (_a2 = this.properties.title) == null ? void 0 : _a2.spacing) != null ? _b : 0;
        const titleOffset = 2 + spacing;
        const dy2 = Math.max(0, -outerRadius);
        return -outerRadius - titleOffset - dy2;
      }
      update(_0) {
        return __async(this, arguments, function* ({ seriesRect }) {
          const { title } = this.properties;
          const newNodeDataDependencies = {
            seriesRectWidth: seriesRect == null ? void 0 : seriesRect.width,
            seriesRectHeight: seriesRect == null ? void 0 : seriesRect.height
          };
          const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
          if (resize) {
            this._nodeDataDependencies = newNodeDataDependencies;
          }
          yield this.maybeRefreshNodeData();
          this.updateTitleNodes();
          this.updateRadiusScale(resize);
          this.contentGroup.translationX = this.centerX;
          this.contentGroup.translationY = this.centerY;
          this.highlightGroup.translationX = this.centerX;
          this.highlightGroup.translationY = this.centerY;
          this.backgroundGroup.translationX = this.centerX;
          this.backgroundGroup.translationY = this.centerY;
          if (this.labelGroup) {
            this.labelGroup.translationX = this.centerX;
            this.labelGroup.translationY = this.centerY;
          }
          if (title) {
            const dy2 = this.getTitleTranslationY();
            const titleBox = title.node.computeBBox();
            title.node.visible = title.enabled && isFinite(dy2) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy2);
            title.node.translationY = isFinite(dy2) ? dy2 : 0;
          }
          for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {
            circle.fillOpacity = 0;
            circle.stroke = this.properties.calloutLabel.color;
            circle.strokeWidth = 1;
            circle.strokeOpacity = 1;
          }
          this.updateNodeMidPoint();
          yield this.updateSelections();
          yield this.updateNodes(seriesRect);
        });
      }
      updateTitleNodes() {
        var _a2, _b;
        const { oldTitle } = this;
        const { title } = this.properties;
        if (oldTitle !== title) {
          if (oldTitle) {
            (_a2 = this.labelGroup) == null ? void 0 : _a2.removeChild(oldTitle.node);
          }
          if (title) {
            title.node.textBaseline = "bottom";
            (_b = this.labelGroup) == null ? void 0 : _b.appendChild(title.node);
          }
          this.oldTitle = title;
        }
      }
      updateNodeMidPoint() {
        this.nodeData.forEach((d) => {
          const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;
          d.midPoint = {
            x: d.midCos * Math.max(0, radius),
            y: d.midSin * Math.max(0, radius)
          };
        });
      }
      updateSelections() {
        return __async(this, null, function* () {
          yield this.updateGroupSelection();
          this.updateInnerCircleSelection();
        });
      }
      updateGroupSelection() {
        return __async(this, null, function* () {
          const { itemSelection, highlightSelection, calloutLabelSelection, sectorLabelSelection, innerLabelsSelection } = this;
          const update = (selection, clone) => {
            let nodeData = this.nodeData;
            if (clone) {
              nodeData = nodeData.map((datum) => __spreadProps(__spreadValues({}, datum), { sectorFormat: __spreadValues({}, datum.sectorFormat) }));
            }
            selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));
            if (this.ctx.animationManager.isSkipped()) {
              selection.cleanup();
            }
          };
          update(itemSelection, false);
          update(highlightSelection, true);
          calloutLabelSelection.update(this.nodeData, (group2) => {
            const line = new Line();
            line.tag = 0 /* Callout */;
            line.pointerEvents = 1 /* None */;
            group2.appendChild(line);
            const text = new Text();
            text.tag = 1 /* Label */;
            text.pointerEvents = 1 /* None */;
            group2.appendChild(text);
          });
          sectorLabelSelection.update(this.nodeData, (node) => {
            node.pointerEvents = 1 /* None */;
          });
          innerLabelsSelection.update(this.properties.innerLabels, (node) => {
            node.pointerEvents = 1 /* None */;
          });
        });
      }
      updateInnerCircleSelection() {
        const { innerCircle } = this.properties;
        let radius = 0;
        const innerRadius = this.getInnerRadius();
        if (innerRadius > 0) {
          const circleRadius = Math.min(innerRadius, this.getOuterRadius());
          const antiAliasingPadding = 1;
          radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);
        }
        const datums = innerCircle ? [{ radius }] : [];
        this.innerCircleSelection.update(datums);
      }
      updateNodes(seriesRect) {
        return __async(this, null, function* () {
          const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();
          const isVisible = this.visible && this.seriesItemEnabled.indexOf(true) >= 0;
          this.rootGroup.visible = isVisible;
          this.backgroundGroup.visible = isVisible;
          this.contentGroup.visible = isVisible;
          this.highlightGroup.visible = isVisible && (highlightedDatum == null ? void 0 : highlightedDatum.series) === this;
          if (this.labelGroup) {
            this.labelGroup.visible = isVisible;
          }
          this.contentGroup.opacity = this.getOpacity();
          this.innerCircleSelection.each((node, { radius }) => {
            var _a2, _b;
            node.setProperties({
              fill: (_a2 = this.properties.innerCircle) == null ? void 0 : _a2.fill,
              opacity: (_b = this.properties.innerCircle) == null ? void 0 : _b.fillOpacity,
              size: radius
            });
          });
          const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {
            const format2 = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);
            datum.sectorFormat.fill = format2.fill;
            datum.sectorFormat.stroke = format2.stroke;
            const animationDisabled = this.ctx.animationManager.isSkipped();
            if (animationDisabled) {
              sector.startAngle = datum.startAngle;
              sector.endAngle = datum.endAngle;
              sector.innerRadius = datum.innerRadius;
              sector.outerRadius = datum.outerRadius;
            }
            if (isDatumHighlighted || animationDisabled) {
              sector.fill = format2.fill;
              sector.stroke = format2.stroke;
            }
            sector.strokeWidth = format2.strokeWidth;
            sector.fillOpacity = format2.fillOpacity;
            sector.strokeOpacity = this.properties.strokeOpacity;
            sector.lineDash = this.properties.lineDash;
            sector.lineDashOffset = this.properties.lineDashOffset;
            sector.fillShadow = this.properties.shadow;
            sector.cornerRadius = this.properties.cornerRadius;
            sector.inset = this.properties.sectorSpacing != null ? (this.properties.sectorSpacing + (format2.stroke != null ? format2.strokeWidth : 0)) / 2 : 0;
            sector.lineJoin = this.properties.sectorSpacing != null ? "miter" : "round";
          };
          this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
          this.highlightSelection.each((node, datum, index) => {
            const isDatumHighlighted = (highlightedDatum == null ? void 0 : highlightedDatum.series) === this && node.datum.itemId === highlightedDatum.itemId;
            updateSectorFn(node, datum, index, true);
            node.visible = isDatumHighlighted;
          });
          this.updateCalloutLineNodes();
          this.updateCalloutLabelNodes(seriesRect);
          this.updateSectorLabelNodes();
          this.updateInnerLabelNodes();
          this.updateZerosumRings();
          this.animationState.transition("update");
        });
      }
      updateCalloutLineNodes() {
        var _a2;
        const { calloutLine } = this.properties;
        const calloutLength = calloutLine.length;
        const calloutStrokeWidth = calloutLine.strokeWidth;
        const calloutColors = (_a2 = calloutLine.colors) != null ? _a2 : this.properties.strokes;
        const { offset: offset4 } = this.properties.calloutLabel;
        this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {
          var _a3;
          const datum = line.datum;
          const { calloutLabel: label, outerRadius } = datum;
          if ((label == null ? void 0 : label.text) && !label.hidden && outerRadius !== 0) {
            line.visible = true;
            line.strokeWidth = calloutStrokeWidth;
            line.stroke = calloutColors[index % calloutColors.length];
            line.fill = void 0;
            const x1 = datum.midCos * outerRadius;
            const y1 = datum.midSin * outerRadius;
            let x2 = datum.midCos * (outerRadius + calloutLength);
            let y2 = datum.midSin * (outerRadius + calloutLength);
            const isMoved = (_a3 = label.collisionTextAlign) != null ? _a3 : label.collisionOffsetY !== 0;
            if (isMoved && label.box != null) {
              const box = label.box;
              let cx = x2;
              let cy = y2;
              if (x2 < box.x) {
                cx = box.x;
              } else if (x2 > box.x + box.width) {
                cx = box.x + box.width;
              }
              if (y2 < box.y) {
                cy = box.y;
              } else if (y2 > box.y + box.height) {
                cy = box.y + box.height;
              }
              const dx2 = cx - x2;
              const dy2 = cy - y2;
              const length = Math.sqrt(Math.pow(dx2, 2) + Math.pow(dy2, 2));
              const paddedLength = length - offset4;
              if (paddedLength > 0) {
                x2 = x2 + dx2 * paddedLength / length;
                y2 = y2 + dy2 * paddedLength / length;
              }
            }
            line.x1 = x1;
            line.y1 = y1;
            line.x2 = x2;
            line.y2 = y2;
          } else {
            line.visible = false;
          }
        });
      }
      getLabelOverflow(text, box, seriesRect) {
        const seriesLeft = seriesRect.x - this.centerX;
        const seriesRight = seriesRect.x + seriesRect.width - this.centerX;
        const seriesTop = seriesRect.y - this.centerY;
        const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;
        const errPx = 1;
        let visibleTextPart = 1;
        if (box.x + errPx < seriesLeft) {
          visibleTextPart = (box.x + box.width - seriesLeft) / box.width;
        } else if (box.x + box.width - errPx > seriesRight) {
          visibleTextPart = (seriesRight - box.x) / box.width;
        }
        const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;
        const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;
        const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);
        return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };
      }
      bboxIntersectsSurroundingSeries(box, dx2 = 0, dy2 = 0) {
        const { surroundingRadius } = this;
        if (surroundingRadius == null) {
          return false;
        }
        const corners = [
          { x: box.x + dx2, y: box.y + dy2 },
          { x: box.x + box.width + dx2, y: box.y + dy2 },
          { x: box.x + box.width + dx2, y: box.y + box.height + dy2 },
          { x: box.x + dx2, y: box.y + box.height + dy2 }
        ];
        const sur2 = __pow(surroundingRadius, 2);
        return corners.some((corner) => __pow(corner.x, 2) + __pow(corner.y, 2) > sur2);
      }
      computeCalloutLabelCollisionOffsets() {
        const { radiusScale } = this;
        const { calloutLabel, calloutLine } = this.properties;
        const { offset: offset4, minSpacing } = calloutLabel;
        const innerRadius = radiusScale.convert(0);
        const shouldSkip = (datum) => {
          const label = datum.calloutLabel;
          return !label || datum.outerRadius === 0;
        };
        const fullData = this.nodeData;
        const data = this.nodeData.filter((t) => !shouldSkip(t));
        data.forEach((datum) => {
          const label = datum.calloutLabel;
          if (label == null)
            return;
          label.hidden = false;
          label.collisionTextAlign = void 0;
          label.collisionOffsetY = 0;
        });
        if (data.length <= 1) {
          return;
        }
        const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);
        const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);
        const topLabels = data.filter((d) => {
          var _a2;
          return d.midSin < 0 && ((_a2 = d.calloutLabel) == null ? void 0 : _a2.textAlign) === "center";
        }).sort((a, b) => a.midCos - b.midCos);
        const bottomLabels = data.filter((d) => {
          var _a2;
          return d.midSin >= 0 && ((_a2 = d.calloutLabel) == null ? void 0 : _a2.textAlign) === "center";
        }).sort((a, b) => a.midCos - b.midCos);
        const tempTextNode = new Text();
        const getTextBBox = (datum) => {
          var _a2;
          const label = datum.calloutLabel;
          if (label == null)
            return new BBox(0, 0, 0, 0);
          const labelRadius = datum.outerRadius + calloutLine.length + offset4;
          const x = datum.midCos * labelRadius;
          const y = datum.midSin * labelRadius + label.collisionOffsetY;
          tempTextNode.text = label.text;
          tempTextNode.x = x;
          tempTextNode.y = y;
          tempTextNode.setFont(this.properties.calloutLabel);
          tempTextNode.setAlign({
            textAlign: (_a2 = label.collisionTextAlign) != null ? _a2 : label.textAlign,
            textBaseline: label.textBaseline
          });
          return tempTextNode.computeBBox();
        };
        const avoidNeighbourYCollision = (label, next, direction) => {
          const box = getTextBBox(label).grow(minSpacing / 2);
          const other = getTextBBox(next).grow(minSpacing / 2);
          const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === "to-top" ? box.y < other.y + other.height : box.y + box.height > other.y);
          if (collidesOrBehind) {
            const dy2 = direction === "to-top" ? box.y - other.y - other.height : box.y + box.height - other.y;
            next.calloutLabel.collisionOffsetY = dy2;
          }
        };
        const avoidYCollisions = (labels) => {
          const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];
          const midIndex = labels.indexOf(midLabel);
          for (let i = midIndex - 1; i >= 0; i--) {
            const prev = labels[i + 1];
            const next = labels[i];
            avoidNeighbourYCollision(prev, next, "to-top");
          }
          for (let i = midIndex + 1; i < labels.length; i++) {
            const prev = labels[i - 1];
            const next = labels[i];
            avoidNeighbourYCollision(prev, next, "to-bottom");
          }
        };
        const avoidXCollisions = (labels) => {
          const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);
          const boxes = labels.map((label) => getTextBBox(label));
          const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));
          let labelsCollideLabelsByX = false;
          for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {
            const box = paddedBoxes[i];
            for (let j = i + 1; j < labels.length; j++) {
              const other = paddedBoxes[j];
              if (box.collidesBBox(other)) {
                labelsCollideLabelsByX = true;
                break;
              }
            }
          }
          const sectors = fullData.map((datum) => {
            const { startAngle, endAngle, outerRadius } = datum;
            return { startAngle, endAngle, innerRadius, outerRadius };
          });
          const labelsCollideSectors = boxes.some((box) => {
            return sectors.some((sector) => boxCollidesSector(box, sector));
          });
          if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {
            return;
          }
          labels.filter((d) => d.calloutLabel.textAlign === "center").forEach((d) => {
            const label = d.calloutLabel;
            if (d.midCos < 0) {
              label.collisionTextAlign = "right";
            } else if (d.midCos > 0) {
              label.collisionTextAlign = "left";
            } else {
              label.collisionTextAlign = "center";
            }
          });
        };
        avoidYCollisions(leftLabels);
        avoidYCollisions(rightLabels);
        avoidXCollisions(topLabels);
        avoidXCollisions(bottomLabels);
      }
      updateCalloutLabelNodes(seriesRect) {
        const { radiusScale } = this;
        const { calloutLabel, calloutLine } = this.properties;
        const calloutLength = calloutLine.length;
        const { offset: offset4, color } = calloutLabel;
        const tempTextNode = new Text();
        this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {
          var _a2;
          const { datum } = text;
          const label = datum.calloutLabel;
          const radius = radiusScale.convert(datum.radius);
          const outerRadius = Math.max(0, radius);
          if (!(label == null ? void 0 : label.text) || outerRadius === 0 || label.hidden) {
            text.visible = false;
            return;
          }
          const labelRadius = outerRadius + calloutLength + offset4;
          const x = datum.midCos * labelRadius;
          const y = datum.midSin * labelRadius + label.collisionOffsetY;
          const align = {
            textAlign: (_a2 = label.collisionTextAlign) != null ? _a2 : label.textAlign,
            textBaseline: label.textBaseline
          };
          tempTextNode.text = label.text;
          tempTextNode.x = x;
          tempTextNode.y = y;
          tempTextNode.setFont(this.properties.calloutLabel);
          tempTextNode.setAlign(align);
          const box = tempTextNode.computeBBox();
          let displayText = label.text;
          let visible = true;
          if (calloutLabel.avoidCollisions) {
            const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);
            displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\u2026`;
            visible = !hasVerticalOverflow;
          }
          text.text = displayText;
          text.x = x;
          text.y = y;
          text.setFont(this.properties.calloutLabel);
          text.setAlign(align);
          text.fill = color;
          text.visible = visible;
        });
      }
      computeLabelsBBox(options, seriesRect) {
        return __async(this, null, function* () {
          const { calloutLabel, calloutLine } = this.properties;
          const calloutLength = calloutLine.length;
          const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;
          if (!calloutLabel.avoidCollisions) {
            return null;
          }
          yield this.maybeRefreshNodeData();
          this.updateRadiusScale(false);
          this.computeCalloutLabelCollisionOffsets();
          const textBoxes = [];
          const text = new Text();
          let titleBox;
          const { title } = this.properties;
          if ((title == null ? void 0 : title.text) && title.enabled) {
            const dy2 = this.getTitleTranslationY();
            if (isFinite(dy2)) {
              text.text = title.text;
              text.x = 0;
              text.y = dy2;
              text.setFont(title);
              text.setAlign({
                textBaseline: "bottom",
                textAlign: "center"
              });
              titleBox = text.computeBBox();
              textBoxes.push(titleBox);
            }
          }
          this.nodeData.forEach((datum) => {
            var _a2;
            const label = datum.calloutLabel;
            if (!label || datum.outerRadius === 0) {
              return null;
            }
            const labelRadius = datum.outerRadius + calloutLength + offset4;
            const x = datum.midCos * labelRadius;
            const y = datum.midSin * labelRadius + label.collisionOffsetY;
            text.text = label.text;
            text.x = x;
            text.y = y;
            text.setFont(this.properties.calloutLabel);
            text.setAlign({
              textAlign: (_a2 = label.collisionTextAlign) != null ? _a2 : label.textAlign,
              textBaseline: label.textBaseline
            });
            const box = text.computeBBox();
            label.box = box;
            if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {
              label.hidden = true;
              return;
            }
            if (titleBox) {
              const seriesTop = seriesRect.y - this.centerY;
              const titleCleanArea = new BBox(
                titleBox.x - minSpacing,
                seriesTop,
                titleBox.width + 2 * minSpacing,
                titleBox.y + titleBox.height + minSpacing - seriesTop
              );
              if (box.collidesBBox(titleCleanArea)) {
                label.hidden = true;
                return;
              }
            }
            if (options.hideWhenNecessary) {
              const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(
                label.text,
                box,
                seriesRect
              );
              const isTooShort = label.text.length > 2 && textLength < 2;
              if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {
                label.hidden = true;
                return;
              }
            }
            label.hidden = false;
            textBoxes.push(box);
          });
          if (textBoxes.length === 0) {
            return null;
          }
          return BBox.merge(textBoxes);
        });
      }
      updateSectorLabelNodes() {
        const { radiusScale } = this;
        const innerRadius = radiusScale.convert(0);
        const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;
        this.sectorLabelSelection.each((text, datum) => {
          const { sectorLabel, outerRadius } = datum;
          let isTextVisible = false;
          if (sectorLabel && outerRadius !== 0) {
            const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;
            text.fill = color;
            text.fontStyle = fontStyle;
            text.fontWeight = fontWeight;
            text.fontSize = fontSize;
            text.fontFamily = fontFamily;
            text.text = sectorLabel.text;
            text.x = datum.midCos * labelRadius;
            text.y = datum.midSin * labelRadius;
            text.textAlign = "center";
            text.textBaseline = "middle";
            const bbox = text.computeBBox();
            const corners = [
              [bbox.x, bbox.y],
              [bbox.x + bbox.width, bbox.y],
              [bbox.x + bbox.width, bbox.y + bbox.height],
              [bbox.x, bbox.y + bbox.height]
            ];
            const { startAngle, endAngle } = datum;
            const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };
            if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {
              isTextVisible = true;
            }
          }
          text.visible = isTextVisible;
        });
      }
      updateInnerLabelNodes() {
        const textBBoxes = [];
        const margins = [];
        this.innerLabelsSelection.each((text, datum) => {
          const { fontStyle, fontWeight, fontSize, fontFamily, color } = datum;
          text.fontStyle = fontStyle;
          text.fontWeight = fontWeight;
          text.fontSize = fontSize;
          text.fontFamily = fontFamily;
          text.text = datum.text;
          text.x = 0;
          text.y = 0;
          text.fill = color;
          text.textAlign = "center";
          text.textBaseline = "alphabetic";
          textBBoxes.push(text.computeBBox());
          margins.push(datum.margin);
        });
        const getMarginTop = (index) => index === 0 ? 0 : margins[index];
        const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];
        const totalHeight = textBBoxes.reduce((sum2, bbox, i) => {
          return sum2 + bbox.height + getMarginTop(i) + getMarginBottom(i);
        }, 0);
        const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));
        const innerRadius = this.getInnerRadius();
        const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));
        const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());
        const textBottoms = [];
        for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {
          const bbox = textBBoxes[i];
          const bottom = bbox.height + prev + getMarginTop(i);
          textBottoms.push(bottom);
          prev = bottom + getMarginBottom(i);
        }
        this.innerLabelsSelection.each((text, _datum, index) => {
          text.y = textBottoms[index];
          text.visible = labelsVisible;
        });
      }
      updateZerosumRings() {
        this.zerosumOuterRing.size = this.getOuterRadius() * 2;
        this.zerosumInnerRing.size = this.getInnerRadius() * 2;
      }
      getDatumLegendName(nodeDatum) {
        const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
        const { sectorLabel, calloutLabel, legendItem } = nodeDatum;
        if (legendItemKey && legendItem !== void 0) {
          return legendItem.text;
        } else if (calloutLabelKey && calloutLabelKey !== angleKey && (calloutLabel == null ? void 0 : calloutLabel.text) !== void 0) {
          return calloutLabel.text;
        } else if (sectorLabelKey && sectorLabelKey !== angleKey && (sectorLabel == null ? void 0 : sectorLabel.text) !== void 0) {
          return sectorLabel.text;
        }
      }
      pickNodeClosestDatum(point) {
        return pickByMatchingAngle(this, point);
      }
      getTooltipHtml(nodeDatum) {
        var _a2;
        if (!this.properties.isValid()) {
          return EMPTY_TOOLTIP_CONTENT;
        }
        const {
          datum,
          angleValue,
          sectorFormat: { fill: color },
          itemId
        } = nodeDatum;
        const title = sanitizeHtml((_a2 = this.properties.title) == null ? void 0 : _a2.text);
        const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);
        const labelText = this.getDatumLegendName(nodeDatum);
        return this.properties.tooltip.toTooltipHtml(
          {
            title: title != null ? title : labelText,
            content: title && labelText ? `${labelText}: ${content}` : content,
            backgroundColor: color
          },
          {
            datum,
            itemId,
            title,
            color,
            seriesId: this.id,
            angleKey: this.properties.angleKey,
            angleName: this.properties.angleName,
            radiusKey: this.properties.radiusKey,
            radiusName: this.properties.radiusName,
            calloutLabelKey: this.properties.calloutLabelKey,
            calloutLabelName: this.properties.calloutLabelName,
            sectorLabelKey: this.properties.sectorLabelKey,
            sectorLabelName: this.properties.sectorLabelName,
            legendItemKey: this.properties.legendItemKey
          }
        );
      }
      getLegendData(legendType) {
        var _a2, _b, _c, _d, _e;
        const { visible, processedData, dataModel } = this;
        if (!dataModel || !(processedData == null ? void 0 : processedData.data.length) || !this.properties.isValid() || legendType !== "category") {
          return [];
        }
        const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
        if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey))
          return [];
        const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);
        const titleText = ((_a2 = this.properties.title) == null ? void 0 : _a2.showInLegend) && this.properties.title.text;
        const legendData = [];
        for (let index = 0; index < processedData.data.length; index++) {
          const { datum, values } = processedData.data[index];
          const labelParts = [];
          if (titleText) {
            labelParts.push(titleText);
          }
          const labels = this.getLabels(
            datum,
            2 * Math.PI,
            2 * Math.PI,
            false,
            values[calloutLabelIdx],
            values[sectorLabelIdx],
            values[legendItemIdx]
          );
          if (legendItemKey && labels.legendItem !== void 0) {
            labelParts.push(labels.legendItem.text);
          } else if (calloutLabelKey && calloutLabelKey !== angleKey && ((_b = labels.calloutLabel) == null ? void 0 : _b.text) !== void 0) {
            labelParts.push((_c = labels.calloutLabel) == null ? void 0 : _c.text);
          } else if (sectorLabelKey && sectorLabelKey !== angleKey && ((_d = labels.sectorLabel) == null ? void 0 : _d.text) !== void 0) {
            labelParts.push((_e = labels.sectorLabel) == null ? void 0 : _e.text);
          }
          if (labelParts.length === 0)
            continue;
          const sectorFormat = this.getSectorFormat(datum, index, false);
          legendData.push({
            legendType: "category",
            id: this.id,
            itemId: index,
            seriesId: this.id,
            enabled: visible && this.seriesItemEnabled[index],
            label: {
              text: labelParts.join(" - ")
            },
            marker: {
              fill: sectorFormat.fill,
              stroke: sectorFormat.stroke,
              fillOpacity: this.properties.fillOpacity,
              strokeOpacity: this.properties.strokeOpacity,
              strokeWidth: this.properties.strokeWidth
            },
            legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0
          });
        }
        return legendData;
      }
      onLegendItemClick(event) {
        const { enabled, itemId, series, legendItemName } = event;
        if (series.id === this.id) {
          this.toggleSeriesItem(itemId, enabled);
        } else if (legendItemName != null) {
          this.toggleOtherSeriesItems(legendItemName, enabled);
        }
      }
      toggleSeriesItem(itemId, enabled) {
        this.seriesItemEnabled[itemId] = enabled;
        this.nodeDataRefresh = true;
      }
      toggleOtherSeriesItems(legendItemName, enabled) {
        var _a2;
        if (!this.properties.legendItemKey || !this.dataModel) {
          return;
        }
        const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);
        (_a2 = this.processedData) == null ? void 0 : _a2.data.forEach(({ values }, datumItemId) => {
          if (values[legendItemIdx] === legendItemName) {
            this.toggleSeriesItem(datumItemId, enabled);
          }
        });
      }
      animateEmptyUpdateReady(_data) {
        const { animationManager } = this.ctx;
        const fns = preparePieSeriesAnimationFunctions(
          true,
          this.properties.rotation,
          this.radiusScale,
          this.previousRadiusScale
        );
        fromToMotion(this.id, "nodes", animationManager, [this.itemSelection, this.highlightSelection], fns.nodes);
        fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
        seriesLabelFadeInAnimation(this, "callout", animationManager, this.calloutLabelSelection);
        seriesLabelFadeInAnimation(this, "sector", animationManager, this.sectorLabelSelection);
        seriesLabelFadeInAnimation(this, "inner", animationManager, this.innerLabelsSelection);
        this.previousRadiusScale.range = this.radiusScale.range;
      }
      animateWaitingUpdateReady() {
        var _a2, _b, _c, _d, _e, _f;
        const { itemSelection, highlightSelection, processedData, radiusScale, previousRadiusScale } = this;
        const { animationManager } = this.ctx;
        const dataDiff = (_a2 = processedData == null ? void 0 : processedData.reduced) == null ? void 0 : _a2.diff;
        this.ctx.animationManager.stopByAnimationGroupId(this.id);
        const supportedDiff = ((_b = dataDiff == null ? void 0 : dataDiff.moved.size) != null ? _b : 0) === 0;
        const hasKeys = ((_c = processedData == null ? void 0 : processedData.defs.keys.length) != null ? _c : 0) > 0;
        const hasUniqueKeys = (_f = (_e = (_d = processedData == null ? void 0 : processedData.reduced) == null ? void 0 : _d.animationValidation) == null ? void 0 : _e.uniqueKeys) != null ? _f : true;
        if (!supportedDiff || !hasKeys || !hasUniqueKeys) {
          this.ctx.animationManager.skipCurrentBatch();
        }
        const fns = preparePieSeriesAnimationFunctions(
          false,
          this.properties.rotation,
          radiusScale,
          previousRadiusScale
        );
        fromToMotion(
          this.id,
          "nodes",
          animationManager,
          [itemSelection, highlightSelection],
          fns.nodes,
          (_, datum) => this.getDatumId(datum),
          dataDiff
        );
        fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
        seriesLabelFadeInAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
        seriesLabelFadeInAnimation(this, "sector", this.ctx.animationManager, this.sectorLabelSelection);
        seriesLabelFadeInAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
        this.previousRadiusScale.range = this.radiusScale.range;
      }
      animateClearingUpdateEmpty() {
        const { itemSelection, highlightSelection, radiusScale, previousRadiusScale } = this;
        const { animationManager } = this.ctx;
        const fns = preparePieSeriesAnimationFunctions(
          false,
          this.properties.rotation,
          radiusScale,
          previousRadiusScale
        );
        fromToMotion(this.id, "nodes", animationManager, [itemSelection, highlightSelection], fns.nodes);
        fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
        seriesLabelFadeOutAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
        seriesLabelFadeOutAnimation(this, "sector", this.ctx.animationManager, this.sectorLabelSelection);
        seriesLabelFadeOutAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
        this.previousRadiusScale.range = this.radiusScale.range;
      }
      getDatumIdFromData(datum) {
        var _a2, _b, _c;
        const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
        if (!((_c = (_b = (_a2 = this.processedData) == null ? void 0 : _a2.reduced) == null ? void 0 : _b.animationValidation) == null ? void 0 : _c.uniqueKeys)) {
          return;
        }
        if (legendItemKey) {
          return datum[legendItemKey];
        } else if (calloutLabelKey) {
          return datum[calloutLabelKey];
        } else if (sectorLabelKey) {
          return datum[sectorLabelKey];
        }
      }
      getDatumId(datum) {
        const { index } = datum;
        const datumId = this.getDatumIdFromData(datum.datum);
        return datumId != null ? String(datumId) : `${index}`;
      }
      onDataChange() {
        var _a2;
        const { data, seriesItemEnabled } = this;
        this.seriesItemEnabled = (_a2 = data == null ? void 0 : data.map((_, index) => {
          var _a3;
          return (_a3 = seriesItemEnabled[index]) != null ? _a3 : true;
        })) != null ? _a2 : [];
      }
      computeFocusBounds(opts) {
        return computeSectorFocusBounds(this, opts);
      }
    };
    DonutSeries.className = "DonutSeries";
    DonutSeries.type = "donut";
  }
});

// packages/ag-charts-community/src/chart/series/polar/pieTheme.ts
var pieTheme, piePaletteFactory;
var init_pieTheme = __esm({
  "packages/ag-charts-community/src/chart/series/polar/pieTheme.ts"() {
    "use strict";
    init_constants();
    init_symbols();
    pieTheme = {
      series: {
        __extends__: EXTENDS_SERIES_DEFAULTS,
        title: {
          enabled: true,
          fontStyle: void 0,
          fontWeight: "normal" /* NORMAL */,
          fontSize: 14,
          fontFamily: DEFAULT_FONT_FAMILY,
          color: DEFAULT_MUTED_LABEL_COLOUR,
          spacing: 5
        },
        calloutLabel: {
          enabled: true,
          fontStyle: void 0,
          fontWeight: void 0,
          fontSize: 12,
          fontFamily: DEFAULT_FONT_FAMILY,
          color: DEFAULT_LABEL_COLOUR,
          offset: 3,
          minAngle: 0
        },
        sectorLabel: {
          enabled: true,
          fontStyle: void 0,
          fontWeight: "normal" /* NORMAL */,
          fontSize: 12,
          fontFamily: DEFAULT_FONT_FAMILY,
          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
          positionOffset: 0,
          positionRatio: 0.5
        },
        calloutLine: {
          length: 10,
          strokeWidth: 2
        },
        fillOpacity: 1,
        strokeOpacity: 1,
        strokeWidth: 1,
        lineDash: [0],
        lineDashOffset: 0,
        rotation: 0,
        // @todo(AG-10275) Uncomment this
        // sectorSpacing: 1,
        shadow: {
          enabled: false,
          color: DEFAULT_SHADOW_COLOUR,
          xOffset: 3,
          yOffset: 3,
          blur: 5
        },
        innerLabels: {
          fontStyle: void 0,
          fontWeight: void 0,
          fontSize: 12,
          fontFamily: DEFAULT_FONT_FAMILY,
          color: DEFAULT_LABEL_COLOUR,
          margin: 2
        },
        // @todo(AG-10275) Remove this
        // @ts-expect-error
        __BACKGROUND_COLOR_DO_NOT_USE: DEFAULT_BACKGROUND_COLOUR
      }
    };
    piePaletteFactory = ({ takeColors, colorsCount, userPalette }) => {
      const { fills, strokes } = takeColors(colorsCount);
      return {
        fills,
        strokes: userPalette ? strokes : [],
        calloutLine: {
          colors: strokes
        }
      };
    };
  }
});

// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts
var DonutSeriesModule;
var init_donutSeriesModule = __esm({
  "packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts"() {
    "use strict";
    init_donutSeries();
    init_pieTheme();
    DonutSeriesModule = {
      type: "series",
      optionsKey: "series[]",
      packageType: "community",
      chartTypes: ["polar"],
      identifier: "donut",
      instanceConstructor: DonutSeries,
      themeTemplate: pieTheme,
      paletteFactory: piePaletteFactory
    };
  }
});

// packages/ag-charts-community/src/chart/series/polar/pieSeriesProperties.ts
var PieTitle, DonutInnerLabel2, DonutInnerCircle2, PieSeriesCalloutLabel, PieSeriesSectorLabel, PieSeriesCalloutLine, PieSeriesProperties;
var init_pieSeriesProperties = __esm({
  "packages/ag-charts-community/src/chart/series/polar/pieSeriesProperties.ts"() {
    "use strict";
    init_dropShadow();
    init_deprecation();
    init_properties();
    init_validation();
    init_caption();
    init_label();
    init_defaultColors();
    init_seriesProperties();
    init_seriesTooltip();
    PieTitle = class extends Caption {
      constructor() {
        super(...arguments);
        this.showInLegend = false;
      }
    };
    __decorateClass([
      Validate(BOOLEAN)
    ], PieTitle.prototype, "showInLegend", 2);
    DonutInnerLabel2 = class extends Label {
      set(properties, _reset) {
        return super.set(properties);
      }
    };
    __decorateClass([
      Deprecated("Use a Donut Series instead"),
      Validate(STRING, { optional: true })
    ], DonutInnerLabel2.prototype, "text", 2);
    __decorateClass([
      Deprecated("Use a Donut Series instead"),
      Validate(NUMBER, { optional: true })
    ], DonutInnerLabel2.prototype, "margin", 2);
    DonutInnerCircle2 = class extends BaseProperties {
    };
    __decorateClass([
      Deprecated("Use a Donut Series instead"),
      Validate(COLOR_STRING, { optional: true })
    ], DonutInnerCircle2.prototype, "fill", 2);
    __decorateClass([
      Deprecated("Use a Donut Series instead"),
      Validate(RATIO, { optional: true })
    ], DonutInnerCircle2.prototype, "fillOpacity", 2);
    PieSeriesCalloutLabel = class extends Label {
      constructor() {
        super(...arguments);
        this.offset = 3;
        this.minAngle = 0;
        this.minSpacing = 4;
        this.maxCollisionOffset = 50;
        this.avoidCollisions = true;
      }
    };
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], PieSeriesCalloutLabel.prototype, "offset", 2);
    __decorateClass([
      Validate(DEGREE)
    ], PieSeriesCalloutLabel.prototype, "minAngle", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], PieSeriesCalloutLabel.prototype, "minSpacing", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], PieSeriesCalloutLabel.prototype, "maxCollisionOffset", 2);
    __decorateClass([
      Validate(BOOLEAN)
    ], PieSeriesCalloutLabel.prototype, "avoidCollisions", 2);
    PieSeriesSectorLabel = class extends Label {
      constructor() {
        super(...arguments);
        this.positionOffset = 0;
        this.positionRatio = 0.5;
      }
    };
    __decorateClass([
      Validate(NUMBER)
    ], PieSeriesSectorLabel.prototype, "positionOffset", 2);
    __decorateClass([
      Validate(RATIO)
    ], PieSeriesSectorLabel.prototype, "positionRatio", 2);
    PieSeriesCalloutLine = class extends BaseProperties {
      constructor() {
        super(...arguments);
        this.length = 10;
        this.strokeWidth = 1;
      }
    };
    __decorateClass([
      Validate(COLOR_STRING_ARRAY, { optional: true })
    ], PieSeriesCalloutLine.prototype, "colors", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], PieSeriesCalloutLine.prototype, "length", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], PieSeriesCalloutLine.prototype, "strokeWidth", 2);
    PieSeriesProperties = class extends SeriesProperties {
      constructor() {
        super(...arguments);
        this.fills = Object.values(DEFAULT_FILLS);
        this.strokes = Object.values(DEFAULT_STROKES);
        this.fillOpacity = 1;
        this.strokeOpacity = 1;
        this.lineDash = [0];
        this.lineDashOffset = 0;
        this.cornerRadius = 0;
        this.rotation = 0;
        this.outerRadiusOffset = 0;
        this.outerRadiusRatio = 1;
        this.strokeWidth = 1;
        this.sectorSpacing = void 0;
        this.innerLabels = new PropertiesArray(DonutInnerLabel2);
        this.title = new PieTitle();
        this.innerCircle = new DonutInnerCircle2();
        this.shadow = new DropShadow();
        this.calloutLabel = new PieSeriesCalloutLabel();
        this.sectorLabel = new PieSeriesSectorLabel();
        this.calloutLine = new PieSeriesCalloutLine();
        this.tooltip = new SeriesTooltip();
        this.__BACKGROUND_COLOR_DO_NOT_USE = void 0;
      }
    };
    __decorateClass([
      Validate(STRING)
    ], PieSeriesProperties.prototype, "angleKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], PieSeriesProperties.prototype, "angleName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], PieSeriesProperties.prototype, "radiusKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], PieSeriesProperties.prototype, "radiusName", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], PieSeriesProperties.prototype, "radiusMin", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], PieSeriesProperties.prototype, "radiusMax", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], PieSeriesProperties.prototype, "calloutLabelKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], PieSeriesProperties.prototype, "calloutLabelName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], PieSeriesProperties.prototype, "sectorLabelKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], PieSeriesProperties.prototype, "sectorLabelName", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], PieSeriesProperties.prototype, "legendItemKey", 2);
    __decorateClass([
      Validate(COLOR_STRING_ARRAY)
    ], PieSeriesProperties.prototype, "fills", 2);
    __decorateClass([
      Validate(COLOR_STRING_ARRAY)
    ], PieSeriesProperties.prototype, "strokes", 2);
    __decorateClass([
      Validate(RATIO)
    ], PieSeriesProperties.prototype, "fillOpacity", 2);
    __decorateClass([
      Validate(RATIO)
    ], PieSeriesProperties.prototype, "strokeOpacity", 2);
    __decorateClass([
      Validate(LINE_DASH)
    ], PieSeriesProperties.prototype, "lineDash", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], PieSeriesProperties.prototype, "lineDashOffset", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], PieSeriesProperties.prototype, "cornerRadius", 2);
    __decorateClass([
      Validate(FUNCTION, { optional: true })
    ], PieSeriesProperties.prototype, "formatter", 2);
    __decorateClass([
      Validate(DEGREE)
    ], PieSeriesProperties.prototype, "rotation", 2);
    __decorateClass([
      Validate(NUMBER)
    ], PieSeriesProperties.prototype, "outerRadiusOffset", 2);
    __decorateClass([
      Validate(RATIO)
    ], PieSeriesProperties.prototype, "outerRadiusRatio", 2);
    __decorateClass([
      Deprecated("Use a Donut Series instead"),
      Validate(NUMBER, { optional: true })
    ], PieSeriesProperties.prototype, "innerRadiusOffset", 2);
    __decorateClass([
      Deprecated("Use a Donut Series instead"),
      Validate(RATIO, { optional: true })
    ], PieSeriesProperties.prototype, "innerRadiusRatio", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER)
    ], PieSeriesProperties.prototype, "strokeWidth", 2);
    __decorateClass([
      Validate(POSITIVE_NUMBER, { optional: true })
    ], PieSeriesProperties.prototype, "sectorSpacing", 2);
    __decorateClass([
      Validate(OBJECT_ARRAY)
    ], PieSeriesProperties.prototype, "innerLabels", 2);
    __decorateClass([
      Validate(OBJECT)
    ], PieSeriesProperties.prototype, "title", 2);
    __decorateClass([
      Validate(OBJECT)
    ], PieSeriesProperties.prototype, "innerCircle", 2);
    __decorateClass([
      Validate(OBJECT)
    ], PieSeriesProperties.prototype, "shadow", 2);
    __decorateClass([
      Validate(OBJECT)
    ], PieSeriesProperties.prototype, "calloutLabel", 2);
    __decorateClass([
      Validate(OBJECT)
    ], PieSeriesProperties.prototype, "sectorLabel", 2);
    __decorateClass([
      Validate(OBJECT)
    ], PieSeriesProperties.prototype, "calloutLine", 2);
    __decorateClass([
      Validate(OBJECT)
    ], PieSeriesProperties.prototype, "tooltip", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], PieSeriesProperties.prototype, "__BACKGROUND_COLOR_DO_NOT_USE", 2);
  }
});

// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts
var PieSeriesNodeEvent, PieSeries;
var init_pieSeries = __esm({
  "packages/ag-charts-community/src/chart/series/polar/pieSeries.ts"() {
    "use strict";
    init_fromToMotion();
    init_linearScale();
    init_bbox();
    init_group();
    init_node();
    init_selection();
    init_line();
    init_sector2();
    init_text();
    init_sector();
    init_angle();
    init_json();
    init_logger();
    init_number();
    init_object();
    init_sanitize();
    init_type_guards();
    init_chartAxisDirection();
    init_dataModel();
    init_processors();
    init_layers();
    init_circle();
    init_tooltip();
    init_series();
    init_series();
    init_seriesLabelUtil();
    init_pieSeriesProperties();
    init_pieUtil();
    init_polarSeries();
    PieSeriesNodeEvent = class extends SeriesNodeEvent {
      constructor(type, nativeEvent, datum, series) {
        super(type, nativeEvent, datum, series);
        this.angleKey = series.properties.angleKey;
        this.radiusKey = series.properties.radiusKey;
        this.calloutLabelKey = series.properties.calloutLabelKey;
        this.sectorLabelKey = series.properties.sectorLabelKey;
      }
    };
    PieSeries = class extends PolarSeries {
      constructor(moduleCtx) {
        super({
          moduleCtx,
          pickModes: [0 /* EXACT_SHAPE_MATCH */],
          useLabelLayer: true,
          animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }
        });
        this.properties = new PieSeriesProperties();
        this.previousRadiusScale = new LinearScale();
        this.radiusScale = new LinearScale();
        // The group node that contains the background graphics.
        this.backgroundGroup = this.rootGroup.appendChild(
          new Group({
            name: `${this.id}-background`,
            layer: true,
            zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */
          })
        );
        // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.
        this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));
        this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());
        this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Circle());
        this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));
        // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.
        this.seriesItemEnabled = [];
        this.surroundingRadius = void 0;
        this.NodeEvent = PieSeriesNodeEvent;
        this.angleScale = new LinearScale();
        this.angleScale.domain = [0, 1];
        this.angleScale.range = [-Math.PI, Math.PI].map((angle) => angle + Math.PI / 2);
        const pieCalloutLabels = new Group({ name: "pieCalloutLabels" });
        const pieSectorLabels = new Group({ name: "pieSectorLabels" });
        const innerLabels = new Group({ name: "innerLabels" });
        this.labelGroup.append(pieCalloutLabels);
        this.labelGroup.append(pieSectorLabels);
        this.labelGroup.append(innerLabels);
        this.calloutLabelSelection = Selection.select(pieCalloutLabels, Group);
        this.sectorLabelSelection = Selection.select(pieSectorLabels, Text);
        this.innerLabelsSelection = Selection.select(innerLabels, Text);
        this.innerCircleSelection = Selection.select(this.innerCircleGroup, Circle);
      }
      addChartEventListeners() {
        var _a2;
        this.destroyFns.push(
          (_a2 = this.ctx.chartEventManager) == null ? void 0 : _a2.addListener("legend-item-click", (event) => this.onLegendItemClick(event))
        );
      }
      get visible() {
        return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.some((visible) => visible));
      }
      nodeFactory() {
        return new Sector();
      }
      getSeriesDomain(direction) {
        if (direction === "x" /* X */) {
          return this.angleScale.domain;
        } else {
          return this.radiusScale.domain;
        }
      }
      processData(dataController) {
        return __async(this, null, function* () {
          var _a2, _b, _c, _d, _e;
          if (this.data == null || !this.properties.isValid()) {
            return;
          }
          let { data } = this;
          const { visible, seriesItemEnabled } = this;
          const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
          const animationEnabled = !this.ctx.animationManager.isSkipped();
          const extraKeyProps = [];
          const extraProps = [];
          if (legendItemKey) {
            extraKeyProps.push(keyProperty(legendItemKey, "band", { id: `legendItemKey` }));
          } else if (calloutLabelKey) {
            extraKeyProps.push(keyProperty(calloutLabelKey, "band", { id: `calloutLabelKey` }));
          } else if (sectorLabelKey) {
            extraKeyProps.push(keyProperty(sectorLabelKey, "band", { id: `sectorLabelKey` }));
          }
          const radiusScaleType = this.radiusScale.type;
          const angleScaleType = this.radiusScale.type;
          if (radiusKey) {
            extraProps.push(
              rangedValueProperty(radiusKey, {
                id: "radiusValue",
                min: (_a2 = this.properties.radiusMin) != null ? _a2 : 0,
                max: this.properties.radiusMax
              }),
              valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),
              // Raw value pass-through.
              normalisePropertyTo(
                { id: "radiusValue" },
                [0, 1],
                1,
                (_b = this.properties.radiusMin) != null ? _b : 0,
                this.properties.radiusMax
              )
            );
          }
          if (calloutLabelKey) {
            extraProps.push(valueProperty(calloutLabelKey, "band", { id: `calloutLabelValue` }));
          }
          if (sectorLabelKey) {
            extraProps.push(valueProperty(sectorLabelKey, "band", { id: `sectorLabelValue` }));
          }
          if (legendItemKey) {
            extraProps.push(valueProperty(legendItemKey, "band", { id: `legendItemValue` }));
          }
          if (animationEnabled && this.processedData && extraKeyProps.length > 0) {
            extraProps.push(diff(this.processedData));
          }
          extraProps.push(animationValidation());
          data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : __spreadProps(__spreadValues({}, d), { [angleKey]: 0 }));
          yield this.requestDataModel(dataController, data, {
            props: [
              ...extraKeyProps,
              accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),
              valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),
              // Raw value pass-through.
              normalisePropertyTo({ id: "angleValue" }, [0, 1], 0, 0),
              ...extraProps
            ]
          });
          for (const valueDef of (_e = (_d = (_c = this.processedData) == null ? void 0 : _c.defs) == null ? void 0 : _d.values) != null ? _e : []) {
            const { id, missing, property } = valueDef;
            const missCount = getMissCount(this, missing);
            if (id !== "angleRaw" && missCount > 0) {
              Logger.warnOnce(
                `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? "s" : ""}`
              );
            }
          }
          this.animationState.transition("updateData");
        });
      }
      maybeRefreshNodeData() {
        return __async(this, null, function* () {
          var _a2;
          if (!this.nodeDataRefresh)
            return;
          const { nodeData = [] } = (_a2 = yield this.createNodeData()) != null ? _a2 : {};
          this.nodeData = nodeData;
          this.nodeDataRefresh = false;
        });
      }
      getProcessedDataIndexes(dataModel) {
        const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);
        const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : -1;
        const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : -1;
        const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : -1;
        const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : -1;
        return { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx };
      }
      createNodeData() {
        return __async(this, null, function* () {
          const { id: seriesId, processedData, dataModel, angleScale } = this;
          const { rotation } = this.properties;
          if (!processedData || !dataModel || processedData.type !== "ungrouped")
            return;
          const { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);
          let currentStart = 0;
          let sum2 = 0;
          const nodeData = processedData.data.map((group2, index) => {
            var _a2;
            const { datum, values } = group2;
            const currentValue = values[angleIdx];
            const startAngle = angleScale.convert(currentStart) + toRadians(rotation);
            currentStart = currentValue;
            sum2 += currentValue;
            const endAngle = angleScale.convert(currentStart) + toRadians(rotation);
            const span = Math.abs(endAngle - startAngle);
            const midAngle = startAngle + span / 2;
            const angleValue = values[angleIdx + 1];
            const radius = radiusIdx >= 0 ? (_a2 = values[radiusIdx]) != null ? _a2 : 1 : 1;
            const radiusValue = radiusIdx >= 0 ? values[radiusIdx + 1] : void 0;
            const legendItemValue = legendItemIdx >= 0 ? values[legendItemIdx] : void 0;
            const labels = this.getLabels(
              datum,
              midAngle,
              span,
              true,
              values[calloutLabelIdx],
              values[sectorLabelIdx],
              legendItemValue
            );
            const sectorFormat = this.getSectorFormat(datum, index, false);
            return __spreadValues({
              itemId: index,
              series: this,
              datum,
              index,
              angleValue,
              midAngle,
              midCos: Math.cos(midAngle),
              midSin: Math.sin(midAngle),
              startAngle,
              endAngle,
              sectorFormat,
              radiusValue,
              radius,
              innerRadius: Math.max(this.radiusScale.convert(0), 0),
              outerRadius: Math.max(this.radiusScale.convert(radius), 0),
              legendItemValue
            }, labels);
          });
          this.zerosumOuterRing.visible = sum2 === 0;
          const { innerRadiusRatio = 1 } = this.properties;
          this.zerosumInnerRing.visible = sum2 === 0 && innerRadiusRatio !== 1 && innerRadiusRatio > 0;
          return { itemId: seriesId, nodeData, labelData: nodeData };
        });
      }
      getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {
        const { calloutLabel, sectorLabel, legendItemKey } = this.properties;
        const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;
        const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;
        if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {
          return {};
        }
        const labelFormatterParams = {
          datum,
          angleKey: this.properties.angleKey,
          angleName: this.properties.angleName,
          radiusKey: this.properties.radiusKey,
          radiusName: this.properties.radiusName,
          calloutLabelKey: this.properties.calloutLabelKey,
          calloutLabelName: this.properties.calloutLabelName,
          sectorLabelKey: this.properties.sectorLabelKey,
          sectorLabelName: this.properties.sectorLabelName,
          legendItemKey: this.properties.legendItemKey
        };
        const result = {};
        if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {
          result.calloutLabel = __spreadProps(__spreadValues({}, this.getTextAlignment(midAngle)), {
            text: this.getLabelText(calloutLabel, __spreadProps(__spreadValues({}, labelFormatterParams), {
              value: calloutLabelValue
            })),
            hidden: false,
            collisionTextAlign: void 0,
            collisionOffsetY: 0,
            box: void 0
          });
        }
        if (sectorLabelKey) {
          result.sectorLabel = {
            text: this.getLabelText(sectorLabel, __spreadProps(__spreadValues({}, labelFormatterParams), {
              value: sectorLabelValue
            }))
          };
        }
        if (legendItemKey != null && legendItemValue != null) {
          result.legendItem = { key: legendItemKey, text: legendItemValue };
        }
        return result;
      }
      getTextAlignment(midAngle) {
        const quadrantTextOpts = [
          { textAlign: "center", textBaseline: "bottom" },
          { textAlign: "left", textBaseline: "middle" },
          { textAlign: "center", textBaseline: "hanging" },
          { textAlign: "right", textBaseline: "middle" }
        ];
        const midAngle180 = normalizeAngle180(midAngle);
        const quadrantStart = -0.75 * Math.PI;
        const quadrantOffset = midAngle180 - quadrantStart;
        const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));
        const quadrantIndex = mod(quadrant, quadrantTextOpts.length);
        return quadrantTextOpts[quadrantIndex];
      }
      getSectorFormat(datum, formatIndex, highlight) {
        var _a2, _b, _c, _d, _e;
        const { callbackCache, highlightManager } = this.ctx;
        const { angleKey, radiusKey, fills, strokes, formatter, sectorSpacing, __BACKGROUND_COLOR_DO_NOT_USE } = this.properties;
        const highlightedDatum = highlightManager.getActiveHighlight();
        const isDatumHighlighted = highlight && (highlightedDatum == null ? void 0 : highlightedDatum.series) === this && formatIndex === highlightedDatum.itemId;
        let defaultStroke = strokes[formatIndex % strokes.length];
        if (sectorSpacing != null) {
          defaultStroke != null ? defaultStroke : defaultStroke = __BACKGROUND_COLOR_DO_NOT_USE;
        }
        const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = mergeDefaults(
          isDatumHighlighted && this.properties.highlightStyle.item,
          {
            fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,
            fillOpacity: this.properties.fillOpacity,
            stroke: defaultStroke,
            strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),
            strokeOpacity: this.getOpacity()
          }
        );
        let format2;
        if (formatter) {
          format2 = callbackCache.call(formatter, {
            datum,
            angleKey,
            radiusKey,
            fill,
            stroke,
            fills,
            strokes,
            strokeWidth,
            highlighted: isDatumHighlighted,
            seriesId: this.id
          });
        }
        return {
          fill: (_a2 = format2 == null ? void 0 : format2.fill) != null ? _a2 : fill,
          fillOpacity: (_b = format2 == null ? void 0 : format2.fillOpacity) != null ? _b : fillOpacity,
          stroke: (_c = format2 == null ? void 0 : format2.stroke) != null ? _c : stroke,
          strokeWidth: (_d = format2 == null ? void 0 : format2.strokeWidth) != null ? _d : strokeWidth,
          strokeOpacity: (_e = format2 == null ? void 0 : format2.strokeOpacity) != null ? _e : strokeOpacity
        };
      }
      getInnerRadius() {
        const { radius } = this;
        const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;
        const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;
        if (innerRadius === radius || innerRadius < 0) {
          return 0;
        }
        return innerRadius;
      }
      getOuterRadius() {
        return Math.max(this.radius * this.properties.outerRadiusRatio + this.properties.outerRadiusOffset, 0);
      }
      updateRadiusScale(resize) {
        const newRange = [this.getInnerRadius(), this.getOuterRadius()];
        this.radiusScale.range = newRange;
        if (resize) {
          this.previousRadiusScale.range = newRange;
        }
        this.nodeData = this.nodeData.map((_a2) => {
          var _b = _a2, { radius } = _b, d = __objRest(_b, ["radius"]);
          return __spreadProps(__spreadValues({}, d), {
            radius,
            innerRadius: Math.max(this.radiusScale.convert(0), 0),
            outerRadius: Math.max(this.radiusScale.convert(radius), 0)
          });
        });
      }
      getTitleTranslationY() {
        var _a2, _b;
        const outerRadius = Math.max(0, this.radiusScale.range[1]);
        if (outerRadius === 0) {
          return NaN;
        }
        const spacing = (_b = (_a2 = this.properties.title) == null ? void 0 : _a2.spacing) != null ? _b : 0;
        const titleOffset = 2 + spacing;
        const dy2 = Math.max(0, -outerRadius);
        return -outerRadius - titleOffset - dy2;
      }
      update(_0) {
        return __async(this, arguments, function* ({ seriesRect }) {
          const { title } = this.properties;
          const newNodeDataDependencies = {
            seriesRectWidth: seriesRect == null ? void 0 : seriesRect.width,
            seriesRectHeight: seriesRect == null ? void 0 : seriesRect.height
          };
          const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;
          if (resize) {
            this._nodeDataDependencies = newNodeDataDependencies;
          }
          yield this.maybeRefreshNodeData();
          this.updateTitleNodes();
          this.updateRadiusScale(resize);
          this.contentGroup.translationX = this.centerX;
          this.contentGroup.translationY = this.centerY;
          this.highlightGroup.translationX = this.centerX;
          this.highlightGroup.translationY = this.centerY;
          this.backgroundGroup.translationX = this.centerX;
          this.backgroundGroup.translationY = this.centerY;
          if (this.labelGroup) {
            this.labelGroup.translationX = this.centerX;
            this.labelGroup.translationY = this.centerY;
          }
          if (title) {
            const dy2 = this.getTitleTranslationY();
            const titleBox = title.node.computeBBox();
            title.node.visible = title.enabled && isFinite(dy2) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy2);
            title.node.translationY = isFinite(dy2) ? dy2 : 0;
          }
          for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {
            circle.fillOpacity = 0;
            circle.stroke = this.properties.calloutLabel.color;
            circle.strokeWidth = 1;
            circle.strokeOpacity = 1;
          }
          this.updateNodeMidPoint();
          yield this.updateSelections();
          yield this.updateNodes(seriesRect);
        });
      }
      updateTitleNodes() {
        var _a2, _b;
        const { oldTitle } = this;
        const { title } = this.properties;
        if (oldTitle !== title) {
          if (oldTitle) {
            (_a2 = this.labelGroup) == null ? void 0 : _a2.removeChild(oldTitle.node);
          }
          if (title) {
            title.node.textBaseline = "bottom";
            (_b = this.labelGroup) == null ? void 0 : _b.appendChild(title.node);
          }
          this.oldTitle = title;
        }
      }
      updateNodeMidPoint() {
        this.nodeData.forEach((d) => {
          const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;
          d.midPoint = {
            x: d.midCos * Math.max(0, radius),
            y: d.midSin * Math.max(0, radius)
          };
        });
      }
      updateSelections() {
        return __async(this, null, function* () {
          yield this.updateGroupSelection();
          this.updateInnerCircleSelection();
        });
      }
      updateGroupSelection() {
        return __async(this, null, function* () {
          const { itemSelection, highlightSelection, calloutLabelSelection, sectorLabelSelection, innerLabelsSelection } = this;
          const update = (selection, clone) => {
            let nodeData = this.nodeData;
            if (clone) {
              nodeData = nodeData.map((datum) => __spreadProps(__spreadValues({}, datum), { sectorFormat: __spreadValues({}, datum.sectorFormat) }));
            }
            selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));
            if (this.ctx.animationManager.isSkipped()) {
              selection.cleanup();
            }
          };
          update(itemSelection, false);
          update(highlightSelection, true);
          calloutLabelSelection.update(this.nodeData, (group2) => {
            const line = new Line();
            line.tag = 0 /* Callout */;
            line.pointerEvents = 1 /* None */;
            group2.appendChild(line);
            const text = new Text();
            text.tag = 1 /* Label */;
            text.pointerEvents = 1 /* None */;
            group2.appendChild(text);
          });
          sectorLabelSelection.update(this.nodeData, (node) => {
            node.pointerEvents = 1 /* None */;
          });
          innerLabelsSelection.update(this.properties.innerLabels, (node) => {
            node.pointerEvents = 1 /* None */;
          });
        });
      }
      updateInnerCircleSelection() {
        const { innerCircle } = this.properties;
        let radius = 0;
        const innerRadius = this.getInnerRadius();
        if (innerRadius > 0) {
          const circleRadius = Math.min(innerRadius, this.getOuterRadius());
          const antiAliasingPadding = 1;
          radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);
        }
        const datums = innerCircle ? [{ radius }] : [];
        this.innerCircleSelection.update(datums);
      }
      updateNodes(seriesRect) {
        return __async(this, null, function* () {
          const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();
          const isVisible = this.visible && this.seriesItemEnabled.indexOf(true) >= 0;
          this.rootGroup.visible = isVisible;
          this.backgroundGroup.visible = isVisible;
          this.contentGroup.visible = isVisible;
          this.highlightGroup.visible = isVisible && (highlightedDatum == null ? void 0 : highlightedDatum.series) === this;
          if (this.labelGroup) {
            this.labelGroup.visible = isVisible;
          }
          this.contentGroup.opacity = this.getOpacity();
          this.innerCircleSelection.each((node, { radius }) => {
            var _a2, _b;
            node.setProperties({
              fill: (_a2 = this.properties.innerCircle) == null ? void 0 : _a2.fill,
              opacity: (_b = this.properties.innerCircle) == null ? void 0 : _b.fillOpacity,
              size: radius
            });
          });
          const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {
            const format2 = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);
            datum.sectorFormat.fill = format2.fill;
            datum.sectorFormat.stroke = format2.stroke;
            const animationDisabled = this.ctx.animationManager.isSkipped();
            if (animationDisabled) {
              sector.startAngle = datum.startAngle;
              sector.endAngle = datum.endAngle;
              sector.innerRadius = datum.innerRadius;
              sector.outerRadius = datum.outerRadius;
            }
            if (isDatumHighlighted || animationDisabled) {
              sector.fill = format2.fill;
              sector.stroke = format2.stroke;
            }
            sector.strokeWidth = format2.strokeWidth;
            sector.fillOpacity = format2.fillOpacity;
            sector.strokeOpacity = this.properties.strokeOpacity;
            sector.lineDash = this.properties.lineDash;
            sector.lineDashOffset = this.properties.lineDashOffset;
            sector.fillShadow = this.properties.shadow;
            sector.cornerRadius = this.properties.cornerRadius;
            sector.inset = this.properties.sectorSpacing != null ? (this.properties.sectorSpacing + (format2.stroke != null ? format2.strokeWidth : 0)) / 2 : 0;
            sector.lineJoin = this.properties.sectorSpacing != null ? "miter" : "round";
          };
          this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));
          this.highlightSelection.each((node, datum, index) => {
            const isDatumHighlighted = (highlightedDatum == null ? void 0 : highlightedDatum.series) === this && node.datum.itemId === highlightedDatum.itemId;
            updateSectorFn(node, datum, index, true);
            node.visible = isDatumHighlighted;
          });
          this.updateCalloutLineNodes();
          this.updateCalloutLabelNodes(seriesRect);
          this.updateSectorLabelNodes();
          this.updateInnerLabelNodes();
          this.updateZerosumRings();
          this.animationState.transition("update");
        });
      }
      updateCalloutLineNodes() {
        var _a2;
        const { calloutLine } = this.properties;
        const calloutLength = calloutLine.length;
        const calloutStrokeWidth = calloutLine.strokeWidth;
        const calloutColors = (_a2 = calloutLine.colors) != null ? _a2 : this.properties.strokes;
        const { offset: offset4 } = this.properties.calloutLabel;
        this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {
          var _a3;
          const datum = line.datum;
          const { calloutLabel: label, outerRadius } = datum;
          if ((label == null ? void 0 : label.text) && !label.hidden && outerRadius !== 0) {
            line.visible = true;
            line.strokeWidth = calloutStrokeWidth;
            line.stroke = calloutColors[index % calloutColors.length];
            line.fill = void 0;
            const x1 = datum.midCos * outerRadius;
            const y1 = datum.midSin * outerRadius;
            let x2 = datum.midCos * (outerRadius + calloutLength);
            let y2 = datum.midSin * (outerRadius + calloutLength);
            const isMoved = (_a3 = label.collisionTextAlign) != null ? _a3 : label.collisionOffsetY !== 0;
            if (isMoved && label.box != null) {
              const box = label.box;
              let cx = x2;
              let cy = y2;
              if (x2 < box.x) {
                cx = box.x;
              } else if (x2 > box.x + box.width) {
                cx = box.x + box.width;
              }
              if (y2 < box.y) {
                cy = box.y;
              } else if (y2 > box.y + box.height) {
                cy = box.y + box.height;
              }
              const dx2 = cx - x2;
              const dy2 = cy - y2;
              const length = Math.sqrt(Math.pow(dx2, 2) + Math.pow(dy2, 2));
              const paddedLength = length - offset4;
              if (paddedLength > 0) {
                x2 = x2 + dx2 * paddedLength / length;
                y2 = y2 + dy2 * paddedLength / length;
              }
            }
            line.x1 = x1;
            line.y1 = y1;
            line.x2 = x2;
            line.y2 = y2;
          } else {
            line.visible = false;
          }
        });
      }
      getLabelOverflow(text, box, seriesRect) {
        const seriesLeft = seriesRect.x - this.centerX;
        const seriesRight = seriesRect.x + seriesRect.width - this.centerX;
        const seriesTop = seriesRect.y - this.centerY;
        const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;
        const errPx = 1;
        let visibleTextPart = 1;
        if (box.x + errPx < seriesLeft) {
          visibleTextPart = (box.x + box.width - seriesLeft) / box.width;
        } else if (box.x + box.width - errPx > seriesRight) {
          visibleTextPart = (seriesRight - box.x) / box.width;
        }
        const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;
        const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;
        const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);
        return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };
      }
      bboxIntersectsSurroundingSeries(box, dx2 = 0, dy2 = 0) {
        const { surroundingRadius } = this;
        if (surroundingRadius == null) {
          return false;
        }
        const corners = [
          { x: box.x + dx2, y: box.y + dy2 },
          { x: box.x + box.width + dx2, y: box.y + dy2 },
          { x: box.x + box.width + dx2, y: box.y + box.height + dy2 },
          { x: box.x + dx2, y: box.y + box.height + dy2 }
        ];
        const sur2 = __pow(surroundingRadius, 2);
        return corners.some((corner) => __pow(corner.x, 2) + __pow(corner.y, 2) > sur2);
      }
      computeCalloutLabelCollisionOffsets() {
        const { radiusScale } = this;
        const { calloutLabel, calloutLine } = this.properties;
        const { offset: offset4, minSpacing } = calloutLabel;
        const innerRadius = radiusScale.convert(0);
        const shouldSkip = (datum) => {
          const label = datum.calloutLabel;
          return !label || datum.outerRadius === 0;
        };
        const fullData = this.nodeData;
        const data = this.nodeData.filter((t) => !shouldSkip(t));
        data.forEach((datum) => {
          const label = datum.calloutLabel;
          if (label == null)
            return;
          label.hidden = false;
          label.collisionTextAlign = void 0;
          label.collisionOffsetY = 0;
        });
        if (data.length <= 1) {
          return;
        }
        const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);
        const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);
        const topLabels = data.filter((d) => {
          var _a2;
          return d.midSin < 0 && ((_a2 = d.calloutLabel) == null ? void 0 : _a2.textAlign) === "center";
        }).sort((a, b) => a.midCos - b.midCos);
        const bottomLabels = data.filter((d) => {
          var _a2;
          return d.midSin >= 0 && ((_a2 = d.calloutLabel) == null ? void 0 : _a2.textAlign) === "center";
        }).sort((a, b) => a.midCos - b.midCos);
        const tempTextNode = new Text();
        const getTextBBox = (datum) => {
          var _a2;
          const label = datum.calloutLabel;
          if (label == null)
            return new BBox(0, 0, 0, 0);
          const labelRadius = datum.outerRadius + calloutLine.length + offset4;
          const x = datum.midCos * labelRadius;
          const y = datum.midSin * labelRadius + label.collisionOffsetY;
          tempTextNode.text = label.text;
          tempTextNode.x = x;
          tempTextNode.y = y;
          tempTextNode.setFont(this.properties.calloutLabel);
          tempTextNode.setAlign({
            textAlign: (_a2 = label.collisionTextAlign) != null ? _a2 : label.textAlign,
            textBaseline: label.textBaseline
          });
          return tempTextNode.computeBBox();
        };
        const avoidNeighbourYCollision = (label, next, direction) => {
          const box = getTextBBox(label).grow(minSpacing / 2);
          const other = getTextBBox(next).grow(minSpacing / 2);
          const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === "to-top" ? box.y < other.y + other.height : box.y + box.height > other.y);
          if (collidesOrBehind) {
            const dy2 = direction === "to-top" ? box.y - other.y - other.height : box.y + box.height - other.y;
            next.calloutLabel.collisionOffsetY = dy2;
          }
        };
        const avoidYCollisions = (labels) => {
          const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];
          const midIndex = labels.indexOf(midLabel);
          for (let i = midIndex - 1; i >= 0; i--) {
            const prev = labels[i + 1];
            const next = labels[i];
            avoidNeighbourYCollision(prev, next, "to-top");
          }
          for (let i = midIndex + 1; i < labels.length; i++) {
            const prev = labels[i - 1];
            const next = labels[i];
            avoidNeighbourYCollision(prev, next, "to-bottom");
          }
        };
        const avoidXCollisions = (labels) => {
          const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);
          const boxes = labels.map((label) => getTextBBox(label));
          const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));
          let labelsCollideLabelsByX = false;
          for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {
            const box = paddedBoxes[i];
            for (let j = i + 1; j < labels.length; j++) {
              const other = paddedBoxes[j];
              if (box.collidesBBox(other)) {
                labelsCollideLabelsByX = true;
                break;
              }
            }
          }
          const sectors = fullData.map((datum) => {
            const { startAngle, endAngle, outerRadius } = datum;
            return { startAngle, endAngle, innerRadius, outerRadius };
          });
          const labelsCollideSectors = boxes.some((box) => {
            return sectors.some((sector) => boxCollidesSector(box, sector));
          });
          if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {
            return;
          }
          labels.filter((d) => d.calloutLabel.textAlign === "center").forEach((d) => {
            const label = d.calloutLabel;
            if (d.midCos < 0) {
              label.collisionTextAlign = "right";
            } else if (d.midCos > 0) {
              label.collisionTextAlign = "left";
            } else {
              label.collisionTextAlign = "center";
            }
          });
        };
        avoidYCollisions(leftLabels);
        avoidYCollisions(rightLabels);
        avoidXCollisions(topLabels);
        avoidXCollisions(bottomLabels);
      }
      updateCalloutLabelNodes(seriesRect) {
        const { radiusScale } = this;
        const { calloutLabel, calloutLine } = this.properties;
        const calloutLength = calloutLine.length;
        const { offset: offset4, color } = calloutLabel;
        const tempTextNode = new Text();
        this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {
          var _a2;
          const { datum } = text;
          const label = datum.calloutLabel;
          const radius = radiusScale.convert(datum.radius);
          const outerRadius = Math.max(0, radius);
          if (!(label == null ? void 0 : label.text) || outerRadius === 0 || label.hidden) {
            text.visible = false;
            return;
          }
          const labelRadius = outerRadius + calloutLength + offset4;
          const x = datum.midCos * labelRadius;
          const y = datum.midSin * labelRadius + label.collisionOffsetY;
          const align = {
            textAlign: (_a2 = label.collisionTextAlign) != null ? _a2 : label.textAlign,
            textBaseline: label.textBaseline
          };
          tempTextNode.text = label.text;
          tempTextNode.x = x;
          tempTextNode.y = y;
          tempTextNode.setFont(this.properties.calloutLabel);
          tempTextNode.setAlign(align);
          const box = tempTextNode.computeBBox();
          let displayText = label.text;
          let visible = true;
          if (calloutLabel.avoidCollisions) {
            const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);
            displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\u2026`;
            visible = !hasVerticalOverflow;
          }
          text.text = displayText;
          text.x = x;
          text.y = y;
          text.setFont(this.properties.calloutLabel);
          text.setAlign(align);
          text.fill = color;
          text.visible = visible;
        });
      }
      computeLabelsBBox(options, seriesRect) {
        return __async(this, null, function* () {
          const { calloutLabel, calloutLine } = this.properties;
          const calloutLength = calloutLine.length;
          const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;
          if (!calloutLabel.avoidCollisions) {
            return null;
          }
          yield this.maybeRefreshNodeData();
          this.updateRadiusScale(false);
          this.computeCalloutLabelCollisionOffsets();
          const textBoxes = [];
          const text = new Text();
          let titleBox;
          const { title } = this.properties;
          if ((title == null ? void 0 : title.text) && title.enabled) {
            const dy2 = this.getTitleTranslationY();
            if (isFinite(dy2)) {
              text.text = title.text;
              text.x = 0;
              text.y = dy2;
              text.setFont(title);
              text.setAlign({
                textBaseline: "bottom",
                textAlign: "center"
              });
              titleBox = text.computeBBox();
              textBoxes.push(titleBox);
            }
          }
          this.nodeData.forEach((datum) => {
            var _a2;
            const label = datum.calloutLabel;
            if (!label || datum.outerRadius === 0) {
              return null;
            }
            const labelRadius = datum.outerRadius + calloutLength + offset4;
            const x = datum.midCos * labelRadius;
            const y = datum.midSin * labelRadius + label.collisionOffsetY;
            text.text = label.text;
            text.x = x;
            text.y = y;
            text.setFont(this.properties.calloutLabel);
            text.setAlign({
              textAlign: (_a2 = label.collisionTextAlign) != null ? _a2 : label.textAlign,
              textBaseline: label.textBaseline
            });
            const box = text.computeBBox();
            label.box = box;
            if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {
              label.hidden = true;
              return;
            }
            if (titleBox) {
              const seriesTop = seriesRect.y - this.centerY;
              const titleCleanArea = new BBox(
                titleBox.x - minSpacing,
                seriesTop,
                titleBox.width + 2 * minSpacing,
                titleBox.y + titleBox.height + minSpacing - seriesTop
              );
              if (box.collidesBBox(titleCleanArea)) {
                label.hidden = true;
                return;
              }
            }
            if (options.hideWhenNecessary) {
              const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(
                label.text,
                box,
                seriesRect
              );
              const isTooShort = label.text.length > 2 && textLength < 2;
              if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {
                label.hidden = true;
                return;
              }
            }
            label.hidden = false;
            textBoxes.push(box);
          });
          if (textBoxes.length === 0) {
            return null;
          }
          return BBox.merge(textBoxes);
        });
      }
      updateSectorLabelNodes() {
        const { radiusScale } = this;
        const innerRadius = radiusScale.convert(0);
        const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;
        const isDonut = innerRadius > 0;
        const singleVisibleSector = this.seriesItemEnabled.filter(Boolean).length === 1;
        this.sectorLabelSelection.each((text, datum) => {
          const { sectorLabel, outerRadius } = datum;
          let isTextVisible = false;
          if (sectorLabel && outerRadius !== 0) {
            const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;
            text.fill = color;
            text.fontStyle = fontStyle;
            text.fontWeight = fontWeight;
            text.fontSize = fontSize;
            text.fontFamily = fontFamily;
            text.text = sectorLabel.text;
            const shouldPutTextInCenter = !isDonut && singleVisibleSector;
            if (shouldPutTextInCenter) {
              text.x = 0;
              text.y = 0;
            } else {
              text.x = datum.midCos * labelRadius;
              text.y = datum.midSin * labelRadius;
            }
            text.textAlign = "center";
            text.textBaseline = "middle";
            const bbox = text.computeBBox();
            const corners = [
              [bbox.x, bbox.y],
              [bbox.x + bbox.width, bbox.y],
              [bbox.x + bbox.width, bbox.y + bbox.height],
              [bbox.x, bbox.y + bbox.height]
            ];
            const { startAngle, endAngle } = datum;
            const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };
            if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {
              isTextVisible = true;
            }
          }
          text.visible = isTextVisible;
        });
      }
      updateInnerLabelNodes() {
        const textBBoxes = [];
        const margins = [];
        this.innerLabelsSelection.each((text, datum) => {
          const { fontStyle, fontWeight, fontSize, fontFamily, color, margin = 2 } = datum;
          text.fontStyle = fontStyle;
          text.fontWeight = fontWeight;
          text.fontSize = fontSize;
          text.fontFamily = fontFamily;
          text.text = datum.text;
          text.x = 0;
          text.y = 0;
          text.fill = color;
          text.textAlign = "center";
          text.textBaseline = "alphabetic";
          textBBoxes.push(text.computeBBox());
          margins.push(margin);
        });
        const getMarginTop = (index) => index === 0 ? 0 : margins[index];
        const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];
        const totalHeight = textBBoxes.reduce((sum2, bbox, i) => {
          return sum2 + bbox.height + getMarginTop(i) + getMarginBottom(i);
        }, 0);
        const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));
        const innerRadius = this.getInnerRadius();
        const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));
        const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());
        const textBottoms = [];
        for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {
          const bbox = textBBoxes[i];
          const bottom = bbox.height + prev + getMarginTop(i);
          textBottoms.push(bottom);
          prev = bottom + getMarginBottom(i);
        }
        this.innerLabelsSelection.each((text, _datum, index) => {
          text.y = textBottoms[index];
          text.visible = labelsVisible;
        });
      }
      updateZerosumRings() {
        this.zerosumOuterRing.size = this.getOuterRadius() * 2;
        this.zerosumInnerRing.size = this.getInnerRadius() * 2;
      }
      getDatumLegendName(nodeDatum) {
        const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
        const { sectorLabel, calloutLabel, legendItem } = nodeDatum;
        if (legendItemKey && legendItem !== void 0) {
          return legendItem.text;
        } else if (calloutLabelKey && calloutLabelKey !== angleKey && (calloutLabel == null ? void 0 : calloutLabel.text) !== void 0) {
          return calloutLabel.text;
        } else if (sectorLabelKey && sectorLabelKey !== angleKey && (sectorLabel == null ? void 0 : sectorLabel.text) !== void 0) {
          return sectorLabel.text;
        }
      }
      pickNodeClosestDatum(point) {
        return pickByMatchingAngle(this, point);
      }
      getTooltipHtml(nodeDatum) {
        var _a2;
        if (!this.properties.isValid()) {
          return EMPTY_TOOLTIP_CONTENT;
        }
        const {
          datum,
          angleValue,
          sectorFormat: { fill: color },
          itemId
        } = nodeDatum;
        const title = sanitizeHtml((_a2 = this.properties.title) == null ? void 0 : _a2.text);
        const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);
        const labelText = this.getDatumLegendName(nodeDatum);
        return this.properties.tooltip.toTooltipHtml(
          {
            title: title != null ? title : labelText,
            content: title && labelText ? `${labelText}: ${content}` : content,
            backgroundColor: color
          },
          {
            datum,
            itemId,
            title,
            color,
            seriesId: this.id,
            angleKey: this.properties.angleKey,
            angleName: this.properties.angleName,
            radiusKey: this.properties.radiusKey,
            radiusName: this.properties.radiusName,
            calloutLabelKey: this.properties.calloutLabelKey,
            calloutLabelName: this.properties.calloutLabelName,
            sectorLabelKey: this.properties.sectorLabelKey,
            sectorLabelName: this.properties.sectorLabelName,
            legendItemKey: this.properties.legendItemKey
          }
        );
      }
      getLegendData(legendType) {
        var _a2, _b, _c, _d, _e;
        const { visible, processedData, dataModel } = this;
        if (!dataModel || !(processedData == null ? void 0 : processedData.data.length) || legendType !== "category") {
          return [];
        }
        const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
        if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {
          return [];
        }
        const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);
        const titleText = ((_a2 = this.properties.title) == null ? void 0 : _a2.showInLegend) && this.properties.title.text;
        const legendData = [];
        for (let index = 0; index < processedData.data.length; index++) {
          const { datum, values } = processedData.data[index];
          const labelParts = [];
          if (titleText) {
            labelParts.push(titleText);
          }
          const labels = this.getLabels(
            datum,
            2 * Math.PI,
            2 * Math.PI,
            false,
            values[calloutLabelIdx],
            values[sectorLabelIdx],
            values[legendItemIdx]
          );
          if (legendItemKey && labels.legendItem !== void 0) {
            labelParts.push(labels.legendItem.text);
          } else if (calloutLabelKey && calloutLabelKey !== angleKey && ((_b = labels.calloutLabel) == null ? void 0 : _b.text) !== void 0) {
            labelParts.push((_c = labels.calloutLabel) == null ? void 0 : _c.text);
          } else if (sectorLabelKey && sectorLabelKey !== angleKey && ((_d = labels.sectorLabel) == null ? void 0 : _d.text) !== void 0) {
            labelParts.push((_e = labels.sectorLabel) == null ? void 0 : _e.text);
          }
          if (labelParts.length === 0)
            continue;
          const sectorFormat = this.getSectorFormat(datum, index, false);
          legendData.push({
            legendType: "category",
            id: this.id,
            itemId: index,
            seriesId: this.id,
            enabled: visible && this.seriesItemEnabled[index],
            label: {
              text: labelParts.join(" - ")
            },
            marker: {
              fill: sectorFormat.fill,
              stroke: sectorFormat.stroke,
              fillOpacity: this.properties.fillOpacity,
              strokeOpacity: this.properties.strokeOpacity,
              strokeWidth: this.properties.strokeWidth
            },
            legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0
          });
        }
        return legendData;
      }
      onLegendItemClick(event) {
        const { enabled, itemId, series, legendItemName } = event;
        if (series.id === this.id) {
          this.toggleSeriesItem(itemId, enabled);
        } else if (legendItemName != null) {
          this.toggleOtherSeriesItems(legendItemName, enabled);
        }
      }
      toggleSeriesItem(itemId, enabled) {
        this.seriesItemEnabled[itemId] = enabled;
        this.nodeDataRefresh = true;
      }
      toggleOtherSeriesItems(legendItemName, enabled) {
        var _a2;
        if (!this.properties.legendItemKey || !this.dataModel) {
          return;
        }
        const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);
        (_a2 = this.processedData) == null ? void 0 : _a2.data.forEach(({ values }, datumItemId) => {
          if (values[legendItemIdx] === legendItemName) {
            this.toggleSeriesItem(datumItemId, enabled);
          }
        });
      }
      animateEmptyUpdateReady(_data) {
        const { animationManager } = this.ctx;
        const fns = preparePieSeriesAnimationFunctions(
          true,
          this.properties.rotation,
          this.radiusScale,
          this.previousRadiusScale
        );
        fromToMotion(this.id, "nodes", animationManager, [this.itemSelection, this.highlightSelection], fns.nodes);
        fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
        seriesLabelFadeInAnimation(this, "callout", animationManager, this.calloutLabelSelection);
        seriesLabelFadeInAnimation(this, "sector", animationManager, this.sectorLabelSelection);
        seriesLabelFadeInAnimation(this, "inner", animationManager, this.innerLabelsSelection);
        this.previousRadiusScale.range = this.radiusScale.range;
      }
      animateWaitingUpdateReady() {
        var _a2, _b, _c, _d, _e, _f;
        const { itemSelection, highlightSelection, processedData, radiusScale, previousRadiusScale } = this;
        const { animationManager } = this.ctx;
        const dataDiff = (_a2 = processedData == null ? void 0 : processedData.reduced) == null ? void 0 : _a2.diff;
        this.ctx.animationManager.stopByAnimationGroupId(this.id);
        const supportedDiff = ((_b = dataDiff == null ? void 0 : dataDiff.moved.size) != null ? _b : 0) === 0;
        const hasKeys = ((_c = processedData == null ? void 0 : processedData.defs.keys.length) != null ? _c : 0) > 0;
        const hasUniqueKeys = (_f = (_e = (_d = processedData == null ? void 0 : processedData.reduced) == null ? void 0 : _d.animationValidation) == null ? void 0 : _e.uniqueKeys) != null ? _f : true;
        if (!supportedDiff || !hasKeys || !hasUniqueKeys) {
          this.ctx.animationManager.skipCurrentBatch();
        }
        const fns = preparePieSeriesAnimationFunctions(
          false,
          this.properties.rotation,
          radiusScale,
          previousRadiusScale
        );
        fromToMotion(
          this.id,
          "nodes",
          animationManager,
          [itemSelection, highlightSelection],
          fns.nodes,
          (_, datum) => this.getDatumId(datum),
          dataDiff
        );
        fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
        seriesLabelFadeInAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
        seriesLabelFadeInAnimation(this, "sector", this.ctx.animationManager, this.sectorLabelSelection);
        seriesLabelFadeInAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
        this.previousRadiusScale.range = this.radiusScale.range;
      }
      animateClearingUpdateEmpty() {
        const { itemSelection, highlightSelection, radiusScale, previousRadiusScale } = this;
        const { animationManager } = this.ctx;
        const fns = preparePieSeriesAnimationFunctions(
          false,
          this.properties.rotation,
          radiusScale,
          previousRadiusScale
        );
        fromToMotion(this.id, "nodes", animationManager, [itemSelection, highlightSelection], fns.nodes);
        fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);
        seriesLabelFadeOutAnimation(this, "callout", this.ctx.animationManager, this.calloutLabelSelection);
        seriesLabelFadeOutAnimation(this, "sector", this.ctx.animationManager, this.sectorLabelSelection);
        seriesLabelFadeOutAnimation(this, "inner", this.ctx.animationManager, this.innerLabelsSelection);
        this.previousRadiusScale.range = this.radiusScale.range;
      }
      getDatumIdFromData(datum) {
        var _a2, _b, _c;
        const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;
        if (!((_c = (_b = (_a2 = this.processedData) == null ? void 0 : _a2.reduced) == null ? void 0 : _b.animationValidation) == null ? void 0 : _c.uniqueKeys)) {
          return;
        }
        if (legendItemKey) {
          return datum[legendItemKey];
        } else if (calloutLabelKey) {
          return datum[calloutLabelKey];
        } else if (sectorLabelKey) {
          return datum[sectorLabelKey];
        }
      }
      getDatumId(datum) {
        const { index } = datum;
        const datumId = this.getDatumIdFromData(datum.datum);
        return datumId != null ? String(datumId) : `${index}`;
      }
      onDataChange() {
        var _a2;
        const { data, seriesItemEnabled } = this;
        this.seriesItemEnabled = (_a2 = data == null ? void 0 : data.map((_, index) => {
          var _a3;
          return (_a3 = seriesItemEnabled[index]) != null ? _a3 : true;
        })) != null ? _a2 : [];
      }
      computeFocusBounds(opts) {
        return computeSectorFocusBounds(this, opts);
      }
    };
    PieSeries.className = "PieSeries";
    PieSeries.type = "pie";
  }
});

// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts
var PieSeriesModule;
var init_pieSeriesModule = __esm({
  "packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts"() {
    "use strict";
    init_pieSeries();
    init_pieTheme();
    PieSeriesModule = {
      type: "series",
      optionsKey: "series[]",
      packageType: "community",
      chartTypes: ["polar"],
      identifier: "pie",
      instanceConstructor: PieSeries,
      themeTemplate: pieTheme,
      paletteFactory: piePaletteFactory
    };
  }
});

// packages/ag-charts-community/src/chart/toolbar/toolbarTypes.ts
var TOOLBAR_ALIGNMENTS, TOOLBAR_GROUPS, ToolbarPosition, TOOLBAR_POSITIONS;
var init_toolbarTypes = __esm({
  "packages/ag-charts-community/src/chart/toolbar/toolbarTypes.ts"() {
    "use strict";
    TOOLBAR_ALIGNMENTS = ["start", "center", "end"];
    TOOLBAR_GROUPS = ["annotations", "ranges", "zoom"];
    ToolbarPosition = /* @__PURE__ */ ((ToolbarPosition2) => {
      ToolbarPosition2["Top"] = "top";
      ToolbarPosition2["Right"] = "right";
      ToolbarPosition2["Bottom"] = "bottom";
      ToolbarPosition2["Left"] = "left";
      ToolbarPosition2["FloatingTop"] = "floating-top";
      ToolbarPosition2["FloatingBottom"] = "floating-bottom";
      return ToolbarPosition2;
    })(ToolbarPosition || {});
    TOOLBAR_POSITIONS = Object.values(ToolbarPosition);
  }
});

// packages/ag-charts-community/src/chart/toolbar/toolbarProperties.ts
var ToolbarGroupProperties;
var init_toolbarProperties = __esm({
  "packages/ag-charts-community/src/chart/toolbar/toolbarProperties.ts"() {
    "use strict";
    init_properties();
    init_proxy();
    init_validation();
    init_toolbarTypes();
    ToolbarGroupProperties = class extends BaseProperties {
      constructor(onChange, onButtonsChange) {
        super();
        this.onChange = onChange;
        this.onButtonsChange = onButtonsChange;
        this.align = "start";
        this.position = "top" /* Top */;
      }
    };
    __decorateClass([
      ObserveChanges((target) => {
        target.onChange(target.enabled);
      }),
      Validate(BOOLEAN)
    ], ToolbarGroupProperties.prototype, "enabled", 2);
    __decorateClass([
      ObserveChanges((target) => {
        target.onChange(target.enabled);
      }),
      Validate(UNION(["start", "center", "end"]), { optional: true })
    ], ToolbarGroupProperties.prototype, "align", 2);
    __decorateClass([
      ObserveChanges((target) => {
        target.onChange(target.enabled);
      }),
      Validate(UNION(["top", "right", "bottom", "left", "floating-top", "floating-bottom"]), { optional: true })
    ], ToolbarGroupProperties.prototype, "position", 2);
    __decorateClass([
      ObserveChanges((target) => {
        target.onButtonsChange(target.buttons);
      }),
      Validate(ARRAY, { optional: true })
    ], ToolbarGroupProperties.prototype, "buttons", 2);
  }
});

// packages/ag-charts-community/src/chart/toolbar/toolbarStyles.ts
var block2, elements2, modifiers2, css2;
var init_toolbarStyles = __esm({
  "packages/ag-charts-community/src/chart/toolbar/toolbarStyles.ts"() {
    "use strict";
    init_toolbarTypes();
    block2 = "ag-charts-toolbar";
    elements2 = {
      align: `${block2}__align`,
      button: `${block2}__button`,
      icon: `${block2}__icon`,
      label: `${block2}__label`
    };
    modifiers2 = {
      ["top" /* Top */]: `${block2}--top`,
      ["right" /* Right */]: `${block2}--right`,
      ["bottom" /* Bottom */]: `${block2}--bottom`,
      ["left" /* Left */]: `${block2}--left`,
      ["floating-top" /* FloatingTop */]: `${block2}--floating-top`,
      ["floating-bottom" /* FloatingBottom */]: `${block2}--floating-bottom`,
      hidden: `${block2}--hidden`,
      preventFlash: `${block2}--prevent-flash`,
      floatingHidden: `${block2}--floating-hidden`,
      align: {
        start: `${elements2.align}--start`,
        center: `${elements2.align}--center`,
        end: `${elements2.align}--end`
      },
      button: {
        hidden: `${elements2.button}--hidden`
      }
    };
    css2 = `
.${block2} {
    align-items: center;
    background: var(--ag-charts-toolbar-background-color);
    border-bottom: var(--ag-charts-toolbar-border-critical);
    border-top: var(--ag-charts-toolbar-border-critical);
    border-left: var(--ag-charts-toolbar-border);
    border-right: var(--ag-charts-toolbar-border);
    display: flex;
    flex-wrap: nowrap;
    opacity: 1;
    position: absolute;
    transform: translateY(0);
    transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
}

.${modifiers2.hidden},
.${modifiers2.preventFlash} {
    visibility: hidden;
}

.${modifiers2.floatingHidden} {
    opacity: 0;
    transition: opacity 0.4s ease-in-out;
}

.${modifiers2["top" /* Top */]},
.${modifiers2["bottom" /* Bottom */]} {
    flex-direction: row;
    height: var(--ag-charts-toolbar-size);
    padding: 0 var(--ag-charts-toolbar-padding);
    width: 100%;
}

.${modifiers2["left" /* Left */]},
.${modifiers2["right" /* Right */]} {
    flex-direction: column;
    padding: var(--ag-charts-toolbar-padding) 0;
    width: var(--ag-charts-toolbar-size);
}

.${modifiers2["floating-top" /* FloatingTop */]},
.${modifiers2["floating-bottom" /* FloatingBottom */]} {
    background: none;
    border: none;
    flex-direction: row;
    height: var(--ag-charts-toolbar-size);
    overflow: hidden;
    padding: 0 var(--ag-charts-toolbar-padding);
    pointer-events: none;
    width: 100%;
}

.${elements2.align} {
    display: flex;
    flex-direction: inherit;
    flex-wrap: inherit;
    max-width: 100%;
}

.${modifiers2.align.center},
.${modifiers2.align.end} {
    margin-left: auto;
}

.${modifiers2["left" /* Left */]} .${modifiers2.align.center},
.${modifiers2["left" /* Left */]} .${modifiers2.align.end},
.${modifiers2["right" /* Right */]} .${modifiers2.align.center},
.${modifiers2["right" /* Right */]} .${modifiers2.align.end} {
    margin-left: 0;
    margin-top: auto;
}

.${modifiers2["floating-top" /* FloatingTop */]} .${elements2.align},
.${modifiers2["floating-bottom" /* FloatingBottom */]} .${elements2.align} {
    gap: var(--ag-charts-toolbar-gap);
    transition: transform 0.4s ease-in-out;
}

.${elements2.button} {
    align-items: center;
    border-radius: var(--ag-charts-button-radius);
    color: var(--ag-charts-toolbar-foreground-color);
    display: flex;
    font-size: 14px;
    font-weight: 500;
    justify-content: center;
    margin: 0;
    padding: var(--ag-charts-button-padding);
    pointer-events: all;
    transition: background-color .25s ease-in-out;
}

.${modifiers2["left" /* Left */]} .${elements2.button},
.${modifiers2["right" /* Right */]} .${elements2.button} {
    height: var(--ag-charts-toolbar-size);
    max-width: 100%;
    overflow: hidden;
}

.${modifiers2["floating-top" /* FloatingTop */]} .${elements2.button},
.${modifiers2["floating-bottom" /* FloatingBottom */]} .${elements2.button} {
    background: var(--ag-charts-toolbar-background-color);
    border: var(--ag-charts-toolbar-border-critical);
}

.${modifiers2.button.hidden} {
    display: none;
}

.${elements2.button}:hover {
    background: var(--ag-charts-toolbar-hover-color);
}

.${elements2.button}:disabled {
    background: var(--ag-charts-toolbar-disabled-background-color);
    color: var(--ag-charts-toolbar-disabled-foreground-color);
}

.${elements2.button}:not([disabled]) {
    cursor: pointer;
}

.${elements2.icon} {
    height: 1.2em;
    width: 1.2em;
}

.${elements2.icon} + .${elements2.label} {
    margin-left: var(--ag-charts-size);
}

.${elements2.icon},
.${elements2.label} {
    pointer-events: none;
}

`;
  }
});

// packages/ag-charts-community/src/chart/toolbar/toolbar.ts
var Toolbar;
var init_toolbar = __esm({
  "packages/ag-charts-community/src/chart/toolbar/toolbar.ts"() {
    "use strict";
    init_module();
    init_dom();
    init_proxy();
    init_validation();
    init_interactionManager();
    init_toolbarProperties();
    init_toolbarStyles();
    init_toolbarTypes();
    Toolbar = class extends BaseModuleInstance {
      constructor(ctx) {
        super();
        this.ctx = ctx;
        this.enabled = true;
        this.annotations = new ToolbarGroupProperties(
          this.onGroupChanged.bind(this, "annotations"),
          this.onGroupButtonsChanged.bind(this, "annotations")
        );
        this.ranges = new ToolbarGroupProperties(
          this.onGroupChanged.bind(this, "ranges"),
          this.onGroupButtonsChanged.bind(this, "ranges")
        );
        this.zoom = new ToolbarGroupProperties(
          this.onGroupChanged.bind(this, "zoom"),
          this.onGroupButtonsChanged.bind(this, "zoom")
        );
        this.margin = 10;
        this.floatingDetectionRange = 28;
        this.positions = {
          ["top" /* Top */]: /* @__PURE__ */ new Set(),
          ["right" /* Right */]: /* @__PURE__ */ new Set(),
          ["bottom" /* Bottom */]: /* @__PURE__ */ new Set(),
          ["left" /* Left */]: /* @__PURE__ */ new Set(),
          ["floating-top" /* FloatingTop */]: /* @__PURE__ */ new Set(),
          ["floating-bottom" /* FloatingBottom */]: /* @__PURE__ */ new Set()
        };
        this.positionAlignments = {
          ["top" /* Top */]: {},
          ["right" /* Right */]: {},
          ["bottom" /* Bottom */]: {},
          ["left" /* Left */]: {},
          ["floating-top" /* FloatingTop */]: {},
          ["floating-bottom" /* FloatingBottom */]: {}
        };
        this.groupCallers = {
          annotations: 0,
          ranges: 0,
          zoom: 0
        };
        this.groupButtons = {
          annotations: [],
          ranges: [],
          zoom: []
        };
        this.pendingButtonToggledEvents = [];
        this.groupProxied = /* @__PURE__ */ new Set();
        this.container = ctx.toolbarManager.element;
        this.elements = {
          ["top" /* Top */]: this.container.appendChild(createElement("div")),
          ["right" /* Right */]: this.container.appendChild(createElement("div")),
          ["bottom" /* Bottom */]: this.container.appendChild(createElement("div")),
          ["left" /* Left */]: this.container.appendChild(createElement("div")),
          ["floating-top" /* FloatingTop */]: this.container.appendChild(createElement("div")),
          ["floating-bottom" /* FloatingBottom */]: this.container.appendChild(createElement("div"))
        };
        injectStyle(css2, block2);
        this.renderToolbar("top" /* Top */);
        this.renderToolbar("right" /* Right */);
        this.renderToolbar("bottom" /* Bottom */);
        this.renderToolbar("left" /* Left */);
        this.renderToolbar("floating-top" /* FloatingTop */);
        this.renderToolbar("floating-bottom" /* FloatingBottom */);
        this.toggleVisibilities();
        this.destroyFns.push(
          ctx.interactionManager.addListener("hover", this.onHover.bind(this), 31 /* All */),
          ctx.interactionManager.addListener("leave", this.onLeave.bind(this), 31 /* All */),
          ctx.toolbarManager.addListener("button-toggled", this.onButtonToggled.bind(this)),
          ctx.toolbarManager.addListener("group-toggled", this.onGroupToggled.bind(this)),
          ctx.toolbarManager.addListener("proxy-group-options", this.onProxyGroupOptions.bind(this)),
          ctx.layoutService.addListener("layout-complete", this.onLayoutComplete.bind(this)),
          () => this.destroyElements()
        );
      }
      destroyElements() {
        for (const element2 of Object.values(this.elements)) {
          element2.remove();
        }
      }
      onHover(event) {
        const {
          enabled,
          elements: elements3,
          floatingDetectionRange,
          ctx: { scene }
        } = this;
        const {
          offsetY,
          sourceEvent: { target }
        } = event;
        const { FloatingBottom, FloatingTop } = ToolbarPosition;
        if (!enabled)
          return;
        const bottom = elements3[FloatingBottom];
        const top = elements3[FloatingTop];
        const bottomDetectionY = bottom.offsetTop - floatingDetectionRange;
        const bottomVisible = offsetY > bottomDetectionY && offsetY < scene.canvas.element.offsetHeight || target === bottom;
        const topDetectionY = top.offsetTop + top.offsetHeight + floatingDetectionRange;
        const topVisible = offsetY > 0 && offsetY < topDetectionY || target === top;
        bottom.classList.toggle(modifiers2.floatingHidden, !bottomVisible);
        top.classList.toggle(modifiers2.floatingHidden, !topVisible);
        this.translateFloatingElements(FloatingBottom, bottomVisible);
        this.translateFloatingElements(FloatingTop, topVisible);
      }
      onLeave(event) {
        const {
          enabled,
          elements: elements3,
          ctx: { scene }
        } = this;
        const { relatedTarget, target } = event.sourceEvent;
        const { FloatingBottom, FloatingTop } = ToolbarPosition;
        if (!enabled || target !== scene.canvas.element)
          return;
        const isTargetButton = TOOLBAR_GROUPS.some(
          (group2) => this.groupButtons[group2].some((button) => button === relatedTarget)
        );
        if (isTargetButton)
          return;
        elements3[FloatingBottom].classList.add(modifiers2.floatingHidden);
        elements3[FloatingTop].classList.add(modifiers2.floatingHidden);
        this.translateFloatingElements(FloatingBottom, false);
        this.translateFloatingElements(FloatingTop, false);
      }
      onGroupChanged(group2) {
        if (this[group2] == null || this.groupProxied.has(group2))
          return;
        this.createGroup(group2);
        this.toggleVisibilities();
      }
      onGroupButtonsChanged(group2, buttons) {
        if (!this.enabled || this.groupProxied.has(group2))
          return;
        this.createGroupButtons(group2, buttons);
        this.toggleVisibilities();
      }
      onLayoutComplete() {
        for (const position of TOOLBAR_POSITIONS) {
          this.elements[position].classList.remove(modifiers2.preventFlash);
        }
      }
      onButtonToggled(event) {
        const { group: group2, value, enabled } = event;
        if (this.groupButtons[group2].length === 0) {
          this.pendingButtonToggledEvents.push(event);
          return;
        }
        for (const button of this.groupButtons[group2]) {
          if (button.dataset.toolbarValue !== `${value}`)
            continue;
          button.disabled = !enabled;
        }
      }
      onGroupToggled(event) {
        const { group: group2, visible } = event;
        this.toggleGroup(group2, visible);
        this.toggleVisibilities();
      }
      onProxyGroupOptions(event) {
        const { group: group2, options } = event;
        this.groupProxied.add(group2);
        this.createGroup(group2, options.enabled, options.position);
        this.createGroupButtons(group2, options.buttons);
        this.toggleGroup(group2, options.enabled);
        this[group2].set(options);
      }
      createGroup(group2, enabled, position) {
        enabled != null ? enabled : enabled = this[group2].enabled;
        position != null ? position : position = this[group2].position;
        for (const pos of TOOLBAR_POSITIONS) {
          if (enabled && position === pos) {
            this.positions[pos].add(group2);
          } else {
            this.positions[pos].delete(group2);
          }
        }
      }
      createGroupButtons(group2, buttons) {
        var _a2, _b;
        for (const button of this.groupButtons[group2]) {
          button.remove();
        }
        this.groupButtons[group2] = [];
        const align = (_a2 = this[group2].align) != null ? _a2 : "start";
        const position = (_b = this[group2].position) != null ? _b : "top";
        const parent = this.positionAlignments[position][align];
        for (const options of buttons != null ? buttons : []) {
          const button = this.createButtonElement(group2, options);
          parent == null ? void 0 : parent.appendChild(button);
          this.groupButtons[group2].push(button);
        }
      }
      toggleGroup(group2, enabled) {
        if (enabled) {
          this.groupCallers[group2] += 1;
        } else {
          this.groupCallers[group2] = Math.max(0, this.groupCallers[group2] - 1);
        }
      }
      processPendingEvents() {
        var _a2;
        const pendingButtonToggledEvents = ((_a2 = this.pendingButtonToggledEvents) != null ? _a2 : []).slice();
        for (const event of pendingButtonToggledEvents) {
          this.onButtonToggled(event);
        }
        this.pendingButtonToggledEvents = [];
      }
      performLayout(_0) {
        return __async(this, arguments, function* ({ shrinkRect }) {
          const { elements: elements3, margin } = this;
          if (!elements3.top.classList.contains(modifiers2.hidden)) {
            shrinkRect.shrink(elements3.top.offsetHeight + margin * 2, "top");
          }
          if (!elements3.right.classList.contains(modifiers2.hidden)) {
            shrinkRect.shrink(elements3.right.offsetWidth + margin, "right");
          }
          if (!elements3.bottom.classList.contains(modifiers2.hidden)) {
            shrinkRect.shrink(elements3.bottom.offsetHeight + margin * 2, "bottom");
          }
          if (!elements3.left.classList.contains(modifiers2.hidden)) {
            shrinkRect.shrink(elements3.left.offsetWidth + margin, "left");
          }
          return { shrinkRect };
        });
      }
      performCartesianLayout(opts) {
        return __async(this, null, function* () {
          const { elements: elements3, margin } = this;
          const { seriesRect } = opts;
          const { FloatingBottom, FloatingTop } = ToolbarPosition;
          elements3.top.style.top = `${seriesRect.y - elements3.top.offsetHeight - margin * 2}px`;
          elements3.top.style.left = `${margin}px`;
          elements3.top.style.width = `calc(100% - ${margin * 2}px)`;
          elements3.right.style.top = `${seriesRect.y + margin}px`;
          elements3.right.style.right = `${margin}px`;
          elements3.right.style.height = `calc(100% - ${seriesRect.y + margin * 2}px)`;
          elements3.bottom.style.bottom = `${margin}px`;
          elements3.bottom.style.left = `${margin}px`;
          elements3.bottom.style.width = `calc(100% - ${margin * 2}px)`;
          elements3.left.style.top = `${seriesRect.y}px`;
          elements3.left.style.left = `${margin}px`;
          elements3.left.style.height = `calc(100% - ${seriesRect.y + margin * 2}px)`;
          elements3[FloatingTop].style.top = `${seriesRect.y}px`;
          elements3[FloatingTop].style.paddingTop = `${margin}px`;
          elements3[FloatingBottom].style.top = `${seriesRect.y + seriesRect.height - elements3[FloatingBottom].offsetHeight}px`;
          elements3[FloatingBottom].style.paddingBottom = `${margin}px`;
        });
      }
      toggleVisibilities() {
        var _a2;
        if (this.elements == null)
          return;
        const isGroupVisible = (group2) => this[group2].enabled && this.groupCallers[group2] > 0;
        const isButtonVisible = (element2) => (button) => typeof button.value !== "string" && typeof button.value !== "number" || `${button.value}` === element2.dataset.toolbarValue;
        for (const position of TOOLBAR_POSITIONS) {
          const visible = this.enabled && Array.from(this.positions[position].values()).some(isGroupVisible);
          this.elements[position].classList.toggle(modifiers2.hidden, !visible);
        }
        for (const group2 of TOOLBAR_GROUPS) {
          if (this[group2] == null)
            continue;
          const visible = isGroupVisible(group2);
          for (const button of this.groupButtons[group2]) {
            const buttonVisible = visible && ((_a2 = this[group2].buttons) == null ? void 0 : _a2.some(isButtonVisible(button)));
            button.classList.toggle(modifiers2.button.hidden, !buttonVisible);
          }
        }
      }
      translateFloatingElements(position, visible) {
        const { elements: elements3, margin, positionAlignments } = this;
        const element2 = elements3[position];
        const alignments = Object.values(positionAlignments[position]);
        for (const align of alignments) {
          align.style.transform = visible && align.style.transform !== "" ? "translateY(0)" : `translateY(${element2.offsetHeight + margin}px)`;
        }
      }
      renderToolbar(position = "top" /* Top */) {
        const element2 = this.elements[position];
        element2.classList.add(block2, modifiers2[position], modifiers2.preventFlash);
        if (position === "floating-top" /* FloatingTop */ || position === "floating-bottom" /* FloatingBottom */) {
          element2.classList.add(modifiers2.floatingHidden);
        }
        for (const align of TOOLBAR_ALIGNMENTS) {
          const alignmentElement = createElement("div");
          alignmentElement.classList.add(elements2.align, modifiers2.align[align]);
          element2.appendChild(alignmentElement);
          this.positionAlignments[position][align] = alignmentElement;
        }
      }
      createButtonElement(group2, options) {
        const button = createElement("button");
        button.classList.add(elements2.button);
        button.dataset.toolbarGroup = group2;
        button.tabIndex = -1;
        if (typeof options.value === "string" || typeof options.value === "number") {
          button.dataset.toolbarValue = `${options.value}`;
        }
        if (options.tooltip) {
          button.title = options.tooltip;
        }
        let inner = "";
        if (options.icon != null) {
          inner = `<span class="ag-charts-icon-${options.icon} ${elements2.icon}"></span>`;
        }
        if (options.label != null) {
          inner = `${inner}<span class="${elements2.label}">${options.label}</span>`;
        }
        button.innerHTML = inner;
        button.onclick = this.onButtonPress.bind(this, group2, options.value);
        this.destroyFns.push(() => button.remove());
        return button;
      }
      onButtonPress(group2, value) {
        this.ctx.toolbarManager.pressButton(group2, value);
      }
    };
    __decorateClass([
      ObserveChanges((target) => {
        target.processPendingEvents();
        target.toggleVisibilities();
      }),
      Validate(BOOLEAN)
    ], Toolbar.prototype, "enabled", 2);
  }
});

// packages/ag-charts-community/src/chart/toolbar/toolbarModule.ts
var DAY, MONTH, YEAR, annotations, ranges, zoom, ToolbarModule;
var init_toolbarModule = __esm({
  "packages/ag-charts-community/src/chart/toolbar/toolbarModule.ts"() {
    "use strict";
    init_toolbar();
    DAY = 1e3 * 60 * 60 * 24;
    MONTH = DAY * 30;
    YEAR = DAY * 365;
    annotations = {
      enabled: false,
      position: "left",
      align: "start",
      buttons: [
        { label: "Li", value: "line" },
        { label: "PCh", value: "parallel-channel" }
      ]
    };
    ranges = {
      enabled: false,
      position: "top",
      align: "start",
      buttons: [
        { label: "1m", value: MONTH },
        { label: "3m", value: 3 * MONTH },
        { label: "6m", value: 6 * MONTH },
        { label: "YTD", value: (_start, end) => [(/* @__PURE__ */ new Date(`${new Date(end).getFullYear()}-01-01`)).getTime(), end] },
        { label: "1y", value: YEAR },
        { label: "All", value: (start, end) => [start, end] }
      ]
    };
    zoom = {
      enabled: false,
      position: "top",
      align: "end",
      buttons: [
        {
          icon: "zoom-out",
          tooltip: "Zoom out",
          value: "zoom-out"
        },
        {
          icon: "zoom-in",
          tooltip: "Zoom in",
          value: "zoom-in"
        },
        {
          icon: "pan-left",
          tooltip: "Pan left",
          value: "pan-left"
        },
        {
          icon: "pan-right",
          tooltip: "Pan right",
          value: "pan-right"
        },
        {
          icon: "pan-start",
          tooltip: "Pan to the start",
          value: "pan-start"
        },
        {
          icon: "pan-end",
          tooltip: "Pan to the end",
          value: "pan-end"
        },
        {
          icon: "reset",
          tooltip: "Reset the zoom",
          value: "reset"
        }
      ]
    };
    ToolbarModule = {
      type: "root",
      optionsKey: "toolbar",
      packageType: "community",
      chartTypes: ["cartesian"],
      instanceConstructor: Toolbar,
      themeTemplate: {
        toolbar: {
          enabled: true,
          annotations,
          ranges,
          zoom
        }
      }
    };
  }
});

// packages/ag-charts-community/src/chart/factory/registerInbuiltModules.ts
function registerInbuiltModules() {
  moduleRegistry.register(
    BackgroundModule,
    CommunityLegendModule,
    NavigatorModule,
    ToolbarModule,
    AreaSeriesModule,
    BarSeriesModule,
    BubbleSeriesModule,
    LineSeriesModule,
    ScatterSeriesModule,
    DonutSeriesModule,
    PieSeriesModule,
    HistogramSeriesModule
  );
  for (const AxisConstructor of [NumberAxis, CategoryAxis, TimeAxis, GroupedCategoryAxis, LogAxis]) {
    axisRegistry.register(AxisConstructor.type, {
      instanceConstructor: AxisConstructor,
      hidden: AxisConstructor === GroupedCategoryAxis
    });
  }
}
var init_registerInbuiltModules = __esm({
  "packages/ag-charts-community/src/chart/factory/registerInbuiltModules.ts"() {
    "use strict";
    init_module();
    init_categoryAxis();
    init_groupedCategoryAxis();
    init_logAxis();
    init_numberAxis();
    init_timeAxis();
    init_backgroundModule();
    init_legendModule();
    init_navigatorModule();
    init_areaSeriesModule();
    init_barSeriesModule();
    init_bubbleSeriesModule();
    init_histogramSeriesModule();
    init_lineSeriesModule();
    init_scatterSeriesModule();
    init_donutSeriesModule();
    init_pieSeriesModule();
    init_toolbarModule();
    init_axisRegistry();
  }
});

// packages/ag-charts-community/src/chart/factory/setupModules.ts
function setupModules() {
  for (const m of moduleRegistry.modules) {
    if (m.packageType === "enterprise" && !verifyIfModuleExpected(m)) {
      Logger.errorOnce("Unexpected enterprise module registered: " + m.identifier);
    }
    if (m.type === "root" && m.themeTemplate) {
      for (const chartType2 of m.chartTypes) {
        chartDefaults.set(chartType2, m.themeTemplate);
      }
    }
    if (m.type === "series") {
      if (m.chartTypes.length > 1) {
        throw new Error(`AG Charts - Module definition error: ${m.identifier}`);
      }
      seriesRegistry.register(m.identifier, m);
    }
    if (m.type === "series-option" && m.themeTemplate) {
      for (const seriesType of m.seriesTypes) {
        seriesRegistry.setThemeTemplate(seriesType, m.themeTemplate);
      }
    }
    if (m.type === "axis-option" && m.themeTemplate) {
      for (const axisType of m.axisTypes) {
        const axisTypeTheme = m.themeTemplate[axisType];
        const theme = __spreadValues(__spreadValues({}, m.themeTemplate), axisTypeTheme);
        for (const innerAxisType of m.axisTypes) {
          delete theme[innerAxisType];
        }
        axisRegistry.setThemeTemplate(axisType, theme);
      }
    }
    if (m.type === "axis") {
      axisRegistry.register(m.identifier, m);
    }
    if (m.type === "legend") {
      legendRegistry.register(m.identifier, m);
    }
  }
  if (moduleRegistry.hasEnterpriseModules()) {
    const expectedButUnused = getUnusedExpectedModules();
    if (expectedButUnused.length > 0) {
      Logger.errorOnce("Enterprise modules expected but not registered: ", expectedButUnused);
    }
  }
}
var init_setupModules = __esm({
  "packages/ag-charts-community/src/chart/factory/setupModules.ts"() {
    "use strict";
    init_module();
    init_logger();
    init_axisRegistry();
    init_chartTypes();
    init_expectedEnterpriseModules();
    init_legendRegistry();
    init_seriesRegistry();
  }
});

// packages/ag-charts-community/src/chart/hierarchyChart.ts
var _HierarchyChart, HierarchyChart;
var init_hierarchyChart = __esm({
  "packages/ag-charts-community/src/chart/hierarchyChart.ts"() {
    "use strict";
    init_bbox();
    init_chart();
    _HierarchyChart = class _HierarchyChart extends Chart {
      constructor(options, resources) {
        super(options, resources);
      }
      performLayout() {
        return __async(this, null, function* () {
          const shrinkRect = yield __superGet(_HierarchyChart.prototype, this, "performLayout").call(this);
          const {
            seriesArea: { padding },
            seriesRoot,
            annotationRoot,
            highlightRoot
          } = this;
          const fullSeriesRect = shrinkRect.clone();
          shrinkRect.shrink(padding.left, "left");
          shrinkRect.shrink(padding.top, "top");
          shrinkRect.shrink(padding.right, "right");
          shrinkRect.shrink(padding.bottom, "bottom");
          this.seriesRect = shrinkRect;
          this.animationRect = shrinkRect;
          this.hoverRect = shrinkRect;
          for (const group2 of [seriesRoot, annotationRoot, highlightRoot]) {
            group2.translationX = Math.floor(shrinkRect.x);
            group2.translationY = Math.floor(shrinkRect.y);
          }
          yield Promise.all(
            this.series.map((series) => __async(this, null, function* () {
              yield series.update({ seriesRect: shrinkRect });
            }))
          );
          seriesRoot.visible = this.series[0].visible;
          seriesRoot.setClipRectInGroupCoordinateSpace(
            new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height)
          );
          this.ctx.layoutService.dispatchLayoutComplete({
            type: "layout-complete",
            chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },
            clipSeries: false,
            series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },
            axes: []
          });
          return shrinkRect;
        });
      }
    };
    _HierarchyChart.className = "HierarchyChart";
    _HierarchyChart.type = "hierarchy";
    HierarchyChart = _HierarchyChart;
  }
});

// packages/ag-charts-community/src/chart/axis/polarAxis.ts
var PolarAxis;
var init_polarAxis = __esm({
  "packages/ag-charts-community/src/chart/axis/polarAxis.ts"() {
    "use strict";
    init_validation();
    init_axis();
    PolarAxis = class extends Axis {
      constructor() {
        super(...arguments);
        this.shape = "polygon";
        this.innerRadiusRatio = 0;
        this.defaultTickMinSpacing = 20;
      }
      computeLabelsBBox(_options, _seriesRect) {
        return null;
      }
    };
    __decorateClass([
      Validate(UNION(["polygon", "circle"], "a polar axis shape"))
    ], PolarAxis.prototype, "shape", 2);
    __decorateClass([
      Validate(RATIO)
    ], PolarAxis.prototype, "innerRadiusRatio", 2);
  }
});

// packages/ag-charts-community/src/chart/polarChart.ts
var _PolarChart, PolarChart;
var init_polarChart = __esm({
  "packages/ag-charts-community/src/chart/polarChart.ts"() {
    "use strict";
    init_bbox();
    init_padding();
    init_polarAxis();
    init_chart();
    init_chartAxisDirection();
    init_layers();
    init_donutSeries();
    init_pieSeries();
    init_polarSeries();
    _PolarChart = class _PolarChart extends Chart {
      constructor(options, resources) {
        super(options, resources);
        this.padding = new Padding(40);
        this.axisGroup.zIndex = 6 /* AXIS_FOREGROUND_ZINDEX */;
      }
      performLayout() {
        return __async(this, null, function* () {
          const shrinkRect = yield __superGet(_PolarChart.prototype, this, "performLayout").call(this);
          const fullSeriesRect = shrinkRect.clone();
          this.computeSeriesRect(shrinkRect);
          yield this.computeCircle(shrinkRect);
          this.axes.forEach((axis) => axis.update());
          this.hoverRect = shrinkRect;
          this.ctx.layoutService.dispatchLayoutComplete({
            type: "layout-complete",
            chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },
            clipSeries: false,
            series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },
            axes: []
          });
          return shrinkRect;
        });
      }
      updateAxes(cx, cy, radius) {
        var _a2, _b;
        const angleAxis = this.axes.find((axis) => axis.direction === "x" /* X */);
        const radiusAxis = this.axes.find((axis) => axis.direction === "y" /* Y */);
        if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis)) {
          return;
        }
        const angleScale = angleAxis.scale;
        const angles = (_a2 = angleScale.ticks) == null ? void 0 : _a2.call(angleScale).map((value) => angleScale.convert(value));
        const innerRadiusRatio = radiusAxis.innerRadiusRatio;
        angleAxis.innerRadiusRatio = innerRadiusRatio;
        (_b = angleAxis.computeRange) == null ? void 0 : _b.call(angleAxis);
        angleAxis.gridLength = radius;
        radiusAxis.gridAngles = angles;
        radiusAxis.gridRange = angleAxis.range;
        radiusAxis.range = [radius, radius * innerRadiusRatio];
        [angleAxis, radiusAxis].forEach((axis) => {
          axis.translation.x = cx;
          axis.translation.y = cy;
          axis.calculateLayout();
        });
      }
      computeSeriesRect(shrinkRect) {
        const {
          seriesArea: { padding }
        } = this;
        shrinkRect.shrink(padding.left, "left");
        shrinkRect.shrink(padding.top, "top");
        shrinkRect.shrink(padding.right, "right");
        shrinkRect.shrink(padding.bottom, "bottom");
        this.seriesRect = shrinkRect;
        this.animationRect = shrinkRect;
      }
      computeCircle(seriesBox) {
        return __async(this, null, function* () {
          const polarSeries = this.series.filter((series) => {
            return series instanceof PolarSeries;
          });
          const polarAxes = this.axes.filter((axis) => {
            return axis instanceof PolarAxis;
          });
          const setSeriesCircle = (cx, cy, r) => {
            this.updateAxes(cx, cy, r);
            polarSeries.forEach((series) => {
              series.centerX = cx;
              series.centerY = cy;
              series.radius = r;
            });
            const pieSeries = polarSeries.filter((s) => {
              return s instanceof PieSeries || s instanceof DonutSeries;
            });
            if (pieSeries.length > 1) {
              const innerRadii = pieSeries.map((series) => {
                const innerRadius = series.getInnerRadius();
                return { series, innerRadius };
              }).sort((a, b) => a.innerRadius - b.innerRadius);
              innerRadii.at(-1).series.surroundingRadius = void 0;
              for (let i = 0; i < innerRadii.length - 1; i++) {
                innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;
              }
            }
          };
          const centerX = seriesBox.x + seriesBox.width / 2;
          const centerY = seriesBox.y + seriesBox.height / 2;
          const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);
          let radius = initialRadius;
          setSeriesCircle(centerX, centerY, radius);
          const shake = (..._0) => __async(this, [..._0], function* ({ hideWhenNecessary = false } = {}) {
            const labelBoxes = [];
            for (const series of [...polarAxes, ...polarSeries]) {
              const box = yield series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);
              if (box) {
                labelBoxes.push(box);
              }
            }
            if (labelBoxes.length === 0) {
              setSeriesCircle(centerX, centerY, initialRadius);
              return;
            }
            const labelBox = BBox.merge(labelBoxes);
            const refined = this.refineCircle(labelBox, radius, seriesBox);
            setSeriesCircle(refined.centerX, refined.centerY, refined.radius);
            if (refined.radius === radius) {
              return;
            }
            radius = refined.radius;
          });
          yield shake();
          yield shake();
          yield shake();
          yield shake({ hideWhenNecessary: true });
          yield shake({ hideWhenNecessary: true });
          return { radius, centerX, centerY };
        });
      }
      refineCircle(labelsBox, radius, seriesBox) {
        const minCircleRatio = 0.5;
        const circleLeft = -radius;
        const circleTop = -radius;
        const circleRight = radius;
        const circleBottom = radius;
        let padLeft = Math.max(0, circleLeft - labelsBox.x);
        let padTop = Math.max(0, circleTop - labelsBox.y);
        let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);
        let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);
        padLeft = padRight = Math.max(padLeft, padRight);
        padTop = padBottom = Math.max(padTop, padBottom);
        const availCircleWidth = seriesBox.width - padLeft - padRight;
        const availCircleHeight = seriesBox.height - padTop - padBottom;
        let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;
        const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;
        const minVerticalRadius = minCircleRatio * seriesBox.height / 2;
        const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);
        if (newRadius < minRadius) {
          newRadius = minRadius;
          const horizontalPadding = padLeft + padRight;
          const verticalPadding = padTop + padBottom;
          if (2 * newRadius + verticalPadding > seriesBox.height) {
            const padHeight = seriesBox.height - 2 * newRadius;
            if (Math.min(padTop, padBottom) * 2 > padHeight) {
              padTop = padHeight / 2;
              padBottom = padHeight / 2;
            } else if (padTop > padBottom) {
              padTop = padHeight - padBottom;
            } else {
              padBottom = padHeight - padTop;
            }
          }
          if (2 * newRadius + horizontalPadding > seriesBox.width) {
            const padWidth = seriesBox.width - 2 * newRadius;
            if (Math.min(padLeft, padRight) * 2 > padWidth) {
              padLeft = padWidth / 2;
              padRight = padWidth / 2;
            } else if (padLeft > padRight) {
              padLeft = padWidth - padRight;
            } else {
              padRight = padWidth - padLeft;
            }
          }
        }
        const newWidth = padLeft + 2 * newRadius + padRight;
        const newHeight = padTop + 2 * newRadius + padBottom;
        return {
          centerX: seriesBox.x + (seriesBox.width - newWidth) / 2 + padLeft + newRadius,
          centerY: seriesBox.y + (seriesBox.height - newHeight) / 2 + padTop + newRadius,
          radius: newRadius
        };
      }
    };
    _PolarChart.className = "PolarChart";
    _PolarChart.type = "polar";
    PolarChart = _PolarChart;
  }
});

// packages/ag-charts-community/src/chart/series/topology/mercatorScale.ts
var radsInDeg, lonX, latY, xLon, yLat, MercatorScale;
var init_mercatorScale = __esm({
  "packages/ag-charts-community/src/chart/series/topology/mercatorScale.ts"() {
    "use strict";
    init_bbox();
    radsInDeg = Math.PI / 180;
    lonX = (lon) => lon * radsInDeg;
    latY = (lat) => -Math.log(Math.tan(Math.PI * 0.25 + lat * radsInDeg * 0.5));
    xLon = (x) => x / radsInDeg;
    yLat = (y) => (Math.atan(Math.exp(-y)) - Math.PI * 0.25) / (radsInDeg * 0.5);
    MercatorScale = class _MercatorScale {
      constructor(domain, range4) {
        this.domain = domain;
        this.range = range4;
        this.type = "mercator";
        this.bounds = _MercatorScale.bounds(domain);
      }
      static bounds(domain) {
        const [[lon0, lat0], [lon1, lat1]] = domain;
        const x0 = lonX(lon0);
        const y0 = latY(lat0);
        const x1 = lonX(lon1);
        const y1 = latY(lat1);
        return new BBox(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x1 - x0), Math.abs(y1 - y0));
      }
      static fixedScale() {
        return new _MercatorScale(
          [
            [xLon(0), yLat(0)],
            [xLon(1), yLat(1)]
          ],
          [
            [0, 0],
            [1, 1]
          ]
        );
      }
      convert([lon, lat]) {
        const [[x0, y0], [x1, y1]] = this.range;
        const xScale = (x1 - x0) / this.bounds.width;
        const yScale = (y1 - y0) / this.bounds.height;
        return [(lonX(lon) - this.bounds.x) * xScale + x0, (latY(lat) - this.bounds.y) * yScale + y0];
      }
      invert([x, y]) {
        const [[x0, y0], [x1, y1]] = this.range;
        const xScale = (x1 - x0) / this.bounds.width;
        const yScale = (y1 - y0) / this.bounds.height;
        return [xLon((x - x0) / xScale + this.bounds.x), yLat((y - y0) / yScale + this.bounds.y)];
      }
    };
  }
});

// packages/ag-charts-community/src/chart/topologyChart.ts
function isTopologySeries(series) {
  return series.type === "map-shape" || series.type === "map-line" || series.type === "map-marker" || series.type === "map-shape-background" || series.type === "map-line-background";
}
var _TopologyChart, TopologyChart;
var init_topologyChart = __esm({
  "packages/ag-charts-community/src/chart/topologyChart.ts"() {
    "use strict";
    init_bbox();
    init_numberAxis();
    init_chart();
    init_mercatorScale();
    _TopologyChart = class _TopologyChart extends Chart {
      constructor(options, resources) {
        super(options, resources);
        this.xAxis = new NumberAxis(this.getModuleContext());
        this.xAxis.position = "bottom";
        this.yAxis = new NumberAxis(this.getModuleContext());
        this.yAxis.position = "left";
        this.ctx.zoomManager.updateAxes([this.xAxis, this.yAxis]);
      }
      updateData() {
        return __async(this, null, function* () {
          yield __superGet(_TopologyChart.prototype, this, "updateData").call(this);
          const { topology } = this.getOptions();
          this.series.forEach((series) => {
            if (isTopologySeries(series)) {
              series.setChartTopology(topology);
            }
          });
        });
      }
      performLayout() {
        return __async(this, null, function* () {
          const shrinkRect = yield __superGet(_TopologyChart.prototype, this, "performLayout").call(this);
          const {
            seriesArea: { padding },
            seriesRoot,
            annotationRoot,
            highlightRoot
          } = this;
          const fullSeriesRect = shrinkRect.clone();
          shrinkRect.shrink(padding.left, "left");
          shrinkRect.shrink(padding.top, "top");
          shrinkRect.shrink(padding.right, "right");
          shrinkRect.shrink(padding.bottom, "bottom");
          this.seriesRect = shrinkRect;
          this.animationRect = shrinkRect;
          this.hoverRect = shrinkRect;
          const mapSeries = this.series.filter(isTopologySeries);
          const combinedBbox = mapSeries.reduce((combined, series) => {
            if (!series.visible)
              return combined;
            const bbox = series.topologyBounds;
            if (bbox == null)
              return combined;
            if (combined == null)
              return bbox;
            combined.merge(bbox);
            return combined;
          }, void 0);
          let scale2;
          if (combinedBbox != null) {
            const { lon0, lat0, lon1, lat1 } = combinedBbox;
            const domain = [
              [lon0, lat0],
              [lon1, lat1]
            ];
            const bounds = MercatorScale.bounds(domain);
            const { width, height } = shrinkRect;
            const viewBoxScale = Math.min(width / bounds.width, height / bounds.height);
            const viewBoxWidth = bounds.width * viewBoxScale;
            const viewBoxHeight = bounds.height * viewBoxScale;
            const viewBoxOriginX = (width - viewBoxWidth) / 2;
            const viewBoxOriginY = (height - viewBoxHeight) / 2;
            const x0 = viewBoxOriginX;
            const y0 = viewBoxOriginY;
            const x1 = viewBoxOriginX + viewBoxWidth;
            const y1 = viewBoxOriginY + viewBoxHeight;
            const xZoom = this.ctx.zoomManager.getAxisZoom(this.xAxis.id);
            const yZoom = this.ctx.zoomManager.getAxisZoom(this.yAxis.id);
            const xSpan = (x1 - x0) / (xZoom.max - xZoom.min);
            const xStart = x0 - xSpan * xZoom.min;
            const ySpan = (y1 - y0) / (1 - yZoom.min - (1 - yZoom.max));
            const yStart = y0 - ySpan * (1 - yZoom.max);
            scale2 = new MercatorScale(domain, [
              [xStart, yStart],
              [xStart + xSpan, yStart + ySpan]
            ]);
          }
          mapSeries.forEach((series) => {
            series.scale = scale2;
          });
          const seriesVisible = this.series.some((s) => s.visible);
          seriesRoot.visible = seriesVisible;
          for (const group2 of [seriesRoot, annotationRoot, highlightRoot]) {
            group2.translationX = Math.floor(shrinkRect.x);
            group2.translationY = Math.floor(shrinkRect.y);
            group2.setClipRectInGroupCoordinateSpace(
              new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height)
            );
          }
          this.ctx.layoutService.dispatchLayoutComplete({
            type: "layout-complete",
            chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },
            clipSeries: false,
            series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: seriesVisible },
            axes: []
          });
          return shrinkRect;
        });
      }
    };
    _TopologyChart.className = "TopologyChart";
    _TopologyChart.type = "topology";
    TopologyChart = _TopologyChart;
  }
});

// packages/ag-charts-community/src/chart/agChartV2.ts
function chartType(options) {
  if (isAgCartesianChartOptions(options)) {
    return "cartesian";
  } else if (isAgPolarChartOptions(options)) {
    return "polar";
  } else if (isAgHierarchyChartOptions(options)) {
    return "hierarchy";
  } else if (isAgTopologyChartOptions(options)) {
    return "topology";
  }
  throw new Error(`AG Chart - unknown type of chart for options with type: ${options.type}`);
}
var debug2, _AgCharts, AgCharts, AgChart, _AgChartsInternal, AgChartsInternal;
var init_agChartV2 = __esm({
  "packages/ag-charts-community/src/chart/agChartV2.ts"() {
    "use strict";
    init_enterpriseModule();
    init_module();
    init_optionsModule();
    init_debug();
    init_deprecation();
    init_json();
    init_logger();
    init_object();
    init_cartesianChart();
    init_chart();
    init_chartProxy();
    init_chartUpdateType();
    init_registerInbuiltModules();
    init_setupModules();
    init_hierarchyChart();
    init_types2();
    init_polarChart();
    init_topologyChart();
    debug2 = Debug.create(true, "opts");
    _AgCharts = class _AgCharts {
      static licenseCheck(options) {
        var _a2, _b, _c, _d;
        if (this.licenseChecked)
          return;
        this.licenseManager = (_b = (_a2 = enterpriseModule).licenseManager) == null ? void 0 : _b.call(_a2, options);
        (_c = this.licenseManager) == null ? void 0 : _c.setLicenseKey(this.licenseKey, this.gridContext);
        (_d = this.licenseManager) == null ? void 0 : _d.validateLicense();
        this.licenseChecked = true;
      }
      static setLicenseKey(licenseKey) {
        this.licenseKey = licenseKey;
      }
      static setGridContext(gridContext) {
        this.gridContext = gridContext;
      }
      static getLicenseDetails(licenseKey) {
        var _a2, _b;
        return (_b = (_a2 = enterpriseModule).licenseManager) == null ? void 0 : _b.call(_a2, {}).getLicenseDetails(licenseKey);
      }
      /**
       * Returns the `AgChartInstance` for a DOM node, if there is one.
       */
      static getInstance(element2) {
        return AgChartsInternal.getInstance(element2);
      }
      /**
       * Create a new `AgChartInstance` based upon the given configuration options.
       */
      static create(options) {
        var _a2, _b, _c;
        this.licenseCheck(options);
        const chart = AgChartsInternal.createOrUpdate(options);
        if ((_a2 = this.licenseManager) == null ? void 0 : _a2.isDisplayWatermark()) {
          (_c = (_b = enterpriseModule).injectWatermark) == null ? void 0 : _c.call(_b, chart.chart.element, this.licenseManager.getWatermarkMessage());
        }
        return chart;
      }
      /**
       * Update an existing `AgChartInstance`. Options provided should be complete and not
       * partial.
       *
       * __NOTE__: As each call could trigger a chart redraw, multiple calls to update options in
       * quick succession could result in undesirable flickering, so callers should batch up and/or
       * debounce changes to avoid unintended partial update renderings.
       */
      static update(chart, options) {
        if (!AgChartInstanceProxy.isInstance(chart)) {
          throw new Error(_AgCharts.INVALID_CHART_REF_MESSAGE);
        }
        AgChartsInternal.createOrUpdate(options, chart);
      }
      /**
       * Update an existing `AgChartInstance` by applying a partial set of option changes.
       *
       * __NOTE__: As each call could trigger a chart redraw, each individual delta options update
       * should leave the chart in a valid options state. Also, multiple calls to update options in
       * quick succession could result in undesirable flickering, so callers should batch up and/or
       * debounce changes to avoid unintended partial update renderings.
       */
      static updateDelta(chart, deltaOptions) {
        if (!AgChartInstanceProxy.isInstance(chart)) {
          throw new Error(_AgCharts.INVALID_CHART_REF_MESSAGE);
        }
        AgChartsInternal.updateUserDelta(chart, deltaOptions);
      }
      /**
       * Starts a browser-based image download for the given `AgChartInstance`.
       */
      static download(chart, options) {
        if (!(chart instanceof AgChartInstanceProxy)) {
          throw new Error(_AgCharts.INVALID_CHART_REF_MESSAGE);
        }
        AgChartsInternal.download(chart, options).catch((e) => Logger.errorOnce(e));
      }
      /**
       * Returns a base64-encoded image data URL for the given `AgChartInstance`.
       */
      static getImageDataURL(chart, options) {
        if (!(chart instanceof AgChartInstanceProxy)) {
          throw new Error(_AgCharts.INVALID_CHART_REF_MESSAGE);
        }
        return AgChartsInternal.getImageDataURL(chart, options);
      }
    };
    _AgCharts.INVALID_CHART_REF_MESSAGE = "AG Charts - invalid chart reference passed";
    _AgCharts.licenseChecked = false;
    _AgCharts.gridContext = false;
    AgCharts = _AgCharts;
    AgChart = class {
      static warnDeprecated(memberName) {
        const warnDeprecated = createDeprecationWarning();
        warnDeprecated(`AgChart.${memberName}`, `Use AgCharts.${memberName} instead`);
      }
      static create(options) {
        this.warnDeprecated("create");
        return AgCharts.create(options);
      }
      static update(chart, options) {
        this.warnDeprecated("update");
        return AgCharts.update(chart, options);
      }
      static updateDelta(chart, deltaOptions) {
        this.warnDeprecated("updateDelta");
        return AgCharts.updateDelta(chart, deltaOptions);
      }
      static download(chart, options) {
        this.warnDeprecated("download");
        return AgCharts.download(chart, options);
      }
      static getImageDataURL(chart, options) {
        this.warnDeprecated("getImageDataURL");
        return AgCharts.getImageDataURL(chart, options);
      }
    };
    _AgChartsInternal = class _AgChartsInternal {
      static getInstance(element2) {
        const chart = Chart.getInstance(element2);
        return chart ? AgChartInstanceProxy.chartInstances.get(chart) : void 0;
      }
      static initialiseModules() {
        if (_AgChartsInternal.initialised)
          return;
        registerInbuiltModules();
        setupModules();
        _AgChartsInternal.initialised = true;
      }
      static createOrUpdate(options, proxy) {
        var _b;
        _AgChartsInternal.initialiseModules();
        debug2(">>> AgChartV2.createOrUpdate() user options", options);
        const _a2 = options, { overrideDevicePixelRatio, document: document2, window: userWindow } = _a2, userOptions = __objRest(_a2, ["overrideDevicePixelRatio", "document", "window"]);
        const chartOptions = new ChartOptions(userOptions, { overrideDevicePixelRatio, document: document2, window: userWindow });
        let chart = proxy == null ? void 0 : proxy.chart;
        if (chart == null || chartType(userOptions) !== chartType(chart.processedOptions)) {
          chart = _AgChartsInternal.createChartInstance(chartOptions, chart);
        }
        if (proxy == null) {
          proxy = new AgChartInstanceProxy(chart);
        } else {
          proxy.chart = chart;
        }
        if (debug2.check() && typeof window !== "undefined") {
          (_b = window.agChartInstances) != null ? _b : window.agChartInstances = {};
          window.agChartInstances[chart.id] = chart;
        }
        chart.queuedUserOptions.push(userOptions);
        chart.requestFactoryUpdate((chartRef) => {
          chartRef.applyOptions(chartOptions);
          chartRef.queuedUserOptions.splice(0, chartRef.queuedUserOptions.indexOf(userOptions));
        });
        return proxy;
      }
      static updateUserDelta(proxy, deltaOptions) {
        deltaOptions = deepClone(deltaOptions, { shallow: ["data"] });
        jsonWalk(
          deltaOptions,
          (node) => {
            if (typeof node !== "object")
              return;
            for (const [key, value] of Object.entries(node)) {
              if (typeof value === "undefined") {
                Object.assign(node, { [key]: Symbol("UNSET") });
              }
            }
          },
          { skip: ["data"] }
        );
        const { chart } = proxy;
        const lastUpdateOptions = chart.getOptions();
        const userOptions = mergeDefaults(deltaOptions, lastUpdateOptions);
        debug2(">>> AgChartV2.updateUserDelta() user delta", deltaOptions);
        debug2("AgChartV2.updateUserDelta() - base options", lastUpdateOptions);
        _AgChartsInternal.createOrUpdate(userOptions, proxy);
      }
      /**
       * Returns the content of the current canvas as an image.
       */
      static download(proxy, opts) {
        return __async(this, null, function* () {
          try {
            const clone = yield _AgChartsInternal.prepareResizedChart(proxy, opts);
            clone.chart.ctx.scene.download(opts == null ? void 0 : opts.fileName, opts == null ? void 0 : opts.fileFormat);
            clone.destroy();
          } catch (error) {
            Logger.errorOnce(error);
          }
        });
      }
      static getImageDataURL(proxy, opts) {
        return __async(this, null, function* () {
          const clone = yield _AgChartsInternal.prepareResizedChart(proxy, opts);
          const result = clone.chart.ctx.scene.getDataURL(opts == null ? void 0 : opts.fileFormat);
          clone.destroy();
          return result;
        });
      }
      static prepareResizedChart(_0) {
        return __async(this, arguments, function* ({ chart }, opts = {}) {
          var _a2, _b, _c, _d;
          const width = (_b = (_a2 = opts.width) != null ? _a2 : chart.width) != null ? _b : chart.ctx.scene.canvas.width;
          const height = (_d = (_c = opts.height) != null ? _c : chart.height) != null ? _d : chart.ctx.scene.canvas.height;
          const options = mergeDefaults(
            {
              container: document.createElement("div"),
              overrideDevicePixelRatio: 1,
              autoSize: false,
              width,
              height
            },
            // Disable enterprise features that may interfere with image generation.
            moduleRegistry.hasEnterpriseModules() && { animation: { enabled: false } },
            chart.userOptions
          );
          const cloneProxy = _AgChartsInternal.createOrUpdate(options);
          cloneProxy.chart.ctx.zoomManager.updateZoom("agChartV2", chart.ctx.zoomManager.getZoom());
          chart.series.forEach((series, index) => {
            if (!series.visible) {
              cloneProxy.chart.series[index].visible = false;
            }
          });
          chart.update(0 /* FULL */, { forceNodeDataRefresh: true });
          yield cloneProxy.chart.waitForUpdate();
          return cloneProxy;
        });
      }
      static createChartInstance(options, oldChart) {
        const transferableResource = oldChart == null ? void 0 : oldChart.destroy({ keepTransferableResources: true });
        const ChartConstructor = _AgChartsInternal.getChartByOptions(options.processedOptions);
        return new ChartConstructor(options, transferableResource);
      }
      static getChartByOptions(options) {
        if (isAgCartesianChartOptions(options)) {
          return CartesianChart;
        } else if (isAgHierarchyChartOptions(options)) {
          return HierarchyChart;
        } else if (isAgPolarChartOptions(options)) {
          return PolarChart;
        } else if (isAgTopologyChartOptions(options)) {
          return TopologyChart;
        }
        throw new Error(
          `AG Charts - couldn't apply configuration, check options are correctly structured and series types are specified`
        );
      }
    };
    _AgChartsInternal.initialised = false;
    AgChartsInternal = _AgChartsInternal;
  }
});

// packages/ag-charts-community/src/version.ts
var VERSION;
var init_version = __esm({
  "packages/ag-charts-community/src/version.ts"() {
    "use strict";
    VERSION = "9.3.2";
  }
});

// packages/ag-charts-community/src/scene/shape/arc.ts
var Arc2;
var init_arc = __esm({
  "packages/ag-charts-community/src/scene/shape/arc.ts"() {
    "use strict";
    init_angle();
    init_number();
    init_bbox();
    init_path();
    init_shape();
    Arc2 = class extends Path {
      constructor() {
        super();
        this.centerX = 0;
        this.centerY = 0;
        this.radius = 10;
        this.startAngle = 0;
        this.endAngle = Math.PI * 2;
        this.counterClockwise = false;
        this.type = 0 /* Open */;
        this.restoreOwnStyles();
      }
      get fullPie() {
        return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));
      }
      updatePath() {
        const path = this.path;
        path.clear();
        path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);
        if (this.type === 1 /* Chord */) {
          path.closePath();
        } else if (this.type === 2 /* Round */ && !this.fullPie) {
          path.lineTo(this.centerX, this.centerY);
          path.closePath();
        }
      }
      computeBBox() {
        return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);
      }
      isPointInPath(x, y) {
        const point = this.transformPoint(x, y);
        const bbox = this.computeBBox();
        return this.type !== 0 /* Open */ && bbox.containsPoint(point.x, point.y) && this.path.isPointInPath(point.x, point.y);
      }
    };
    Arc2.className = "Arc";
    Arc2.defaultStyles = Object.assign({}, Shape.defaultStyles, {
      lineWidth: 1,
      fillStyle: null
    });
    __decorateClass([
      ScenePathChangeDetection()
    ], Arc2.prototype, "centerX", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Arc2.prototype, "centerY", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Arc2.prototype, "radius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Arc2.prototype, "startAngle", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Arc2.prototype, "endAngle", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Arc2.prototype, "counterClockwise", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], Arc2.prototype, "type", 2);
  }
});

// packages/ag-charts-community/src/scene/shape/linearGradientFill.ts
var LinearGradientFill;
var init_linearGradientFill = __esm({
  "packages/ag-charts-community/src/scene/shape/linearGradientFill.ts"() {
    "use strict";
    init_colorScale();
    init_node();
    init_shape();
    LinearGradientFill = class extends Shape {
      constructor() {
        super(...arguments);
        this.direction = "to-right";
        this.stops = void 0;
        this._mask = void 0;
      }
      get mask() {
        return this._mask;
      }
      set mask(newMask) {
        if (this._mask != null) {
          this.removeChild(this._mask);
        }
        if (newMask != null) {
          this.appendChild(newMask);
        }
        this._mask = newMask;
      }
      isPointInPath(x, y) {
        var _a2, _b;
        return (_b = (_a2 = this.mask) == null ? void 0 : _a2.isPointInPath(x, y)) != null ? _b : false;
      }
      computeBBox() {
        var _a2;
        return (_a2 = this.mask) == null ? void 0 : _a2.computeBBox();
      }
      render(renderCtx) {
        const { mask, stops } = this;
        const { ctx, devicePixelRatio } = renderCtx;
        const pixelLength = 1 / devicePixelRatio;
        const maskBbox = mask == null ? void 0 : mask.computeTransformedBBox();
        if (mask == null || stops == null || maskBbox == null)
          return;
        if (mask.dirtyPath) {
          mask.updatePath();
          mask.dirtyPath = false;
        }
        ctx.save();
        ctx.clip(mask.path.getPath2D());
        ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
        const x0 = Math.floor(maskBbox.x);
        const x1 = Math.ceil(maskBbox.x + maskBbox.width);
        const y0 = Math.floor(maskBbox.y);
        const y1 = Math.ceil(maskBbox.y + maskBbox.height);
        const colorScale = new ColorScale();
        const [i0, i1] = this.direction === "to-right" ? [x0, x1] : [y0, y1];
        colorScale.domain = stops.map((_, index) => {
          return i0 + (i1 - i0) * index / (stops.length - 1);
        });
        colorScale.range = stops;
        colorScale.update();
        if (this.direction === "to-right") {
          const height = y1 - y0;
          for (let x = x0; x <= x1; x += pixelLength) {
            ctx.fillStyle = colorScale.convert(x);
            ctx.fillRect(x, y0, pixelLength, height);
          }
        } else {
          const width = x1 - x0;
          for (let y = y0; y <= y1; y += pixelLength) {
            ctx.fillStyle = colorScale.convert(y);
            ctx.fillRect(x0, y, width, pixelLength);
          }
        }
        ctx.restore();
      }
    };
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], LinearGradientFill.prototype, "direction", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], LinearGradientFill.prototype, "stops", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], LinearGradientFill.prototype, "_mask", 2);
  }
});

// packages/ag-charts-community/src/scene/shape/radialColumnShape.ts
function rotatePoint(x, y, rotation) {
  const radius = Math.sqrt(__pow(x, 2) + __pow(y, 2));
  const angle = Math.atan2(y, x);
  const rotated = angle + rotation;
  return {
    x: Math.cos(rotated) * radius,
    y: Math.sin(rotated) * radius
  };
}
function getRadialColumnWidth(startAngle, endAngle, axisOuterRadius, columnWidthRatio, maxColumnWidthRatio) {
  const rotation = angleBetween(startAngle, endAngle);
  const pad2 = rotation * (1 - columnWidthRatio) / 2;
  startAngle += pad2;
  endAngle -= pad2;
  if (rotation < 1e-3) {
    return 2 * axisOuterRadius * maxColumnWidthRatio;
  }
  if (rotation >= 2 * Math.PI) {
    const midAngle = startAngle + rotation / 2;
    startAngle = midAngle - Math.PI;
    endAngle = midAngle + Math.PI;
  }
  const startX = axisOuterRadius * Math.cos(startAngle);
  const startY = axisOuterRadius * Math.sin(startAngle);
  const endX = axisOuterRadius * Math.cos(endAngle);
  const endY = axisOuterRadius * Math.sin(endAngle);
  const colWidth = Math.floor(Math.sqrt(__pow(startX - endX, 2) + __pow(startY - endY, 2)));
  const maxWidth = 2 * axisOuterRadius * maxColumnWidthRatio;
  return Math.max(1, Math.min(maxWidth, colWidth));
}
var RadialColumnShape;
var init_radialColumnShape = __esm({
  "packages/ag-charts-community/src/scene/shape/radialColumnShape.ts"() {
    "use strict";
    init_angle();
    init_number();
    init_extendedPath2D();
    init_path();
    RadialColumnShape = class extends Path {
      constructor() {
        super(...arguments);
        this.borderPath = new ExtendedPath2D();
        this.isBeveled = true;
        this.columnWidth = 0;
        this.startAngle = 0;
        this.endAngle = 0;
        this.outerRadius = 0;
        this.innerRadius = 0;
        this.axisInnerRadius = 0;
        this.axisOuterRadius = 0;
        this.isRadiusAxisReversed = false;
      }
      getRotation() {
        const { startAngle, endAngle } = this;
        const midAngle = angleBetween(startAngle, endAngle);
        return normalizeAngle360(startAngle + midAngle / 2 + Math.PI / 2);
      }
      updatePath() {
        const { isBeveled } = this;
        if (isBeveled) {
          this.updateBeveledPath();
        } else {
          this.updateRectangularPath();
        }
        this.checkPathDirty();
      }
      updateRectangularPath() {
        const { columnWidth, innerRadius, outerRadius, path } = this;
        const left = -columnWidth / 2;
        const right = columnWidth / 2;
        const top = -outerRadius;
        const bottom = -innerRadius;
        const rotation = this.getRotation();
        const points = [
          [left, bottom],
          [left, top],
          [right, top],
          [right, bottom],
          [left, bottom]
        ].map(([x, y]) => rotatePoint(x, y, rotation));
        path.clear(true);
        path.moveTo(points[0].x, points[0].y);
        path.lineTo(points[1].x, points[1].y);
        path.lineTo(points[2].x, points[2].y);
        path.lineTo(points[3].x, points[3].y);
        path.lineTo(points[0].x, points[0].y);
        path.closePath();
      }
      updateBeveledPath() {
        const { columnWidth, path, outerRadius, innerRadius, axisInnerRadius, axisOuterRadius, isRadiusAxisReversed } = this;
        const isStackBottom = isEqual(innerRadius, axisInnerRadius);
        const sideRotation = Math.asin(columnWidth / 2 / innerRadius);
        const pointRotation = this.getRotation();
        const rotate = (x, y) => rotatePoint(x, y, pointRotation);
        const getTriangleHypotenuse = (leg, otherLeg) => Math.sqrt(__pow(leg, 2) + __pow(otherLeg, 2));
        const getTriangleLeg = (hypotenuse, otherLeg) => {
          if (otherLeg > hypotenuse) {
            return 0;
          }
          return Math.sqrt(__pow(hypotenuse, 2) - __pow(otherLeg, 2));
        };
        const compare = (value, otherValue, lessThan) => lessThan ? value < otherValue : value > otherValue;
        const shouldConnectBottomCircle = isStackBottom && !isNaN(sideRotation) && sideRotation < Math.PI / 6;
        let left = -columnWidth / 2;
        let right = columnWidth / 2;
        const top = -outerRadius;
        const bottom = -innerRadius * (shouldConnectBottomCircle ? Math.cos(sideRotation) : 1);
        const hasBottomIntersection = compare(
          axisOuterRadius,
          getTriangleHypotenuse(innerRadius, columnWidth / 2),
          !isRadiusAxisReversed
        );
        if (hasBottomIntersection) {
          const bottomIntersectionX = getTriangleLeg(axisOuterRadius, innerRadius);
          left = -bottomIntersectionX;
          right = bottomIntersectionX;
        }
        path.clear(true);
        const bottomLeftPt = rotate(left, bottom);
        path.moveTo(bottomLeftPt.x, bottomLeftPt.y);
        const isEmpty = isEqual(innerRadius, outerRadius);
        const hasSideIntersection = compare(
          axisOuterRadius,
          getTriangleHypotenuse(outerRadius, columnWidth / 2),
          !isRadiusAxisReversed
        );
        if (isEmpty && shouldConnectBottomCircle) {
          path.arc(
            0,
            0,
            innerRadius,
            normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,
            normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,
            false
          );
        } else if (hasSideIntersection) {
          const sideIntersectionY = -getTriangleLeg(axisOuterRadius, columnWidth / 2);
          const topIntersectionX = getTriangleLeg(axisOuterRadius, outerRadius);
          if (!hasBottomIntersection) {
            const topLeftPt = rotate(left, sideIntersectionY);
            path.lineTo(topLeftPt.x, topLeftPt.y);
          }
          path.arc(
            0,
            0,
            axisOuterRadius,
            Math.atan2(sideIntersectionY, left) + pointRotation,
            Math.atan2(top, -topIntersectionX) + pointRotation,
            false
          );
          if (!isEqual(topIntersectionX, 0)) {
            const topRightBevelPt = rotate(topIntersectionX, top);
            path.lineTo(topRightBevelPt.x, topRightBevelPt.y);
          }
          path.arc(
            0,
            0,
            axisOuterRadius,
            Math.atan2(top, topIntersectionX) + pointRotation,
            Math.atan2(sideIntersectionY, right) + pointRotation,
            false
          );
        } else {
          const topLeftPt = rotate(left, top);
          const topRightPt = rotate(right, top);
          path.lineTo(topLeftPt.x, topLeftPt.y);
          path.lineTo(topRightPt.x, topRightPt.y);
        }
        const bottomRightPt = rotate(right, bottom);
        path.lineTo(bottomRightPt.x, bottomRightPt.y);
        if (shouldConnectBottomCircle) {
          path.arc(
            0,
            0,
            innerRadius,
            normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,
            normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,
            true
          );
        } else {
          const rotatedBottomLeftPt = rotate(left, bottom);
          path.lineTo(rotatedBottomLeftPt.x, rotatedBottomLeftPt.y);
        }
        path.closePath();
      }
    };
    RadialColumnShape.className = "RadialColumnShape";
    __decorateClass([
      ScenePathChangeDetection()
    ], RadialColumnShape.prototype, "isBeveled", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], RadialColumnShape.prototype, "columnWidth", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], RadialColumnShape.prototype, "startAngle", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], RadialColumnShape.prototype, "endAngle", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], RadialColumnShape.prototype, "outerRadius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], RadialColumnShape.prototype, "innerRadius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], RadialColumnShape.prototype, "axisInnerRadius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], RadialColumnShape.prototype, "axisOuterRadius", 2);
    __decorateClass([
      ScenePathChangeDetection()
    ], RadialColumnShape.prototype, "isRadiusAxisReversed", 2);
  }
});

// packages/ag-charts-community/src/scene/image.ts
var Image;
var init_image = __esm({
  "packages/ag-charts-community/src/scene/image.ts"() {
    "use strict";
    init_node();
    Image = class extends Node {
      constructor(sourceImage) {
        super();
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
        this.opacity = 1;
        this.sourceImage = sourceImage;
      }
      render(renderCtx) {
        const { ctx, forceRender, stats } = renderCtx;
        if (this.dirty === 0 /* NONE */ && !forceRender) {
          if (stats)
            stats.nodesSkipped++;
          return;
        }
        this.computeTransformMatrix();
        this.matrix.toContext(ctx);
        const image = this.sourceImage;
        ctx.globalAlpha = this.opacity;
        ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);
        super.render(renderCtx);
      }
    };
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], Image.prototype, "x", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], Image.prototype, "y", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], Image.prototype, "width", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], Image.prototype, "height", 2);
    __decorateClass([
      SceneChangeDetection({ redraw: 3 /* MAJOR */ })
    ], Image.prototype, "opacity", 2);
  }
});

// packages/ag-charts-community/src/integrated-charts-scene.ts
var integrated_charts_scene_exports = {};
__export(integrated_charts_scene_exports, {
  Arc: () => Arc2,
  BBox: () => BBox,
  BandScale: () => BandScale,
  Caption: () => Caption,
  ChangeDetectableProperties: () => ChangeDetectableProperties,
  Circle: () => Circle,
  ContinuousScale: () => ContinuousScale,
  Diamond: () => Diamond,
  DropShadow: () => DropShadow,
  ExtendedPath2D: () => ExtendedPath2D,
  Group: () => Group,
  HdpiCanvas: () => HdpiCanvas,
  Image: () => Image,
  Label: () => Label,
  Line: () => Line,
  LinearGradientFill: () => LinearGradientFill,
  LinearScale: () => LinearScale,
  Marker: () => Marker,
  Node: () => Node,
  OrdinalTimeScale: () => OrdinalTimeScale,
  Path: () => Path,
  PointerEvents: () => PointerEvents,
  RadialColumnShape: () => RadialColumnShape,
  Rect: () => Rect,
  RedrawType: () => RedrawType,
  Scene: () => Scene,
  SceneChangeDetection: () => SceneChangeDetection,
  ScenePathChangeDetection: () => ScenePathChangeDetection,
  Sector: () => Sector,
  SectorBox: () => SectorBox,
  Selection: () => Selection,
  Shape: () => Shape,
  Square: () => Square,
  Text: () => Text,
  Tooltip: () => Tooltip,
  Triangle: () => Triangle,
  easing: () => easing_exports,
  getFont: () => getFont,
  getMarker: () => getMarker,
  getRadialColumnWidth: () => getRadialColumnWidth,
  motion: () => motion,
  nearestSquared: () => nearestSquared,
  nearestSquaredInContainer: () => nearestSquaredInContainer,
  toRadians: () => toRadians,
  toTooltipHtml: () => toTooltipHtml
});
var motion;
var init_integrated_charts_scene = __esm({
  "packages/ag-charts-community/src/integrated-charts-scene.ts"() {
    "use strict";
    init_fromToMotion();
    init_resetMotion();
    init_caption();
    init_dropShadow();
    init_changeDetectableProperties();
    init_group();
    init_scene();
    init_node();
    init_selection();
    init_arc();
    init_line();
    init_linearGradientFill();
    init_path();
    init_rect();
    init_sector2();
    init_radialColumnShape();
    init_shape();
    init_text();
    init_continuousScale();
    init_bandScale();
    init_ordinalTimeScale();
    init_linearScale();
    init_angle();
    init_label();
    init_marker();
    init_util();
    init_circle();
    init_diamond();
    init_square();
    init_triangle();
    init_tooltip();
    init_bbox();
    init_sectorBox();
    init_nearest();
    init_hdpiCanvas();
    init_image();
    init_extendedPath2D();
    init_easing();
    motion = __spreadValues(__spreadValues({}, fromToMotion_exports), resetMotion_exports);
  }
});

// packages/ag-charts-community/src/integrated-charts-theme.ts
var integrated_charts_theme_exports = {};
__export(integrated_charts_theme_exports, {
  CARTESIAN_AXIS_TYPE: () => CARTESIAN_AXIS_TYPE,
  ChartTheme: () => ChartTheme,
  DEFAULT_ANNOTATION_BACKGROUND_FILL: () => DEFAULT_ANNOTATION_BACKGROUND_FILL,
  DEFAULT_ANNOTATION_HANDLE_FILL: () => DEFAULT_ANNOTATION_HANDLE_FILL,
  DEFAULT_ANNOTATION_STROKE: () => DEFAULT_ANNOTATION_STROKE,
  DEFAULT_AXIS_GRID_COLOUR: () => DEFAULT_AXIS_GRID_COLOUR,
  DEFAULT_AXIS_LINE_COLOUR: () => DEFAULT_AXIS_LINE_COLOUR,
  DEFAULT_BACKGROUND_COLOUR: () => DEFAULT_BACKGROUND_COLOUR,
  DEFAULT_COLOURS: () => DEFAULT_COLOURS,
  DEFAULT_CROSS_LINES_COLOUR: () => DEFAULT_CROSS_LINES_COLOUR,
  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: () => DEFAULT_DIVERGING_SERIES_COLOUR_RANGE,
  DEFAULT_FONT_FAMILY: () => DEFAULT_FONT_FAMILY,
  DEFAULT_HIERARCHY_FILLS: () => DEFAULT_HIERARCHY_FILLS,
  DEFAULT_HIERARCHY_STROKES: () => DEFAULT_HIERARCHY_STROKES,
  DEFAULT_INSIDE_SERIES_LABEL_COLOUR: () => DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
  DEFAULT_INVERTED_LABEL_COLOUR: () => DEFAULT_INVERTED_LABEL_COLOUR,
  DEFAULT_LABEL_COLOUR: () => DEFAULT_LABEL_COLOUR,
  DEFAULT_MUTED_LABEL_COLOUR: () => DEFAULT_MUTED_LABEL_COLOUR,
  DEFAULT_POLAR_SERIES_STROKE: () => DEFAULT_POLAR_SERIES_STROKE,
  DEFAULT_SHADOW_COLOUR: () => DEFAULT_SHADOW_COLOUR,
  DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE: () => DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
  DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS: () => DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,
  DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS: () => DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,
  DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS: () => DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,
  EXTENDS_AXES_DEFAULTS: () => EXTENDS_AXES_DEFAULTS,
  EXTENDS_AXES_GRID_LINE_DEFAULTS: () => EXTENDS_AXES_GRID_LINE_DEFAULTS,
  EXTENDS_AXES_LINE_DEFAULTS: () => EXTENDS_AXES_LINE_DEFAULTS,
  EXTENDS_AXES_TICK_DEFAULTS: () => EXTENDS_AXES_TICK_DEFAULTS,
  EXTENDS_CARTESIAN_MARKER_DEFAULTS: () => EXTENDS_CARTESIAN_MARKER_DEFAULTS,
  EXTENDS_SERIES_DEFAULTS: () => EXTENDS_SERIES_DEFAULTS,
  FONT_SIZE: () => FONT_SIZE,
  FONT_WEIGHT: () => FONT_WEIGHT,
  IS_DARK_THEME: () => IS_DARK_THEME,
  POLAR_AXIS_SHAPE: () => POLAR_AXIS_SHAPE,
  POLAR_AXIS_TYPE: () => POLAR_AXIS_TYPE,
  POSITION: () => POSITION,
  getChartTheme: () => getChartTheme,
  markerPaletteFactory: () => markerPaletteFactory,
  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,
  themes: () => themes2
});
var themes2;
var init_integrated_charts_theme = __esm({
  "packages/ag-charts-community/src/integrated-charts-theme.ts"() {
    "use strict";
    init_themes();
    init_object();
    init_themes();
    init_chartTheme();
    init_symbols();
    init_constants();
    init_theme();
    themes2 = mapValues(themes, (themeFactory) => themeFactory == null ? void 0 : themeFactory());
  }
});

// packages/ag-charts-community/src/scale/scale.ts
var init_scale = __esm({
  "packages/ag-charts-community/src/scale/scale.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/sparklines-scale.ts
var sparklines_scale_exports = {};
__export(sparklines_scale_exports, {
  BandScale: () => BandScale,
  ColorScale: () => ColorScale,
  ContinuousScale: () => ContinuousScale,
  Invalidating: () => Invalidating,
  LinearScale: () => LinearScale,
  OrdinalTimeScale: () => OrdinalTimeScale,
  TimeScale: () => TimeScale
});
var init_sparklines_scale = __esm({
  "packages/ag-charts-community/src/sparklines-scale.ts"() {
    "use strict";
    init_timeScale();
    init_bandScale();
    init_continuousScale();
    init_ordinalTimeScale();
    init_colorScale();
    init_linearScale();
    init_scale();
    init_invalidating();
  }
});

// packages/ag-charts-community/src/util/zip.ts
function zipObject(keys, values) {
  const zipped = {};
  if (Array.isArray(values)) {
    for (let i = 0; i < keys.length; i++) {
      zipped[`${keys[i]}`] = values[i];
    }
  } else {
    for (let i = 0; i < keys.length; i++) {
      zipped[`${keys[i]}`] = values;
    }
  }
  return zipped;
}
var init_zip = __esm({
  "packages/ag-charts-community/src/util/zip.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/sparklines-util.ts
var sparklines_util_exports = {};
__export(sparklines_util_exports, {
  Color: () => Color,
  Logger: () => Logger,
  Padding: () => Padding,
  angleBetween: () => angleBetween,
  areArrayItemsStrictlyEqual: () => areArrayItemsStrictlyEqual,
  areArrayNumbersEqual: () => areArrayNumbersEqual,
  bifurcate: () => bifurcate,
  checkDatum: () => checkDatum,
  clamp: () => clamp,
  clampArray: () => clampArray,
  countFractionDigits: () => countFractionDigits,
  createId: () => createId,
  deepClone: () => deepClone,
  displacePointFromVector: () => displacePointFromVector,
  extent: () => extent,
  findMinMax: () => findMinMax,
  findRangeExtent: () => findRangeExtent,
  isBetweenAngles: () => isBetweenAngles,
  isContinuous: () => isContinuous,
  isDate: () => isValidDate,
  isDenseInterval: () => isDenseInterval,
  isEqual: () => isEqual,
  isNegative: () => isNegative,
  isNumber: () => isFiniteNumber,
  isNumberEqual: () => isEqual,
  isNumberObject: () => isNumberObject,
  isString: () => isString,
  isStringObject: () => isStringObject,
  jsonApply: () => jsonApply,
  jsonDiff: () => jsonDiff,
  jsonWalk: () => jsonWalk,
  mod: () => mod,
  normalisedExtent: () => normalisedExtent,
  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,
  normalizeAngle180: () => normalizeAngle180,
  normalizeAngle360: () => normalizeAngle360,
  normalizeAngle360Inclusive: () => normalizeAngle360Inclusive,
  range: () => range,
  resetIds: () => resetIds,
  round: () => round,
  sanitizeHtml: () => sanitizeHtml,
  setAttribute: () => setAttribute,
  shallowClone: () => shallowClone,
  tickFormat: () => tickFormat,
  tickStep: () => tickStep,
  ticks: () => ticks_default,
  toDegrees: () => toDegrees,
  toFixed: () => toFixed,
  toRadians: () => toRadians,
  transformIntegratedCategoryValue: () => transformIntegratedCategoryValue,
  zipObject: () => zipObject
});
var init_sparklines_util = __esm({
  "packages/ag-charts-community/src/sparklines-util.ts"() {
    "use strict";
    init_angle();
    init_attributeUtil();
    init_equal();
    init_id();
    init_json();
    init_number();
    init_padding();
    init_sanitize();
    init_value();
    init_zip();
    init_type_guards();
    init_array();
    init_number();
    init_numberFormat();
    init_ticks();
    init_color();
    init_logger();
  }
});

// packages/ag-charts-community/src/util/types.ts
var init_types3 = __esm({
  "packages/ag-charts-community/src/util/types.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/module/axisModule.ts
var init_axisModule = __esm({
  "packages/ag-charts-community/src/module/axisModule.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/module/baseModule.ts
var init_baseModule = __esm({
  "packages/ag-charts-community/src/module/baseModule.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/module/coreModules.ts
var init_coreModules = __esm({
  "packages/ag-charts-community/src/module/coreModules.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/module/optionsModuleTypes.ts
var init_optionsModuleTypes = __esm({
  "packages/ag-charts-community/src/module/optionsModuleTypes.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/module/moduleContext.ts
var init_moduleContext = __esm({
  "packages/ag-charts-community/src/module/moduleContext.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/chartAnimationPhase.ts
var init_chartAnimationPhase = __esm({
  "packages/ag-charts-community/src/chart/chartAnimationPhase.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/series/seriesEvents.ts
var init_seriesEvents = __esm({
  "packages/ag-charts-community/src/chart/series/seriesEvents.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/series/seriesTypes.ts
var init_seriesTypes = __esm({
  "packages/ag-charts-community/src/chart/series/seriesTypes.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/series/util.ts
function convertValuesToScaleByDefs({
  defs,
  values,
  xAxis,
  yAxis
}) {
  if (!(xAxis && yAxis)) {
    throw new Error("Axes must be defined");
  }
  const result = {};
  for (const [searchId, { def }] of defs) {
    if (Object.hasOwn(values, searchId)) {
      const { scale: scale2 } = def.type === "key" ? xAxis : yAxis;
      result[searchId] = Math.round(scale2.convert(values[searchId]));
    }
  }
  return result;
}
var init_util2 = __esm({
  "packages/ag-charts-community/src/chart/series/util.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeries.ts
var _HierarchyNode, HierarchyNode, HierarchySeries;
var init_hierarchySeries = __esm({
  "packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeries.ts"() {
    "use strict";
    init_resetMotion();
    init_states();
    init_colorScale();
    init_series();
    _HierarchyNode = class _HierarchyNode {
      constructor(series, index, datum, size, colorValue, fill, stroke, sumSize, depth, parent, children) {
        this.series = series;
        this.index = index;
        this.datum = datum;
        this.size = size;
        this.colorValue = colorValue;
        this.fill = fill;
        this.stroke = stroke;
        this.sumSize = sumSize;
        this.depth = depth;
        this.parent = parent;
        this.children = children;
        this.midPoint = { x: 0, y: 0 };
      }
      contains(other) {
        let current = other;
        while (current != null && current.index >= this.index) {
          if (current === this) {
            return true;
          }
          current = current.parent;
        }
        return false;
      }
      walk(callback, order = _HierarchyNode.Walk.PreOrder) {
        if (order === _HierarchyNode.Walk.PreOrder) {
          callback(this);
        }
        this.children.forEach((child) => {
          child.walk(callback, order);
        });
        if (order === _HierarchyNode.Walk.PostOrder) {
          callback(this);
        }
      }
      *[Symbol.iterator]() {
        yield this;
        for (const child of this.children) {
          yield* __yieldStar(child);
        }
      }
    };
    _HierarchyNode.Walk = {
      PreOrder: 0,
      PostOrder: 1
    };
    HierarchyNode = _HierarchyNode;
    HierarchySeries = class extends Series {
      constructor(moduleCtx) {
        super({
          moduleCtx,
          pickModes: [0 /* EXACT_SHAPE_MATCH */],
          contentGroupVirtual: false
        });
        this.rootNode = new HierarchyNode(
          this,
          0,
          void 0,
          0,
          void 0,
          void 0,
          void 0,
          0,
          void 0,
          void 0,
          []
        );
        this.colorDomain = [0, 0];
        this.maxDepth = 0;
        this.animationState = new StateMachine(
          "empty",
          {
            empty: {
              update: {
                target: "ready",
                action: (data) => this.animateEmptyUpdateReady(data)
              },
              reset: "empty",
              skip: "ready"
            },
            ready: {
              updateData: "waiting",
              clear: "clearing",
              highlight: (data) => this.animateReadyHighlight(data),
              resize: (data) => this.animateReadyResize(data),
              reset: "empty",
              skip: "ready"
            },
            waiting: {
              update: {
                target: "ready",
                action: (data) => this.animateWaitingUpdateReady(data)
              },
              reset: "empty",
              skip: "ready"
            },
            clearing: {
              update: {
                target: "empty",
                action: (data) => this.animateClearingUpdateEmpty(data)
              },
              reset: "empty",
              skip: "ready"
            }
          },
          () => this.checkProcessedDataAnimatable()
        );
      }
      resetAnimation(phase) {
        if (phase === "initial") {
          this.animationState.transition("reset");
        } else if (phase === "ready") {
          this.animationState.transition("skip");
        }
      }
      processData() {
        return __async(this, null, function* () {
          var _a2, _b;
          const { childrenKey, sizeKey, colorKey, fills, strokes, colorRange } = this.properties;
          let index = 0;
          const getIndex = () => {
            index += 1;
            return index;
          };
          let maxDepth = 0;
          let minColor = Infinity;
          let maxColor = -Infinity;
          const colors = new Array(((_b = (_a2 = this.data) == null ? void 0 : _a2.length) != null ? _b : 0) + 1).fill(void 0);
          const createNode = (datum, parent) => {
            const nodeIndex = getIndex();
            const depth = parent.depth != null ? parent.depth + 1 : 0;
            const children = childrenKey != null ? datum[childrenKey] : void 0;
            const isLeaf = children == null || children.length === 0;
            let size = sizeKey != null ? datum[sizeKey] : void 0;
            if (Number.isFinite(size)) {
              size = Math.max(size, 0);
            } else {
              size = isLeaf ? 1 : 0;
            }
            const sumSize = size;
            maxDepth = Math.max(maxDepth, depth);
            const color = colorKey != null ? datum[colorKey] : void 0;
            if (typeof color === "number") {
              colors[nodeIndex] = color;
              minColor = Math.min(minColor, color);
              maxColor = Math.max(maxColor, color);
            }
            return appendChildren(
              new HierarchyNode(
                this,
                nodeIndex,
                datum,
                size,
                color,
                void 0,
                void 0,
                sumSize,
                depth,
                parent,
                []
              ),
              children
            );
          };
          const appendChildren = (node, data) => {
            data == null ? void 0 : data.forEach((datum) => {
              const child = createNode(datum, node);
              node.children.push(child);
              node.sumSize += child.sumSize;
            });
            return node;
          };
          const rootNode = appendChildren(
            new HierarchyNode(
              this,
              0,
              void 0,
              0,
              void 0,
              void 0,
              void 0,
              0,
              void 0,
              void 0,
              []
            ),
            this.data
          );
          const colorDomain = [minColor, maxColor];
          let colorScale;
          if (colorRange != null && Number.isFinite(minColor) && Number.isFinite(maxColor)) {
            colorScale = new ColorScale();
            colorScale.domain = colorDomain;
            colorScale.range = colorRange;
            colorScale.update();
          }
          rootNode.children.forEach((child, childIndex) => {
            child.walk((node) => {
              let fill;
              const color = colors[node.index];
              if (color != null) {
                fill = colorScale == null ? void 0 : colorScale.convert(color);
              }
              fill != null ? fill : fill = fills == null ? void 0 : fills[childIndex % fills.length];
              node.fill = fill;
              node.stroke = colorScale == null ? strokes == null ? void 0 : strokes[childIndex % strokes.length] : "rgba(0, 0, 0, 0.2)";
            });
          });
          this.rootNode = rootNode;
          this.maxDepth = maxDepth;
          this.colorDomain = colorDomain;
        });
      }
      update(_0) {
        return __async(this, arguments, function* ({ seriesRect }) {
          yield this.updateSelections();
          yield this.updateNodes();
          const animationData = this.getAnimationData();
          const resize = this.checkResize(seriesRect);
          if (resize) {
            this.animationState.transition("resize", animationData);
          }
          this.animationState.transition("update", animationData);
        });
      }
      resetAllAnimation(data) {
        var _a2;
        const datum = (_a2 = this.animationResetFns) == null ? void 0 : _a2.datum;
        this.ctx.animationManager.stopByAnimationGroupId(this.id);
        if (datum != null) {
          resetMotion(data.datumSelections, datum);
        }
      }
      animateEmptyUpdateReady(data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation(data);
      }
      animateWaitingUpdateReady(data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation(data);
      }
      animateReadyHighlight(data) {
        var _a2;
        const datum = (_a2 = this.animationResetFns) == null ? void 0 : _a2.datum;
        if (datum != null) {
          resetMotion([data], datum);
        }
      }
      animateReadyResize(data) {
        this.resetAllAnimation(data);
      }
      animateClearingUpdateEmpty(data) {
        this.ctx.animationManager.skipCurrentBatch();
        this.resetAllAnimation(data);
      }
      animationTransitionClear() {
        this.animationState.transition("clear", this.getAnimationData());
      }
      getAnimationData() {
        const animationData = {
          datumSelections: [this.groupSelection]
        };
        return animationData;
      }
      isProcessedDataAnimatable() {
        return true;
      }
      checkProcessedDataAnimatable() {
        if (!this.isProcessedDataAnimatable()) {
          this.ctx.animationManager.skipCurrentBatch();
        }
      }
      getLabelData() {
        return [];
      }
      getSeriesDomain() {
        return [NaN, NaN];
      }
      getLegendData(legendType) {
        const { colorKey, colorName, colorRange, visible } = this.properties;
        return legendType === "gradient" && colorKey != null && colorRange != null ? [
          {
            legendType: "gradient",
            enabled: visible,
            seriesId: this.id,
            colorName,
            colorRange,
            colorDomain: this.colorDomain
          }
        ] : [];
      }
      getDatumIdFromData(node) {
        return `${node.index}`;
      }
      getDatumId(node) {
        return this.getDatumIdFromData(node);
      }
    };
  }
});

// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeriesProperties.ts
var HierarchySeriesProperties;
var init_hierarchySeriesProperties = __esm({
  "packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeriesProperties.ts"() {
    "use strict";
    init_validation();
    init_defaultColors();
    init_seriesProperties();
    HierarchySeriesProperties = class extends SeriesProperties {
      constructor() {
        super(...arguments);
        this.childrenKey = "children";
        this.fills = Object.values(DEFAULT_FILLS);
        this.strokes = Object.values(DEFAULT_STROKES);
      }
    };
    __decorateClass([
      Validate(STRING)
    ], HierarchySeriesProperties.prototype, "childrenKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], HierarchySeriesProperties.prototype, "sizeKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], HierarchySeriesProperties.prototype, "colorKey", 2);
    __decorateClass([
      Validate(STRING, { optional: true })
    ], HierarchySeriesProperties.prototype, "colorName", 2);
    __decorateClass([
      Validate(COLOR_STRING_ARRAY)
    ], HierarchySeriesProperties.prototype, "fills", 2);
    __decorateClass([
      Validate(COLOR_STRING_ARRAY)
    ], HierarchySeriesProperties.prototype, "strokes", 2);
    __decorateClass([
      Validate(COLOR_STRING_ARRAY, { optional: true })
    ], HierarchySeriesProperties.prototype, "colorRange", 2);
  }
});

// packages/ag-charts-community/src/chart/series/topologySeries.ts
var init_topologySeries = __esm({
  "packages/ag-charts-community/src/chart/series/topologySeries.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/series/topology/geojson.ts
var init_geojson = __esm({
  "packages/ag-charts-community/src/chart/series/topology/geojson.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/series/topology/lonLatBbox.ts
var LonLatBBox;
var init_lonLatBbox = __esm({
  "packages/ag-charts-community/src/chart/series/topology/lonLatBbox.ts"() {
    "use strict";
    LonLatBBox = class {
      constructor(lon0, lat0, lon1, lat1) {
        this.lon0 = lon0;
        this.lat0 = lat0;
        this.lon1 = lon1;
        this.lat1 = lat1;
      }
      merge(other) {
        this.lon0 = Math.min(this.lon0, other.lon0);
        this.lat0 = Math.min(this.lat0, other.lat0);
        this.lon1 = Math.max(this.lon1, other.lon1);
        this.lat1 = Math.max(this.lat1, other.lat1);
      }
    };
  }
});

// packages/ag-charts-community/src/chart/chartAxis.ts
var init_chartAxis = __esm({
  "packages/ag-charts-community/src/chart/chartAxis.ts"() {
    "use strict";
  }
});

// packages/ag-charts-community/src/chart/legendDatum.ts
var __FORCE_MODULE_DETECTION2;
var init_legendDatum = __esm({
  "packages/ag-charts-community/src/chart/legendDatum.ts"() {
    "use strict";
    __FORCE_MODULE_DETECTION2 = 0;
  }
});

// packages/ag-charts-community/src/module-support.ts
var module_support_exports = {};
__export(module_support_exports, {
  AND: () => AND,
  ARRAY: () => ARRAY,
  ARRAY_OF: () => ARRAY_OF,
  AbstractBarSeries: () => AbstractBarSeries,
  AbstractBarSeriesProperties: () => AbstractBarSeriesProperties,
  ActionOnSet: () => ActionOnSet,
  Animation: () => Animation,
  AnimationManager: () => AnimationManager,
  AreaSeriesTag: () => AreaSeriesTag,
  Axis: () => Axis,
  AxisLabel: () => AxisLabel,
  AxisTick: () => AxisTick,
  BOOLEAN: () => BOOLEAN,
  BOOLEAN_ARRAY: () => BOOLEAN_ARRAY,
  Background: () => Background,
  BackgroundModule: () => BackgroundModule,
  BaseModuleInstance: () => BaseModuleInstance,
  BaseProperties: () => BaseProperties,
  COLOR_STRING: () => COLOR_STRING,
  COLOR_STRING_ARRAY: () => COLOR_STRING_ARRAY,
  CartesianAxis: () => CartesianAxis,
  CartesianSeries: () => CartesianSeries,
  CartesianSeriesNodeEvent: () => CartesianSeriesNodeEvent,
  CartesianSeriesProperties: () => CartesianSeriesProperties,
  CategoryAxis: () => CategoryAxis,
  CategoryAxisTick: () => CategoryAxisTick,
  ChartAxisDirection: () => ChartAxisDirection,
  ChartEventManager: () => ChartEventManager,
  ChartOptions: () => ChartOptions,
  ChartUpdateType: () => ChartUpdateType,
  ContextMenuRegistry: () => ContextMenuRegistry,
  CursorManager: () => CursorManager,
  DATE: () => DATE,
  DATE_ARRAY: () => DATE_ARRAY,
  DATE_OR_DATETIME_MS: () => DATE_OR_DATETIME_MS,
  DEFAULT_CARTESIAN_DIRECTION_KEYS: () => DEFAULT_CARTESIAN_DIRECTION_KEYS,
  DEFAULT_CARTESIAN_DIRECTION_NAMES: () => DEFAULT_CARTESIAN_DIRECTION_NAMES,
  DEFAULT_TOOLTIP_CLASS: () => DEFAULT_TOOLTIP_CLASS,
  DEFAULT_TOOLTIP_DARK_CLASS: () => DEFAULT_TOOLTIP_DARK_CLASS,
  DEGREE: () => DEGREE,
  DIRECTION: () => DIRECTION,
  DataController: () => DataController,
  DataModel: () => DataModel,
  DataModelSeries: () => DataModelSeries,
  DataService: () => DataService,
  Default: () => Default,
  Deprecated: () => Deprecated,
  DeprecatedAndRenamedTo: () => DeprecatedAndRenamedTo,
  EMPTY_TOOLTIP_CONTENT: () => EMPTY_TOOLTIP_CONTENT,
  FONT_STYLE: () => FONT_STYLE,
  FONT_WEIGHT: () => FONT_WEIGHT2,
  FUNCTION: () => FUNCTION,
  GREATER_THAN: () => GREATER_THAN,
  GestureDetector: () => GestureDetector,
  GroupedCategoryAxis: () => GroupedCategoryAxis,
  HierarchyNode: () => HierarchyNode,
  HierarchySeries: () => HierarchySeries,
  HierarchySeriesProperties: () => HierarchySeriesProperties,
  HighlightManager: () => HighlightManager,
  HighlightStyle: () => HighlightStyle,
  INTERACTION_RANGE: () => INTERACTION_RANGE,
  InteractionManager: () => InteractionManager,
  InteractionState: () => InteractionState,
  LABEL_PLACEMENT: () => LABEL_PLACEMENT,
  LESS_THAN: () => LESS_THAN,
  LINE_CAP: () => LINE_CAP,
  LINE_DASH: () => LINE_DASH,
  LINE_JOIN: () => LINE_JOIN,
  Layers: () => Layers,
  LayoutService: () => LayoutService,
  LonLatBBox: () => LonLatBBox,
  MARKER_SHAPE: () => MARKER_SHAPE,
  MATCHING_CROSSLINE_TYPE: () => MATCHING_CROSSLINE_TYPE,
  MAX_SPACING: () => MAX_SPACING,
  MIN_SPACING: () => MIN_SPACING,
  MercatorScale: () => MercatorScale,
  Motion: () => easing_exports,
  NAN: () => NAN,
  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,
  NUMBER: () => NUMBER,
  NUMBER_ARRAY: () => NUMBER_ARRAY,
  NUMBER_OR_NAN: () => NUMBER_OR_NAN,
  Navigator: () => Navigator,
  NavigatorModule: () => NavigatorModule,
  OBJECT: () => OBJECT,
  OBJECT_ARRAY: () => OBJECT_ARRAY,
  OR: () => OR,
  OVERFLOW_STRATEGY: () => OVERFLOW_STRATEGY,
  ObserveChanges: () => ObserveChanges,
  PHASE_METADATA: () => PHASE_METADATA,
  PHASE_ORDER: () => PHASE_ORDER,
  PLACEMENT: () => PLACEMENT,
  PLAIN_OBJECT: () => PLAIN_OBJECT,
  POINTER_INTERACTION_TYPES: () => POINTER_INTERACTION_TYPES,
  POSITION: () => POSITION2,
  POSITIVE_NUMBER: () => POSITIVE_NUMBER,
  PolarAxis: () => PolarAxis,
  PolarSeries: () => PolarSeries,
  PropertiesArray: () => PropertiesArray,
  ProxyOnWrite: () => ProxyOnWrite,
  ProxyProperty: () => ProxyProperty,
  ProxyPropertyOnWrite: () => ProxyPropertyOnWrite,
  QUICK_TRANSITION: () => QUICK_TRANSITION,
  RATIO: () => RATIO,
  RepeatType: () => RepeatType,
  SKIP_JS_BUILTINS: () => SKIP_JS_BUILTINS,
  SMALLEST_KEY_INTERVAL: () => SMALLEST_KEY_INTERVAL,
  SORT_DOMAIN_GROUPS: () => SORT_DOMAIN_GROUPS,
  STRING: () => STRING,
  STRING_ARRAY: () => STRING_ARRAY,
  Series: () => Series,
  SeriesGroupingChangedEvent: () => SeriesGroupingChangedEvent,
  SeriesItemHighlightStyle: () => SeriesItemHighlightStyle,
  SeriesMarker: () => SeriesMarker,
  SeriesNodeEvent: () => SeriesNodeEvent,
  SeriesNodePickMode: () => SeriesNodePickMode,
  SeriesProperties: () => SeriesProperties,
  SeriesTooltip: () => SeriesTooltip,
  StateMachine: () => StateMachine,
  TEXT_ALIGN: () => TEXT_ALIGN,
  TEXT_WRAP: () => TEXT_WRAP,
  ToolbarManager: () => ToolbarManager,
  Tooltip: () => Tooltip,
  TooltipManager: () => TooltipManager,
  TooltipPosition: () => TooltipPosition,
  UNION: () => UNION,
  UpdateService: () => UpdateService,
  VERTICAL_ALIGN: () => VERTICAL_ALIGN,
  Validate: () => Validate,
  ZoomManager: () => ZoomManager,
  __FORCE_MODULE_DETECTION: () => __FORCE_MODULE_DETECTION2,
  accumulateGroup: () => accumulateGroup,
  accumulatedValue: () => accumulatedValue,
  accumulativeValueProperty: () => accumulativeValueProperty,
  addHitTestersToQuadtree: () => addHitTestersToQuadtree,
  adjustLabelPlacement: () => adjustLabelPlacement,
  allInStringUnion: () => allInStringUnion,
  animationValidation: () => animationValidation,
  area: () => area,
  arraysEqual: () => arraysEqual,
  assignJsonApplyConstructedArray: () => assignJsonApplyConstructedArray,
  backfillPathPointData: () => backfillPathPointData,
  basicContinuousCheckDatumValidation: () => basicContinuousCheckDatumValidation,
  bifurcate: () => bifurcate,
  buildFormatter: () => buildFormatter,
  buildResetPathFn: () => buildResetPathFn,
  calculateDefaultTimeTickFormat: () => calculateDefaultTimeTickFormat,
  calculatePlacement: () => calculatePlacement,
  checkCrisp: () => checkCrisp,
  childrenIter: () => childrenIter,
  circularSliceArray: () => circularSliceArray,
  clamp: () => clamp,
  clampArray: () => clampArray,
  collapsedStartingBarPosition: () => collapsedStartingBarPosition,
  computeBarFocusBounds: () => computeBarFocusBounds,
  computeMarkerFocusBounds: () => computeMarkerFocusBounds,
  computeSectorFocusBounds: () => computeSectorFocusBounds,
  convertValuesToScaleByDefs: () => convertValuesToScaleByDefs,
  countFractionDigits: () => countFractionDigits,
  createDatumId: () => createDatumId,
  createDeprecationWarning: () => createDeprecationWarning,
  createElement: () => createElement,
  dateToNumber: () => dateToNumber,
  deconstructSelectionsOrNodes: () => deconstructSelectionsOrNodes,
  deepClone: () => deepClone,
  deepMerge: () => deepMerge,
  defaultTimeTickFormat: () => defaultTimeTickFormat,
  determinePathStatus: () => determinePathStatus,
  diff: () => diff,
  downloadUrl: () => downloadUrl,
  enterpriseModule: () => enterpriseModule,
  extent: () => extent,
  extractDecoratedProperties: () => extractDecoratedProperties,
  findMinMax: () => findMinMax,
  findQuadtreeMatch: () => findQuadtreeMatch,
  findRangeExtent: () => findRangeExtent,
  fixNumericExtent: () => fixNumericExtent,
  fromToMotion: () => fromToMotion,
  getDocument: () => getDocument,
  getMissCount: () => getMissCount,
  getPath: () => getPath,
  getRectConfig: () => getRectConfig,
  getWindow: () => getWindow,
  groupAccumulativeValueProperty: () => groupAccumulativeValueProperty,
  groupAverage: () => groupAverage,
  groupBy: () => groupBy,
  groupCount: () => groupCount,
  groupSum: () => groupSum,
  injectStyle: () => injectStyle,
  isArray: () => isArray,
  isBoolean: () => isBoolean,
  isDate: () => isDate,
  isDecoratedObject: () => isDecoratedObject,
  isDefined: () => isDefined,
  isEnumKey: () => isEnumKey,
  isEnumValue: () => isEnumValue,
  isEqual: () => isEqual,
  isFiniteNumber: () => isFiniteNumber,
  isFunction: () => isFunction,
  isHtmlElement: () => isHtmlElement,
  isNegative: () => isNegative,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isObjectLike: () => isObjectLike,
  isPlainObject: () => isPlainObject,
  isProperties: () => isProperties,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isValidDate: () => isValidDate,
  jsonApply: () => jsonApply,
  jsonDiff: () => jsonDiff,
  jsonWalk: () => jsonWalk,
  keyProperty: () => keyProperty,
  listDecoratedProperties: () => listDecoratedProperties,
  mapIterable: () => mapIterable,
  mapValues: () => mapValues,
  markerFadeInAnimation: () => markerFadeInAnimation,
  markerPaletteFactory: () => markerPaletteFactory,
  markerScaleInAnimation: () => markerScaleInAnimation,
  markerSwipeScaleInAnimation: () => markerSwipeScaleInAnimation,
  mergeArrayDefaults: () => mergeArrayDefaults,
  mergeDefaults: () => mergeDefaults,
  midpointStartingBarPosition: () => midpointStartingBarPosition,
  minMax: () => minMax,
  mod: () => mod,
  moduleRegistry: () => moduleRegistry,
  normaliseGroupTo: () => normaliseGroupTo,
  normalisePropertyTo: () => normalisePropertyTo,
  normalisedExtent: () => normalisedExtent,
  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,
  pairCategoryData: () => pairCategoryData,
  pairContinuousData: () => pairContinuousData,
  partialAssign: () => partialAssign,
  pathFadeInAnimation: () => pathFadeInAnimation,
  pathFadeOutAnimation: () => pathFadeOutAnimation,
  pathSwipeInAnimation: () => pathSwipeInAnimation,
  pickByMatchingAngle: () => pickByMatchingAngle,
  predicateWithMessage: () => predicateWithMessage,
  prepareAreaPathAnimation: () => prepareAreaPathAnimation,
  prepareAxisAnimationContext: () => prepareAxisAnimationContext,
  prepareAxisAnimationFunctions: () => prepareAxisAnimationFunctions,
  prepareBarAnimationFunctions: () => prepareBarAnimationFunctions,
  prepareLinePathAnimation: () => prepareLinePathAnimation,
  prepareLinePathAnimationFns: () => prepareLinePathAnimationFns,
  prepareMarkerAnimation: () => prepareMarkerAnimation,
  preparePieSeriesAnimationFunctions: () => preparePieSeriesAnimationFunctions,
  range: () => range2,
  rangedValueProperty: () => rangedValueProperty,
  renderPartialPath: () => renderPartialPath,
  resetAxisGroupFn: () => resetAxisGroupFn,
  resetAxisLabelSelectionFn: () => resetAxisLabelSelectionFn,
  resetAxisLineSelectionFn: () => resetAxisLineSelectionFn,
  resetAxisSelectionFn: () => resetAxisSelectionFn,
  resetBarSelectionsFn: () => resetBarSelectionsFn,
  resetIds: () => resetIds,
  resetLabelFn: () => resetLabelFn,
  resetMarkerFn: () => resetMarkerFn,
  resetMarkerPositionFn: () => resetMarkerPositionFn,
  resetMotion: () => resetMotion,
  resetPieSelectionsFn: () => resetPieSelectionsFn,
  round: () => round,
  seriesLabelFadeInAnimation: () => seriesLabelFadeInAnimation,
  seriesLabelFadeOutAnimation: () => seriesLabelFadeOutAnimation,
  setDocument: () => setDocument,
  setPath: () => setPath,
  setWindow: () => setWindow,
  shallowClone: () => shallowClone,
  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,
  staticFromToMotion: () => staticFromToMotion,
  stringify: () => stringify,
  sum: () => sum,
  sumValues: () => sumValues,
  toArray: () => toArray,
  toFixed: () => toFixed,
  toTooltipHtml: () => toTooltipHtml,
  trailingAccumulatedValue: () => trailingAccumulatedValue,
  trailingAccumulatedValueProperty: () => trailingAccumulatedValueProperty,
  unique: () => unique,
  updateClipPath: () => updateClipPath,
  updateLabelNode: () => updateLabelNode,
  updateRect: () => updateRect,
  validateCrossLineValues: () => validateCrossLineValues,
  valueProperty: () => valueProperty,
  without: () => without
});
var init_module_support = __esm({
  "packages/ag-charts-community/src/module-support.ts"() {
    "use strict";
    init_array();
    init_placement();
    init_validation();
    init_default();
    init_decorator();
    init_dom();
    init_deprecation();
    init_json();
    init_number();
    init_object();
    init_properties();
    init_proxy();
    init_timeFormatDefaults();
    init_timeFormat();
    init_types3();
    init_type_guards();
    init_theme();
    init_axisModule();
    init_baseModule();
    init_coreModules();
    init_optionsModule();
    init_optionsModuleTypes();
    init_module();
    init_moduleContext();
    init_enterpriseModule();
    init_background();
    init_backgroundModule();
    init_navigator();
    init_navigatorModule();
    init_chartAnimationPhase();
    init_chartAxisDirection();
    init_chartOptions2();
    init_axisUtil();
    init_dataModel();
    init_dataController();
    init_dataService();
    init_processors();
    init_aggregateFunctions();
    init_updateService();
    init_layoutService();
    init_animationManager();
    init_chartEventManager();
    init_contextMenuRegistry();
    init_cursorManager();
    init_highlightManager();
    init_interactionManager();
    init_gestureDetector();
    init_toolbarManager();
    init_tooltipManager();
    init_zoomManager();
    init_layers();
    init_series();
    init_seriesEvents();
    init_seriesLabelUtil();
    init_seriesProperties();
    init_seriesMarker();
    init_seriesTooltip();
    init_seriesTypes();
    init_util2();
    init_abstractBarSeries();
    init_cartesianSeries();
    init_lineUtil();
    init_barUtil();
    init_areaUtil();
    init_markerUtil();
    init_labelUtil();
    init_pathUtil();
    init_quadtreeUtil();
    init_dataModelSeries();
    init_polarSeries();
    init_pieUtil();
    init_hierarchySeries();
    init_hierarchySeriesProperties();
    init_topologySeries();
    init_geojson();
    init_lonLatBbox();
    init_mercatorScale();
    init_axis();
    init_axisLabel();
    init_axisTick();
    init_polarAxis();
    init_categoryAxis();
    init_groupedCategoryAxis();
    init_cartesianAxis();
    init_chartAxis();
    init_crossLine();
    init_legendDatum();
    init_tooltip();
    init_animation();
    init_easing();
    init_states();
    init_resetMotion();
    init_fromToMotion();
    init_id();
    init_defaultColors();
    init_chartUpdateType();
  }
});

// packages/ag-charts-community/src/main.ts
var main_exports = {};
__export(main_exports, {
  AgChart: () => AgChart,
  AgCharts: () => AgCharts,
  AgErrorBarSupportedSeriesTypes: () => AgErrorBarSupportedSeriesTypes,
  AgTooltipPositionType: () => AgTooltipPositionType,
  Marker: () => Marker,
  VERSION: () => VERSION,
  _ModuleSupport: () => module_support_exports,
  _Scale: () => sparklines_scale_exports,
  _Scene: () => integrated_charts_scene_exports,
  _Theme: () => integrated_charts_theme_exports,
  _Util: () => sparklines_util_exports,
  __FORCE_MODULE_DETECTION: () => __FORCE_MODULE_DETECTION,
  time: () => time_exports
});
var init_main = __esm({
  "packages/ag-charts-community/src/main.ts"() {
    "use strict";
    init_agChartOptions();
    init_time();
    init_agChartV2();
    init_version();
    init_marker();
    init_integrated_charts_scene();
    init_integrated_charts_theme();
    init_sparklines_scale();
    init_sparklines_util();
    init_module_support();
  }
});

// packages/ag-charts-enterprise/dist/package/main.cjs.js
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __reflectGet2 = Reflect.get;
var __pow2 = Math.pow;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b) => __defProps2(a, __getOwnPropDescs2(b));
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp2(target, name, { get: all[name], enumerable: true });
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod2, secondTarget) => (__copyProps2(target, mod2, "default"), secondTarget && __copyProps2(secondTarget, mod2, "default"));
var __toCommonJS2 = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
var __decorateClass2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp2(target, key, result);
  return result;
};
var __superGet2 = (cls, obj, key) => __reflectGet2(__getProtoOf2(cls), key, obj);
var __async2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var main_exports2 = {};
__export2(main_exports2, {
  AgCharts: () => import_ag_charts_community139.AgCharts,
  time: () => import_ag_charts_community139.time
});
module.exports = __toCommonJS2(main_exports2);
var import_ag_charts_community139 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community138 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community = (init_main(), __toCommonJS(main_exports));
var ANGLE_AXIS_THEME = {
  __extends__: import_ag_charts_community._Theme.EXTENDS_AXES_DEFAULTS,
  gridLine: {
    enabled: false,
    __extends__: import_ag_charts_community._Theme.EXTENDS_AXES_GRID_LINE_DEFAULTS
  }
};
var import_ag_charts_community5 = (init_main(), __toCommonJS(main_exports));
function loopSymmetrically(items, step, iterator) {
  const loop = (start, end, loopStep, loopIterator) => {
    let prev = items[0];
    for (let i = start; loopStep > 0 ? i <= end : i > end; i += loopStep) {
      const curr = items[i];
      if (loopIterator(prev, curr))
        return true;
      prev = curr;
    }
    return false;
  };
  const midIndex = Math.floor(items.length / 2);
  if (loop(step, midIndex, step, iterator))
    return true;
  return loop(items.length - step, midIndex, -step, iterator);
}
var import_ag_charts_community4 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community3 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community2 = (init_main(), __toCommonJS(main_exports));
var {
  ChartAxisDirection: ChartAxisDirection2,
  Layers: Layers2,
  ARRAY: ARRAY2,
  BOOLEAN: BOOLEAN2,
  COLOR_STRING: COLOR_STRING2,
  FONT_STYLE: FONT_STYLE2,
  FONT_WEIGHT: FONT_WEIGHT3,
  LINE_DASH: LINE_DASH2,
  NUMBER: NUMBER2,
  POSITIVE_NUMBER: POSITIVE_NUMBER2,
  RATIO: RATIO2,
  STRING: STRING2,
  UNION: UNION2,
  AND: AND2,
  Validate: Validate2,
  MATCHING_CROSSLINE_TYPE: MATCHING_CROSSLINE_TYPE2
} = import_ag_charts_community2._ModuleSupport;
var { Group: Group2 } = import_ag_charts_community2._Scene;
var { createId: createId2 } = import_ag_charts_community2._Util;
var PolarCrossLineLabel = class {
  constructor() {
    this.enabled = void 0;
    this.text = void 0;
    this.fontStyle = void 0;
    this.fontWeight = void 0;
    this.fontSize = 14;
    this.fontFamily = "Verdana, sans-serif";
    this.padding = 5;
    this.color = "rgba(87, 87, 87, 1)";
    this.parallel = void 0;
  }
};
__decorateClass2([
  Validate2(BOOLEAN2, { optional: true })
], PolarCrossLineLabel.prototype, "enabled", 2);
__decorateClass2([
  Validate2(STRING2, { optional: true })
], PolarCrossLineLabel.prototype, "text", 2);
__decorateClass2([
  Validate2(FONT_STYLE2, { optional: true })
], PolarCrossLineLabel.prototype, "fontStyle", 2);
__decorateClass2([
  Validate2(FONT_WEIGHT3, { optional: true })
], PolarCrossLineLabel.prototype, "fontWeight", 2);
__decorateClass2([
  Validate2(POSITIVE_NUMBER2)
], PolarCrossLineLabel.prototype, "fontSize", 2);
__decorateClass2([
  Validate2(STRING2)
], PolarCrossLineLabel.prototype, "fontFamily", 2);
__decorateClass2([
  Validate2(NUMBER2)
], PolarCrossLineLabel.prototype, "padding", 2);
__decorateClass2([
  Validate2(COLOR_STRING2, { optional: true })
], PolarCrossLineLabel.prototype, "color", 2);
__decorateClass2([
  Validate2(BOOLEAN2, { optional: true })
], PolarCrossLineLabel.prototype, "parallel", 2);
var _PolarCrossLine = class _PolarCrossLine2 {
  constructor() {
    this.id = createId2(this);
    this.enabled = void 0;
    this.type = void 0;
    this.range = void 0;
    this.value = void 0;
    this.fill = void 0;
    this.fillOpacity = void 0;
    this.stroke = void 0;
    this.strokeWidth = void 0;
    this.strokeOpacity = void 0;
    this.lineDash = void 0;
    this.shape = "polygon";
    this.label = new PolarCrossLineLabel();
    this.scale = void 0;
    this.clippedRange = [-Infinity, Infinity];
    this.gridLength = 0;
    this.sideFlag = -1;
    this.parallelFlipRotation = 0;
    this.regularFlipRotation = 0;
    this.direction = ChartAxisDirection2.X;
    this.axisInnerRadius = 0;
    this.axisOuterRadius = 0;
    this.group = new Group2({ name: `${this.id}`, layer: true, zIndex: _PolarCrossLine2.LINE_LAYER_ZINDEX });
    this.labelGroup = new Group2({ name: `${this.id}`, layer: true, zIndex: _PolarCrossLine2.LABEL_LAYER_ZINDEX });
  }
  setSectorNodeProps(node) {
    var _a2, _b, _c;
    node.fill = this.fill;
    node.fillOpacity = (_a2 = this.fillOpacity) != null ? _a2 : 1;
    node.stroke = this.stroke;
    node.strokeOpacity = (_b = this.strokeOpacity) != null ? _b : 1;
    node.strokeWidth = (_c = this.strokeWidth) != null ? _c : 1;
    node.lineDash = this.lineDash;
  }
  setLabelNodeProps(node, x, y, baseline, rotation) {
    const { label } = this;
    node.x = x;
    node.y = y;
    node.text = label.text;
    node.textAlign = "center";
    node.textBaseline = baseline;
    node.rotation = rotation;
    node.rotationCenterX = x;
    node.rotationCenterY = y;
    node.fill = label.color;
    node.fontFamily = label.fontFamily;
    node.fontSize = label.fontSize;
    node.fontStyle = label.fontStyle;
    node.visible = true;
  }
  calculateLayout(_visible) {
    return;
  }
};
_PolarCrossLine.LINE_LAYER_ZINDEX = Layers2.SERIES_CROSSLINE_LINE_ZINDEX;
_PolarCrossLine.RANGE_LAYER_ZINDEX = Layers2.SERIES_CROSSLINE_RANGE_ZINDEX;
_PolarCrossLine.LABEL_LAYER_ZINDEX = Layers2.SERIES_LABEL_ZINDEX;
__decorateClass2([
  Validate2(BOOLEAN2, { optional: true })
], _PolarCrossLine.prototype, "enabled", 2);
__decorateClass2([
  Validate2(UNION2(["range", "line"], "a crossLine type"), { optional: true })
], _PolarCrossLine.prototype, "type", 2);
__decorateClass2([
  Validate2(AND2(MATCHING_CROSSLINE_TYPE2("range"), ARRAY2.restrict({ length: 2 })), {
    optional: true
  })
], _PolarCrossLine.prototype, "range", 2);
__decorateClass2([
  Validate2(MATCHING_CROSSLINE_TYPE2("value"), { optional: true })
], _PolarCrossLine.prototype, "value", 2);
__decorateClass2([
  Validate2(COLOR_STRING2, { optional: true })
], _PolarCrossLine.prototype, "fill", 2);
__decorateClass2([
  Validate2(RATIO2, { optional: true })
], _PolarCrossLine.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate2(COLOR_STRING2, { optional: true })
], _PolarCrossLine.prototype, "stroke", 2);
__decorateClass2([
  Validate2(NUMBER2, { optional: true })
], _PolarCrossLine.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate2(RATIO2, { optional: true })
], _PolarCrossLine.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate2(LINE_DASH2, { optional: true })
], _PolarCrossLine.prototype, "lineDash", 2);
var PolarCrossLine = _PolarCrossLine;
var { ChartAxisDirection: ChartAxisDirection22, validateCrossLineValues: validateCrossLineValues2 } = import_ag_charts_community3._ModuleSupport;
var { Path: Path2, Sector: Sector2, Text: Text2 } = import_ag_charts_community3._Scene;
var { normalizeAngle360: normalizeAngle3602, isNumberEqual } = import_ag_charts_community3._Util;
var _AngleCrossLine = class _AngleCrossLine2 extends PolarCrossLine {
  constructor() {
    super();
    this.direction = ChartAxisDirection22.X;
    this.polygonNode = new Path2();
    this.sectorNode = new Sector2();
    this.lineNode = new Path2();
    this.labelNode = new Text2();
    this.group.append(this.polygonNode);
    this.group.append(this.sectorNode);
    this.group.append(this.lineNode);
    this.labelGroup.append(this.labelNode);
  }
  update(visible) {
    const { scale: scale2, shape, type, value, range: range22 } = this;
    if (!scale2 || !type || !validateCrossLineValues2(type, value, range22, scale2)) {
      this.group.visible = false;
      this.labelGroup.visible = false;
      return;
    }
    this.group.visible = visible;
    this.labelGroup.visible = visible;
    if (type === "line" && shape === "circle" && scale2 instanceof import_ag_charts_community3._Scale.BandScale) {
      this.type = "range";
      this.range = [value, value];
    }
    this.updateLineNode(visible);
    this.updatePolygonNode(visible);
    this.updateSectorNode(visible);
    this.updateLabelNode(visible);
  }
  updateLineNode(visible) {
    var _a2, _b;
    const { scale: scale2, type, value, lineNode: line } = this;
    let angle;
    if (!visible || type !== "line" || !scale2 || isNaN(angle = scale2.convert(value))) {
      line.visible = false;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    line.visible = true;
    line.stroke = this.stroke;
    line.strokeOpacity = (_a2 = this.strokeOpacity) != null ? _a2 : 1;
    line.strokeWidth = (_b = this.strokeWidth) != null ? _b : 1;
    line.fill = void 0;
    line.lineDash = this.lineDash;
    const x = axisOuterRadius * Math.cos(angle);
    const y = axisOuterRadius * Math.sin(angle);
    const x0 = axisInnerRadius * Math.cos(angle);
    const y0 = axisInnerRadius * Math.sin(angle);
    line.path.clear(true);
    line.path.moveTo(x0, y0);
    line.path.lineTo(x, y);
    this.group.zIndex = _AngleCrossLine2.LINE_LAYER_ZINDEX;
  }
  updatePolygonNode(visible) {
    var _a2;
    const { polygonNode: polygon, range: range22, scale: scale2, shape, type } = this;
    let ticks;
    if (!visible || type !== "range" || shape !== "polygon" || !scale2 || !range22 || !(ticks = (_a2 = scale2.ticks) == null ? void 0 : _a2.call(scale2))) {
      polygon.visible = false;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    const startIndex = ticks.indexOf(range22[0]);
    const endIndex = ticks.indexOf(range22[1]);
    const stops = startIndex <= endIndex ? ticks.slice(startIndex, endIndex + 1) : ticks.slice(startIndex).concat(ticks.slice(0, endIndex + 1));
    const angles = stops.map((value) => scale2.convert(value));
    polygon.visible = true;
    this.setSectorNodeProps(polygon);
    const { path } = polygon;
    path.clear(true);
    angles.forEach((angle, index) => {
      const x = axisOuterRadius * Math.cos(angle);
      const y = axisOuterRadius * Math.sin(angle);
      if (index === 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    });
    if (axisInnerRadius === 0) {
      path.lineTo(0, 0);
    } else {
      angles.slice().reverse().forEach((angle) => {
        const x = axisInnerRadius * Math.cos(angle);
        const y = axisInnerRadius * Math.sin(angle);
        path.lineTo(x, y);
      });
    }
    polygon.path.closePath();
    this.group.zIndex = _AngleCrossLine2.RANGE_LAYER_ZINDEX;
  }
  updateSectorNode(visible) {
    var _a2;
    const { sectorNode: sector, range: range22, scale: scale2, shape, type } = this;
    if (!visible || type !== "range" || shape !== "circle" || !scale2 || !range22) {
      sector.visible = false;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    const angles = range22.map((value) => scale2.convert(value));
    const step = (_a2 = scale2.step) != null ? _a2 : 0;
    const padding = scale2 instanceof import_ag_charts_community3._Scale.BandScale ? step / 2 : 0;
    sector.visible = true;
    this.setSectorNodeProps(sector);
    sector.centerX = 0;
    sector.centerY = 0;
    sector.innerRadius = axisInnerRadius;
    sector.outerRadius = axisOuterRadius;
    sector.startAngle = angles[0] - padding;
    sector.endAngle = angles[1] + padding;
    this.group.zIndex = _AngleCrossLine2.RANGE_LAYER_ZINDEX;
  }
  updateLabelNode(visible) {
    var _a2, _b;
    const { label, labelNode: node, range: range22, scale: scale2, type } = this;
    if (!visible || label.enabled === false || !label.text || !scale2 || type === "range" && !range22) {
      node.visible = true;
      return;
    }
    const { axisInnerRadius, axisOuterRadius } = this;
    let labelX;
    let labelY;
    let rotation;
    let textBaseline;
    if (type === "line") {
      const angle = normalizeAngle3602(scale2.convert(this.value));
      const angle270 = 1.5 * Math.PI;
      const isRightSide = isNumberEqual(angle, angle270) || angle > angle270 || angle < Math.PI / 2;
      const midX = (axisInnerRadius + axisOuterRadius) / 2 * Math.cos(angle);
      const midY = (axisInnerRadius + axisOuterRadius) / 2 * Math.sin(angle);
      labelX = midX + label.padding * Math.cos(angle + Math.PI / 2);
      labelY = midY + label.padding * Math.sin(angle + Math.PI / 2);
      textBaseline = isRightSide ? "top" : "bottom";
      rotation = isRightSide ? angle : angle - Math.PI;
    } else {
      const [startAngle, endAngle] = range22.map((value) => normalizeAngle3602(scale2.convert(value)));
      let angle = (startAngle + endAngle) / 2;
      if (startAngle > endAngle) {
        angle -= Math.PI;
      }
      angle = normalizeAngle3602(angle);
      const isBottomSide = (isNumberEqual(angle, 0) || angle > 0) && angle < Math.PI;
      let distance2;
      const ticks = (_b = (_a2 = scale2.ticks) == null ? void 0 : _a2.call(scale2)) != null ? _b : [];
      if (this.shape === "circle" || ticks.length < 3) {
        distance2 = axisOuterRadius - label.padding;
      } else {
        distance2 = axisOuterRadius * Math.cos(Math.PI / ticks.length) - label.padding;
      }
      labelX = distance2 * Math.cos(angle);
      labelY = distance2 * Math.sin(angle);
      textBaseline = isBottomSide ? "bottom" : "top";
      rotation = isBottomSide ? angle - Math.PI / 2 : angle + Math.PI / 2;
    }
    this.setLabelNodeProps(node, labelX, labelY, textBaseline, rotation);
  }
};
_AngleCrossLine.className = "AngleCrossLine";
var AngleCrossLine = _AngleCrossLine;
var {
  AND: AND22,
  assignJsonApplyConstructedArray: assignJsonApplyConstructedArray2,
  ChartAxisDirection: ChartAxisDirection3,
  GREATER_THAN: GREATER_THAN2,
  NUMBER: NUMBER22,
  UNION: UNION22,
  ProxyOnWrite: ProxyOnWrite2,
  Validate: Validate22
} = import_ag_charts_community4._ModuleSupport;
var { Path: Path22, Text: Text22 } = import_ag_charts_community4._Scene;
var { angleBetween: angleBetween2, isNumberEqual: isNumberEqual2, toRadians: toRadians2, normalizeAngle360: normalizeAngle36022 } = import_ag_charts_community4._Util;
var AngleAxisLabel = class extends import_ag_charts_community4._ModuleSupport.AxisLabel {
  constructor() {
    super(...arguments);
    this.orientation = "fixed";
  }
};
__decorateClass2([
  Validate22(UNION22(["fixed", "parallel", "perpendicular"], "a label orientation"))
], AngleAxisLabel.prototype, "orientation", 2);
var AngleAxis = class extends import_ag_charts_community4._ModuleSupport.PolarAxis {
  constructor(moduleCtx, scale2) {
    super(moduleCtx, scale2);
    this.startAngle = 0;
    this.endAngle = void 0;
    this.labelData = [];
    this.tickData = [];
    this.radiusLine = this.axisGroup.appendChild(new Path22());
    this.computeRange = () => {
      const startAngle = normalizeAngle36022(-Math.PI / 2 + toRadians2(this.startAngle));
      let endAngle = this.endAngle == null ? startAngle + Math.PI * 2 : -Math.PI / 2 + toRadians2(this.endAngle);
      if (endAngle < startAngle) {
        endAngle += 2 * Math.PI;
      }
      this.range = [startAngle, endAngle];
    };
    this.includeInvisibleDomains = true;
  }
  get direction() {
    return ChartAxisDirection3.X;
  }
  assignCrossLineArrayConstructor(crossLines) {
    assignJsonApplyConstructedArray2(crossLines, AngleCrossLine);
  }
  createLabel() {
    return new AngleAxisLabel();
  }
  update() {
    this.updateScale();
    this.updatePosition();
    this.updateGridLines();
    this.updateTickLines();
    this.updateLabels();
    this.updateRadiusLine();
    this.updateCrossLines();
    return this.tickData.length;
  }
  calculateAvailableRange() {
    const { range: range22, gridLength: radius } = this;
    return angleBetween2(range22[0], range22[1]) * radius;
  }
  updatePosition() {
    const { translation, axisGroup, gridGroup, crossLineGroup } = this;
    const translationX = Math.floor(translation.x);
    const translationY = Math.floor(translation.y);
    axisGroup.translationX = translationX;
    axisGroup.translationY = translationY;
    gridGroup.translationX = translationX;
    gridGroup.translationY = translationY;
    crossLineGroup.translationX = translationX;
    crossLineGroup.translationY = translationY;
  }
  updateRadiusLine() {
    const node = this.radiusLine;
    const { path } = node;
    path.clear(true);
    const { points, closePath } = this.getAxisLinePoints();
    points.forEach(({ x, y, moveTo, arc, radius = 0, startAngle = 0, endAngle = 0 }) => {
      if (arc) {
        path.arc(x, y, radius, startAngle, endAngle);
      } else if (moveTo) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    });
    if (closePath) {
      path.closePath();
    }
    node.visible = this.line.enabled;
    node.stroke = this.line.color;
    node.strokeWidth = this.line.width;
    node.fill = void 0;
  }
  getAxisLinePoints() {
    var _a2, _b;
    const { scale: scale2, shape, gridLength: radius } = this;
    const [startAngle, endAngle] = this.range;
    const isFullCircle = isNumberEqual2(endAngle - startAngle, 2 * Math.PI);
    const points = [];
    if (shape === "circle") {
      if (isFullCircle) {
        points.push({ x: radius, y: 0, moveTo: true });
        points.push({
          x: 0,
          y: 0,
          radius,
          startAngle: 0,
          endAngle: 2 * Math.PI,
          arc: true,
          moveTo: false
        });
      } else {
        points.push({
          x: radius * Math.cos(startAngle),
          y: radius * Math.sin(startAngle),
          moveTo: true
        });
        points.push({
          x: 0,
          y: 0,
          radius,
          startAngle: normalizeAngle36022(startAngle),
          endAngle: normalizeAngle36022(endAngle),
          arc: true,
          moveTo: false
        });
      }
    } else if (shape === "polygon") {
      const angles = ((_b = (_a2 = scale2.ticks) == null ? void 0 : _a2.call(scale2)) != null ? _b : []).map((value) => scale2.convert(value));
      if (angles.length > 2) {
        angles.forEach((angle, i) => {
          const x = radius * Math.cos(angle);
          const y = radius * Math.sin(angle);
          const moveTo = i === 0;
          points.push({ x, y, moveTo });
        });
      }
    }
    return { points, closePath: isFullCircle };
  }
  updateGridLines() {
    const {
      scale: scale2,
      gridLength: radius,
      gridLine: { enabled, style, width },
      innerRadiusRatio
    } = this;
    if (!(style && radius > 0)) {
      return;
    }
    const ticks = this.tickData;
    const innerRadius = radius * innerRadiusRatio;
    const styleCount = style.length;
    const idFn = (datum) => datum.value;
    this.gridLineGroupSelection.update(enabled ? ticks : [], void 0, idFn).each((line, datum, index) => {
      const { value } = datum;
      const { stroke, lineDash } = style[index % styleCount];
      const angle = scale2.convert(value);
      line.x1 = innerRadius * Math.cos(angle);
      line.y1 = innerRadius * Math.sin(angle);
      line.x2 = radius * Math.cos(angle);
      line.y2 = radius * Math.sin(angle);
      line.stroke = stroke;
      line.strokeWidth = width;
      line.lineDash = lineDash;
      line.fill = void 0;
    });
    this.gridLineGroupSelection.cleanup();
  }
  updateLabels() {
    const { label, tickLabelGroupSelection } = this;
    const ticks = this.tickData;
    tickLabelGroupSelection.update(label.enabled ? ticks : []).each((node, _, index) => {
      const labelDatum = this.labelData[index];
      if (!labelDatum || labelDatum.hidden) {
        node.visible = false;
        return;
      }
      node.text = labelDatum.text;
      node.setFont(label);
      node.fill = label.color;
      node.x = labelDatum.x;
      node.y = labelDatum.y;
      node.textAlign = labelDatum.textAlign;
      node.textBaseline = labelDatum.textBaseline;
      node.visible = true;
      if (labelDatum.rotation) {
        node.rotation = labelDatum.rotation;
        node.rotationCenterX = labelDatum.x;
        node.rotationCenterY = labelDatum.y;
      } else {
        node.rotation = 0;
      }
    });
  }
  updateTickLines() {
    const { scale: scale2, gridLength: radius, tick, tickLineGroupSelection } = this;
    const ticks = this.tickData;
    tickLineGroupSelection.update(tick.enabled ? ticks : []).each((line, datum) => {
      const { value } = datum;
      const angle = scale2.convert(value);
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      line.x1 = radius * cos;
      line.y1 = radius * sin;
      line.x2 = (radius + tick.size) * cos;
      line.y2 = (radius + tick.size) * sin;
      line.stroke = tick.color;
      line.strokeWidth = tick.width;
    });
  }
  createLabelNodeData(ticks, options, seriesRect) {
    const { label, gridLength: radius, scale: scale2, tick } = this;
    if (!label.enabled) {
      return [];
    }
    const tempText2 = new Text22();
    const seriesLeft = seriesRect.x - this.translation.x;
    const seriesRight = seriesRect.x + seriesRect.width - this.translation.x;
    const labelData = ticks.map((datum, index) => {
      var _a2;
      const { value } = datum;
      const distance2 = radius + label.padding + tick.size;
      const angle = scale2.convert(value);
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const x = distance2 * cos;
      const y = distance2 * sin;
      const { textAlign, textBaseline } = this.getLabelAlign(angle);
      const isLastTickOverFirst = index === ticks.length - 1 && value !== ticks[0] && isNumberEqual2(normalizeAngle36022(angle), normalizeAngle36022(scale2.convert(ticks[0])));
      const rotation = this.getLabelRotation(angle);
      let text = String(value);
      if (label.formatter) {
        const { callbackCache } = this.moduleCtx;
        text = (_a2 = callbackCache.call(label.formatter, { value, index })) != null ? _a2 : "";
      }
      tempText2.text = text;
      tempText2.x = x;
      tempText2.y = y;
      tempText2.setFont(label);
      tempText2.textAlign = textAlign;
      tempText2.textBaseline = textBaseline;
      tempText2.rotation = rotation;
      if (rotation) {
        tempText2.rotationCenterX = x;
        tempText2.rotationCenterY = y;
      }
      let box = rotation ? tempText2.computeTransformedBBox() : tempText2.computeBBox();
      if (box && options.hideWhenNecessary && !rotation) {
        const overflowLeft = seriesLeft - box.x;
        const overflowRight = box.x + box.width - seriesRight;
        const pixelError = 1;
        if (overflowLeft > pixelError || overflowRight > pixelError) {
          const availWidth = box.width - Math.max(overflowLeft, overflowRight);
          ({ text } = Text22.wrap(text, availWidth, Infinity, label, "never"));
          if (text === "\u2026") {
            text = "";
            box = void 0;
          }
          tempText2.text = text;
          box = tempText2.computeBBox();
        }
      }
      return {
        text,
        x,
        y,
        textAlign,
        textBaseline,
        hidden: text === "" || datum.hidden || isLastTickOverFirst,
        rotation,
        box
      };
    });
    if (label.avoidCollisions) {
      this.avoidLabelCollisions(labelData);
    }
    return labelData;
  }
  computeLabelsBBox(options, seriesRect) {
    this.tickData = this.generateAngleTicks();
    this.labelData = this.createLabelNodeData(this.tickData, options, seriesRect);
    const textBoxes = this.labelData.map(({ box }) => box).filter((box) => box != null);
    if (!this.label.enabled || textBoxes.length === 0) {
      return null;
    }
    return import_ag_charts_community4._Scene.BBox.merge(textBoxes);
  }
  getLabelOrientation() {
    const { label } = this;
    return label instanceof AngleAxisLabel ? label.orientation : "fixed";
  }
  getLabelRotation(tickAngle) {
    var _a2;
    let rotation = toRadians2((_a2 = this.label.rotation) != null ? _a2 : 0);
    tickAngle = normalizeAngle36022(tickAngle);
    const orientation = this.getLabelOrientation();
    if (orientation === "parallel") {
      rotation += tickAngle;
      if (tickAngle >= 0 && tickAngle < Math.PI) {
        rotation -= Math.PI / 2;
      } else {
        rotation += Math.PI / 2;
      }
    } else if (orientation === "perpendicular") {
      rotation += tickAngle;
      if (tickAngle >= Math.PI / 2 && tickAngle < 1.5 * Math.PI) {
        rotation += Math.PI;
      }
    }
    return rotation;
  }
  getLabelAlign(tickAngle) {
    const cos = Math.cos(tickAngle);
    const sin = Math.sin(tickAngle);
    let textAlign;
    let textBaseline;
    const orientation = this.getLabelOrientation();
    const isCos0 = isNumberEqual2(cos, 0);
    const isSin0 = isNumberEqual2(sin, 0);
    const isCos1 = isNumberEqual2(cos, 1);
    const isSinMinus1 = isNumberEqual2(sin, -1);
    const isCosPositive = cos > 0 && !isCos0;
    const isSinPositive = sin > 0 && !isSin0;
    if (orientation === "parallel") {
      textAlign = "center";
      textBaseline = isCos1 && isSin0 || isSinPositive ? "top" : "bottom";
    } else if (orientation === "perpendicular") {
      textAlign = isSinMinus1 || isCosPositive ? "left" : "right";
      textBaseline = "middle";
    } else {
      textAlign = "right";
      if (isCos0) {
        textAlign = "center";
      } else if (isCosPositive) {
        textAlign = "left";
      }
      textBaseline = "bottom";
      if (isSin0) {
        textBaseline = "middle";
      } else if (isSinPositive) {
        textBaseline = "top";
      }
    }
    return { textAlign, textBaseline };
  }
  updateCrossLines() {
    var _a2;
    (_a2 = this.crossLines) == null ? void 0 : _a2.forEach((crossLine) => {
      if (crossLine instanceof AngleCrossLine) {
        const { shape, gridLength: radius, innerRadiusRatio } = this;
        crossLine.shape = shape;
        crossLine.axisOuterRadius = radius;
        crossLine.axisInnerRadius = radius * innerRadiusRatio;
      }
    });
    super.updateCrossLines({ rotation: 0, parallelFlipRotation: 0, regularFlipRotation: 0 });
  }
};
__decorateClass2([
  ProxyOnWrite2("rotation"),
  Validate22(NUMBER22.restrict({ min: 0, max: 360 }))
], AngleAxis.prototype, "startAngle", 2);
__decorateClass2([
  Validate22(AND22(NUMBER22.restrict({ min: 0, max: 720 }), GREATER_THAN2("startAngle")), { optional: true })
], AngleAxis.prototype, "endAngle", 2);
var { RATIO: RATIO22, OR: OR2, POSITIVE_NUMBER: POSITIVE_NUMBER22, NAN: NAN2, Validate: Validate3 } = import_ag_charts_community5._ModuleSupport;
var { BandScale: BandScale2 } = import_ag_charts_community5._Scale;
var { isNumberEqual: isNumberEqual3 } = import_ag_charts_community5._Util;
var AngleCategoryAxisTick = class extends import_ag_charts_community5._ModuleSupport.AxisTick {
  constructor() {
    super(...arguments);
    this.minSpacing = NaN;
  }
};
__decorateClass2([
  Validate3(OR2(POSITIVE_NUMBER22, NAN2))
], AngleCategoryAxisTick.prototype, "minSpacing", 2);
var AngleCategoryAxis = class extends AngleAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new BandScale2());
    this.groupPaddingInner = 0;
    this.paddingInner = 0;
  }
  createTick() {
    return new AngleCategoryAxisTick();
  }
  generateAngleTicks() {
    var _a2, _b;
    const { scale: scale2, tick, gridLength: radius } = this;
    const ticks = (_b = (_a2 = tick.values) != null ? _a2 : scale2.ticks()) != null ? _b : [];
    if (ticks.length < 2 || isNaN(tick.minSpacing)) {
      return ticks.map((value) => {
        return { value, visible: true };
      });
    }
    const startTick = ticks[0];
    const startAngle = scale2.convert(startTick);
    const startX = radius * Math.cos(startAngle);
    const startY = radius * Math.sin(startAngle);
    for (let step = 1; step < ticks.length - 1; step++) {
      const nextTick = ticks[step];
      const nextAngle = scale2.convert(nextTick);
      if (nextAngle - startAngle > Math.PI) {
        break;
      }
      const nextX = radius * Math.cos(nextAngle);
      const nextY = radius * Math.sin(nextAngle);
      const spacing = Math.sqrt(__pow2(nextX - startX, 2) + __pow2(nextY - startY, 2));
      if (spacing > tick.minSpacing) {
        const visibleTicks = /* @__PURE__ */ new Set([startTick]);
        loopSymmetrically(ticks, step, (_, next) => {
          visibleTicks.add(next);
        });
        return ticks.map((value) => {
          const visible = visibleTicks.has(value);
          return { value, visible };
        });
      }
    }
    return [{ value: startTick, visible: true }];
  }
  avoidLabelCollisions(labelData) {
    let { minSpacing } = this.label;
    if (!Number.isFinite(minSpacing)) {
      minSpacing = 0;
    }
    if (labelData.length < 3) {
      return;
    }
    const labelsCollide = (prev, next) => {
      if (prev.hidden || next.hidden) {
        return false;
      }
      const prevBox = prev.box.clone().grow(minSpacing / 2);
      const nextBox = next.box.clone().grow(minSpacing / 2);
      return prevBox.collidesBBox(nextBox);
    };
    const firstLabel = labelData[0];
    const lastLabel = labelData.at(-1);
    const visibleLabels = /* @__PURE__ */ new Set([firstLabel]);
    const lastLabelIsOverFirst = isNumberEqual3(firstLabel.x, lastLabel.x) && isNumberEqual3(firstLabel.y, lastLabel.y);
    const maxStep = Math.floor(labelData.length / 2);
    for (let step = 1; step <= maxStep; step++) {
      const labels = lastLabelIsOverFirst ? labelData.slice(0, -1) : labelData;
      const collisionDetected = loopSymmetrically(labels, step, labelsCollide);
      if (!collisionDetected) {
        loopSymmetrically(labels, step, (_, next) => {
          visibleLabels.add(next);
        });
        break;
      }
    }
    labelData.forEach((datum) => {
      if (!visibleLabels.has(datum)) {
        datum.hidden = true;
        datum.box = void 0;
      }
    });
  }
};
AngleCategoryAxis.className = "AngleCategoryAxis";
AngleCategoryAxis.type = "angle-category";
__decorateClass2([
  Validate3(RATIO22)
], AngleCategoryAxis.prototype, "groupPaddingInner", 2);
__decorateClass2([
  Validate3(RATIO22)
], AngleCategoryAxis.prototype, "paddingInner", 2);
var AngleCategoryAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "angle-category",
  instanceConstructor: AngleCategoryAxis,
  themeTemplate: ANGLE_AXIS_THEME
};
var import_ag_charts_community7 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community6 = (init_main(), __toCommonJS(main_exports));
var { LinearScale: LinearScale2, Invalidating: Invalidating2 } = import_ag_charts_community6._Scale;
var { isNumberEqual: isNumberEqual4, range: range3, isDenseInterval: isDenseInterval2 } = import_ag_charts_community6._Util;
var LinearAngleScale = class extends LinearScale2 {
  constructor() {
    super(...arguments);
    this.arcLength = 0;
    this.niceTickStep = 0;
  }
  ticks() {
    if (!this.domain || this.domain.length < 2 || this.domain.some((d) => !isFinite(d)) || this.arcLength <= 0) {
      return [];
    }
    this.refresh();
    const [d0, d1] = this.getDomain();
    const { interval } = this;
    if (interval) {
      const step2 = Math.abs(interval);
      const availableRange = this.getPixelRange();
      if (!isDenseInterval2({ start: d0, stop: d1, interval: step2, availableRange })) {
        return range3(d0, d1, step2);
      }
    }
    const step = this.nice && this.niceTickStep ? this.niceTickStep : this.getTickStep(d0, d1);
    return range3(d0, d1, step);
  }
  hasNiceRange() {
    const sortedRange = this.range.slice().sort((a, b) => a - b);
    const niceRanges = [Math.PI, 2 * Math.PI];
    return niceRanges.some((r) => isNumberEqual4(r, sortedRange[1] - sortedRange[0]));
  }
  getNiceStepAndTickCount() {
    const [start, stop] = this.niceDomain;
    let step = this.getTickStep(start, stop);
    const maxTickCount = isNaN(this.maxTickCount) ? Infinity : this.maxTickCount;
    const expectedTickCount = Math.abs(stop - start) / step;
    let niceTickCount = Math.pow(2, Math.ceil(Math.log(expectedTickCount) / Math.log(2)));
    if (niceTickCount > maxTickCount) {
      niceTickCount /= 2;
      step *= 2;
    }
    return {
      count: niceTickCount,
      step
    };
  }
  updateNiceDomain() {
    super.updateNiceDomain();
    if (!this.hasNiceRange()) {
      return;
    }
    const reversed = this.niceDomain[0] > this.niceDomain[1];
    const start = reversed ? this.niceDomain[1] : this.niceDomain[0];
    const { step, count } = this.getNiceStepAndTickCount();
    const s = 1 / step;
    const stop = step >= 1 ? Math.ceil(start / step + count) * step : Math.ceil((start + count * step) * s) / s;
    this.niceDomain = reversed ? [stop, start] : [start, stop];
    this.niceTickStep = step;
  }
  getPixelRange() {
    return this.arcLength;
  }
};
__decorateClass2([
  Invalidating2
], LinearAngleScale.prototype, "arcLength", 2);
var { AND: AND3, Default: Default2, GREATER_THAN: GREATER_THAN22, LESS_THAN: LESS_THAN2, OR: OR22, POSITIVE_NUMBER: POSITIVE_NUMBER3, NAN: NAN22, NUMBER_OR_NAN: NUMBER_OR_NAN2, MIN_SPACING: MIN_SPACING2, Validate: Validate4 } = import_ag_charts_community7._ModuleSupport;
var { angleBetween: angleBetween22, isNumberEqual: isNumberEqual5, normalisedExtentWithMetadata: normalisedExtentWithMetadata2 } = import_ag_charts_community7._Util;
var AngleNumberAxisTick = class extends import_ag_charts_community7._ModuleSupport.AxisTick {
  constructor() {
    super(...arguments);
    this.minSpacing = NaN;
    this.maxSpacing = NaN;
  }
};
__decorateClass2([
  Validate4(OR22(POSITIVE_NUMBER3, NAN22))
], AngleNumberAxisTick.prototype, "minSpacing", 2);
__decorateClass2([
  Validate4(MIN_SPACING2),
  Default2(NaN)
], AngleNumberAxisTick.prototype, "maxSpacing", 2);
var AngleNumberAxis = class extends AngleAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new LinearAngleScale());
    this.shape = "circle";
    this.min = NaN;
    this.max = NaN;
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent6, clipped } = normalisedExtentWithMetadata2(d, min, max);
    return { domain: extent6, clipped };
  }
  createTick() {
    return new AngleNumberAxisTick();
  }
  getRangeArcLength() {
    const { range: requestedRange } = this;
    const min = Math.min(...requestedRange);
    const max = Math.max(...requestedRange);
    const rotation = angleBetween22(min, max) || 2 * Math.PI;
    const radius = this.gridLength;
    return rotation * radius;
  }
  generateAngleTicks() {
    var _a2;
    const arcLength = this.getRangeArcLength();
    const { scale: scale2, tick, range: requestedRange } = this;
    const { minSpacing = NaN, maxSpacing = NaN } = tick;
    const minTicksCount = maxSpacing ? Math.floor(arcLength / maxSpacing) : 1;
    const maxTicksCount = minSpacing ? Math.floor(arcLength / minSpacing) : Infinity;
    const preferredTicksCount = Math.floor(4 / Math.PI * Math.abs(requestedRange[0] - requestedRange[1]));
    scale2.tickCount = Math.max(minTicksCount, Math.min(maxTicksCount, preferredTicksCount));
    scale2.minTickCount = minTicksCount;
    scale2.maxTickCount = maxTicksCount;
    scale2.arcLength = arcLength;
    const ticks = (_a2 = tick.values) != null ? _a2 : scale2.ticks();
    return ticks.map((value) => {
      return { value, visible: true };
    });
  }
  avoidLabelCollisions(labelData) {
    let { minSpacing } = this.label;
    if (!Number.isFinite(minSpacing)) {
      minSpacing = 0;
    }
    const labelsCollide = (prev, next) => {
      if (prev.hidden || next.hidden) {
        return false;
      }
      const prevBox = prev.box.clone().grow(minSpacing / 2);
      const nextBox = next.box.clone().grow(minSpacing / 2);
      return prevBox.collidesBBox(nextBox);
    };
    const firstLabel = labelData[0];
    const lastLabel = labelData.at(-1);
    if (firstLabel !== lastLabel && isNumberEqual5(firstLabel.x, lastLabel.x) && isNumberEqual5(firstLabel.y, lastLabel.y)) {
      lastLabel.hidden = true;
    }
    for (let step = 1; step < labelData.length; step *= 2) {
      let collisionDetected = false;
      for (let i = step; i < labelData.length; i += step) {
        const next = labelData[i];
        const prev = labelData[i - step];
        if (labelsCollide(prev, next)) {
          collisionDetected = true;
          break;
        }
      }
      if (!collisionDetected) {
        labelData.forEach((datum, i) => {
          if (i % step > 0) {
            datum.hidden = true;
            datum.box = void 0;
          }
        });
        return;
      }
    }
    labelData.forEach((datum, i) => {
      if (i > 0) {
        datum.hidden = true;
        datum.box = void 0;
      }
    });
  }
};
AngleNumberAxis.className = "AngleNumberAxis";
AngleNumberAxis.type = "angle-number";
__decorateClass2([
  Validate4(AND3(NUMBER_OR_NAN2, LESS_THAN2("max"))),
  Default2(NaN)
], AngleNumberAxis.prototype, "min", 2);
__decorateClass2([
  Validate4(AND3(NUMBER_OR_NAN2, GREATER_THAN22("min"))),
  Default2(NaN)
], AngleNumberAxis.prototype, "max", 2);
var AngleNumberAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "angle-number",
  instanceConstructor: AngleNumberAxis,
  themeTemplate: ANGLE_AXIS_THEME
};
var import_ag_charts_community8 = (init_main(), __toCommonJS(main_exports));
var { OrdinalTimeScale: OrdinalTimeScale2 } = import_ag_charts_community8._Scale;
var { dateToNumber: dateToNumber2, Validate: Validate5, Default: Default22, MAX_SPACING: MAX_SPACING2, MIN_SPACING: MIN_SPACING22 } = import_ag_charts_community8._ModuleSupport;
var OrdinalTimeAxisTick = class extends import_ag_charts_community8._ModuleSupport.AxisTick {
  constructor() {
    super(...arguments);
    this.minSpacing = NaN;
    this.maxSpacing = NaN;
  }
};
__decorateClass2([
  Validate5(MIN_SPACING22)
], OrdinalTimeAxisTick.prototype, "minSpacing", 2);
__decorateClass2([
  Validate5(MAX_SPACING2),
  Default22(NaN)
], OrdinalTimeAxisTick.prototype, "maxSpacing", 2);
var OrdinalTimeAxis = class extends import_ag_charts_community8._ModuleSupport.CategoryAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new OrdinalTimeScale2());
  }
  createTick() {
    return new OrdinalTimeAxisTick();
  }
  normaliseDataDomain(d) {
    const domain = [];
    const uniqueValues = /* @__PURE__ */ new Set();
    for (let v of d) {
      if (typeof v === "number") {
        v = new Date(v);
      }
      const key = dateToNumber2(v);
      if (!uniqueValues.has(key)) {
        uniqueValues.add(key);
        domain.push(v);
      }
    }
    domain.sort((a, b) => dateToNumber2(a) - dateToNumber2(b));
    return { domain, clipped: false };
  }
  onLabelFormatChange(ticks, domain, format2) {
    if (format2) {
      super.onLabelFormatChange(ticks, domain, format2);
    } else {
      this.labelFormatter = this.scale.tickFormat({ ticks, domain });
    }
  }
};
OrdinalTimeAxis.className = "OrdinalTimeAxis";
OrdinalTimeAxis.type = "ordinal-time";
var import_ag_charts_community9 = (init_main(), __toCommonJS(main_exports));
var ORDINAL_TIME_AXIS_THEME = {
  __extends__: import_ag_charts_community9._Theme.EXTENDS_AXES_DEFAULTS,
  groupPaddingInner: 0,
  label: {
    autoRotate: false
  },
  gridLine: {
    __extends__: import_ag_charts_community9._Theme.EXTENDS_AXES_GRID_LINE_DEFAULTS,
    enabled: false
  },
  crosshair: {
    enabled: true,
    snap: true,
    stroke: import_ag_charts_community9._Theme.DEFAULT_MUTED_LABEL_COLOUR,
    strokeWidth: 1,
    strokeOpacity: 1,
    lineDash: [5, 6],
    lineDashOffset: 0,
    label: {
      enabled: true
    }
  }
};
var OrdinalTimeAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "ordinal-time",
  instanceConstructor: OrdinalTimeAxis,
  themeTemplate: ORDINAL_TIME_AXIS_THEME
};
var import_ag_charts_community10 = (init_main(), __toCommonJS(main_exports));
var RADIUS_AXIS_THEME = {
  __extends__: import_ag_charts_community10._Theme.EXTENDS_AXES_DEFAULTS,
  line: {
    enabled: false,
    __extends__: import_ag_charts_community10._Theme.EXTENDS_AXES_LINE_DEFAULTS
  },
  tick: {
    enabled: false,
    __extends__: import_ag_charts_community10._Theme.EXTENDS_AXES_TICK_DEFAULTS
  }
};
var import_ag_charts_community13 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community12 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community11 = (init_main(), __toCommonJS(main_exports));
var { ChartAxisDirection: ChartAxisDirection4, Validate: Validate6, DEGREE: DEGREE2, validateCrossLineValues: validateCrossLineValues22 } = import_ag_charts_community11._ModuleSupport;
var { Path: Path3, Sector: Sector22, Text: Text3 } = import_ag_charts_community11._Scene;
var { normalizeAngle360: normalizeAngle3603, toRadians: toRadians22, isNumberEqual: isNumberEqual6 } = import_ag_charts_community11._Util;
var RadiusCrossLineLabel = class extends PolarCrossLineLabel {
  constructor() {
    super(...arguments);
    this.positionAngle = void 0;
  }
};
__decorateClass2([
  Validate6(DEGREE2, { optional: true })
], RadiusCrossLineLabel.prototype, "positionAngle", 2);
var _RadiusCrossLine = class _RadiusCrossLine2 extends PolarCrossLine {
  constructor() {
    super();
    this.direction = ChartAxisDirection4.Y;
    this.label = new RadiusCrossLineLabel();
    this.polygonNode = new Path3();
    this.sectorNode = new Sector22();
    this.labelNode = new Text3();
    this.outerRadius = 0;
    this.innerRadius = 0;
    this.group.append(this.polygonNode);
    this.group.append(this.sectorNode);
    this.labelGroup.append(this.labelNode);
  }
  update(visible) {
    const { scale: scale2, type, value, range: range22 } = this;
    if (!scale2 || !type || !validateCrossLineValues22(type, value, range22, scale2)) {
      this.group.visible = false;
      this.labelGroup.visible = false;
      return;
    }
    if (type === "line" && scale2 instanceof import_ag_charts_community11._Scale.BandScale) {
      this.type = "range";
      this.range = [value, value];
    }
    this.updateRadii();
    const { innerRadius, outerRadius } = this;
    visible && (visible = innerRadius >= this.axisInnerRadius && outerRadius <= this.axisOuterRadius);
    this.group.visible = visible;
    this.labelGroup.visible = visible;
    this.updatePolygonNode(visible);
    this.updateSectorNode(visible);
    this.updateLabelNode(visible);
    this.group.zIndex = this.type === "line" ? _RadiusCrossLine2.LINE_LAYER_ZINDEX : _RadiusCrossLine2.RANGE_LAYER_ZINDEX;
  }
  updateRadii() {
    var _a2;
    const { range: range22, scale: scale2, type, axisInnerRadius, axisOuterRadius } = this;
    if (!scale2)
      return { innerRadius: 0, outerRadius: 0 };
    const getRadius = (value) => axisOuterRadius + axisInnerRadius - value;
    let outerRadius = 0;
    let innerRadius = 0;
    if (type === "line") {
      outerRadius = getRadius(scale2.convert(this.value));
      innerRadius = outerRadius;
    } else {
      const bandwidth = Math.abs((_a2 = scale2 == null ? void 0 : scale2.bandwidth) != null ? _a2 : 0);
      const convertedRange = range22.map((r) => scale2.convert(r));
      outerRadius = getRadius(Math.max(...convertedRange));
      innerRadius = getRadius(Math.min(...convertedRange)) + bandwidth;
    }
    this.outerRadius = outerRadius;
    this.innerRadius = innerRadius;
  }
  drawPolygon(radius, angles, polygon) {
    angles.forEach((angle, index) => {
      const x = radius * Math.cos(angle);
      const y = radius * Math.sin(angle);
      if (index === 0) {
        polygon.path.moveTo(x, y);
      } else {
        polygon.path.lineTo(x, y);
      }
    });
    polygon.path.closePath();
  }
  updatePolygonNode(visible) {
    const { gridAngles, polygonNode: polygon, scale: scale2, shape, type, innerRadius, outerRadius } = this;
    if (!visible || shape !== "polygon" || !scale2 || !gridAngles) {
      polygon.visible = false;
      return;
    }
    polygon.visible = true;
    const padding = this.getPadding();
    polygon.path.clear(true);
    this.drawPolygon(outerRadius - padding, gridAngles, polygon);
    const reversedAngles = gridAngles.slice().reverse();
    const innerPolygonRadius = type === "line" ? outerRadius - padding : innerRadius + padding;
    this.drawPolygon(innerPolygonRadius, reversedAngles, polygon);
    this.setSectorNodeProps(polygon);
  }
  updateSectorNode(visible) {
    const { axisInnerRadius, axisOuterRadius, scale: scale2, sectorNode: sector, shape, innerRadius, outerRadius } = this;
    if (!visible || shape !== "circle" || !scale2) {
      sector.visible = false;
      return;
    }
    sector.visible = true;
    sector.startAngle = 0;
    sector.endAngle = 2 * Math.PI;
    const padding = this.getPadding();
    sector.innerRadius = import_ag_charts_community11._Util.clamp(axisInnerRadius, innerRadius + padding, axisOuterRadius);
    sector.outerRadius = import_ag_charts_community11._Util.clamp(axisInnerRadius, outerRadius - padding, axisOuterRadius);
    this.setSectorNodeProps(sector);
  }
  updateLabelNode(visible) {
    var _a2, _b;
    const { innerRadius, label, labelNode: node, scale: scale2, shape, type } = this;
    if (!visible || label.enabled === false || !label.text || !scale2) {
      node.visible = false;
      return;
    }
    const angle = normalizeAngle3603(toRadians22(((_a2 = label.positionAngle) != null ? _a2 : 0) - 90));
    const isBottomSide = (isNumberEqual6(angle, 0) || angle > 0) && angle < Math.PI;
    const rotation = isBottomSide ? angle - Math.PI / 2 : angle + Math.PI / 2;
    let distance2 = 0;
    const angles = (_b = this.gridAngles) != null ? _b : [];
    if (type === "line") {
      distance2 = innerRadius + label.padding;
    } else if (shape === "circle" || angles.length < 3) {
      distance2 = innerRadius - label.padding;
    } else {
      distance2 = innerRadius * Math.cos(Math.PI / angles.length) - label.padding;
    }
    const labelX = distance2 * Math.cos(angle);
    const labelY = distance2 * Math.sin(angle);
    let textBaseline;
    if (type === "line") {
      textBaseline = isBottomSide ? "top" : "bottom";
    } else {
      textBaseline = isBottomSide ? "bottom" : "top";
    }
    this.setLabelNodeProps(node, labelX, labelY, textBaseline, rotation);
  }
  getPadding() {
    var _a2, _b;
    const { scale: scale2 } = this;
    if (!scale2)
      return 0;
    const bandwidth = Math.abs((_a2 = scale2.bandwidth) != null ? _a2 : 0);
    const step = Math.abs((_b = scale2.step) != null ? _b : 0);
    return scale2 instanceof import_ag_charts_community11._Scale.BandScale ? (step - bandwidth) / 2 : 0;
  }
};
_RadiusCrossLine.className = "RadiusCrossLine";
var RadiusCrossLine = _RadiusCrossLine;
var {
  assignJsonApplyConstructedArray: assignJsonApplyConstructedArray22,
  ChartAxisDirection: ChartAxisDirection5,
  Default: Default3,
  Layers: Layers22,
  DEGREE: DEGREE22,
  MIN_SPACING: MIN_SPACING3,
  MAX_SPACING: MAX_SPACING22,
  BOOLEAN: BOOLEAN22,
  Validate: Validate7
} = import_ag_charts_community12._ModuleSupport;
var { Caption: Caption2, Group: Group22, Path: Path4, Selection: Selection2 } = import_ag_charts_community12._Scene;
var { isNumberEqual: isNumberEqual7, normalizeAngle360: normalizeAngle3604, toRadians: toRadians3 } = import_ag_charts_community12._Util;
var RadiusAxisTick = class extends import_ag_charts_community12._ModuleSupport.AxisTick {
  constructor() {
    super(...arguments);
    this.minSpacing = NaN;
    this.maxSpacing = NaN;
  }
};
__decorateClass2([
  Validate7(MIN_SPACING3),
  Default3(NaN)
], RadiusAxisTick.prototype, "minSpacing", 2);
__decorateClass2([
  Validate7(MAX_SPACING22),
  Default3(NaN)
], RadiusAxisTick.prototype, "maxSpacing", 2);
var RadiusAxisLabel = class extends import_ag_charts_community12._ModuleSupport.AxisLabel {
  constructor() {
    super(...arguments);
    this.autoRotateAngle = 335;
  }
};
__decorateClass2([
  Validate7(BOOLEAN22, { optional: true })
], RadiusAxisLabel.prototype, "autoRotate", 2);
__decorateClass2([
  Validate7(DEGREE22)
], RadiusAxisLabel.prototype, "autoRotateAngle", 2);
var RadiusAxis = class extends import_ag_charts_community12._ModuleSupport.PolarAxis {
  constructor(moduleCtx, scale2) {
    super(moduleCtx, scale2);
    this.positionAngle = 0;
    this.gridPathGroup = this.gridGroup.appendChild(
      new Group22({
        name: `${this.id}-gridPaths`,
        zIndex: Layers22.AXIS_GRID_ZINDEX
      })
    );
    this.gridPathSelection = Selection2.select(this.gridPathGroup, Path4);
  }
  get direction() {
    return ChartAxisDirection5.Y;
  }
  assignCrossLineArrayConstructor(crossLines) {
    assignJsonApplyConstructedArray22(crossLines, RadiusCrossLine);
  }
  getAxisTransform() {
    const maxRadius = this.scale.range[0];
    const { translation, positionAngle, innerRadiusRatio } = this;
    const innerRadius = maxRadius * innerRadiusRatio;
    const rotation = toRadians3(positionAngle);
    return {
      translationX: translation.x,
      translationY: translation.y - maxRadius - innerRadius,
      rotation,
      rotationCenterX: 0,
      rotationCenterY: maxRadius + innerRadius
    };
  }
  updateSelections(lineData, data, params) {
    var _a2;
    super.updateSelections(lineData, data, params);
    const {
      gridLine: { enabled, style, width },
      shape
    } = this;
    if (!style) {
      return;
    }
    const ticks = this.prepareTickData(data);
    const styleCount = style.length;
    const setStyle = (node, index) => {
      const { stroke, lineDash } = style[index % styleCount];
      node.stroke = stroke;
      node.strokeWidth = width;
      node.lineDash = lineDash;
      node.fill = void 0;
    };
    const [startAngle, endAngle] = (_a2 = this.gridRange) != null ? _a2 : [0, 2 * Math.PI];
    const isFullCircle = isNumberEqual7(endAngle - startAngle, 2 * Math.PI);
    const drawCircleShape = (node, value) => {
      const { path } = node;
      path.clear(true);
      const radius = this.getTickRadius(value);
      if (isFullCircle) {
        path.moveTo(radius, 0);
        path.arc(0, 0, radius, 0, 2 * Math.PI);
      } else {
        path.moveTo(radius * Math.cos(startAngle), radius * Math.sin(startAngle));
        path.arc(0, 0, radius, normalizeAngle3604(startAngle), normalizeAngle3604(endAngle));
      }
      if (isFullCircle) {
        path.closePath();
      }
    };
    const drawPolygonShape = (node, value) => {
      const { path } = node;
      const angles = this.gridAngles;
      path.clear(true);
      if (!angles || angles.length < 3) {
        return;
      }
      const radius = this.getTickRadius(value);
      angles.forEach((angle, idx) => {
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        if (idx === 0) {
          path.moveTo(x, y);
        } else {
          path.lineTo(x, y);
        }
        angles.forEach((innerAngle, innerIdx) => {
          const x2 = radius * Math.cos(innerAngle);
          const y2 = radius * Math.sin(innerAngle);
          if (innerIdx === 0) {
            path.moveTo(x2, y2);
          } else {
            path.lineTo(x2, y2);
          }
        });
        path.closePath();
      });
      path.closePath();
    };
    this.gridPathSelection.update(enabled ? ticks : []).each((node, value, index) => {
      setStyle(node, index);
      if (shape === "circle") {
        drawCircleShape(node, value);
      } else {
        drawPolygonShape(node, value);
      }
    });
  }
  updateTitle() {
    var _a2;
    const identityFormatter = (params) => params.defaultValue;
    const {
      title,
      _titleCaption,
      range: requestedRange,
      moduleCtx: { callbackCache }
    } = this;
    const { formatter = identityFormatter } = (_a2 = this.title) != null ? _a2 : {};
    if (!title) {
      _titleCaption.enabled = false;
      return;
    }
    _titleCaption.enabled = title.enabled;
    _titleCaption.fontFamily = title.fontFamily;
    _titleCaption.fontSize = title.fontSize;
    _titleCaption.fontStyle = title.fontStyle;
    _titleCaption.fontWeight = title.fontWeight;
    _titleCaption.color = title.color;
    _titleCaption.wrapping = title.wrapping;
    let titleVisible = false;
    const titleNode = _titleCaption.node;
    if (title.enabled) {
      titleVisible = true;
      titleNode.rotation = Math.PI / 2;
      titleNode.x = Math.floor((requestedRange[0] + requestedRange[1]) / 2);
      titleNode.y = -Caption2.SMALL_PADDING;
      titleNode.textAlign = "center";
      titleNode.textBaseline = "bottom";
      titleNode.text = callbackCache.call(formatter, this.getTitleFormatterParams());
    }
    titleNode.visible = titleVisible;
  }
  createTick() {
    return new RadiusAxisTick();
  }
  updateCrossLines() {
    var _a2;
    (_a2 = this.crossLines) == null ? void 0 : _a2.forEach((crossLine) => {
      if (crossLine instanceof RadiusCrossLine) {
        const { shape, gridAngles, range: range22, innerRadiusRatio } = this;
        const radius = range22[0];
        crossLine.shape = shape;
        crossLine.gridAngles = gridAngles;
        crossLine.axisOuterRadius = radius;
        crossLine.axisInnerRadius = radius * innerRadiusRatio;
      }
    });
    super.updateCrossLines({ rotation: 0, parallelFlipRotation: 0, regularFlipRotation: 0 });
  }
  createLabel() {
    return new RadiusAxisLabel();
  }
};
__decorateClass2([
  Validate7(DEGREE22),
  Default3(0)
], RadiusAxis.prototype, "positionAngle", 2);
var { RATIO: RATIO3, ProxyPropertyOnWrite: ProxyPropertyOnWrite2, Validate: Validate8 } = import_ag_charts_community13._ModuleSupport;
var { BandScale: BandScale22 } = import_ag_charts_community13._Scale;
var RadiusCategoryAxis = class extends RadiusAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new BandScale22());
    this.shape = "circle";
    this.groupPaddingInner = 0;
    this.paddingInner = 0;
    this.paddingOuter = 0;
  }
  prepareTickData(data) {
    return data.slice().reverse();
  }
  getTickRadius(tickDatum) {
    const { scale: scale2 } = this;
    const maxRadius = scale2.range[0];
    const minRadius = maxRadius * this.innerRadiusRatio;
    const tickRange = (maxRadius - minRadius) / scale2.domain.length;
    return maxRadius - tickDatum.translationY + minRadius - tickRange / 2;
  }
};
RadiusCategoryAxis.className = "RadiusCategoryAxis";
RadiusCategoryAxis.type = "radius-category";
__decorateClass2([
  Validate8(RATIO3)
], RadiusCategoryAxis.prototype, "groupPaddingInner", 2);
__decorateClass2([
  ProxyPropertyOnWrite2("scale", "paddingInner"),
  Validate8(RATIO3)
], RadiusCategoryAxis.prototype, "paddingInner", 2);
__decorateClass2([
  ProxyPropertyOnWrite2("scale", "paddingOuter"),
  Validate8(RATIO3)
], RadiusCategoryAxis.prototype, "paddingOuter", 2);
var RadiusCategoryAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radius-category",
  instanceConstructor: RadiusCategoryAxis,
  themeTemplate: RADIUS_AXIS_THEME
};
var import_ag_charts_community14 = (init_main(), __toCommonJS(main_exports));
var { AND: AND4, Default: Default4, GREATER_THAN: GREATER_THAN3, LESS_THAN: LESS_THAN22, NUMBER_OR_NAN: NUMBER_OR_NAN22, Validate: Validate9 } = import_ag_charts_community14._ModuleSupport;
var { LinearScale: LinearScale22 } = import_ag_charts_community14._Scale;
var { normalisedExtentWithMetadata: normalisedExtentWithMetadata22 } = import_ag_charts_community14._Util;
var RadiusNumberAxis = class extends RadiusAxis {
  constructor(moduleCtx) {
    super(moduleCtx, new LinearScale22());
    this.shape = "polygon";
    this.min = NaN;
    this.max = NaN;
  }
  prepareTickData(data) {
    var _a2;
    const { scale: scale2 } = this;
    const domainTop = (_a2 = scale2.getDomain) == null ? void 0 : _a2.call(scale2)[1];
    return data.filter(({ tick }) => tick !== domainTop).sort((a, b) => b.tick - a.tick);
  }
  getTickRadius(tickDatum) {
    const { scale: scale2 } = this;
    const maxRadius = scale2.range[0];
    const minRadius = maxRadius * this.innerRadiusRatio;
    return maxRadius - tickDatum.translationY + minRadius;
  }
  normaliseDataDomain(d) {
    const { min, max } = this;
    const { extent: extent6, clipped } = normalisedExtentWithMetadata22(d, min, max);
    return { domain: extent6, clipped };
  }
};
RadiusNumberAxis.className = "RadiusNumberAxis";
RadiusNumberAxis.type = "radius-number";
__decorateClass2([
  Validate9(AND4(NUMBER_OR_NAN22, LESS_THAN22("max"))),
  Default4(NaN)
], RadiusNumberAxis.prototype, "min", 2);
__decorateClass2([
  Validate9(AND4(NUMBER_OR_NAN22, GREATER_THAN3("min"))),
  Default4(NaN)
], RadiusNumberAxis.prototype, "max", 2);
var RadiusNumberAxisModule = {
  type: "axis",
  optionsKey: "axes[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radius-number",
  instanceConstructor: RadiusNumberAxis,
  themeTemplate: RADIUS_AXIS_THEME
};
var import_ag_charts_community15 = (init_main(), __toCommonJS(main_exports));
var { BOOLEAN: BOOLEAN3, POSITIVE_NUMBER: POSITIVE_NUMBER4, ObserveChanges: ObserveChanges2, Validate: Validate10 } = import_ag_charts_community15._ModuleSupport;
var Animation2 = class extends import_ag_charts_community15._ModuleSupport.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = true;
    ctx.animationManager.skip(false);
  }
};
__decorateClass2([
  ObserveChanges2((target, newValue) => {
    target.ctx.animationManager.skip(!newValue);
  }),
  Validate10(BOOLEAN3)
], Animation2.prototype, "enabled", 2);
__decorateClass2([
  ObserveChanges2((target, newValue) => {
    target.ctx.animationManager.defaultDuration = newValue;
  }),
  Validate10(POSITIVE_NUMBER4, { optional: true })
], Animation2.prototype, "duration", 2);
var AnimationModule = {
  type: "root",
  optionsKey: "animation",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "hierarchy", "topology"],
  instanceConstructor: Animation2,
  themeTemplate: {
    animation: {
      enabled: true
    }
  }
};
var import_ag_charts_community22 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community21 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community16 = (init_main(), __toCommonJS(main_exports));
var { BOOLEAN: BOOLEAN4, COLOR_STRING: COLOR_STRING22, DATE: DATE2, LINE_DASH: LINE_DASH22, NUMBER: NUMBER3, RATIO: RATIO4, STRING: STRING22, OBJECT: OBJECT2, OR: OR3, UNION: UNION3, BaseProperties: BaseProperties2, Validate: Validate11 } = import_ag_charts_community16._ModuleSupport;
var LineAnnotationStylesProperties = class extends BaseProperties2 {
};
__decorateClass2([
  Validate11(COLOR_STRING22, { optional: true })
], LineAnnotationStylesProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate11(RATIO4, { optional: true })
], LineAnnotationStylesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate11(NUMBER3, { optional: true })
], LineAnnotationStylesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate11(LINE_DASH22, { optional: true })
], LineAnnotationStylesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate11(NUMBER3, { optional: true })
], LineAnnotationStylesProperties.prototype, "lineDashOffset", 2);
var ChannelAnnotationStylesProperties = class extends LineAnnotationStylesProperties {
  constructor() {
    super(...arguments);
    this.middle = new LineAnnotationStylesProperties();
    this.background = new AnnotationFillProperties();
  }
};
__decorateClass2([
  Validate11(OBJECT2, { optional: true })
], ChannelAnnotationStylesProperties.prototype, "middle", 2);
__decorateClass2([
  Validate11(OBJECT2, { optional: true })
], ChannelAnnotationStylesProperties.prototype, "background", 2);
var AnnotationProperties = class extends LineAnnotationStylesProperties {
  constructor() {
    super(...arguments);
    this.type = "line";
    this.handle = new AnnotationHandleProperties();
    this.start = new AnnotationPointProperties();
    this.end = new AnnotationPointProperties();
    this.top = new AnnotationLinePointsProperties();
    this.bottom = new AnnotationLinePointsProperties();
    this.middle = new LineAnnotationStylesProperties();
    this.background = new AnnotationFillProperties();
  }
};
__decorateClass2([
  Validate11(UNION3(["line", "parallel-channel"]))
], AnnotationProperties.prototype, "type", 2);
__decorateClass2([
  Validate11(BOOLEAN4, { optional: true })
], AnnotationProperties.prototype, "locked", 2);
__decorateClass2([
  Validate11(BOOLEAN4, { optional: true })
], AnnotationProperties.prototype, "visible", 2);
__decorateClass2([
  Validate11(OBJECT2, { optional: true })
], AnnotationProperties.prototype, "handle", 2);
__decorateClass2([
  Validate11(OBJECT2, { optional: true })
], AnnotationProperties.prototype, "start", 2);
__decorateClass2([
  Validate11(OBJECT2, { optional: true })
], AnnotationProperties.prototype, "end", 2);
__decorateClass2([
  Validate11(OBJECT2, { optional: true })
], AnnotationProperties.prototype, "top", 2);
__decorateClass2([
  Validate11(OBJECT2, { optional: true })
], AnnotationProperties.prototype, "bottom", 2);
__decorateClass2([
  Validate11(OBJECT2, { optional: true })
], AnnotationProperties.prototype, "middle", 2);
__decorateClass2([
  Validate11(OBJECT2, { optional: true })
], AnnotationProperties.prototype, "background", 2);
var AnnotationLinePointsProperties = class extends BaseProperties2 {
  constructor() {
    super(...arguments);
    this.start = new AnnotationPointProperties();
    this.end = new AnnotationPointProperties();
  }
};
__decorateClass2([
  Validate11(OBJECT2, { optional: true })
], AnnotationLinePointsProperties.prototype, "start", 2);
__decorateClass2([
  Validate11(OBJECT2, { optional: true })
], AnnotationLinePointsProperties.prototype, "end", 2);
var AnnotationHandleProperties = class extends BaseProperties2 {
};
__decorateClass2([
  Validate11(COLOR_STRING22, { optional: true })
], AnnotationHandleProperties.prototype, "fill", 2);
__decorateClass2([
  Validate11(COLOR_STRING22, { optional: true })
], AnnotationHandleProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate11(RATIO4, { optional: true })
], AnnotationHandleProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate11(LINE_DASH22, { optional: true })
], AnnotationHandleProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate11(NUMBER3, { optional: true })
], AnnotationHandleProperties.prototype, "lineDashOffset", 2);
var AnnotationPointProperties = class extends BaseProperties2 {
};
__decorateClass2([
  Validate11(OR3(STRING22, NUMBER3, DATE2))
], AnnotationPointProperties.prototype, "x", 2);
__decorateClass2([
  Validate11(OR3(STRING22, NUMBER3, DATE2))
], AnnotationPointProperties.prototype, "y", 2);
var AnnotationFillProperties = class extends BaseProperties2 {
};
__decorateClass2([
  Validate11(COLOR_STRING22, { optional: true })
], AnnotationFillProperties.prototype, "fill", 2);
__decorateClass2([
  Validate11(RATIO4, { optional: true })
], AnnotationFillProperties.prototype, "fillOpacity", 2);
var AnnotationType = /* @__PURE__ */ ((AnnotationType2) => {
  AnnotationType2["Line"] = "line";
  AnnotationType2["ParallelChannel"] = "parallel-channel";
  return AnnotationType2;
})(AnnotationType || {});
var import_ag_charts_community20 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community17 = (init_main(), __toCommonJS(main_exports));
var Annotation = class extends import_ag_charts_community17._Scene.Group {
  constructor() {
    super(...arguments);
    this.locked = false;
  }
};
var import_ag_charts_community18 = (init_main(), __toCommonJS(main_exports));
var Handle = class extends import_ag_charts_community18._Scene.Group {
  constructor() {
    super(...arguments);
    this.visible = false;
  }
  drag(target) {
    return {
      point: target,
      offset: { x: target.x - this.handle.x, y: target.y - this.handle.y }
    };
  }
  toggleActive(active) {
    this.handle.strokeWidth = active ? 1.5 : 1;
    this.handle.dirtyPath = true;
  }
  toggleHovered(hovered) {
    this.glow.visible = hovered;
    this.glow.dirtyPath = true;
  }
  toggleDragging(dragging) {
    this.handle.visible = !dragging;
    this.glow.visible = this.glow.visible && !dragging;
    this.handle.dirtyPath = true;
    this.glow.dirtyPath = true;
  }
  getCursor() {
    return "default";
  }
  containsPoint(x, y) {
    return this.handle.containsPoint(x, y);
  }
};
var UnivariantHandle = class extends Handle {
  constructor() {
    super();
    this.handle = new import_ag_charts_community18._Scene.Rect();
    this.glow = new import_ag_charts_community18._Scene.Rect();
    this.gradient = "horizontal";
    this.append([this.glow, this.handle]);
    this.handle.cornerRadius = 4;
    this.handle.width = 12;
    this.handle.height = 12;
    this.handle.strokeWidth = 1;
    this.handle.zIndex = 2;
    this.glow.cornerRadius = 4;
    this.glow.width = 16;
    this.glow.height = 16;
    this.glow.strokeWidth = 0;
    this.glow.fillOpacity = 0.2;
    this.glow.zIndex = 1;
    this.glow.visible = false;
  }
  update(styles) {
    var _a2, _b, _c;
    this.handle.setProperties(styles);
    this.glow.setProperties(__spreadProps2(__spreadValues2({}, styles), {
      x: ((_a2 = styles.x) != null ? _a2 : this.glow.x) - 2,
      y: ((_b = styles.y) != null ? _b : this.glow.y) - 2,
      fill: (_c = styles.stroke) != null ? _c : styles.fill
    }));
  }
  drag(target) {
    if (this.gradient === "vertical") {
      return {
        point: { x: target.x, y: this.handle.y },
        offset: { x: target.x - this.handle.x, y: 0 }
      };
    }
    return {
      point: { x: this.handle.x, y: target.y },
      offset: { x: 0, y: target.y - this.handle.y }
    };
  }
  getCursor() {
    return this.gradient === "vertical" ? "col-resize" : "row-resize";
  }
};
var DivariantHandle = class extends Handle {
  constructor() {
    super();
    this.handle = new import_ag_charts_community18._Scene.Circle();
    this.glow = new import_ag_charts_community18._Scene.Circle();
    this.append([this.glow, this.handle]);
    this.handle.size = 11;
    this.handle.strokeWidth = 1;
    this.handle.zIndex = 2;
    this.glow.size = 17;
    this.glow.strokeWidth = 0;
    this.glow.fillOpacity = 0.2;
    this.glow.zIndex = 1;
    this.glow.visible = false;
  }
  update(styles) {
    this.handle.setProperties(styles);
    this.glow.setProperties(__spreadProps2(__spreadValues2({}, styles), { fill: styles.stroke }));
  }
};
var import_ag_charts_community19 = (init_main(), __toCommonJS(main_exports));
var magnitude = (x, y) => Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
var CollidableLine = class extends import_ag_charts_community19._Scene.Line {
  constructor() {
    super(...arguments);
    this.growCollisionBox = 2;
  }
  updateCollisionBBox() {
    const x = this.x1;
    const height = this.strokeWidth + this.growCollisionBox;
    const y = this.y1 - Math.floor(height / 2);
    const width = magnitude(this.x2 - x, this.y2 - y);
    this.collisionBBox = new import_ag_charts_community19._Scene.BBox(x, y, width, height);
  }
  isPointInPath(pointX, pointY) {
    var _a2, _b;
    const { collisionBBox, x1, y1, x2, y2 } = this;
    if (!collisionBBox)
      return false;
    pointX -= x1;
    pointY -= y1;
    const endX = x2 - x1;
    const endY = y2 - y1;
    const angle = Math.atan2(pointY, pointX) - Math.atan2(endY, endX);
    const mag = magnitude(pointX, pointY);
    const x = x1 + mag * Math.cos(angle);
    const y = y1 + mag * Math.sin(angle);
    return (_b = (_a2 = this.collisionBBox) == null ? void 0 : _a2.containsPoint(x, y)) != null ? _b : false;
  }
};
var Channel = class extends Annotation {
  constructor() {
    super();
    this.type = "channel";
    this.topLine = new CollidableLine();
    this.middleLine = new import_ag_charts_community20._Scene.Line();
    this.bottomLine = new CollidableLine();
    this.background = new import_ag_charts_community20._Scene.Path();
    this.handles = {
      topLeft: new DivariantHandle(),
      topMiddle: new UnivariantHandle(),
      topRight: new DivariantHandle(),
      bottomLeft: new DivariantHandle(),
      bottomMiddle: new UnivariantHandle(),
      bottomRight: new DivariantHandle()
    };
    this.append([this.background, this.topLine, this.middleLine, this.bottomLine, ...Object.values(this.handles)]);
  }
  update(datum, seriesRect, top, bottom) {
    const { locked, visible } = datum;
    this.locked = locked != null ? locked : false;
    this.seriesRect = seriesRect;
    if (top == null || bottom == null) {
      this.visible = false;
      return;
    } else {
      this.visible = visible != null ? visible : true;
    }
    this.updateLines(datum, top, bottom);
    this.updateHandles(datum, top, bottom);
    this.updateBackground(datum, top, bottom);
  }
  toggleHandles(show) {
    var _a2;
    if (typeof show === "boolean") {
      show = {
        topLeft: show,
        topMiddle: show,
        topRight: show,
        bottomLeft: show,
        bottomMiddle: show,
        bottomRight: show
      };
    }
    for (const [handle, node] of Object.entries(this.handles)) {
      node.visible = (_a2 = show[handle]) != null ? _a2 : true;
      node.toggleHovered(this.activeHandle === handle);
    }
  }
  toggleActive(active) {
    this.toggleHandles(active);
    for (const node of Object.values(this.handles)) {
      node.toggleActive(active);
    }
  }
  dragHandle(datum, target, invertPoint) {
    const { activeHandle, handles } = this;
    if (activeHandle == null)
      return;
    const { offset: offset4 } = handles[activeHandle].drag(target);
    handles[activeHandle].toggleDragging(true);
    let moves = [];
    switch (activeHandle) {
      case "topLeft":
      case "bottomLeft":
        moves = ["topLeft", "bottomLeft"];
        break;
      case "topMiddle":
        moves = ["topLeft", "topRight"];
        offset4.y -= 6;
        break;
      case "topRight":
      case "bottomRight":
        moves = ["topRight", "bottomRight"];
        break;
      case "bottomMiddle":
        moves = ["bottomLeft", "bottomRight"];
        offset4.y -= 6;
        break;
    }
    const invertedMoves = moves.map(
      (move) => invertPoint({
        x: handles[move].handle.x + offset4.x,
        y: handles[move].handle.y + offset4.y
      })
    );
    if (invertedMoves.some((invertedMove) => invertedMove === void 0)) {
      return;
    }
    for (const [index, invertedMove] of invertedMoves.entries()) {
      const datumPoint = this.getHandleDatumPoint(moves[index], datum);
      datumPoint.x = invertedMove.x;
      datumPoint.y = invertedMove.y;
    }
  }
  stopDragging() {
    const { activeHandle, handles } = this;
    if (activeHandle == null)
      return;
    handles[activeHandle].toggleDragging(false);
  }
  getCursor() {
    if (this.activeHandle == null)
      return "pointer";
    return this.handles[this.activeHandle].getCursor();
  }
  containsPoint(x, y) {
    var _a2, _b;
    const { handles, seriesRect, topLine, bottomLine } = this;
    this.activeHandle = void 0;
    for (const [handle, child] of Object.entries(handles)) {
      if (child.containsPoint(x, y)) {
        this.activeHandle = handle;
        return true;
      }
    }
    x -= (_a2 = seriesRect == null ? void 0 : seriesRect.x) != null ? _a2 : 0;
    y -= (_b = seriesRect == null ? void 0 : seriesRect.y) != null ? _b : 0;
    return topLine.containsPoint(x, y) || bottomLine.containsPoint(x, y);
  }
  updateLines(datum, top, bottom) {
    var _a2, _b, _c, _d, _e;
    const { topLine, middleLine, bottomLine } = this;
    const { lineDash, lineDashOffset, stroke, strokeOpacity, strokeWidth } = datum;
    const lineStyles = { lineDash, lineDashOffset, stroke, strokeOpacity, strokeWidth };
    topLine.setProperties(__spreadValues2({
      x1: top.x1,
      y1: top.y1,
      x2: top.x2,
      y2: top.y2
    }, lineStyles));
    bottomLine.setProperties(__spreadValues2({
      x1: bottom.x1,
      y1: bottom.y1,
      x2: bottom.x2,
      y2: bottom.y2
    }, lineStyles));
    topLine.updateCollisionBBox();
    bottomLine.updateCollisionBBox();
    if (datum.type === "parallel-channel") {
      middleLine.setProperties({
        x1: top.x1,
        y1: bottom.y1 + (top.y1 - bottom.y1) / 2,
        x2: top.x2,
        y2: bottom.y2 + (top.y2 - bottom.y2) / 2,
        lineDash: (_a2 = datum.middle.lineDash) != null ? _a2 : lineDash,
        lineDashOffset: (_b = datum.middle.lineDashOffset) != null ? _b : lineDashOffset,
        stroke: (_c = datum.middle.stroke) != null ? _c : stroke,
        strokeOpacity: (_d = datum.middle.strokeOpacity) != null ? _d : strokeOpacity,
        strokeWidth: (_e = datum.middle.strokeWidth) != null ? _e : strokeWidth
      });
    } else {
      middleLine.visible = false;
    }
  }
  updateHandles(datum, top, bottom) {
    var _a2, _b;
    const {
      handles: { topLeft, topMiddle, topRight, bottomLeft, bottomMiddle, bottomRight }
    } = this;
    const handleStyles = {
      fill: datum.handle.fill,
      stroke: (_a2 = datum.handle.stroke) != null ? _a2 : datum.stroke,
      strokeOpacity: (_b = datum.handle.strokeOpacity) != null ? _b : datum.strokeOpacity
    };
    topLeft.update(__spreadProps2(__spreadValues2({}, handleStyles), { x: top.x1, y: top.y1 }));
    topRight.update(__spreadProps2(__spreadValues2({}, handleStyles), { x: top.x2, y: top.y2 }));
    bottomLeft.update(__spreadProps2(__spreadValues2({}, handleStyles), { x: bottom.x1, y: bottom.y1 }));
    bottomRight.update(__spreadProps2(__spreadValues2({}, handleStyles), { x: bottom.x2, y: bottom.y2 }));
    topMiddle.update(__spreadProps2(__spreadValues2({}, handleStyles), {
      x: top.x1 + (top.x2 - top.x1) / 2 - topMiddle.handle.width / 2,
      y: top.y1 + (top.y2 - top.y1) / 2 - topMiddle.handle.height / 2
    }));
    bottomMiddle.update(__spreadProps2(__spreadValues2({}, handleStyles), {
      x: bottom.x1 + (bottom.x2 - bottom.x1) / 2 - bottomMiddle.handle.width / 2,
      y: bottom.y1 + (bottom.y2 - bottom.y1) / 2 - bottomMiddle.handle.height / 2
    }));
  }
  updateBackground(datum, top, bottom) {
    const { background } = this;
    background.path.clear();
    background.path.moveTo(top.x1, top.y1);
    background.path.lineTo(top.x2, top.y2);
    background.path.lineTo(bottom.x2, bottom.y2);
    background.path.lineTo(bottom.x1, bottom.y1);
    background.path.closePath();
    background.checkPathDirty();
    background.setProperties({
      fill: datum.background.fill,
      fillOpacity: datum.background.fillOpacity
    });
  }
  getHandleDatumPoint(handle, datum) {
    switch (handle) {
      case "topLeft":
        return datum.top.start;
      case "topRight":
        return datum.top.end;
      case "bottomLeft":
        return datum.bottom.start;
      case "bottomRight":
      default:
        return datum.bottom.end;
    }
  }
};
var Line2 = class extends Annotation {
  constructor() {
    super();
    this.type = "line";
    this.line = new CollidableLine();
    this.start = new DivariantHandle();
    this.end = new DivariantHandle();
    this.append([this.line, this.start, this.end]);
  }
  update(datum, seriesRect, coords) {
    var _a2, _b;
    const { line, start, end } = this;
    const { locked, visible, lineDash, lineDashOffset, stroke, strokeWidth, strokeOpacity } = datum;
    this.locked = locked != null ? locked : false;
    this.seriesRect = seriesRect;
    if (coords == null) {
      this.visible = false;
      return;
    } else {
      this.visible = visible != null ? visible : true;
    }
    const { x1, y1, x2, y2 } = coords;
    line.setProperties({
      x1,
      y1,
      x2,
      y2,
      lineDash,
      lineDashOffset,
      stroke,
      strokeWidth,
      strokeOpacity,
      fillOpacity: 0
    });
    line.updateCollisionBBox();
    const handleStyles = {
      fill: datum.handle.fill,
      stroke: (_a2 = datum.handle.stroke) != null ? _a2 : stroke,
      strokeOpacity: (_b = datum.handle.strokeOpacity) != null ? _b : strokeOpacity
    };
    start.update(__spreadProps2(__spreadValues2({}, handleStyles), { x: x1, y: y1 }));
    end.update(__spreadProps2(__spreadValues2({}, handleStyles), { x: x2, y: y2 }));
  }
  toggleHandles(show) {
    var _a2, _b;
    if (typeof show === "boolean") {
      show = { start: show, end: show };
    }
    this.start.visible = (_a2 = show.start) != null ? _a2 : true;
    this.end.visible = (_b = show.end) != null ? _b : true;
    this.start.toggleHovered(this.activeHandle === "start");
    this.end.toggleHovered(this.activeHandle === "end");
  }
  toggleActive(active) {
    this.toggleHandles(active);
    this.start.toggleActive(active);
    this.end.toggleActive(active);
  }
  dragHandle(datum, target, invertPoint) {
    const { activeHandle } = this;
    if (!activeHandle || datum.start == null || datum.end == null)
      return;
    this[activeHandle].toggleDragging(true);
    const point = invertPoint(this[activeHandle].drag(target).point);
    if (!point)
      return;
    datum[activeHandle].x = point.x;
    datum[activeHandle].y = point.y;
  }
  stopDragging() {
    this.start.toggleDragging(false);
    this.end.toggleDragging(false);
  }
  getCursor() {
    if (this.activeHandle == null)
      return "pointer";
    return "default";
  }
  containsPoint(x, y) {
    var _a2, _b;
    const { start, end, seriesRect, line } = this;
    this.activeHandle = void 0;
    if (start.containsPoint(x, y)) {
      this.activeHandle = "start";
      return true;
    }
    if (end.containsPoint(x, y)) {
      this.activeHandle = "end";
      return true;
    }
    x -= (_a2 = seriesRect == null ? void 0 : seriesRect.x) != null ? _a2 : 0;
    y -= (_b = seriesRect == null ? void 0 : seriesRect.y) != null ? _b : 0;
    return line.isPointInPath(x, y);
  }
};
var { BOOLEAN: BOOLEAN5, OBJECT_ARRAY: OBJECT_ARRAY2, InteractionState: InteractionState2, PropertiesArray: PropertiesArray2, Validate: Validate12 } = import_ag_charts_community21._ModuleSupport;
var Annotations = class extends import_ag_charts_community21._ModuleSupport.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = true;
    this.initial = new PropertiesArray2(AnnotationProperties);
    this.container = new import_ag_charts_community21._Scene.Group({ name: "static-annotations" });
    this.annotations = new import_ag_charts_community21._Scene.Selection(
      this.container,
      this.createAnnotation.bind(this)
    );
    this.hoverAddingFns = {
      [
        "line"
        /* Line */
      ]: {
        [
          "end"
          /* End */
        ]: (datum, node, point) => {
          datum.set({ end: point });
          node.toggleHandles({ end: false });
        }
      },
      [
        "parallel-channel"
        /* ParallelChannel */
      ]: {
        [
          "end"
          /* End */
        ]: (datum, node, point) => {
          datum.set({ top: { end: point }, bottom: { end: point } });
          node.toggleHandles(false);
        },
        [
          "height"
          /* Height */
        ]: (datum, node, point, offset4) => {
          const start = this.convertPoint(datum.bottom.start);
          const end = this.convertPoint(datum.bottom.end);
          if (!start || !end)
            return;
          const height = offset4.y - end.y;
          const startY = this.invertY(start.y + height);
          const endY = point.y;
          if (!this.validateDatumPoint({ x: start.x, y: startY }) || !this.validateDatumPoint({ x: end.x, y: endY })) {
            return;
          }
          node.toggleHandles({ topMiddle: false, bottomMiddle: false });
          datum.set({
            bottom: { start: { y: startY }, end: { y: endY } }
          });
        }
      }
    };
    this.clickAddingFns = {
      [
        "line"
        /* Line */
      ]: {
        [
          "start"
          /* Start */
        ]: (_node, point) => {
          var _a2;
          const datum = this.createDatum("line", point);
          (_a2 = this.annotationData) == null ? void 0 : _a2.push(datum);
          this.addingStep = "end";
        },
        [
          "end"
          /* End */
        ]: (node, point) => {
          var _a2, _b;
          (_b = (_a2 = this.annotationData) == null ? void 0 : _a2.at(-1)) == null ? void 0 : _b.set({ end: point });
          node == null ? void 0 : node.toggleHandles(true);
          this.addingStep = void 0;
          this.ctx.cursorManager.updateCursor("annotations");
          this.ctx.interactionManager.popState(InteractionState2.Annotations);
        }
      },
      [
        "parallel-channel"
        /* ParallelChannel */
      ]: {
        [
          "start"
          /* Start */
        ]: (_node, point) => {
          var _a2;
          const datum = this.createDatum("parallel-channel", point);
          (_a2 = this.annotationData) == null ? void 0 : _a2.push(datum);
          this.addingStep = "end";
        },
        [
          "end"
          /* End */
        ]: (node, point) => {
          var _a2, _b;
          (_b = (_a2 = this.annotationData) == null ? void 0 : _a2.at(-1)) == null ? void 0 : _b.set({
            top: { end: point },
            bottom: { end: point }
          });
          node == null ? void 0 : node.toggleHandles({ topMiddle: false, bottomMiddle: false });
          this.addingStep = "height";
        },
        [
          "height"
          /* Height */
        ]: (node, point, offset4) => {
          var _a2;
          const datum = (_a2 = this.annotationData) == null ? void 0 : _a2.at(-1);
          const start = this.convertPoint(datum.bottom.start);
          const end = this.convertPoint(datum.bottom.end);
          if (!start || !end)
            return;
          const height = offset4.y - end.y;
          const startY = this.invertY(start.y + height);
          const endY = point.y;
          if (datum && this.validateDatumPoint({ x: start.x, y: startY }) && this.validateDatumPoint({ x: end.x, y: endY })) {
            datum.set({
              bottom: { start: { y: startY }, end: { y: endY } }
            });
          }
          node == null ? void 0 : node.toggleHandles(true);
          this.addingStep = void 0;
          this.ctx.cursorManager.updateCursor("annotations");
          this.ctx.interactionManager.popState(InteractionState2.Annotations);
        }
      }
    };
    const { All, Default: Default6, Annotations: AnnotationsState, ZoomDrag } = InteractionState2;
    const region = ctx.regionManager.getRegion("series");
    this.destroyFns.push(
      ctx.annotationManager.attachNode(this.container),
      region.addListener("hover", this.onHover.bind(this), All),
      region.addListener("click", this.onClick.bind(this), All),
      region.addListener("drag", this.onDrag.bind(this), Default6 | ZoomDrag | AnnotationsState),
      region.addListener("drag-end", this.onDragEnd.bind(this), All),
      ctx.toolbarManager.addListener("button-pressed", (event) => this.onToolbarButtonPress(event)),
      ctx.layoutService.addListener("layout-complete", this.onLayoutComplete.bind(this))
    );
  }
  onToolbarButtonPress(event) {
    if (this.active != null) {
      this.annotations.nodes()[this.active].toggleActive(false);
      this.active = void 0;
    }
    if (event.group !== "annotations" || !Object.values(AnnotationType).includes(event.value))
      return;
    this.ctx.interactionManager.pushState(InteractionState2.Annotations);
    this.addingStep = "start";
    this.addingType = event.value;
  }
  createAnnotation(datum) {
    switch (datum.type) {
      case "parallel-channel":
        return new Channel();
      case "line":
      default:
        return new Line2();
    }
  }
  createDatum(type, point) {
    const datum = new AnnotationProperties();
    datum.set(import_ag_charts_community21._ModuleSupport.mergeDefaults({ type }, this.ctx.annotationManager.getAnnotationTypeStyles(type)));
    switch (type) {
      case "line":
        datum.set({ start: point, end: point });
        break;
      case "parallel-channel":
        datum.set({
          top: { start: point, end: point },
          bottom: { start: point, end: point }
        });
        break;
    }
    return datum;
  }
  onLayoutComplete(event) {
    var _a2, _b, _c, _d, _e;
    const { annotationData, annotations: annotations2 } = this;
    this.seriesRect = event.series.rect;
    for (const axis of (_a2 = event.axes) != null ? _a2 : []) {
      if (axis.direction === import_ag_charts_community21._ModuleSupport.ChartAxisDirection.X) {
        (_b = this.scaleX) != null ? _b : this.scaleX = axis.scale;
        (_c = this.domainX) != null ? _c : this.domainX = axis.domain;
      } else {
        (_d = this.scaleY) != null ? _d : this.scaleY = axis.scale;
        (_e = this.domainY) != null ? _e : this.domainY = axis.domain;
      }
    }
    annotations2.update(annotationData != null ? annotationData : []).each((node, datum) => {
      if (!this.validateDatum(datum)) {
        return;
      }
      switch (datum.type) {
        case "line":
          node.update(datum, event.series.rect, this.convertLine(datum));
          break;
        case "parallel-channel":
          node.update(
            datum,
            event.series.rect,
            this.convertLine(datum.top),
            this.convertLine(datum.bottom)
          );
          break;
      }
    });
  }
  // Validation of the options beyond the scope of the @Validate decorator
  validateDatum(datum) {
    let valid = true;
    switch (datum.type) {
      case "line":
        valid = this.validateDatumLine(datum, `Annotation [${datum.type}]`);
        break;
      case "parallel-channel":
        valid = this.validateDatumLine(datum.top, `Annotation [${datum.type}] [top]`);
        valid && (valid = this.validateDatumLine(datum.bottom, `Annotation [${datum.type}] [bottom]`));
        break;
    }
    return valid;
  }
  validateDatumLine(datum, prefix) {
    let valid = true;
    if (datum.start == null || datum.end == null) {
      import_ag_charts_community21._Util.Logger.warnOnce(`${prefix} requires both a [start] and [end] property, ignoring.`);
      valid = false;
    } else {
      valid && (valid = this.validateDatumPoint(datum.start, `${prefix} [start]`));
      valid && (valid = this.validateDatumPoint(datum.end, `${prefix} [end]`));
    }
    return valid;
  }
  validateDatumPoint(point, loggerPrefix) {
    const { domainX, domainY, scaleX, scaleY } = this;
    if (point.x == null || point.y == null) {
      if (loggerPrefix) {
        import_ag_charts_community21._Util.Logger.warnOnce(`${loggerPrefix} requires both an [x] and [y] property, ignoring.`);
      }
      return false;
    }
    if (!domainX || !domainY || !scaleX || !scaleY)
      return true;
    const validX = this.validateDatumPointDirection(domainX, scaleX, point.x);
    const validY = this.validateDatumPointDirection(domainY, scaleY, point.y);
    if (!validX || !validY) {
      let text = "x & y domains";
      if (validX)
        text = "y domain";
      if (validY)
        text = "x domain";
      if (loggerPrefix) {
        import_ag_charts_community21._Util.Logger.warnOnce(
          `${loggerPrefix} is outside the ${text}, ignoring. - x: [${point.x}], y: ${point.y}]`
        );
      }
      return false;
    }
    return true;
  }
  validateDatumPointDirection(domain, scale2, value) {
    if (import_ag_charts_community21._Scene.ContinuousScale.is(scale2)) {
      return value >= domain[0] && value <= domain[1];
    }
    return true;
  }
  onHover(event) {
    const { addingStep } = this;
    if (addingStep == null) {
      this.onHoverSelecting(event);
    } else {
      this.onHoverEditing(event);
    }
  }
  onHoverSelecting(event) {
    const {
      active,
      annotations: annotations2,
      ctx: { cursorManager }
    } = this;
    this.hovered = void 0;
    annotations2.each((annotation, _, index) => {
      var _a2;
      if (annotation.locked)
        return;
      const contains = annotation.containsPoint(event.offsetX, event.offsetY);
      if (contains)
        (_a2 = this.hovered) != null ? _a2 : this.hovered = index;
      annotation.toggleHandles(contains || active === index);
    });
    cursorManager.updateCursor(
      "annotations",
      this.hovered == null ? void 0 : annotations2.nodes()[this.hovered].getCursor()
    );
  }
  onHoverEditing(event) {
    var _a2, _b, _c, _d, _e;
    const {
      annotationData,
      annotations: annotations2,
      addingStep,
      addingType,
      ctx: { cursorManager, updateService }
    } = this;
    if (!annotationData || !addingType || !addingStep)
      return;
    const offset4 = {
      x: event.offsetX - ((_b = (_a2 = this.seriesRect) == null ? void 0 : _a2.x) != null ? _b : 0),
      y: event.offsetY - ((_d = (_c = this.seriesRect) == null ? void 0 : _c.y) != null ? _d : 0)
    };
    const point = this.invertPoint(offset4);
    const valid = this.validateDatumPoint(point);
    cursorManager.updateCursor("annotations", valid ? void 0 : "not-allowed");
    if (!valid || addingStep === "start")
      return;
    const datum = annotationData.at(-1);
    this.active = annotationData.length - 1;
    const node = annotations2.nodes()[this.active];
    if (!datum || !node)
      return;
    node.toggleActive(true);
    const hoverAddingFn = (_e = this.hoverAddingFns[addingType]) == null ? void 0 : _e[addingStep];
    if (hoverAddingFn) {
      hoverAddingFn(datum, node, point, offset4);
    }
    updateService.update();
  }
  onClick(event) {
    if (this.addingStep == null) {
      this.onClickSelecting();
    } else {
      this.onClickAdding(event);
    }
  }
  onClickSelecting() {
    if (this.active != null) {
      this.annotations.nodes()[this.active].toggleActive(false);
    }
    this.active = this.hovered;
    if (this.active == null)
      return;
    this.annotations.nodes()[this.active].toggleActive(true);
  }
  onClickAdding(event) {
    var _a2, _b, _c, _d, _e;
    const {
      active,
      annotationData,
      annotations: annotations2,
      addingStep,
      addingType,
      ctx: { updateService }
    } = this;
    if (!annotationData || !addingStep || !addingType)
      return;
    const offset4 = {
      x: event.offsetX - ((_b = (_a2 = this.seriesRect) == null ? void 0 : _a2.x) != null ? _b : 0),
      y: event.offsetY - ((_d = (_c = this.seriesRect) == null ? void 0 : _c.y) != null ? _d : 0)
    };
    const point = this.invertPoint(offset4);
    const node = active ? annotations2.nodes()[active] : void 0;
    if (!this.validateDatumPoint(point)) {
      return;
    }
    const clickAddingFn = (_e = this.clickAddingFns[addingType]) == null ? void 0 : _e[addingStep];
    if (clickAddingFn) {
      clickAddingFn(node, point, offset4);
    }
    updateService.update(import_ag_charts_community21._ModuleSupport.ChartUpdateType.PERFORM_LAYOUT, { skipAnimations: true });
  }
  onDrag(event) {
    var _a2, _b;
    const {
      active,
      annotationData,
      annotations: annotations2,
      addingStep,
      seriesRect,
      ctx: { cursorManager, interactionManager, updateService }
    } = this;
    if (active == null || annotationData == null || addingStep != null)
      return;
    interactionManager.pushState(InteractionState2.Annotations);
    const { offsetX, offsetY } = event;
    const datum = annotationData[active];
    const node = annotations2.nodes()[active];
    const offset4 = {
      x: offsetX - ((_a2 = seriesRect == null ? void 0 : seriesRect.x) != null ? _a2 : 0),
      y: offsetY - ((_b = seriesRect == null ? void 0 : seriesRect.y) != null ? _b : 0)
    };
    cursorManager.updateCursor("annotations");
    node.dragHandle(datum, offset4, this.onDragNodeHandle.bind(this));
    updateService.update(import_ag_charts_community21._ModuleSupport.ChartUpdateType.PERFORM_LAYOUT, { skipAnimations: true });
  }
  onDragNodeHandle(handleOffset) {
    const point = this.invertPoint(handleOffset);
    const valid = this.validateDatumPoint(point);
    if (!valid) {
      this.ctx.cursorManager.updateCursor("annotations", "not-allowed");
      return;
    }
    return point;
  }
  onDragEnd(_event) {
    const {
      active,
      annotations: annotations2,
      addingStep,
      ctx: { cursorManager, interactionManager, updateService }
    } = this;
    if (addingStep != null)
      return;
    interactionManager.popState(InteractionState2.Annotations);
    cursorManager.updateCursor("annotations");
    if (active == null)
      return;
    annotations2.nodes()[active].stopDragging();
    updateService.update(import_ag_charts_community21._ModuleSupport.ChartUpdateType.PERFORM_LAYOUT, { skipAnimations: true });
  }
  convertLine(datum) {
    if (datum.start == null || datum.end == null)
      return;
    const start = this.convertPoint(datum.start);
    const end = this.convertPoint(datum.end);
    if (start == null || end == null)
      return;
    return { x1: start.x, y1: start.y, x2: end.x, y2: end.y };
  }
  convertPoint(point) {
    const { scaleX, scaleY } = this;
    let x = 0;
    let y = 0;
    if (!scaleX || !scaleY || point.x == null || point.y == null)
      return { x, y };
    x = scaleX.convert(point.x);
    y = scaleY.convert(point.y);
    return { x, y };
  }
  invertPoint(point) {
    return {
      x: this.invertX(point.x),
      y: this.invertY(point.y)
    };
  }
  invertX(x) {
    const { scaleX } = this;
    if (import_ag_charts_community21._Scene.ContinuousScale.is(scaleX)) {
      x = scaleX.invert(x);
    } else if (import_ag_charts_community21._Scene.BandScale.is(scaleX)) {
      x = scaleX.invertNearest(x);
    }
    return x;
  }
  invertY(y) {
    const { scaleY } = this;
    if (import_ag_charts_community21._Scene.ContinuousScale.is(scaleY)) {
      y = scaleY.invert(y);
    } else if (import_ag_charts_community21._Scene.BandScale.is(scaleY)) {
      y = scaleY.invertNearest(y);
    }
    return y;
  }
};
__decorateClass2([
  import_ag_charts_community21._ModuleSupport.ObserveChanges((target, enabled) => {
    target.ctx.toolbarManager.toggleGroup("annotations", Boolean(enabled));
  }),
  Validate12(BOOLEAN5)
], Annotations.prototype, "enabled", 2);
__decorateClass2([
  import_ag_charts_community21._ModuleSupport.ObserveChanges((target, newValue) => {
    var _a2;
    (_a2 = target.annotationData) != null ? _a2 : target.annotationData = newValue;
  }),
  Validate12(OBJECT_ARRAY2, { optional: true })
], Annotations.prototype, "initial", 2);
var AnnotationsModule = {
  type: "root",
  optionsKey: "annotations",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  dependencies: ["toolbar"],
  instanceConstructor: Annotations,
  themeTemplate: {
    annotations: {
      line: {
        stroke: import_ag_charts_community22._Theme.DEFAULT_ANNOTATION_STROKE,
        strokeWidth: 2,
        strokeOpacity: 1,
        handle: {
          fill: import_ag_charts_community22._Theme.DEFAULT_ANNOTATION_HANDLE_FILL
        }
      },
      "parallel-channel": {
        stroke: import_ag_charts_community22._Theme.DEFAULT_ANNOTATION_STROKE,
        strokeWidth: 2,
        strokeOpacity: 1,
        middle: {
          lineDash: [6, 5],
          strokeWidth: 1
        },
        background: {
          fill: import_ag_charts_community22._Theme.DEFAULT_ANNOTATION_BACKGROUND_FILL,
          fillOpacity: 0.2
        },
        handle: {
          fill: import_ag_charts_community22._Theme.DEFAULT_ANNOTATION_HANDLE_FILL
        }
      }
    }
  }
};
var import_ag_charts_community24 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community23 = (init_main(), __toCommonJS(main_exports));
var { Image: Image2 } = import_ag_charts_community23._Scene;
var {
  BaseProperties: BaseProperties22,
  ObserveChanges: ObserveChanges22,
  ProxyProperty: ProxyProperty2,
  Validate: Validate13,
  NUMBER: NUMBER4,
  POSITIVE_NUMBER: POSITIVE_NUMBER5,
  RATIO: RATIO5,
  createElement: createElement2,
  calculatePlacement: calculatePlacement2
} = import_ag_charts_community23._ModuleSupport;
var BackgroundImage = class extends BaseProperties22 {
  constructor() {
    super();
    this.opacity = 1;
    this.loadedSynchronously = true;
    this.containerWidth = 0;
    this.containerHeight = 0;
    this.onLoad = void 0;
    this.onImageLoad = () => {
      var _a2;
      if (this.loadedSynchronously) {
        return;
      }
      this.node.visible = false;
      this.performLayout(this.containerWidth, this.containerHeight);
      (_a2 = this.onLoad) == null ? void 0 : _a2.call(this);
    };
    this.imageElement = createElement2("img");
    this.imageElement.onload = this.onImageLoad;
    this.node = new Image2(this.imageElement);
  }
  get complete() {
    return this.imageElement.width > 0 && this.imageElement.height > 0;
  }
  performLayout(containerWidth, containerHeight) {
    this.containerWidth = containerWidth;
    this.containerHeight = containerHeight;
    this.node.setProperties(
      this.complete ? __spreadValues2({
        visible: true,
        opacity: this.opacity
      }, calculatePlacement2(
        this.imageElement.width,
        this.imageElement.height,
        this.containerWidth,
        this.containerHeight,
        this
      )) : { visible: false }
    );
  }
};
__decorateClass2([
  Validate13(NUMBER4, { optional: true })
], BackgroundImage.prototype, "top", 2);
__decorateClass2([
  Validate13(NUMBER4, { optional: true })
], BackgroundImage.prototype, "right", 2);
__decorateClass2([
  Validate13(NUMBER4, { optional: true })
], BackgroundImage.prototype, "bottom", 2);
__decorateClass2([
  Validate13(NUMBER4, { optional: true })
], BackgroundImage.prototype, "left", 2);
__decorateClass2([
  Validate13(POSITIVE_NUMBER5, { optional: true })
], BackgroundImage.prototype, "width", 2);
__decorateClass2([
  Validate13(POSITIVE_NUMBER5, { optional: true })
], BackgroundImage.prototype, "height", 2);
__decorateClass2([
  Validate13(RATIO5)
], BackgroundImage.prototype, "opacity", 2);
__decorateClass2([
  ProxyProperty2("imageElement.src"),
  ObserveChanges22((target) => target.loadedSynchronously = target.complete)
], BackgroundImage.prototype, "url", 2);
var { ActionOnSet: ActionOnSet2, OBJECT: OBJECT22, Validate: Validate14 } = import_ag_charts_community24._ModuleSupport;
var Background2 = class extends import_ag_charts_community24._ModuleSupport.Background {
  constructor(ctx) {
    super(ctx);
    this.ctx = ctx;
    this.image = new BackgroundImage();
  }
  onLayoutComplete(event) {
    super.onLayoutComplete(event);
    if (this.image) {
      const { width, height } = event.chart;
      this.image.performLayout(width, height);
    }
  }
  onImageLoad() {
    this.ctx.updateService.update(import_ag_charts_community24._ModuleSupport.ChartUpdateType.SCENE_RENDER);
  }
};
__decorateClass2([
  Validate14(OBJECT22, { optional: true }),
  ActionOnSet2({
    newValue(image) {
      this.node.appendChild(image.node);
      image.onLoad = () => this.onImageLoad();
    },
    oldValue(image) {
      this.node.removeChild(image.node);
      image.onLoad = void 0;
    }
  })
], Background2.prototype, "image", 2);
var BackgroundModule2 = {
  type: "root",
  optionsKey: "background",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "hierarchy", "topology"],
  instanceConstructor: Background2
};
var import_ag_charts_community26 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community25 = (init_main(), __toCommonJS(main_exports));
var DEFAULT_CONTEXT_MENU_CLASS = "ag-chart-context-menu";
var DEFAULT_CONTEXT_MENU_DARK_CLASS = `ag-charts-dark-context-menu`;
var defaultContextMenuCss = `
.${DEFAULT_CONTEXT_MENU_CLASS} {
    background: rgb(248, 248, 248);
    border: 1px solid #babfc7;
    border-radius: 5px;
    box-shadow: 0 1px 4px 1px rgba(186, 191, 199, 0.4);
    color: rgb(24, 29, 31);
    font: 13px Verdana, sans-serif;
    position: fixed;
    transition: transform 0.1s ease;
    white-space: nowrap;
    z-index: 99999;
}

.${DEFAULT_CONTEXT_MENU_CLASS}.${DEFAULT_CONTEXT_MENU_DARK_CLASS} {
    color: white;
    background: #15181c;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__cover {
    position: fixed;
    left: 0px;
    top: 0px;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__menu {
    display: flex;
    flex-direction: column;
    padding: 0.5em 0;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item {
    background: none;
    border: none;
    box-sizing: border-box;
    font: inherit;
    padding: 0.5em 1em;
    text-align: left;
    -webkit-appearance: none;
    -moz-appearance: none;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item.${DEFAULT_CONTEXT_MENU_DARK_CLASS} {
    color: white;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item:hover {
    background: rgb(33, 150, 243, 0.1);
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item:hover.${DEFAULT_CONTEXT_MENU_DARK_CLASS} {
    background: rgb(33, 150, 243, 0.1);
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item:active {
    background: rgb(33, 150, 243, 0.2);
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item:active.${DEFAULT_CONTEXT_MENU_DARK_CLASS} {
    background: rgb(33, 150, 243, 0.1);
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item[disabled] {
    border: none;
    opacity: 0.5;
    text-align: left;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__item[disabled]:hover {
    background: inherit;
    cursor: inherit;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__divider {
    margin: 5px 0;
    background: #babfc7;
    height: 1px;
}

.${DEFAULT_CONTEXT_MENU_CLASS}__divider.${DEFAULT_CONTEXT_MENU_DARK_CLASS} {
    background: rgb(33, 150, 243, 0.1);
}
`;
var { BOOLEAN: BOOLEAN6, Validate: Validate15, createElement: createElement22, getDocument: getDocument2, getWindow: getWindow2, injectStyle: injectStyle2 } = import_ag_charts_community25._ModuleSupport;
var ContextMenu = class extends import_ag_charts_community25._ModuleSupport.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = true;
    this.darkTheme = false;
    this.extraActions = [];
    this.extraNodeActions = [];
    this.x = 0;
    this.y = 0;
    this.highlightManager = ctx.highlightManager;
    this.interactionManager = ctx.interactionManager;
    this.registry = ctx.contextMenuRegistry;
    this.scene = ctx.scene;
    const { Default: Default6, ContextMenu: ContextMenuState, All } = import_ag_charts_community25._ModuleSupport.InteractionState;
    const contextState = Default6 | ContextMenuState;
    this.destroyFns.push(
      ctx.interactionManager.addListener("contextmenu", (event) => this.onContextMenu(event), contextState),
      ctx.interactionManager.addListener("click", () => this.onClick(), All)
    );
    this.groups = { default: [], node: [], extra: [], extraNode: [] };
    this.canvasElement = ctx.scene.canvas.element;
    this.container = getDocument2("body");
    this.element = this.container.appendChild(createElement22("div"));
    this.element.classList.add(DEFAULT_CONTEXT_MENU_CLASS);
    this.element.addEventListener("contextmenu", (event) => event.preventDefault());
    this.destroyFns.push(() => {
      var _a2;
      return (_a2 = this.element.parentNode) == null ? void 0 : _a2.removeChild(this.element);
    });
    this.hide();
    if (typeof IntersectionObserver !== "undefined") {
      const observer = new IntersectionObserver(
        (entries) => {
          for (const entry of entries) {
            if (entry.target === this.canvasElement && entry.intersectionRatio === 0) {
              this.hide();
            }
          }
        },
        { root: this.container }
      );
      observer.observe(this.canvasElement);
      this.intersectionObserver = observer;
    }
    if (typeof MutationObserver !== "undefined") {
      const observer = new MutationObserver(() => {
        if (this.menuElement && this.element.contains(this.menuElement)) {
          this.reposition();
        }
      });
      observer.observe(this.element, { childList: true });
      this.mutationObserver = observer;
    }
    injectStyle2(defaultContextMenuCss, "contextMenu");
    this.registry.registerDefaultAction({
      id: "download",
      label: "Download",
      action: () => {
        const title = ctx.chartService.title;
        let fileName = "image";
        if ((title == null ? void 0 : title.enabled) && (title == null ? void 0 : title.text) !== void 0) {
          fileName = title.text;
        }
        this.scene.download(fileName);
      }
    });
  }
  isShown() {
    return this.menuElement !== void 0;
  }
  onClick() {
    if (this.isShown()) {
      this.hide();
    }
  }
  onContextMenu(event) {
    if (!this.enabled)
      return;
    this.showEvent = event.sourceEvent;
    this.x = event.pageX;
    this.y = event.pageY;
    this.groups.default = this.registry.copyDefaultActions();
    this.pickedNode = this.highlightManager.getActivePicked();
    if (this.extraActions.length > 0) {
      this.groups.extra = [...this.extraActions];
    }
    if (this.extraNodeActions.length > 0 && this.pickedNode) {
      this.groups.extraNode = [...this.extraNodeActions];
    }
    const { default: def, node, extra, extraNode } = this.groups;
    const groupCount2 = def.length + node.length + extra.length + extraNode.length;
    if (groupCount2 === 0)
      return;
    event.consume();
    event.sourceEvent.preventDefault();
    this.show();
  }
  show() {
    this.interactionManager.pushState(import_ag_charts_community25._ModuleSupport.InteractionState.ContextMenu);
    this.element.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    const newMenuElement = this.renderMenu();
    if (this.menuElement) {
      this.element.replaceChild(newMenuElement, this.menuElement);
    } else {
      this.element.appendChild(newMenuElement);
    }
    this.menuElement = newMenuElement;
    this.element.style.display = "block";
  }
  hide() {
    this.interactionManager.popState(import_ag_charts_community25._ModuleSupport.InteractionState.ContextMenu);
    if (this.menuElement) {
      this.element.removeChild(this.menuElement);
      this.menuElement = void 0;
    }
    this.element.style.display = "none";
  }
  renderMenu() {
    const menuElement = createElement22("div");
    menuElement.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__menu`);
    menuElement.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    this.appendMenuGroup(menuElement, this.groups.default, false);
    if (this.pickedNode) {
      this.appendMenuGroup(menuElement, this.groups.node);
    }
    this.appendMenuGroup(menuElement, this.groups.extra);
    if (this.pickedNode) {
      this.appendMenuGroup(menuElement, this.groups.extraNode);
    }
    return menuElement;
  }
  appendMenuGroup(menuElement, group2, divider = true) {
    if (group2.length === 0)
      return;
    if (divider)
      menuElement.appendChild(this.createDividerElement());
    group2.forEach((i) => {
      const item = this.renderItem(i);
      if (item)
        menuElement.appendChild(item);
    });
  }
  renderItem(item) {
    if (item && typeof item === "object" && item.constructor === Object) {
      return this.createActionElement(item);
    }
  }
  createDividerElement() {
    const el = createElement22("div");
    el.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__divider`);
    el.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    return el;
  }
  createActionElement({ id, label, action }) {
    if (id && this.registry.isDisabled(id)) {
      return this.createDisabledElement(label);
    }
    return this.createButtonElement(label, action);
  }
  createButtonElement(label, callback) {
    const el = createElement22("button");
    el.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__item`);
    el.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    el.innerHTML = label;
    el.onclick = () => {
      var _a2;
      const event = (_a2 = this.pickedNode) == null ? void 0 : _a2.series.createNodeContextMenuActionEvent(this.showEvent, this.pickedNode);
      if (event) {
        Object.defineProperty(event, "itemId", {
          enumerable: false,
          get: () => {
            var _a3;
            import_ag_charts_community25._Util.Logger.warnOnce(
              `Property [AgNodeContextMenuActionEvent.itemId] is deprecated. Use [yKey], [angleKey] and others instead.`
            );
            return (_a3 = this.pickedNode) == null ? void 0 : _a3.itemId;
          }
        });
        callback(event);
      } else {
        callback({ event: this.showEvent });
      }
      this.hide();
    };
    return el;
  }
  createDisabledElement(label) {
    const el = createElement22("button");
    el.classList.add(`${DEFAULT_CONTEXT_MENU_CLASS}__item`);
    el.classList.toggle(DEFAULT_CONTEXT_MENU_DARK_CLASS, this.darkTheme);
    el.disabled = true;
    el.innerHTML = label;
    return el;
  }
  reposition() {
    const { x, y } = this;
    this.element.style.top = "unset";
    this.element.style.bottom = "unset";
    this.element.style.left = "unset";
    this.element.style.right = "unset";
    if (x + this.element.offsetWidth > getWindow2("innerWidth")) {
      this.element.style.right = `calc(100% - ${x - 1}px)`;
    } else {
      this.element.style.left = `${x + 1}px`;
    }
    if (y + this.element.offsetHeight > getWindow2("innerHeight")) {
      this.element.style.bottom = `calc(100% - ${y}px - 0.5em)`;
    } else {
      this.element.style.top = `calc(${y}px - 0.5em)`;
    }
  }
  destroy() {
    var _a2, _b;
    super.destroy();
    (_a2 = this.intersectionObserver) == null ? void 0 : _a2.unobserve(this.canvasElement);
    (_b = this.mutationObserver) == null ? void 0 : _b.disconnect();
  }
};
__decorateClass2([
  Validate15(BOOLEAN6)
], ContextMenu.prototype, "enabled", 2);
__decorateClass2([
  Validate15(BOOLEAN6)
], ContextMenu.prototype, "darkTheme", 2);
var ContextMenuModule = {
  type: "root",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "hierarchy", "topology"],
  optionsKey: "contextMenu",
  instanceConstructor: ContextMenu,
  themeTemplate: {
    contextMenu: {
      enabled: true,
      darkTheme: import_ag_charts_community26._Theme.IS_DARK_THEME
    }
  }
};
var import_ag_charts_community28 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community27 = (init_main(), __toCommonJS(main_exports));
var { ActionOnSet: ActionOnSet22, BaseProperties: BaseProperties3, BOOLEAN: BOOLEAN7, FUNCTION: FUNCTION2, NUMBER: NUMBER5, STRING: STRING3, Validate: Validate16, createElement: createElement3, injectStyle: injectStyle22 } = import_ag_charts_community27._ModuleSupport;
var { setAttribute: setAttribute2 } = import_ag_charts_community27._Util;
var { BBox: BBox2 } = import_ag_charts_community27._Scene;
var DEFAULT_LABEL_CLASS = "ag-crosshair-label";
var defaultLabelCss = `
.${DEFAULT_LABEL_CLASS} {
    position: absolute;
    left: 0px;
    top: 0px;
    user-select: none;
    pointer-events: none;
    font: 12px Verdana, sans-serif;
    overflow: hidden;
    white-space: nowrap;
    z-index: 99999;
    box-sizing: border-box;
}

.${DEFAULT_LABEL_CLASS}-content {
    padding: 0 7px;
    border-radius: 2px;
    line-height: 1.7em;
    background-color: rgb(71,71,71);
    color: rgb(255, 255, 255);
}

.${DEFAULT_LABEL_CLASS}-hidden {
    top: -10000px !important;
}
`;
var CrosshairLabelProperties = class extends import_ag_charts_community27._Scene.ChangeDetectableProperties {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.xOffset = 0;
    this.yOffset = 0;
    this.format = void 0;
    this.renderer = void 0;
  }
};
__decorateClass2([
  Validate16(BOOLEAN7)
], CrosshairLabelProperties.prototype, "enabled", 2);
__decorateClass2([
  Validate16(STRING3, { optional: true })
], CrosshairLabelProperties.prototype, "className", 2);
__decorateClass2([
  Validate16(NUMBER5)
], CrosshairLabelProperties.prototype, "xOffset", 2);
__decorateClass2([
  Validate16(NUMBER5)
], CrosshairLabelProperties.prototype, "yOffset", 2);
__decorateClass2([
  Validate16(STRING3, { optional: true })
], CrosshairLabelProperties.prototype, "format", 2);
__decorateClass2([
  Validate16(FUNCTION2, { optional: true })
], CrosshairLabelProperties.prototype, "renderer", 2);
var CrosshairLabel = class extends BaseProperties3 {
  constructor(labelRoot) {
    super();
    this.labelRoot = labelRoot;
    this.enabled = true;
    this.xOffset = 0;
    this.yOffset = 0;
    this.renderer = void 0;
    this.element = createElement3("div");
    this.element.classList.add(DEFAULT_LABEL_CLASS);
    setAttribute2(this.element, "aria-hidden", true);
    labelRoot.appendChild(this.element);
    injectStyle22(defaultLabelCss, "crosshairLabel");
  }
  show(meta) {
    const { element: element2 } = this;
    let left = meta.x + this.xOffset;
    let top = meta.y + this.yOffset;
    const limit = (low, actual, high) => {
      return Math.max(Math.min(actual, high), low);
    };
    const containerBounds = this.getContainerBoundingBox();
    const maxLeft = containerBounds.x + containerBounds.width - element2.clientWidth - 1;
    const maxTop = containerBounds.y + containerBounds.height - element2.clientHeight;
    left = limit(containerBounds.x + 1, left, maxLeft);
    top = limit(containerBounds.y, top, maxTop);
    element2.style.top = `${Math.round(top)}px`;
    element2.style.left = `${Math.round(left)}px`;
    this.toggle(true);
  }
  setLabelHtml(html) {
    if (html !== void 0) {
      this.element.innerHTML = html;
    }
  }
  computeBBox() {
    const { element: element2 } = this;
    return new import_ag_charts_community27._Scene.BBox(element2.clientLeft, element2.clientTop, element2.clientWidth, element2.clientHeight);
  }
  getContainerBoundingBox() {
    const { width, height } = this.labelRoot.getBoundingClientRect();
    return new BBox2(0, 0, width, height);
  }
  toggle(visible) {
    this.element.classList.toggle(`${DEFAULT_LABEL_CLASS}-hidden`, !visible);
  }
  destroy() {
    const { parentNode } = this.element;
    if (parentNode) {
      parentNode.removeChild(this.element);
    }
  }
  toLabelHtml(input, defaults) {
    var _a2, _b;
    if (typeof input === "string") {
      return input;
    }
    defaults = defaults != null ? defaults : {};
    const {
      text = (_a2 = defaults.text) != null ? _a2 : "",
      color = defaults.color,
      backgroundColor = defaults.backgroundColor,
      opacity = (_b = defaults.opacity) != null ? _b : 1
    } = input;
    const style = `opacity: ${opacity}; background-color: ${backgroundColor == null ? void 0 : backgroundColor.toLowerCase()}; color: ${color}`;
    return `<div class="${DEFAULT_LABEL_CLASS}-content" style="${style}">
                    <span>${text}</span>
                </div>`;
  }
};
__decorateClass2([
  Validate16(BOOLEAN7)
], CrosshairLabel.prototype, "enabled", 2);
__decorateClass2([
  Validate16(STRING3, { optional: true }),
  ActionOnSet22({
    changeValue(newValue, oldValue) {
      if (newValue !== oldValue) {
        if (oldValue) {
          this.element.classList.remove(oldValue);
        }
        if (newValue) {
          this.element.classList.add(newValue);
        }
      }
    }
  })
], CrosshairLabel.prototype, "className", 2);
__decorateClass2([
  Validate16(NUMBER5)
], CrosshairLabel.prototype, "xOffset", 2);
__decorateClass2([
  Validate16(NUMBER5)
], CrosshairLabel.prototype, "yOffset", 2);
__decorateClass2([
  Validate16(STRING3, { optional: true })
], CrosshairLabel.prototype, "format", 2);
__decorateClass2([
  Validate16(FUNCTION2, { optional: true })
], CrosshairLabel.prototype, "renderer", 2);
var { Group: Group3, Line: Line22, BBox: BBox22 } = import_ag_charts_community28._Scene;
var { createId: createId22 } = import_ag_charts_community28._Util;
var { POSITIVE_NUMBER: POSITIVE_NUMBER6, RATIO: RATIO6, BOOLEAN: BOOLEAN8, COLOR_STRING: COLOR_STRING3, LINE_DASH: LINE_DASH3, OBJECT: OBJECT3, Validate: Validate17, Layers: Layers3, getDocument: getDocument22 } = import_ag_charts_community28._ModuleSupport;
var Crosshair = class extends import_ag_charts_community28._ModuleSupport.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.id = createId22(this);
    this.enabled = false;
    this.stroke = "rgb(195, 195, 195)";
    this.lineDash = [6, 3];
    this.lineDashOffset = 0;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.snap = true;
    this.label = new CrosshairLabelProperties();
    this.seriesRect = new BBox22(0, 0, 0, 0);
    this.hoverRect = new BBox22(0, 0, 0, 0);
    this.bounds = new BBox22(0, 0, 0, 0);
    this.visible = false;
    this.crosshairGroup = new Group3({ layer: true, zIndex: Layers3.SERIES_CROSSHAIR_ZINDEX });
    this.lineGroup = this.crosshairGroup.appendChild(
      new Group3({
        name: `${this.id}-crosshair-lines`,
        zIndex: Layers3.SERIES_CROSSHAIR_ZINDEX
      })
    );
    this.lineGroupSelection = import_ag_charts_community28._Scene.Selection.select(this.lineGroup, Line22, false);
    this.activeHighlight = void 0;
    this.axisCtx = ctx.parent;
    this.crosshairGroup.visible = false;
    this.labels = {};
    const region = ctx.regionManager.getRegion("series");
    this.destroyFns.push(
      ctx.scene.attachNode(this.crosshairGroup),
      region.addListener("hover", (event) => this.onMouseMove(event)),
      region.addListener("leave", () => this.onMouseOut()),
      ctx.highlightManager.addListener("highlight-change", (event) => this.onHighlightChange(event)),
      ctx.layoutService.addListener("layout-complete", (event) => this.layout(event)),
      () => Object.entries(this.labels).forEach(([_, label]) => label.destroy())
    );
  }
  layout({ series: { rect, paddedRect, visible }, axes }) {
    this.hideCrosshairs();
    if (!(visible && axes && this.enabled)) {
      this.visible = false;
      return;
    }
    this.visible = true;
    this.seriesRect = rect;
    this.hoverRect = paddedRect;
    const { position: axisPosition = "left", axisId } = this.axisCtx;
    const axisLayout = axes.find((a) => a.id === axisId);
    if (!axisLayout) {
      return;
    }
    this.axisLayout = axisLayout;
    const padding = axisLayout.gridPadding + axisLayout.seriesAreaPadding;
    this.bounds = this.buildBounds(rect, axisPosition, padding);
    const { crosshairGroup, bounds } = this;
    crosshairGroup.translationX = Math.round(bounds.x);
    crosshairGroup.translationY = Math.round(bounds.y);
    const crosshairKeys = ["pointer", ...this.axisCtx.seriesKeyProperties()];
    this.updateSelections(crosshairKeys);
    this.updateLines();
    this.updateLabels(crosshairKeys);
  }
  buildBounds(rect, axisPosition, padding) {
    const bounds = rect.clone();
    bounds.x += axisPosition === "left" ? -padding : 0;
    bounds.y += axisPosition === "top" ? -padding : 0;
    bounds.width += axisPosition === "left" || axisPosition === "right" ? padding : 0;
    bounds.height += axisPosition === "top" || axisPosition === "bottom" ? padding : 0;
    return bounds;
  }
  updateSelections(data) {
    this.lineGroupSelection.update(
      data,
      (group2) => group2.append(new Line22()),
      (key) => key
    );
  }
  updateLabels(keys) {
    var _a2;
    const { labels, ctx, axisLayout } = this;
    keys.forEach((key) => {
      var _a3, _b;
      (_b = labels[key]) != null ? _b : labels[key] = new CrosshairLabel((_a3 = ctx.scene.canvas.container) != null ? _a3 : getDocument22("body"));
      this.updateLabel(labels[key]);
    });
    const format2 = (_a2 = this.label.format) != null ? _a2 : axisLayout == null ? void 0 : axisLayout.label.format;
    this.labelFormatter = format2 ? this.axisCtx.scaleValueFormatter(format2) : void 0;
  }
  updateLabel(label) {
    const { enabled, className, xOffset, yOffset, format: format2, renderer } = this.label;
    label.enabled = enabled;
    label.className = className;
    label.xOffset = xOffset;
    label.yOffset = yOffset;
    label.format = format2;
    label.renderer = renderer;
  }
  updateLines() {
    const { lineGroupSelection, bounds, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, axisLayout } = this;
    if (!axisLayout) {
      return;
    }
    const isVertical = this.isVertical();
    lineGroupSelection.each((line) => {
      line.stroke = stroke;
      line.strokeWidth = strokeWidth;
      line.strokeOpacity = strokeOpacity;
      line.lineDash = lineDash;
      line.lineDashOffset = lineDashOffset;
      line.y1 = 0;
      line.y2 = isVertical ? bounds.height : 0;
      line.x1 = 0;
      line.x2 = isVertical ? 0 : bounds.width;
    });
  }
  isVertical() {
    return this.axisCtx.direction === "x";
  }
  formatValue(val) {
    var _a2;
    const {
      labelFormatter,
      axisLayout,
      ctx: { callbackCache }
    } = this;
    if (labelFormatter) {
      const result = callbackCache.call(labelFormatter, val);
      if (result !== void 0)
        return result;
    }
    const isInteger = val % 1 === 0;
    const fractionDigits = ((_a2 = axisLayout == null ? void 0 : axisLayout.label.fractionDigits) != null ? _a2 : 0) + (isInteger ? 0 : 1);
    return typeof val === "number" ? val.toFixed(fractionDigits) : String(val);
  }
  onMouseMove(event) {
    if (!this.enabled || this.snap) {
      return;
    }
    const { crosshairGroup, hoverRect } = this;
    const { offsetX, offsetY } = event;
    if (this.visible && hoverRect.containsPoint(offsetX, offsetY)) {
      crosshairGroup.visible = true;
      const lineData = this.getData(event);
      this.updatePositions(lineData);
    } else {
      this.hideCrosshairs();
    }
  }
  onMouseOut() {
    this.hideCrosshairs();
  }
  onHighlightChange(event) {
    var _a2, _b, _c;
    if (!this.enabled) {
      return;
    }
    const { crosshairGroup, axisCtx } = this;
    const { datum, series } = (_a2 = event.currentHighlight) != null ? _a2 : {};
    const hasCrosshair = datum && (((_b = series == null ? void 0 : series.axes.x) == null ? void 0 : _b.id) === axisCtx.axisId || ((_c = series == null ? void 0 : series.axes.y) == null ? void 0 : _c.id) === axisCtx.axisId);
    this.activeHighlight = hasCrosshair ? event.currentHighlight : void 0;
    if (this.snap) {
      if (!this.visible || !this.activeHighlight) {
        this.hideCrosshairs();
        return;
      }
      const activeHighlightData = this.getActiveHighlightData(this.activeHighlight);
      this.updatePositions(activeHighlightData);
      crosshairGroup.visible = true;
    }
  }
  updatePositions(data) {
    const { seriesRect, lineGroupSelection } = this;
    lineGroupSelection.each((line, key) => {
      const lineData = data[key];
      if (!lineData) {
        line.visible = false;
        return;
      }
      line.visible = true;
      const { value, position } = lineData;
      let x = 0;
      let y = 0;
      if (this.isVertical()) {
        x = position;
        line.translationX = Math.round(x);
      } else {
        y = position;
        line.translationY = Math.round(y);
      }
      if (this.label.enabled) {
        this.showLabel(x + seriesRect.x, y + seriesRect.y, value, key);
      } else {
        this.hideLabel(key);
      }
    });
  }
  getData(event) {
    var _a2, _b;
    const { seriesRect, axisCtx } = this;
    const key = "pointer";
    const { datum, xKey = "", yKey = "" } = (_a2 = this.activeHighlight) != null ? _a2 : {};
    const { offsetX, offsetY } = event;
    const x = offsetX - seriesRect.x;
    const y = offsetY - seriesRect.y;
    const isVertical = this.isVertical();
    return {
      [key]: {
        position: isVertical ? x : y,
        value: axisCtx.continuous ? axisCtx.scaleInvert(isVertical ? x : y) : (_b = datum == null ? void 0 : datum[isVertical ? xKey : yKey]) != null ? _b : ""
      }
    };
  }
  getActiveHighlightData(activeHighlight) {
    var _a2, _b;
    const { axisCtx } = this;
    const { datum, series, xKey = "", aggregatedValue, cumulativeValue, midPoint } = activeHighlight;
    const seriesKeyProperties = series.getKeyProperties(axisCtx.direction);
    const halfBandwidth = axisCtx.scaleBandwidth() / 2;
    const matchingAxisId = ((_a2 = series.axes[axisCtx.direction]) == null ? void 0 : _a2.id) === axisCtx.axisId;
    const isYKey = seriesKeyProperties.indexOf("yKey") > -1 && matchingAxisId;
    const isXKey = seriesKeyProperties.indexOf("xKey") > -1 && matchingAxisId;
    if (isYKey && aggregatedValue !== void 0) {
      return {
        yKey: { value: aggregatedValue, position: axisCtx.scaleConvert(aggregatedValue) + halfBandwidth }
      };
    }
    if (isYKey && cumulativeValue !== void 0) {
      return {
        yKey: { value: cumulativeValue, position: axisCtx.scaleConvert(cumulativeValue) + halfBandwidth }
      };
    }
    if (isXKey) {
      const position = (_b = this.isVertical() ? midPoint == null ? void 0 : midPoint.x : midPoint == null ? void 0 : midPoint.y) != null ? _b : 0;
      return {
        xKey: {
          value: axisCtx.continuous ? axisCtx.scaleInvert(position) : datum[xKey],
          position
        }
      };
    }
    const activeHighlightData = {};
    seriesKeyProperties.forEach((key) => {
      const keyValue = series.properties[key];
      const value = datum[keyValue];
      const position = axisCtx.scaleConvert(value) + halfBandwidth;
      activeHighlightData[key] = { value, position };
    });
    return activeHighlightData;
  }
  getLabelHtml(value, label) {
    const {
      label: { renderer: labelRenderer },
      axisLayout: { label: { fractionDigits = 0 } = {} } = {}
    } = this;
    const defaults = {
      text: this.formatValue(value)
    };
    if (labelRenderer) {
      const params = {
        value,
        fractionDigits
      };
      return label.toLabelHtml(labelRenderer(params), defaults);
    }
    return label.toLabelHtml(defaults);
  }
  showLabel(x, y, value, key) {
    const { axisCtx, bounds, axisLayout } = this;
    if (!axisLayout) {
      return;
    }
    const {
      label: { padding: labelPadding },
      tickSize
    } = axisLayout;
    const padding = labelPadding + tickSize;
    const label = this.labels[key];
    const html = this.getLabelHtml(value, label);
    label.setLabelHtml(html);
    const labelBBox = label.computeBBox();
    let labelMeta;
    if (this.isVertical()) {
      const xOffset = -labelBBox.width / 2;
      const yOffset = axisCtx.position === "bottom" ? 0 : -labelBBox.height;
      const fixedY = axisCtx.position === "bottom" ? bounds.y + bounds.height + padding : bounds.y - padding;
      labelMeta = {
        x: x + xOffset,
        y: fixedY + yOffset
      };
    } else {
      const yOffset = -labelBBox.height / 2;
      const xOffset = axisCtx.position === "right" ? 0 : -labelBBox.width;
      const fixedX = axisCtx.position === "right" ? bounds.x + bounds.width + padding : bounds.x - padding;
      labelMeta = {
        x: fixedX + xOffset,
        y: y + yOffset
      };
    }
    label.show(labelMeta);
  }
  hideCrosshairs() {
    this.crosshairGroup.visible = false;
    for (const key in this.labels) {
      this.hideLabel(key);
    }
  }
  hideLabel(key) {
    this.labels[key].toggle(false);
  }
};
__decorateClass2([
  Validate17(BOOLEAN8)
], Crosshair.prototype, "enabled", 2);
__decorateClass2([
  Validate17(COLOR_STRING3, { optional: true })
], Crosshair.prototype, "stroke", 2);
__decorateClass2([
  Validate17(LINE_DASH3, { optional: true })
], Crosshair.prototype, "lineDash", 2);
__decorateClass2([
  Validate17(POSITIVE_NUMBER6)
], Crosshair.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate17(POSITIVE_NUMBER6)
], Crosshair.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate17(RATIO6)
], Crosshair.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate17(BOOLEAN8)
], Crosshair.prototype, "snap", 2);
__decorateClass2([
  Validate17(OBJECT3)
], Crosshair.prototype, "label", 2);
var import_ag_charts_community29 = (init_main(), __toCommonJS(main_exports));
var AXIS_CROSSHAIR_THEME = {
  crosshair: {
    enabled: true,
    snap: true,
    stroke: import_ag_charts_community29._Theme.DEFAULT_MUTED_LABEL_COLOUR,
    strokeWidth: 1,
    strokeOpacity: 1,
    lineDash: [5, 6],
    lineDashOffset: 0,
    label: {
      enabled: true
    }
  },
  category: {
    crosshair: {
      enabled: false,
      snap: true,
      stroke: import_ag_charts_community29._Theme.DEFAULT_MUTED_LABEL_COLOUR,
      strokeWidth: 1,
      strokeOpacity: 1,
      lineDash: [5, 6],
      lineDashOffset: 0,
      label: {
        enabled: true
      }
    }
  }
};
var CrosshairModule = {
  type: "axis-option",
  optionsKey: "crosshair",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  axisTypes: ["category", "ordinal-time", "number", "log", "time"],
  instanceConstructor: Crosshair,
  themeTemplate: AXIS_CROSSHAIR_THEME
};
var import_ag_charts_community30 = (init_main(), __toCommonJS(main_exports));
var { BOOLEAN: BOOLEAN9, FUNCTION: FUNCTION22, ActionOnSet: ActionOnSet3, Validate: Validate18 } = import_ag_charts_community30._ModuleSupport;
var DataSource = class extends import_ag_charts_community30._ModuleSupport.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.enabled = false;
    this.getData = () => Promise.resolve();
    this.dataService = ctx.dataService;
  }
  updateCallback(enabled, getData) {
    if (!this.dataService)
      return;
    if (enabled && getData != null) {
      this.dataService.updateCallback(getData);
    } else {
      this.dataService.clearCallback();
    }
  }
};
__decorateClass2([
  ActionOnSet3({
    newValue(enabled) {
      this.updateCallback(enabled, this.getData);
    }
  }),
  Validate18(BOOLEAN9)
], DataSource.prototype, "enabled", 2);
__decorateClass2([
  ActionOnSet3({
    newValue(getData) {
      this.updateCallback(this.enabled, getData);
    }
  }),
  Validate18(FUNCTION22)
], DataSource.prototype, "getData", 2);
__decorateClass2([
  ActionOnSet3({
    newValue(requestThrottle) {
      this.dataService.requestThrottle = requestThrottle;
    }
  })
], DataSource.prototype, "requestThrottle", 2);
__decorateClass2([
  ActionOnSet3({
    newValue(updateThrottle) {
      this.dataService.dispatchThrottle = updateThrottle;
    }
  })
], DataSource.prototype, "updateThrottle", 2);
__decorateClass2([
  ActionOnSet3({
    newValue(updateDuringInteraction) {
      this.dataService.dispatchOnlyLatest = !updateDuringInteraction;
    }
  })
], DataSource.prototype, "updateDuringInteraction", 2);
var DataSourceModule = {
  type: "root",
  optionsKey: "dataSource",
  packageType: "enterprise",
  chartTypes: ["cartesian", "hierarchy", "polar", "topology"],
  instanceConstructor: DataSource,
  themeTemplate: {
    dataSource: { enabled: false }
  }
};
var import_ag_charts_community35 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community33 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community31 = (init_main(), __toCommonJS(main_exports));
var { partialAssign: partialAssign2, mergeDefaults: mergeDefaults2 } = import_ag_charts_community31._ModuleSupport;
var { BBox: BBox3 } = import_ag_charts_community31._Scene;
var HierarchicalBBox = class {
  constructor(components) {
    this.components = components;
    this.union = BBox3.merge(components);
  }
  containsPoint(x, y) {
    if (!this.union.containsPoint(x, y)) {
      return false;
    }
    for (const bbox of this.components) {
      if (bbox.containsPoint(x, y)) {
        return true;
      }
    }
    return false;
  }
};
var ErrorBarNode = class extends import_ag_charts_community31._Scene.Group {
  constructor() {
    super();
    this.capLength = NaN;
    this._datum = void 0;
    this.whiskerPath = new import_ag_charts_community31._Scene.Path();
    this.capsPath = new import_ag_charts_community31._Scene.Path();
    this.bboxes = new HierarchicalBBox([]);
    this.append([this.whiskerPath, this.capsPath]);
  }
  get datum() {
    return this._datum;
  }
  set datum(datum) {
    this._datum = datum;
  }
  calculateCapLength(capsTheme, capDefaults) {
    const { lengthRatio = 1, length } = capsTheme;
    const { lengthRatioMultiplier, lengthMax } = capDefaults;
    const desiredLength = length != null ? length : lengthRatio * lengthRatioMultiplier;
    return Math.min(desiredLength, lengthMax);
  }
  getFormatterParams(formatters, highlighted) {
    const { datum } = this;
    if (datum === void 0 || formatters.formatter === void 0 && formatters.cap.formatter === void 0) {
      return;
    }
    const { xLowerKey, xLowerName, xUpperKey, xUpperName, yLowerKey, yLowerName, yUpperKey, yUpperName } = formatters;
    return {
      datum: datum.datum,
      seriesId: datum.datum.seriesId,
      xKey: datum.xKey,
      yKey: datum.yKey,
      xLowerKey,
      xLowerName,
      xUpperKey,
      xUpperName,
      yLowerKey,
      yLowerName,
      yUpperKey,
      yUpperName,
      highlighted
    };
  }
  formatStyles(style, formatters, highlighted) {
    let _a2 = style, { cap: capsStyle } = _a2, whiskerStyle = __objRest2(_a2, ["cap"]);
    const params = this.getFormatterParams(formatters, highlighted);
    if (params !== void 0) {
      if (formatters.formatter !== void 0) {
        const result = formatters.formatter(params);
        whiskerStyle = mergeDefaults2(result, whiskerStyle);
        capsStyle = mergeDefaults2(result, capsStyle);
        capsStyle = mergeDefaults2(result == null ? void 0 : result.cap, capsStyle);
      }
      if (formatters.cap.formatter !== void 0) {
        const result = formatters.cap.formatter(params);
        capsStyle = mergeDefaults2(result, capsStyle);
      }
    }
    return { whiskerStyle, capsStyle };
  }
  applyStyling(target, source) {
    partialAssign2(
      ["visible", "stroke", "strokeWidth", "strokeOpacity", "lineDash", "lineDashOffset"],
      target,
      source
    );
  }
  update(style, formatters, highlighted) {
    if (this.datum === void 0) {
      return;
    }
    const { whiskerStyle, capsStyle } = this.formatStyles(style, formatters, highlighted);
    const { xBar, yBar, capDefaults } = this.datum;
    const whisker = this.whiskerPath;
    this.applyStyling(whisker, whiskerStyle);
    whisker.path.clear();
    if (yBar !== void 0) {
      whisker.path.moveTo(yBar.lowerPoint.x, yBar.lowerPoint.y);
      whisker.path.lineTo(yBar.upperPoint.x, yBar.upperPoint.y);
    }
    if (xBar !== void 0) {
      whisker.path.moveTo(xBar.lowerPoint.x, xBar.lowerPoint.y);
      whisker.path.lineTo(xBar.upperPoint.x, xBar.upperPoint.y);
    }
    whisker.path.closePath();
    whisker.markDirtyTransform();
    this.capLength = this.calculateCapLength(capsStyle != null ? capsStyle : {}, capDefaults);
    const capOffset = this.capLength / 2;
    const caps = this.capsPath;
    this.applyStyling(caps, capsStyle);
    caps.path.clear();
    if (yBar !== void 0) {
      caps.path.moveTo(yBar.lowerPoint.x - capOffset, yBar.lowerPoint.y);
      caps.path.lineTo(yBar.lowerPoint.x + capOffset, yBar.lowerPoint.y);
      caps.path.moveTo(yBar.upperPoint.x - capOffset, yBar.upperPoint.y);
      caps.path.lineTo(yBar.upperPoint.x + capOffset, yBar.upperPoint.y);
    }
    if (xBar !== void 0) {
      caps.path.moveTo(xBar.lowerPoint.x, xBar.lowerPoint.y - capOffset);
      caps.path.lineTo(xBar.lowerPoint.x, xBar.lowerPoint.y + capOffset);
      caps.path.moveTo(xBar.upperPoint.x, xBar.upperPoint.y - capOffset);
      caps.path.lineTo(xBar.upperPoint.x, xBar.upperPoint.y + capOffset);
    }
    caps.path.closePath();
    caps.markDirtyTransform();
  }
  updateBBoxes() {
    var _a2;
    const { capLength, whiskerPath: whisker, capsPath: caps } = this;
    const { yBar, xBar } = (_a2 = this.datum) != null ? _a2 : {};
    const capOffset = capLength / 2;
    const components = [];
    if (yBar !== void 0) {
      const whiskerHeight = yBar.lowerPoint.y - yBar.upperPoint.y;
      components.push(
        new BBox3(yBar.lowerPoint.x, yBar.upperPoint.y, whisker.strokeWidth, whiskerHeight),
        new BBox3(yBar.lowerPoint.x - capOffset, yBar.lowerPoint.y, capLength, caps.strokeWidth),
        new BBox3(yBar.upperPoint.x - capOffset, yBar.upperPoint.y, capLength, caps.strokeWidth)
      );
    }
    if (xBar !== void 0) {
      const whiskerWidth = xBar.upperPoint.x - xBar.lowerPoint.x;
      components.push(
        new BBox3(xBar.lowerPoint.x, xBar.upperPoint.y, whiskerWidth, whisker.strokeWidth),
        new BBox3(xBar.lowerPoint.x, xBar.lowerPoint.y - capOffset, caps.strokeWidth, capLength),
        new BBox3(xBar.upperPoint.x, xBar.upperPoint.y - capOffset, caps.strokeWidth, capLength)
      );
    }
    this.bboxes.components = components;
    this.bboxes.union = BBox3.merge(components);
  }
  containsPoint(x, y) {
    return this.bboxes.containsPoint(x, y);
  }
  pickNode(x, y) {
    return this.containsPoint(x, y) ? this : void 0;
  }
  nearestSquared(x, y, maxDistance) {
    const { bboxes } = this;
    if (bboxes.union.distanceSquared(x, y) > maxDistance) {
      return { nearest: void 0, distanceSquared: Infinity };
    }
    const { distanceSquared: distanceSquared2 } = BBox3.nearestBox(x, y, bboxes.components);
    return { nearest: this, distanceSquared: distanceSquared2 };
  }
};
var ErrorBarGroup = class extends import_ag_charts_community31._Scene.Group {
  get children() {
    return super.children;
  }
  nearestSquared(x, y) {
    const { nearest, distanceSquared: distanceSquared2 } = import_ag_charts_community31._Scene.nearestSquaredInContainer(x, y, this);
    if (nearest !== void 0 && !isNaN(distanceSquared2)) {
      return { datum: nearest.datum, distanceSquared: distanceSquared2 };
    }
  }
};
var import_ag_charts_community32 = (init_main(), __toCommonJS(main_exports));
var {
  BaseProperties: BaseProperties4,
  Validate: Validate19,
  BOOLEAN: BOOLEAN10,
  COLOR_STRING: COLOR_STRING4,
  FUNCTION: FUNCTION3,
  LINE_DASH: LINE_DASH4,
  NUMBER: NUMBER6,
  OBJECT: OBJECT4,
  POSITIVE_NUMBER: POSITIVE_NUMBER7,
  RATIO: RATIO7,
  STRING: STRING4
} = import_ag_charts_community32._ModuleSupport;
var ErrorBarCap = class extends BaseProperties4 {
};
__decorateClass2([
  Validate19(BOOLEAN10, { optional: true })
], ErrorBarCap.prototype, "visible", 2);
__decorateClass2([
  Validate19(COLOR_STRING4, { optional: true })
], ErrorBarCap.prototype, "stroke", 2);
__decorateClass2([
  Validate19(POSITIVE_NUMBER7, { optional: true })
], ErrorBarCap.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate19(RATIO7, { optional: true })
], ErrorBarCap.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate19(LINE_DASH4, { optional: true })
], ErrorBarCap.prototype, "lineDash", 2);
__decorateClass2([
  Validate19(POSITIVE_NUMBER7, { optional: true })
], ErrorBarCap.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate19(NUMBER6, { optional: true })
], ErrorBarCap.prototype, "length", 2);
__decorateClass2([
  Validate19(RATIO7, { optional: true })
], ErrorBarCap.prototype, "lengthRatio", 2);
__decorateClass2([
  Validate19(FUNCTION3, { optional: true })
], ErrorBarCap.prototype, "formatter", 2);
var ErrorBarProperties = class extends BaseProperties4 {
  constructor() {
    super(...arguments);
    this.visible = true;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.cap = new ErrorBarCap();
  }
};
__decorateClass2([
  Validate19(STRING4, { optional: true })
], ErrorBarProperties.prototype, "yLowerKey", 2);
__decorateClass2([
  Validate19(STRING4, { optional: true })
], ErrorBarProperties.prototype, "yLowerName", 2);
__decorateClass2([
  Validate19(STRING4, { optional: true })
], ErrorBarProperties.prototype, "yUpperKey", 2);
__decorateClass2([
  Validate19(STRING4, { optional: true })
], ErrorBarProperties.prototype, "yUpperName", 2);
__decorateClass2([
  Validate19(STRING4, { optional: true })
], ErrorBarProperties.prototype, "xLowerKey", 2);
__decorateClass2([
  Validate19(STRING4, { optional: true })
], ErrorBarProperties.prototype, "xLowerName", 2);
__decorateClass2([
  Validate19(STRING4, { optional: true })
], ErrorBarProperties.prototype, "xUpperKey", 2);
__decorateClass2([
  Validate19(STRING4, { optional: true })
], ErrorBarProperties.prototype, "xUpperName", 2);
__decorateClass2([
  Validate19(BOOLEAN10, { optional: true })
], ErrorBarProperties.prototype, "visible", 2);
__decorateClass2([
  Validate19(COLOR_STRING4, { optional: true })
], ErrorBarProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate19(POSITIVE_NUMBER7, { optional: true })
], ErrorBarProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate19(RATIO7, { optional: true })
], ErrorBarProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate19(LINE_DASH4, { optional: true })
], ErrorBarProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate19(POSITIVE_NUMBER7, { optional: true })
], ErrorBarProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate19(FUNCTION3, { optional: true })
], ErrorBarProperties.prototype, "formatter", 2);
__decorateClass2([
  Validate19(OBJECT4)
], ErrorBarProperties.prototype, "cap", 2);
var {
  fixNumericExtent: fixNumericExtent2,
  groupAccumulativeValueProperty: groupAccumulativeValueProperty2,
  isDefined: isDefined2,
  mergeDefaults: mergeDefaults22,
  valueProperty: valueProperty2,
  ChartAxisDirection: ChartAxisDirection6
} = import_ag_charts_community33._ModuleSupport;
function toErrorBoundCartesianSeries(ctx) {
  for (const supportedType of import_ag_charts_community33.AgErrorBarSupportedSeriesTypes) {
    if (supportedType === ctx.series.type) {
      return ctx.series;
    }
  }
  throw new Error(
    `AG Charts - unsupported series type '${ctx.series.type}', error bars supported series types: ${import_ag_charts_community33.AgErrorBarSupportedSeriesTypes.join(", ")}`
  );
}
var ErrorBars = class _ErrorBars extends import_ag_charts_community33._ModuleSupport.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.properties = new ErrorBarProperties();
    const series = toErrorBoundCartesianSeries(ctx);
    const { annotationGroup, annotationSelections } = series;
    this.cartesianSeries = series;
    this.groupNode = new ErrorBarGroup({
      name: `${annotationGroup.id}-errorBars`,
      zIndex: import_ag_charts_community33._ModuleSupport.Layers.SERIES_LAYER_ZINDEX,
      zIndexSubOrder: series.getGroupZIndexSubOrder("annotation")
    });
    annotationGroup.appendChild(this.groupNode);
    this.selection = import_ag_charts_community33._Scene.Selection.select(this.groupNode, () => this.errorBarFactory());
    annotationSelections.add(this.selection);
    this.destroyFns.push(
      series.addListener("data-processed", (e) => this.onDataProcessed(e)),
      series.addListener("data-update", (e) => this.onDataUpdate(e)),
      series.addListener("visibility-changed", (e) => this.onToggleSeriesItem(e)),
      ctx.highlightManager.addListener("highlight-change", (event) => this.onHighlightChange(event)),
      () => annotationGroup.removeChild(this.groupNode),
      () => annotationSelections.delete(this.selection)
    );
  }
  hasErrorBars() {
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.properties;
    return isDefined2(xLowerKey) && isDefined2(xUpperKey) || isDefined2(yLowerKey) && isDefined2(yUpperKey);
  }
  isStacked() {
    var _a2;
    const stackCount = (_a2 = this.cartesianSeries.seriesGrouping) == null ? void 0 : _a2.stackCount;
    return stackCount == null ? false : stackCount > 0;
  }
  getUnstackPropertyDefinition(opts) {
    const props = [];
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey, xErrorsID, yErrorsID } = this.getMaybeFlippedKeys();
    const { xScaleType, yScaleType } = opts;
    if (yLowerKey != null && yUpperKey != null) {
      props.push(
        valueProperty2(yLowerKey, yScaleType, { id: `${yErrorsID}-lower` }),
        valueProperty2(yUpperKey, yScaleType, { id: `${yErrorsID}-upper` })
      );
    }
    if (xLowerKey != null && xUpperKey != null) {
      props.push(
        valueProperty2(xLowerKey, xScaleType, { id: `${xErrorsID}-lower` }),
        valueProperty2(xUpperKey, xScaleType, { id: `${xErrorsID}-upper` })
      );
    }
    return props;
  }
  getStackPropertyDefinition(opts) {
    var _a2, _b;
    const props = [];
    const { cartesianSeries } = this;
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey, xErrorsID, yErrorsID } = this.getMaybeFlippedKeys();
    const { xScaleType, yScaleType } = opts;
    const groupIndex = (_b = (_a2 = cartesianSeries.seriesGrouping) == null ? void 0 : _a2.groupIndex) != null ? _b : cartesianSeries.id;
    const groupOpts = __spreadValues2({
      invalidValue: null,
      missingValue: 0,
      separateNegative: true
    }, cartesianSeries.visible ? {} : { forceValue: 0 });
    const makeErrorProperty = (key, id, type, scaleType) => {
      return groupAccumulativeValueProperty2(
        key,
        "normal",
        "current",
        __spreadValues2({
          id: `${id}-${type}`,
          groupId: `errorGroup-${groupIndex}-${type}`
        }, groupOpts),
        scaleType
      );
    };
    const pushErrorProperties = (lowerKey, upperKey, id, scaleType) => {
      props.push(
        ...makeErrorProperty(lowerKey, id, "lower", scaleType),
        ...makeErrorProperty(upperKey, id, "upper", scaleType)
      );
    };
    if (yLowerKey != null && yUpperKey != null) {
      pushErrorProperties(yLowerKey, yUpperKey, yErrorsID, yScaleType);
    }
    if (xLowerKey != null && xUpperKey != null) {
      pushErrorProperties(xLowerKey, xUpperKey, xErrorsID, xScaleType);
    }
    return props;
  }
  getPropertyDefinitions(opts) {
    if (this.isStacked()) {
      return this.getStackPropertyDefinition(opts);
    } else {
      return this.getUnstackPropertyDefinition(opts);
    }
  }
  onDataProcessed(event) {
    this.dataModel = event.dataModel;
    this.processedData = event.processedData;
  }
  getDomain(direction) {
    const { xLowerKey, xUpperKey, xErrorsID, yLowerKey, yUpperKey, yErrorsID } = this.getMaybeFlippedKeys();
    const hasAxisErrors = direction === ChartAxisDirection6.X ? isDefined2(xLowerKey) && isDefined2(xUpperKey) : isDefined2(yLowerKey) && isDefined2(yUpperKey);
    if (hasAxisErrors) {
      const { dataModel, processedData, cartesianSeries: series } = this;
      if (dataModel != null && processedData != null) {
        const axis = series.axes[direction];
        const id = { x: xErrorsID, y: yErrorsID }[direction];
        const lowerDomain = dataModel.getDomain(series, `${id}-lower`, "value", processedData);
        const upperDomain = dataModel.getDomain(series, `${id}-upper`, "value", processedData);
        const domain = [Math.min(...lowerDomain, ...upperDomain), Math.max(...lowerDomain, ...upperDomain)];
        return fixNumericExtent2(domain, axis);
      }
    }
    return [];
  }
  onDataUpdate(event) {
    this.dataModel = event.dataModel;
    this.processedData = event.processedData;
    if (isDefined2(event.dataModel) && isDefined2(event.processedData)) {
      this.createNodeData();
      this.update();
    }
  }
  getNodeData() {
    var _a2;
    return (_a2 = this.cartesianSeries.contextNodeData) == null ? void 0 : _a2.nodeData;
  }
  createNodeData() {
    var _a2, _b;
    const nodeData = this.getNodeData();
    const xScale = (_a2 = this.cartesianSeries.axes[ChartAxisDirection6.X]) == null ? void 0 : _a2.scale;
    const yScale = (_b = this.cartesianSeries.axes[ChartAxisDirection6.Y]) == null ? void 0 : _b.scale;
    if (!this.hasErrorBars() || !xScale || !yScale || !nodeData) {
      return;
    }
    for (let i = 0; i < nodeData.length; i++) {
      const { midPoint, xLower, xUpper, yLower, yUpper } = this.getDatum(nodeData, i);
      if (midPoint != null) {
        let xBar, yBar;
        if (isDefined2(xLower) && isDefined2(xUpper)) {
          xBar = {
            lowerPoint: { x: this.convert(xScale, xLower), y: midPoint.y },
            upperPoint: { x: this.convert(xScale, xUpper), y: midPoint.y }
          };
        }
        if (isDefined2(yLower) && isDefined2(yUpper)) {
          yBar = {
            lowerPoint: { x: midPoint.x, y: this.convert(yScale, yLower) },
            upperPoint: { x: midPoint.x, y: this.convert(yScale, yUpper) }
          };
        }
        nodeData[i].xBar = xBar;
        nodeData[i].yBar = yBar;
      }
    }
  }
  getMaybeFlippedKeys() {
    let { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.properties;
    let [xErrorsID, yErrorsID] = ["xValue-errors", "yValue-errors"];
    if (this.cartesianSeries.shouldFlipXY()) {
      [xLowerKey, yLowerKey] = [yLowerKey, xLowerKey];
      [xUpperKey, yUpperKey] = [yUpperKey, xUpperKey];
      [xErrorsID, yErrorsID] = [yErrorsID, xErrorsID];
    }
    return { xLowerKey, xUpperKey, xErrorsID, yLowerKey, yUpperKey, yErrorsID };
  }
  static getDatumKey(datum, key, offset4) {
    if (key == null) {
      return;
    }
    const value = datum.datum[key];
    if (value == null) {
      return;
    }
    if (typeof value !== "number") {
      import_ag_charts_community33._Util.Logger.warnOnce(`Found [${key}] error value of type ${typeof value}. Expected number type`);
      return;
    }
    return value + offset4;
  }
  getDatum(nodeData, datumIndex) {
    const { xLowerKey, xUpperKey, yLowerKey, yUpperKey } = this.getMaybeFlippedKeys();
    const datum = nodeData[datumIndex];
    const d = datum.cumulativeValue == null || !this.isStacked() ? 0 : datum.cumulativeValue - datum.yValue;
    const [xOffset, yOffset] = this.cartesianSeries.shouldFlipXY() ? [d, 0] : [0, d];
    return {
      midPoint: datum.midPoint,
      xLower: _ErrorBars.getDatumKey(datum, xLowerKey, xOffset),
      xUpper: _ErrorBars.getDatumKey(datum, xUpperKey, xOffset),
      yLower: _ErrorBars.getDatumKey(datum, yLowerKey, yOffset),
      yUpper: _ErrorBars.getDatumKey(datum, yUpperKey, yOffset)
    };
  }
  convert(scale2, value) {
    var _a2;
    const offset4 = ((_a2 = scale2.bandwidth) != null ? _a2 : 0) / 2;
    return scale2.convert(value) + offset4;
  }
  update() {
    const nodeData = this.getNodeData();
    if (nodeData != null) {
      this.selection.update(nodeData);
      this.selection.each((node, datum, i) => this.updateNode(node, datum, i));
    }
  }
  updateNode(node, datum, _index) {
    node.datum = datum;
    node.update(this.getDefaultStyle(), this.properties, false);
    node.updateBBoxes();
  }
  pickNodeExact(point) {
    const { x, y } = this.groupNode.transformPoint(point.x, point.y);
    const node = this.groupNode.pickNode(x, y);
    if (node != null) {
      return { datum: node.datum, distanceSquared: 0 };
    }
  }
  pickNodeNearest(point) {
    return this.groupNode.nearestSquared(point.x, point.y);
  }
  pickNodeMainAxisFirst(point) {
    return this.groupNode.nearestSquared(point.x, point.y);
  }
  getTooltipParams() {
    const {
      xLowerKey,
      xUpperKey,
      yLowerKey,
      yUpperKey,
      xLowerName = xLowerKey,
      xUpperName = xUpperKey,
      yLowerName = yLowerKey,
      yUpperName = yUpperKey
    } = this.properties;
    return { xLowerKey, xLowerName, xUpperKey, xUpperName, yLowerKey, yLowerName, yUpperKey, yUpperName };
  }
  onToggleSeriesItem(event) {
    this.groupNode.visible = event.enabled;
  }
  makeStyle(baseStyle) {
    return {
      visible: baseStyle.visible,
      lineDash: baseStyle.lineDash,
      lineDashOffset: baseStyle.lineDashOffset,
      stroke: baseStyle.stroke,
      strokeWidth: baseStyle.strokeWidth,
      strokeOpacity: baseStyle.strokeOpacity,
      cap: mergeDefaults22(this.properties.cap, baseStyle)
    };
  }
  getDefaultStyle() {
    return this.makeStyle(this.getWhiskerProperties());
  }
  getHighlightStyle() {
    return this.makeStyle(this.getWhiskerProperties());
  }
  restyleHighlightChange(highlightChange, style, highlighted) {
    const nodeData = this.getNodeData();
    if (nodeData == null)
      return;
    for (let i = 0; i < nodeData.length; i++) {
      if (highlightChange === nodeData[i]) {
        this.selection.nodes()[i].update(style, this.properties, highlighted);
        break;
      }
    }
  }
  onHighlightChange(event) {
    const { previousHighlight, currentHighlight } = event;
    if ((currentHighlight == null ? void 0 : currentHighlight.series) === this.cartesianSeries) {
      this.restyleHighlightChange(currentHighlight, this.getHighlightStyle(), true);
    }
    if ((previousHighlight == null ? void 0 : previousHighlight.series) === this.cartesianSeries) {
      this.restyleHighlightChange(previousHighlight, this.getDefaultStyle(), false);
    }
    this.groupNode.opacity = this.cartesianSeries.getOpacity();
  }
  errorBarFactory() {
    return new ErrorBarNode();
  }
  getWhiskerProperties() {
    const { stroke, strokeWidth, visible, strokeOpacity, lineDash, lineDashOffset } = this.properties;
    return { stroke, strokeWidth, visible, strokeOpacity, lineDash, lineDashOffset };
  }
};
var import_ag_charts_community34 = (init_main(), __toCommonJS(main_exports));
var ERROR_BARS_THEME = {
  series: {
    errorBar: {
      visible: true,
      stroke: import_ag_charts_community34._Theme.DEFAULT_LABEL_COLOUR,
      strokeWidth: 1,
      strokeOpacity: 1,
      cap: {
        length: void 0,
        lengthRatio: void 0
      }
    }
  }
};
var ErrorBarsModule = {
  type: "series-option",
  identifier: "error-bars",
  optionsKey: "errorBar",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  seriesTypes: import_ag_charts_community35.AgErrorBarSupportedSeriesTypes,
  instanceConstructor: ErrorBars,
  themeTemplate: ERROR_BARS_THEME
};
var import_ag_charts_community38 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community37 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community36 = (init_main(), __toCommonJS(main_exports));
var { Validate: Validate20, BOOLEAN: BOOLEAN11, POSITIVE_NUMBER: POSITIVE_NUMBER8, Layers: Layers4, ActionOnSet: ActionOnSet4, CategoryAxis: CategoryAxis2, GroupedCategoryAxis: GroupedCategoryAxis2 } = import_ag_charts_community36._ModuleSupport;
var { toRadians: toRadians4, Padding: Padding2, Logger: Logger2 } = import_ag_charts_community36._Util;
var { Text: Text4, Group: Group4, BBox: BBox4 } = import_ag_charts_community36._Scene;
var MiniChartPadding = class {
  constructor() {
    this.top = 0;
    this.bottom = 0;
  }
};
__decorateClass2([
  Validate20(POSITIVE_NUMBER8)
], MiniChartPadding.prototype, "top", 2);
__decorateClass2([
  Validate20(POSITIVE_NUMBER8)
], MiniChartPadding.prototype, "bottom", 2);
var MiniChart = class extends import_ag_charts_community36._ModuleSupport.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.padding = new MiniChartPadding();
    this.root = new Group4({ name: "root" });
    this.seriesRoot = this.root.appendChild(
      new Group4({ name: "Series-root", layer: true, zIndex: Layers4.SERIES_LAYER_ZINDEX })
    );
    this.axisGridGroup = this.root.appendChild(
      new Group4({ name: "Axes-Grids", layer: true, zIndex: Layers4.AXIS_GRID_ZINDEX })
    );
    this.axisGroup = this.root.appendChild(
      new Group4({ name: "Axes-Grids", layer: true, zIndex: Layers4.AXIS_GRID_ZINDEX })
    );
    this.data = [];
    this._destroyed = false;
    this.miniChartAnimationPhase = "initial";
    this.axes = [];
    this.series = [];
  }
  destroy() {
    if (this._destroyed) {
      return;
    }
    this.destroySeries(this.series);
    this.axes.forEach((a) => a.destroy());
    this.axes = [];
    this._destroyed = true;
  }
  onSeriesChange(newValue, oldValue) {
    var _a2;
    const seriesToDestroy = (_a2 = oldValue == null ? void 0 : oldValue.filter((series) => !newValue.includes(series))) != null ? _a2 : [];
    this.destroySeries(seriesToDestroy);
    for (const series of newValue) {
      if (oldValue == null ? void 0 : oldValue.includes(series))
        continue;
      if (series.rootGroup.parent == null) {
        this.seriesRoot.appendChild(series.rootGroup);
      }
      const chart = this;
      series.chart = {
        get mode() {
          return "standalone";
        },
        get isMiniChart() {
          return true;
        },
        get seriesRect() {
          return chart.seriesRect;
        },
        placeLabels() {
          return /* @__PURE__ */ new Map();
        }
      };
      series.resetAnimation(this.miniChartAnimationPhase === "initial" ? "initial" : "disabled");
    }
  }
  destroySeries(allSeries) {
    allSeries == null ? void 0 : allSeries.forEach((series) => {
      series.destroy();
      if (series.rootGroup != null) {
        this.seriesRoot.removeChild(series.rootGroup);
      }
      series.chart = void 0;
    });
  }
  assignSeriesToAxes() {
    this.axes.forEach((axis) => {
      axis.boundSeries = this.series.filter((s) => {
        const seriesAxis = s.axes[axis.direction];
        return seriesAxis === axis;
      });
    });
  }
  assignAxesToSeries() {
    const directionToAxesMap = {};
    this.axes.forEach((axis) => {
      var _a2;
      const direction = axis.direction;
      const directionAxes = (_a2 = directionToAxesMap[direction]) != null ? _a2 : directionToAxesMap[direction] = [];
      directionAxes.push(axis);
    });
    this.series.forEach((series) => {
      series.directions.forEach((direction) => {
        const directionAxes = directionToAxesMap[direction];
        if (!directionAxes) {
          Logger2.warnOnce(
            `no available axis for direction [${direction}]; check series and axes configuration.`
          );
          return;
        }
        const seriesKeys = series.getKeys(direction);
        const newAxis = this.findMatchingAxis(directionAxes, seriesKeys);
        if (!newAxis) {
          Logger2.warnOnce(
            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`
          );
          return;
        }
        series.axes[direction] = newAxis;
      });
    });
  }
  findMatchingAxis(directionAxes, directionKeys) {
    for (const axis of directionAxes) {
      if (!axis.keys.length) {
        return axis;
      }
      if (!directionKeys) {
        continue;
      }
      for (const directionKey of directionKeys) {
        if (axis.keys.includes(directionKey)) {
          return axis;
        }
      }
    }
  }
  updateData(opts) {
    return __async2(this, null, function* () {
      this.series.forEach((s) => s.setChartData(opts.data));
      if (this.miniChartAnimationPhase === "initial") {
        this.ctx.animationManager.onBatchStop(() => {
          this.miniChartAnimationPhase = "ready";
          this.series.forEach((s) => s.resetAnimation("disabled"));
        });
      }
    });
  }
  processData(opts) {
    return __async2(this, null, function* () {
      if (this.series.some((s) => s.canHaveAxes)) {
        this.assignAxesToSeries();
        this.assignSeriesToAxes();
      }
      const seriesPromises = this.series.map((s) => s.processData(opts.dataController));
      yield Promise.all(seriesPromises);
    });
  }
  computeAxisPadding() {
    const padding = new Padding2();
    if (!this.enabled) {
      return padding;
    }
    this.axes.forEach((axis) => {
      var _a2;
      const { position, thickness = 0, line, label } = axis;
      if (position == null)
        return;
      let size;
      if (thickness > 0) {
        size = thickness;
      } else {
        size = (line.enabled ? line.width : 0) + (label.enabled ? ((_a2 = label.fontSize) != null ? _a2 : 0) * Text4.defaultLineHeightRatio + label.padding : 0);
      }
      padding[position] = Math.ceil(size);
    });
    return padding;
  }
  layout(width, height) {
    return __async2(this, null, function* () {
      const { padding } = this;
      const animated = this.seriesRect != null;
      const seriesRect = new BBox4(0, 0, width, height - (padding.top + padding.bottom));
      this.seriesRect = seriesRect;
      this.seriesRoot.translationY = padding.top;
      this.seriesRoot.setClipRectInGroupCoordinateSpace(
        this.seriesRoot.inverseTransformBBox(new BBox4(0, -padding.top, width, height))
      );
      const axisLeftRightRange = (axis) => {
        if (axis instanceof CategoryAxis2 || axis instanceof GroupedCategoryAxis2) {
          return [0, seriesRect.height];
        }
        return [seriesRect.height, 0];
      };
      this.axes.forEach((axis) => {
        const { position = "left" } = axis;
        switch (position) {
          case "top":
          case "bottom":
            axis.range = [0, seriesRect.width];
            axis.gridLength = seriesRect.height;
            break;
          case "right":
          case "left":
            axis.range = axisLeftRightRange(axis);
            axis.gridLength = seriesRect.width;
            break;
        }
        switch (position) {
          case "top":
          case "left":
            axis.translation.x = 0;
            axis.translation.y = 0;
            break;
          case "bottom":
            axis.translation.x = 0;
            axis.translation.y = height;
            break;
          case "right":
            axis.translation.x = width;
            axis.translation.y = 0;
            break;
        }
        axis.gridPadding = 0;
        axis.calculateLayout();
        axis.updatePosition({ rotation: toRadians4(axis.rotation), sideFlag: axis.label.getSideFlag() });
        axis.update(void 0, animated);
      });
      yield Promise.all(this.series.map((series) => series.update({ seriesRect })));
    });
  }
};
__decorateClass2([
  Validate20(BOOLEAN11)
], MiniChart.prototype, "enabled", 2);
__decorateClass2([
  ActionOnSet4({
    changeValue(newValue, oldValue = []) {
      for (const axis of oldValue) {
        if (newValue.includes(axis))
          continue;
        axis.detachAxis(this.axisGroup, this.axisGridGroup);
        axis.destroy();
      }
      for (const axis of newValue) {
        if (oldValue == null ? void 0 : oldValue.includes(axis))
          continue;
        axis.attachAxis(this.axisGroup, this.axisGridGroup);
      }
    }
  })
], MiniChart.prototype, "axes", 2);
__decorateClass2([
  ActionOnSet4({
    changeValue(newValue, oldValue) {
      this.onSeriesChange(newValue, oldValue);
    }
  })
], MiniChart.prototype, "series", 2);
var { ObserveChanges: ObserveChanges3 } = import_ag_charts_community37._ModuleSupport;
var _Navigator = class _Navigator2 extends import_ag_charts_community37._ModuleSupport.Navigator {
  constructor(ctx) {
    super(ctx);
    this.miniChart = new MiniChart(ctx);
  }
  updateData(opts) {
    return __async2(this, null, function* () {
      yield this.miniChart.updateData(opts);
    });
  }
  processData(opts) {
    return __async2(this, null, function* () {
      yield this.miniChart.processData(opts);
    });
  }
  performLayout(opts) {
    return __async2(this, null, function* () {
      const { shrinkRect } = yield __superGet2(_Navigator2.prototype, this, "performLayout").call(this, opts);
      if (this.enabled) {
        const { top, bottom } = this.miniChart.computeAxisPadding();
        shrinkRect.shrink(top + bottom, "bottom");
        this.y -= bottom;
      }
      return { shrinkRect };
    });
  }
  performCartesianLayout(opts) {
    return __async2(this, null, function* () {
      yield __superGet2(_Navigator2.prototype, this, "performCartesianLayout").call(this, opts);
      yield this.miniChart.layout(this.width, this.height);
    });
  }
};
__decorateClass2([
  ObserveChanges3((target, value, oldValue) => {
    target.updateBackground(oldValue == null ? void 0 : oldValue.root, value == null ? void 0 : value.root);
  })
], _Navigator.prototype, "miniChart", 2);
var Navigator2 = _Navigator;
var _a;
var NavigatorModule2 = {
  type: "root",
  optionsKey: "navigator",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  instanceConstructor: Navigator2,
  themeTemplate: __spreadProps2(__spreadValues2({}, import_ag_charts_community38._ModuleSupport.NavigatorModule.themeTemplate), {
    navigator: __spreadProps2(__spreadValues2({}, (_a = import_ag_charts_community38._ModuleSupport.NavigatorModule.themeTemplate) == null ? void 0 : _a.navigator), {
      miniChart: {
        enabled: false,
        label: {
          color: import_ag_charts_community38._Theme.DEFAULT_LABEL_COLOUR,
          fontStyle: void 0,
          fontWeight: void 0,
          fontSize: 10,
          fontFamily: import_ag_charts_community38._Theme.DEFAULT_FONT_FAMILY,
          formatter: void 0,
          padding: 0
        },
        padding: {
          top: 0,
          bottom: 0
        }
      }
    })
  })
};
var import_ag_charts_community39 = (init_main(), __toCommonJS(main_exports));
var {
  BOOLEAN: BOOLEAN12,
  STRING: STRING5,
  UNION: UNION4,
  BaseProperties: BaseProperties5,
  CartesianAxis: CartesianAxis2,
  ChartUpdateType: ChartUpdateType2,
  arraysEqual: arraysEqual2,
  isDate: isDate2,
  isDefined: isDefined22,
  isFiniteNumber: isFiniteNumber2,
  ObserveChanges: ObserveChanges4,
  TooltipManager: TooltipManager2,
  Validate: Validate21
} = import_ag_charts_community39._ModuleSupport;
var { Logger: Logger22 } = import_ag_charts_community39._Util;
var ChartSync = class extends BaseProperties5 {
  constructor(moduleContext) {
    super();
    this.moduleContext = moduleContext;
    this.enabled = false;
    this.axes = "x";
    this.nodeInteraction = true;
    this.zoom = true;
  }
  updateChart(chart, updateType = ChartUpdateType2.UPDATE_DATA) {
    chart.ctx.updateService.update(updateType, { skipSync: true });
  }
  updateSiblings(groupId) {
    const { syncManager } = this.moduleContext;
    const updateFn = () => __async2(this, null, function* () {
      for (const chart of syncManager.getGroupSiblings(groupId)) {
        yield chart.waitForDataProcess(120);
        this.updateChart(chart);
      }
    });
    updateFn().catch((e) => {
      Logger22.warnOnce("Error updating sibling chart", e);
    });
  }
  enabledZoomSync() {
    const { syncManager, zoomManager } = this.moduleContext;
    this.disableZoomSync = zoomManager.addListener("zoom-change", () => {
      var _a2;
      for (const chart of syncManager.getGroupSiblings(this.groupId)) {
        if ((_a2 = chart.modulesManager.getModule("sync")) == null ? void 0 : _a2.zoom) {
          chart.ctx.zoomManager.updateZoom("sync", this.mergeZoom(chart));
        }
      }
    });
  }
  enabledNodeInteractionSync() {
    const { highlightManager, syncManager } = this.moduleContext;
    this.disableNodeInteractionSync = highlightManager.addListener("highlight-change", (event) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      for (const chart of syncManager.getGroupSiblings(this.groupId)) {
        if (!((_a2 = chart.modulesManager.getModule("sync")) == null ? void 0 : _a2.nodeInteraction))
          continue;
        if (!((_b = event.currentHighlight) == null ? void 0 : _b.datum)) {
          chart.ctx.highlightManager.updateHighlight(chart.id);
          chart.ctx.tooltipManager.removeTooltip(chart.id);
          continue;
        }
        for (const axis of chart.axes) {
          const validDirection = this.axes === "xy" ? "x" : this.axes;
          if (!CartesianAxis2.is(axis) || axis.direction !== validDirection)
            continue;
          const matchingNodes = chart.series.map((series) => {
            const seriesKeys = series.getKeys(axis.direction);
            if (axis.keys.length && !axis.keys.some((key) => seriesKeys.includes(key)))
              return;
            const { nodeData } = series.contextNodeData;
            if (!(nodeData == null ? void 0 : nodeData.length))
              return;
            const valueKey = nodeData[0][`${axis.direction}Key`];
            let eventValue = event.currentHighlight.datum[valueKey];
            const valueIsDate = isDate2(eventValue);
            if (valueIsDate) {
              eventValue = eventValue.getTime();
            }
            const nodeDatum = nodeData.find((datum) => {
              const nodeValue = datum.datum[valueKey];
              return valueIsDate ? nodeValue.getTime() === eventValue : nodeValue === eventValue;
            });
            return nodeDatum ? { series, nodeDatum } : null;
          }).filter(isDefined22);
          if (matchingNodes.length < 2 && ((_c = matchingNodes[0]) == null ? void 0 : _c.nodeDatum) !== chart.ctx.highlightManager.getActiveHighlight()) {
            const { series, nodeDatum } = (_d = matchingNodes[0]) != null ? _d : {};
            chart.ctx.highlightManager.updateHighlight(chart.id, nodeDatum);
            if (nodeDatum) {
              const offsetX = (_h = (_g = (_e = nodeDatum.midPoint) == null ? void 0 : _e.x) != null ? _g : (_f = nodeDatum.point) == null ? void 0 : _f.x) != null ? _h : 0;
              const offsetY = (_l = (_k = (_i = nodeDatum.midPoint) == null ? void 0 : _i.y) != null ? _k : (_j = nodeDatum.point) == null ? void 0 : _j.y) != null ? _l : 0;
              const tooltipMeta = TooltipManager2.makeTooltipMeta(
                { type: "hover", offsetX, offsetY },
                nodeDatum
              );
              delete tooltipMeta.lastPointerEvent;
              chart.ctx.tooltipManager.updateTooltip(
                chart.id,
                tooltipMeta,
                series.getTooltipHtml(nodeDatum)
              );
            } else {
              chart.ctx.tooltipManager.removeTooltip(chart.id);
            }
            this.updateChart(chart, ChartUpdateType2.SERIES_UPDATE);
          }
        }
      }
    });
  }
  syncAxes(stopPropagation = false) {
    const { syncManager } = this.moduleContext;
    const chart = syncManager.getChart();
    const syncGroup = syncManager.getGroup(this.groupId);
    const syncSeries = syncGroup.flatMap((c) => c.series);
    const syncAxes = syncGroup[0].axes;
    let hasUpdated = false;
    chart.axes.forEach((axis) => {
      if (!CartesianAxis2.is(axis) || this.axes !== "xy" && this.axes !== axis.direction) {
        axis.boundSeries = chart.series.filter((s) => s.axes[axis.direction] === axis);
        return;
      }
      const { direction, min, max, nice, reverse } = axis;
      for (const mainAxis of syncAxes) {
        if (direction !== mainAxis.direction)
          continue;
        if (nice !== mainAxis.nice || reverse !== mainAxis.reverse || min !== mainAxis.min && (isFiniteNumber2(min) || isFiniteNumber2(mainAxis.min)) || max !== mainAxis.max && (isFiniteNumber2(max) || isFiniteNumber2(mainAxis.max))) {
          Logger22.warnOnce(
            "To allow synchronization, ensure that all charts have matching min, max, nice, and reverse properties on the synchronized axes."
          );
          axis.boundSeries = chart.series.filter((s) => s.axes[axis.direction] === axis);
          this.enabled = false;
          return;
        }
      }
      const boundSeries = syncSeries.filter((series) => {
        if (series.visible) {
          const seriesKeys = series.getKeys(axis.direction);
          return axis.keys.length ? axis.keys.some((key) => seriesKeys.includes(key)) : true;
        }
      });
      if (!arraysEqual2(axis.boundSeries, boundSeries)) {
        axis.boundSeries = boundSeries;
        hasUpdated = true;
      }
    });
    if (hasUpdated && !stopPropagation) {
      this.updateSiblings(this.groupId);
    }
  }
  mergeZoom(chart) {
    var _a2, _b;
    const { zoomManager } = this.moduleContext;
    if (this.axes === "xy") {
      return zoomManager.getZoom();
    }
    const combinedZoom = (_a2 = chart.zoomManager.getZoom()) != null ? _a2 : {};
    combinedZoom[this.axes] = (_b = zoomManager.getZoom()) == null ? void 0 : _b[this.axes];
    return combinedZoom;
  }
  onEnabledChange() {
    const { syncManager } = this.moduleContext;
    if (this.enabled) {
      syncManager.subscribe(this.groupId);
    } else {
      syncManager.unsubscribe(this.groupId);
    }
    this.updateSiblings(this.groupId);
    this.onNodeInteractionChange();
    this.onZoomChange();
  }
  onGroupIdChange(newValue, oldValue) {
    if (!this.enabled || newValue === oldValue)
      return;
    const { syncManager } = this.moduleContext;
    syncManager.unsubscribe(oldValue);
    syncManager.subscribe(newValue);
    this.updateSiblings(oldValue);
    this.updateSiblings(newValue);
  }
  onAxesChange() {
    if (!this.enabled)
      return;
    const { syncManager } = this.moduleContext;
    this.updateChart(syncManager.getChart());
  }
  onNodeInteractionChange() {
    var _a2;
    if (this.enabled && this.nodeInteraction) {
      this.enabledNodeInteractionSync();
    } else {
      (_a2 = this.disableNodeInteractionSync) == null ? void 0 : _a2.call(this);
    }
  }
  onZoomChange() {
    var _a2;
    if (this.enabled && this.zoom) {
      this.enabledZoomSync();
    } else {
      (_a2 = this.disableZoomSync) == null ? void 0 : _a2.call(this);
    }
  }
  destroy() {
    var _a2;
    const { syncManager } = this.moduleContext;
    syncManager.unsubscribe(this.groupId);
    this.updateSiblings(this.groupId);
    (_a2 = this.disableZoomSync) == null ? void 0 : _a2.call(this);
  }
};
ChartSync.className = "Sync";
__decorateClass2([
  Validate21(BOOLEAN12),
  ObserveChanges4((target) => target.onEnabledChange())
], ChartSync.prototype, "enabled", 2);
__decorateClass2([
  Validate21(STRING5, { optional: true }),
  ObserveChanges4((target, newValue, oldValue) => target.onGroupIdChange(newValue, oldValue))
], ChartSync.prototype, "groupId", 2);
__decorateClass2([
  Validate21(UNION4(["x", "y", "xy"], "an axis")),
  ObserveChanges4((target) => target.onAxesChange())
], ChartSync.prototype, "axes", 2);
__decorateClass2([
  Validate21(BOOLEAN12),
  ObserveChanges4((target) => target.onNodeInteractionChange())
], ChartSync.prototype, "nodeInteraction", 2);
__decorateClass2([
  Validate21(BOOLEAN12),
  ObserveChanges4((target) => target.onZoomChange())
], ChartSync.prototype, "zoom", 2);
var SyncModule = {
  type: "root",
  optionsKey: "sync",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  instanceConstructor: ChartSync,
  themeTemplate: {
    sync: { enabled: false }
  }
};
var import_ag_charts_community48 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community40 = (init_main(), __toCommonJS(main_exports));
var { COLOR_STRING: COLOR_STRING5, RATIO: RATIO8, Validate: Validate222 } = import_ag_charts_community40._ModuleSupport;
var ZoomRect = class extends import_ag_charts_community40._Scene.Rect {
  constructor() {
    super(...arguments);
    this.fill = "rgb(33, 150, 243)";
    this.fillOpacity = 0.2;
  }
};
ZoomRect.className = "ZoomRect";
__decorateClass2([
  Validate222(COLOR_STRING5)
], ZoomRect.prototype, "fill", 2);
__decorateClass2([
  Validate222(RATIO8)
], ZoomRect.prototype, "fillOpacity", 2);
var import_ag_charts_community42 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community41 = (init_main(), __toCommonJS(main_exports));
var { clamp: clamp2, isEqual: isEqual2, round: round3 } = import_ag_charts_community41._ModuleSupport;
var UNIT = { min: 0, max: 1 };
var DEFAULT_ANCHOR_POINT_X = "end";
var DEFAULT_ANCHOR_POINT_Y = "middle";
var constrain = (value, min = UNIT.min, max = UNIT.max) => clamp2(min, value, max);
function unitZoomState() {
  return { x: __spreadValues2({}, UNIT), y: __spreadValues2({}, UNIT) };
}
function dx(zoom2) {
  return zoom2.x.max - zoom2.x.min;
}
function dy(zoom2) {
  return zoom2.y.max - zoom2.y.min;
}
function isZoomEqual(left, right, epsilon2 = 1e-10) {
  return isEqual2(left.x.min, right.x.min, epsilon2) && isEqual2(left.x.max, right.x.max, epsilon2) && isEqual2(left.y.min, right.y.min, epsilon2) && isEqual2(left.y.max, right.y.max, epsilon2);
}
function isZoomLess(zoom2, minRatioX, minRatioY) {
  const isMinXZoom = round3(dx(zoom2), 10) <= minRatioX;
  const isMinYZoom = round3(dy(zoom2), 10) <= minRatioY;
  return isMinXZoom || isMinYZoom;
}
function definedZoomState(zoom2) {
  var _a2, _b, _c, _d, _e, _f, _g, _h;
  return {
    x: { min: (_b = (_a2 = zoom2 == null ? void 0 : zoom2.x) == null ? void 0 : _a2.min) != null ? _b : UNIT.min, max: (_d = (_c = zoom2 == null ? void 0 : zoom2.x) == null ? void 0 : _c.max) != null ? _d : UNIT.max },
    y: { min: (_f = (_e = zoom2 == null ? void 0 : zoom2.y) == null ? void 0 : _e.min) != null ? _f : UNIT.min, max: (_h = (_g = zoom2 == null ? void 0 : zoom2.y) == null ? void 0 : _g.max) != null ? _h : UNIT.max }
  };
}
function pointToRatio(bbox, x, y) {
  if (!bbox)
    return { x: 0, y: 0 };
  const constrainedX = constrain(x - bbox.x, 0, bbox.x + bbox.width);
  const constrainedY = constrain(y - bbox.y, 0, bbox.y + bbox.height);
  const rx = 1 / bbox.width * constrainedX;
  const ry = 1 - 1 / bbox.height * constrainedY;
  return { x: constrain(rx), y: constrain(ry) };
}
function translateZoom(zoom2, x, y) {
  return {
    x: { min: zoom2.x.min + x, max: zoom2.x.max + x },
    y: { min: zoom2.y.min + y, max: zoom2.y.max + y }
  };
}
function scaleZoom(zoom2, sx, sy) {
  return {
    x: { min: zoom2.x.min, max: zoom2.x.min + dx(zoom2) * sx },
    y: { min: zoom2.y.min, max: zoom2.y.min + dy(zoom2) * sy }
  };
}
function scaleZoomCenter(zoom2, sx, sy) {
  const dx_ = dx(zoom2);
  const dy_ = dy(zoom2);
  const cx = zoom2.x.min + dx_ / 2;
  const cy = zoom2.y.min + dy_ / 2;
  return {
    x: { min: cx - dx_ * sx / 2, max: cx + dx_ * sx / 2 },
    y: { min: cy - dy_ * sy / 2, max: cy + dy_ * sy / 2 }
  };
}
function scaleZoomAxisWithAnchor(newState, oldState, anchor, origin) {
  const { min, max } = oldState;
  const center = min + (max - min) / 2;
  const diff8 = newState.max - newState.min;
  switch (anchor) {
    case "start":
      return { min, max: oldState.min + diff8 };
    case "end":
      return { min: oldState.max - diff8, max };
    case "middle":
      return { min: center - diff8 / 2, max: center + diff8 / 2 };
    case "pointer":
      return scaleZoomAxisWithPoint(newState, oldState, origin != null ? origin : center);
    default:
      return { min, max };
  }
}
function scaleZoomAxisWithPoint(newState, oldState, origin) {
  const scaledOrigin = origin * (1 - (oldState.max - oldState.min - (newState.max - newState.min)));
  const translation = origin - scaledOrigin;
  const min = newState.min + translation;
  const max = newState.max + translation;
  return { min, max };
}
function multiplyZoom(zoom2, nx, ny) {
  return {
    x: { min: zoom2.x.min * nx, max: zoom2.x.max * nx },
    y: { min: zoom2.y.min * ny, max: zoom2.y.max * ny }
  };
}
function constrainZoom(zoom2) {
  const after = unitZoomState();
  after.x = constrainAxis(zoom2.x);
  after.y = constrainAxis(zoom2.y);
  return after;
}
function constrainAxis(axis) {
  const size = axis.max - axis.min;
  let min = axis.max > UNIT.max ? UNIT.max - size : axis.min;
  let max = axis.min < UNIT.min ? size : axis.max;
  min = Math.max(UNIT.min, min);
  max = Math.min(UNIT.max, max);
  return { min, max };
}
function constrainAxisWithOld({ min, max }, old, minRatio) {
  if (max === old.max) {
    min = max - minRatio;
  } else if (min === old.min) {
    max = min + minRatio;
  } else {
    const cx = old.min + (old.max - old.min) / 2;
    min = cx - minRatio / 2;
    max = cx + minRatio / 2;
  }
  return { min, max };
}
var ZoomAxisDragger = class {
  update(event, direction, anchor, bbox, zoom2, axisZoom) {
    var _a2;
    (_a2 = this.oldZoom) != null ? _a2 : this.oldZoom = definedZoomState(
      direction === import_ag_charts_community42._ModuleSupport.ChartAxisDirection.X ? __spreadProps2(__spreadValues2({}, zoom2), { x: axisZoom }) : __spreadProps2(__spreadValues2({}, zoom2), { y: axisZoom })
    );
    this.updateCoords(event.offsetX, event.offsetY);
    return this.updateZoom(direction, anchor, bbox);
  }
  stop() {
    this.coords = void 0;
    this.oldZoom = void 0;
  }
  updateCoords(x, y) {
    if (this.coords) {
      this.coords.x2 = x;
      this.coords.y2 = y;
    } else {
      this.coords = { x1: x, y1: y, x2: x, y2: y };
    }
  }
  updateZoom(direction, anchor, bbox) {
    const { coords, oldZoom } = this;
    let newZoom = definedZoomState(oldZoom);
    if (!coords || !oldZoom) {
      if (direction === import_ag_charts_community42._ModuleSupport.ChartAxisDirection.X)
        return newZoom.x;
      return newZoom.y;
    }
    const origin = pointToRatio(bbox, coords.x1, coords.y1);
    const target = pointToRatio(bbox, coords.x2, coords.y2);
    if (direction === import_ag_charts_community42._ModuleSupport.ChartAxisDirection.X) {
      const scaleX = (target.x - origin.x) * dx(oldZoom);
      newZoom.x.max += scaleX;
      newZoom.x = scaleZoomAxisWithAnchor(newZoom.x, oldZoom.x, anchor, origin.x);
      newZoom = constrainZoom(newZoom);
      return newZoom.x;
    }
    const scaleY = (target.y - origin.y) * dy(oldZoom);
    newZoom.y.max -= scaleY;
    newZoom.y = scaleZoomAxisWithAnchor(newZoom.y, oldZoom.y, anchor, origin.y);
    newZoom = constrainZoom(newZoom);
    return newZoom.y;
  }
};
var CONTEXT_ZOOM_ACTION_ID = "zoom-action";
var CONTEXT_PAN_ACTION_ID = "pan-action";
var ZoomContextMenu = class {
  constructor(contextMenuRegistry, zoomManager, updateZoom) {
    this.contextMenuRegistry = contextMenuRegistry;
    this.zoomManager = zoomManager;
    this.updateZoom = updateZoom;
  }
  registerActions(enabled, zoom2, props) {
    if (!enabled)
      return;
    const { contextMenuRegistry } = this;
    contextMenuRegistry.registerDefaultAction({
      id: CONTEXT_ZOOM_ACTION_ID,
      label: "Zoom to here",
      action: (params) => this.onZoomToHere(params, props)
    });
    contextMenuRegistry.registerDefaultAction({
      id: CONTEXT_PAN_ACTION_ID,
      label: "Pan to here",
      action: (params) => this.onPanToHere(params, props)
    });
    this.toggleActions(zoom2, props);
  }
  toggleActions(zoom2, props) {
    const { contextMenuRegistry } = this;
    if (isZoomLess(zoom2, props.minRatioX, props.minRatioY)) {
      contextMenuRegistry.disableAction(CONTEXT_ZOOM_ACTION_ID);
    } else {
      contextMenuRegistry.enableAction(CONTEXT_ZOOM_ACTION_ID);
    }
    if (isZoomEqual(zoom2, unitZoomState())) {
      contextMenuRegistry.disableAction(CONTEXT_PAN_ACTION_ID);
    } else {
      contextMenuRegistry.enableAction(CONTEXT_PAN_ACTION_ID);
    }
  }
  onZoomToHere({ event }, props) {
    const { rect } = this;
    const { enabled, isScalingX, isScalingY, minRatioX, minRatioY } = props;
    if (!enabled || !rect || !event || !event.target)
      return;
    const zoom2 = definedZoomState(this.zoomManager.getZoom());
    const origin = pointToRatio(rect, event.clientX, event.clientY);
    const scaledOriginX = origin.x * dx(zoom2);
    const scaledOriginY = origin.y * dy(zoom2);
    const size = UNIT.max - UNIT.min;
    const halfSize = size / 2;
    let newZoom = {
      x: { min: origin.x - halfSize, max: origin.x + halfSize },
      y: { min: origin.y - halfSize, max: origin.y + halfSize }
    };
    newZoom = scaleZoomCenter(newZoom, isScalingX ? minRatioX : size, isScalingY ? minRatioY : size);
    newZoom = translateZoom(newZoom, zoom2.x.min - origin.x + scaledOriginX, zoom2.y.min - origin.y + scaledOriginY);
    this.updateZoom(constrainZoom(newZoom));
  }
  onPanToHere({ event }, props) {
    const { rect } = this;
    const { enabled } = props;
    if (!enabled || !rect || !event || !event.target)
      return;
    const zoom2 = definedZoomState(this.zoomManager.getZoom());
    const origin = pointToRatio(rect, event.clientX, event.clientY);
    const scaleX = dx(zoom2);
    const scaleY = dy(zoom2);
    const scaledOriginX = origin.x * scaleX;
    const scaledOriginY = origin.y * scaleY;
    const halfSize = (UNIT.max - UNIT.min) / 2;
    let newZoom = {
      x: { min: origin.x - halfSize, max: origin.x + halfSize },
      y: { min: origin.y - halfSize, max: origin.y + halfSize }
    };
    newZoom = scaleZoomCenter(newZoom, scaleX, scaleY);
    newZoom = translateZoom(newZoom, zoom2.x.min - origin.x + scaledOriginX, zoom2.y.min - origin.y + scaledOriginY);
    this.updateZoom(constrainZoom(newZoom));
  }
};
var import_ag_charts_community43 = (init_main(), __toCommonJS(main_exports));
var maxZoomCoords = 16;
var ZoomPanner = class {
  constructor() {
    this.deceleration = 1;
    this.zoomCoordsHistoryIndex = 0;
    this.coordsHistory = [];
  }
  addListener(_type, fn) {
    this.onUpdate = fn;
    return () => {
      this.onUpdate = void 0;
    };
  }
  stopInteractions() {
    if (this.inertiaHandle != null) {
      cancelAnimationFrame(this.inertiaHandle);
      this.inertiaHandle = void 0;
    }
  }
  update(event) {
    var _a2, _b;
    this.updateCoords(event.offsetX, event.offsetY);
    const { x1 = 0, y1 = 0, x2 = 0, y2 = 0 } = (_a2 = this.coords) != null ? _a2 : {};
    (_b = this.onUpdate) == null ? void 0 : _b.call(this, {
      type: "update",
      deltaX: x1 - x2,
      deltaY: y1 - y2
    });
  }
  start() {
    this.coordsMonitorTimeout = setInterval(this.recordCurrentZoomCoords.bind(this), 16);
  }
  stop() {
    const { coordsHistory } = this;
    let deltaX = 0;
    let deltaY = 0;
    let deltaT = 0;
    if (coordsHistory.length > 0) {
      const arrayIndex = this.zoomCoordsHistoryIndex % maxZoomCoords;
      let index1 = arrayIndex - 1;
      if (index1 < 0)
        index1 = coordsHistory.length - 1;
      let index0 = arrayIndex;
      if (index0 >= coordsHistory.length)
        index0 = 0;
      const coords1 = coordsHistory[index1];
      const coords0 = coordsHistory[index0];
      deltaX = coords1.x - coords0.x;
      deltaY = coords1.y - coords0.y;
      deltaT = coords1.t - coords0.t;
    }
    this.coords = void 0;
    clearInterval(this.coordsMonitorTimeout);
    this.coordsMonitorTimeout = void 0;
    this.zoomCoordsHistoryIndex = 0;
    this.coordsHistory.length = 0;
    if (deltaT > 0 && this.deceleration < 1) {
      const xVelocity = deltaX / deltaT;
      const yVelocity = deltaY / deltaT;
      const velocity = Math.hypot(xVelocity, yVelocity);
      const angle = Math.atan2(yVelocity, xVelocity);
      const t0 = performance.now();
      this.inertiaHandle = requestAnimationFrame((t) => {
        this.animateInertia(t, t, t0, velocity, angle);
      });
    }
  }
  recordCurrentZoomCoords() {
    const { coords, coordsHistory, zoomCoordsHistoryIndex } = this;
    if (!coords)
      return;
    const { x2: x, y2: y } = coords;
    const t = Date.now();
    coordsHistory[zoomCoordsHistoryIndex % maxZoomCoords] = { x, y, t };
    this.zoomCoordsHistoryIndex += 1;
  }
  animateInertia(t, prevT, t0, velocity, angle) {
    var _a2;
    const friction = 1 - this.deceleration;
    const maxS = -velocity / Math.log(friction);
    const s0 = velocity * (__pow2(friction, prevT - t0) - 1) / Math.log(friction);
    const s1 = velocity * (__pow2(friction, t - t0) - 1) / Math.log(friction);
    (_a2 = this.onUpdate) == null ? void 0 : _a2.call(this, {
      type: "update",
      deltaX: -Math.cos(angle) * (s1 - s0),
      deltaY: -Math.sin(angle) * (s1 - s0)
    });
    if (s1 >= maxS - 1)
      return;
    this.inertiaHandle = requestAnimationFrame((nextT) => {
      this.animateInertia(nextT, t, t0, velocity, angle);
    });
  }
  updateCoords(x, y) {
    if (this.coords) {
      this.coords = { x1: this.coords.x2, y1: this.coords.y2, x2: x, y2: y };
    } else {
      this.coords = { x1: x, y1: y, x2: x, y2: y };
    }
  }
  translateZooms(bbox, currentZooms, deltaX, deltaY) {
    const offset4 = pointToRatio(bbox, bbox.x + Math.abs(deltaX), bbox.y + bbox.height - Math.abs(deltaY));
    const offsetX = Math.sign(deltaX) * offset4.x;
    const offsetY = -Math.sign(deltaY) * offset4.y;
    const newZooms = {};
    for (const [axisId, { direction, zoom: currentZoom }] of Object.entries(currentZooms)) {
      let zoom2;
      if (direction === import_ag_charts_community43._ModuleSupport.ChartAxisDirection.X) {
        zoom2 = definedZoomState({ x: currentZoom });
      } else {
        zoom2 = definedZoomState({ y: currentZoom });
      }
      zoom2 = constrainZoom(translateZoom(zoom2, offsetX * dx(zoom2), offsetY * dy(zoom2)));
      if (direction === import_ag_charts_community43._ModuleSupport.ChartAxisDirection.X) {
        newZooms[axisId] = { direction, zoom: zoom2.x };
      } else {
        newZooms[axisId] = { direction, zoom: zoom2.y };
      }
    }
    return newZooms;
  }
};
var import_ag_charts_community44 = (init_main(), __toCommonJS(main_exports));
var { AND: AND5, DATE: DATE22, NUMBER: NUMBER7, OR: OR4, ActionOnSet: ActionOnSet5, isFiniteNumber: isFiniteNumber22, isValidDate: isValidDate2, Validate: Validate23 } = import_ag_charts_community44._ModuleSupport;
var ZoomRange = class {
  constructor(onChange) {
    this.onChange = onChange;
  }
  getRange() {
    return this.getRangeWithValues(this.start, this.end);
  }
  getInitialRange() {
    return this.getRangeWithValues(this.initialStart, this.initialEnd);
  }
  extendToEnd(extent6) {
    return this.extendWith((end) => Number(end) - extent6);
  }
  extendWith(fn) {
    var _a2;
    if (!this.domain)
      return;
    const [, end] = this.domain;
    if (end == null)
      return;
    const start = fn(end);
    const changed = this.start !== start || this.end !== end;
    this.end = end;
    this.start = start;
    if (!changed)
      (_a2 = this.onChange) == null ? void 0 : _a2.call(this, this.getRange());
  }
  updateWith(fn) {
    var _a2;
    if (!this.domain)
      return;
    let [start, end] = this.domain;
    [start, end] = fn(start, end);
    const changed = this.start !== start || this.end !== end;
    this.end = end;
    this.start = start;
    if (!changed)
      (_a2 = this.onChange) == null ? void 0 : _a2.call(this, this.getRange());
  }
  extendAll() {
    var _a2;
    if (!this.domain)
      return;
    const [start, end] = this.domain;
    const changed = this.start !== start || this.end !== end;
    this.start = start;
    this.end = end;
    if (!changed)
      (_a2 = this.onChange) == null ? void 0 : _a2.call(this, this.getRange());
  }
  updateAxis(axes) {
    const validAxis = axes.find(({ domain }) => {
      const isNumberAxis = !isFiniteNumber22(domain[0]) || !isFiniteNumber22(domain.at(-1));
      const isDateAxis = !isValidDate2(domain[0]) || !isValidDate2(domain.at(-1));
      return isNumberAxis || isDateAxis;
    });
    if (!validAxis)
      return this.domain != null;
    let validAxisDomain = validAxis.domain;
    if (validAxisDomain != null) {
      validAxisDomain = [validAxisDomain[0], validAxisDomain.at(-1)];
      if (validAxisDomain[0] instanceof Date && validAxisDomain[1] instanceof Date) {
        validAxisDomain = [validAxisDomain[0].getTime(), validAxisDomain[1].getTime()];
      }
    }
    const changed = this.domain == null || !import_ag_charts_community44._Util.areArrayItemsStrictlyEqual(this.domain, validAxisDomain);
    if (changed) {
      this.domain = validAxisDomain;
    }
    return changed;
  }
  getRangeWithValues(start, end) {
    var _a2;
    let [d0, d1] = (_a2 = this.domain) != null ? _a2 : [];
    if (start == null && end == null || d0 == null || d1 == null)
      return;
    d0 = Number(d0);
    d1 = Number(d1);
    let min = 0;
    let max = 1;
    if (start != null)
      min = (Number(start) - d0) / (d1 - d0);
    if (end != null)
      max = (Number(end) - d0) / (d1 - d0);
    return { min, max };
  }
};
__decorateClass2([
  ActionOnSet5({
    changeValue(start) {
      var _a2, _b;
      (_a2 = this.initialStart) != null ? _a2 : this.initialStart = start;
      (_b = this.onChange) == null ? void 0 : _b.call(this, this.getRangeWithValues(start, this.end));
    }
  }),
  Validate23(AND5(
    OR4(DATE22, NUMBER7)
    /* LESS_THAN('end') */
  ), { optional: true })
], ZoomRange.prototype, "start", 2);
__decorateClass2([
  ActionOnSet5({
    changeValue(end) {
      var _a2, _b;
      (_a2 = this.initialEnd) != null ? _a2 : this.initialEnd = end;
      (_b = this.onChange) == null ? void 0 : _b.call(this, this.getRangeWithValues(this.start, end));
    }
  }),
  Validate23(AND5(
    OR4(DATE22, NUMBER7)
    /* GREATER_THAN('start') */
  ), { optional: true })
], ZoomRange.prototype, "end", 2);
var import_ag_charts_community45 = (init_main(), __toCommonJS(main_exports));
var { AND: AND6, GREATER_THAN: GREATER_THAN4, LESS_THAN: LESS_THAN3, RATIO: RATIO9, ActionOnSet: ActionOnSet6, Validate: Validate24 } = import_ag_charts_community45._ModuleSupport;
var ZoomRatio = class {
  constructor(onChange) {
    this.onChange = onChange;
  }
  getRatio() {
    return this.getRatioWithValues(this.start, this.end);
  }
  getInitialRatio() {
    return this.getRatioWithValues(this.initialStart, this.initialEnd);
  }
  getRatioWithValues(start, end) {
    if (start == null && end == null)
      return;
    return {
      min: start != null ? start : UNIT.min,
      max: end != null ? end : UNIT.max
    };
  }
};
__decorateClass2([
  ActionOnSet6({
    changeValue(start) {
      var _a2, _b;
      (_a2 = this.initialStart) != null ? _a2 : this.initialStart = start;
      (_b = this.onChange) == null ? void 0 : _b.call(this, this.getRatioWithValues(start, this.end));
    }
  }),
  Validate24(AND6(RATIO9, LESS_THAN3("end")), { optional: true })
], ZoomRatio.prototype, "start", 2);
__decorateClass2([
  ActionOnSet6({
    changeValue(end) {
      var _a2, _b;
      (_a2 = this.initialEnd) != null ? _a2 : this.initialEnd = end;
      (_b = this.onChange) == null ? void 0 : _b.call(this, this.getRatioWithValues(this.start, end));
    }
  }),
  Validate24(AND6(RATIO9, GREATER_THAN4("start")), { optional: true })
], ZoomRatio.prototype, "end", 2);
var import_ag_charts_community46 = (init_main(), __toCommonJS(main_exports));
var DELTA_SCALE = 200;
var ZoomScrollPanner = class {
  update(event, step, bbox, zooms) {
    const deltaX = event.deltaX * step * DELTA_SCALE;
    return this.translateZooms(bbox, zooms, deltaX);
  }
  translateZooms(bbox, currentZooms, deltaX) {
    const newZooms = {};
    const offset4 = pointToRatio(bbox, bbox.x + Math.abs(deltaX), 0);
    const offsetX = deltaX < 0 ? -offset4.x : offset4.x;
    for (const [axisId, { direction, zoom: currentZoom }] of Object.entries(currentZooms)) {
      if (direction !== import_ag_charts_community46._ModuleSupport.ChartAxisDirection.X)
        continue;
      let zoom2 = definedZoomState({ x: currentZoom });
      zoom2 = constrainZoom(translateZoom(zoom2, offsetX * dx(zoom2), 0));
      newZooms[axisId] = { direction, zoom: zoom2.x };
    }
    return newZooms;
  }
};
var ZoomScroller = class {
  update(event, props, bbox, oldZoom) {
    const sourceEvent = event.sourceEvent;
    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;
    const dir = event.deltaY;
    let newZoom = definedZoomState(oldZoom);
    newZoom.x.max += isScalingX ? scrollingStep * dir * dx(oldZoom) : 0;
    newZoom.y.max += isScalingY ? scrollingStep * dir * dy(oldZoom) : 0;
    if (anchorPointX === "pointer" && isScalingX || anchorPointY === "pointer" && isScalingY) {
      newZoom = this.scaleZoomToPointer(sourceEvent, isScalingX, isScalingY, bbox, oldZoom, newZoom);
    } else {
      if (isScalingX) {
        newZoom.x = scaleZoomAxisWithAnchor(newZoom.x, oldZoom.x, anchorPointX);
      }
      if (isScalingY) {
        newZoom.y = scaleZoomAxisWithAnchor(newZoom.y, oldZoom.y, anchorPointY);
      }
    }
    newZoom = constrainZoom(newZoom);
    return newZoom;
  }
  scaleZoomToPointer(sourceEvent, isScalingX, isScalingY, bbox, oldZoom, newZoom) {
    var _a2, _b;
    const origin = pointToRatio(
      bbox,
      (_a2 = sourceEvent.offsetX) != null ? _a2 : sourceEvent.clientX,
      (_b = sourceEvent.offsetY) != null ? _b : sourceEvent.clientY
    );
    newZoom.x = isScalingX ? scaleZoomAxisWithPoint(newZoom.x, oldZoom.x, origin.x) : newZoom.x;
    newZoom.y = isScalingY ? scaleZoomAxisWithPoint(newZoom.y, oldZoom.y, origin.y) : newZoom.y;
    return newZoom;
  }
};
var ZoomSelector = class {
  constructor(rect) {
    this.rect = rect;
    this.rect.visible = false;
  }
  update(event, props, bbox, currentZoom) {
    this.rect.visible = true;
    this.updateCoords(event.offsetX, event.offsetY, props, bbox, currentZoom);
    this.updateRect(bbox);
  }
  stop(innerBBox, bbox, currentZoom) {
    let zoom2 = definedZoomState();
    if (!innerBBox || !bbox)
      return zoom2;
    if (this.coords) {
      zoom2 = this.createZoomFromCoords(bbox, currentZoom);
    }
    const multiplyX = bbox.width / innerBBox.width;
    const multiplyY = bbox.height / innerBBox.height;
    zoom2 = constrainZoom(multiplyZoom(zoom2, multiplyX, multiplyY));
    this.reset();
    return zoom2;
  }
  reset() {
    this.coords = void 0;
    this.rect.visible = false;
  }
  didUpdate() {
    return this.rect.visible;
  }
  updateCoords(x, y, props, bbox, currentZoom) {
    if (!this.coords) {
      this.coords = { x1: x, y1: y, x2: x, y2: y };
      return;
    }
    this.coords.x2 = x;
    this.coords.y2 = y;
    if (!bbox)
      return;
    const { isScalingX, isScalingY, minRatioX, minRatioY } = props;
    const zoom2 = definedZoomState(currentZoom);
    const normal = this.getNormalisedDimensions();
    const aspectRatio = bbox.width / bbox.height;
    const scaleX = zoom2.x.max - zoom2.x.min;
    const scaleY = zoom2.y.max - zoom2.y.min;
    const xRatio = minRatioX / scaleX;
    const yRatio = minRatioY / scaleY;
    if (normal.width / bbox.width < xRatio) {
      if (this.coords.x2 < this.coords.x1) {
        this.coords.x2 = this.coords.x1 - bbox.width * xRatio;
      } else {
        this.coords.x2 = this.coords.x1 + bbox.width * xRatio;
      }
    }
    if (isScalingY && !isScalingX) {
      if (normal.height / bbox.height < yRatio) {
        if (this.coords.y2 < this.coords.y1) {
          this.coords.y2 = this.coords.y1 - bbox.width * xRatio;
        } else {
          this.coords.y2 = this.coords.y1 + bbox.height * yRatio;
        }
      }
    } else if (this.coords.y2 < this.coords.y1) {
      this.coords.y2 = Math.min(
        this.coords.y1 - normal.width / aspectRatio,
        this.coords.y1 - bbox.height * yRatio
      );
    } else {
      this.coords.y2 = Math.max(
        this.coords.y1 + normal.width / aspectRatio,
        this.coords.y1 + bbox.height * yRatio
      );
    }
    if (!isScalingX) {
      this.coords.x1 = bbox.x;
      this.coords.x2 = bbox.x + bbox.width;
    }
    if (!isScalingY) {
      this.coords.y1 = bbox.y;
      this.coords.y2 = bbox.y + bbox.height;
    }
  }
  updateRect(bbox) {
    if (!bbox)
      return;
    const { rect } = this;
    const normal = this.getNormalisedDimensions();
    const { width, height } = normal;
    let { x, y } = normal;
    x = Math.max(x, bbox.x);
    x -= Math.max(0, x + width - (bbox.x + bbox.width));
    y = Math.max(y, bbox.y);
    y -= Math.max(0, y + height - (bbox.y + bbox.height));
    rect.x = x;
    rect.y = y;
    rect.width = width;
    rect.height = height;
  }
  createZoomFromCoords(bbox, currentZoom) {
    const oldZoom = definedZoomState(currentZoom);
    const normal = this.getNormalisedDimensions();
    const origin = pointToRatio(bbox, normal.x, normal.y + normal.height);
    const xFactor = normal.width / bbox.width;
    const yFactor = normal.height / bbox.height;
    let newZoom = scaleZoom(oldZoom, xFactor, yFactor);
    const translateX = origin.x * (oldZoom.x.max - oldZoom.x.min);
    const translateY = origin.y * (oldZoom.y.max - oldZoom.y.min);
    newZoom = translateZoom(newZoom, translateX, translateY);
    newZoom = constrainZoom(newZoom);
    return newZoom;
  }
  getNormalisedDimensions() {
    var _a2;
    const { x1 = 0, y1 = 0, x2 = 0, y2 = 0 } = (_a2 = this.coords) != null ? _a2 : {};
    const x = x1 <= x2 ? x1 : x2;
    const y = y1 <= y2 ? y1 : y2;
    const width = x1 <= x2 ? x2 - x1 : x1 - x2;
    const height = y1 <= y2 ? y2 - y1 : y1 - y2;
    return { x, y, width, height };
  }
};
var import_ag_charts_community47 = (init_main(), __toCommonJS(main_exports));
var { ToolbarManager: ToolbarManager2 } = import_ag_charts_community47._ModuleSupport;
var ZoomToolbar = class {
  constructor(toolbarManager, zoomManager, getResetZoom, updateZoom) {
    this.toolbarManager = toolbarManager;
    this.zoomManager = zoomManager;
    this.getResetZoom = getResetZoom;
    this.updateZoom = updateZoom;
  }
  toggle(enabled, zoom2, props) {
    this.toggleGroups(enabled);
    if (enabled) {
      this.toggleButtons(zoom2, props);
    }
  }
  toggleButtons(zoom2, props) {
    const { toolbarManager } = this;
    const isMaxZoom = isZoomEqual(zoom2, unitZoomState());
    const isMinZoom = isZoomLess(zoom2, props.minRatioX, props.minRatioY);
    const isResetZoom = isZoomEqual(zoom2, this.getResetZoom());
    toolbarManager.toggleButton("zoom", "pan-start", zoom2.x.min > UNIT.min);
    toolbarManager.toggleButton("zoom", "pan-end", zoom2.x.max < UNIT.max);
    toolbarManager.toggleButton("zoom", "pan-left", zoom2.x.min > UNIT.min);
    toolbarManager.toggleButton("zoom", "pan-right", zoom2.x.max < UNIT.max);
    toolbarManager.toggleButton("zoom", "zoom-out", !isMaxZoom);
    toolbarManager.toggleButton("zoom", "zoom-in", !isMinZoom);
    toolbarManager.toggleButton("zoom", "reset", !isResetZoom);
  }
  onButtonPress(event, props) {
    this.onButtonPressRanges(event, props);
    this.onButtonPressZoom(event, props);
  }
  toggleGroups(enabled) {
    var _a2, _b;
    (_a2 = this.toolbarManager) == null ? void 0 : _a2.toggleGroup("ranges", Boolean(enabled));
    (_b = this.toolbarManager) == null ? void 0 : _b.toggleGroup("zoom", Boolean(enabled));
  }
  onButtonPressRanges(event, props) {
    if (!ToolbarManager2.isGroup("ranges", event))
      return;
    const { rangeX } = props;
    const time2 = event.value;
    if (typeof time2 === "number") {
      rangeX.extendToEnd(time2);
    } else if (Array.isArray(time2)) {
      rangeX.updateWith(() => time2);
    } else if (typeof time2 === "function") {
      rangeX.updateWith(time2);
    }
  }
  onButtonPressZoom(event, props) {
    if (!ToolbarManager2.isGroup("zoom", event))
      return;
    const { anchorPointX, anchorPointY, isScalingX, isScalingY, scrollingStep } = props;
    const oldZoom = definedZoomState(this.zoomManager.getZoom());
    let zoom2 = definedZoomState(oldZoom);
    switch (event.value) {
      case "reset":
        zoom2 = this.getResetZoom();
        break;
      case "pan-start":
        zoom2.x.max = dx(zoom2);
        zoom2.x.min = 0;
        break;
      case "pan-end":
        zoom2.x.min = UNIT.max - dx(zoom2);
        zoom2.x.max = UNIT.max;
        break;
      case "pan-left":
      case "pan-right":
        zoom2 = translateZoom(zoom2, event.value === "pan-left" ? -dx(zoom2) : dx(zoom2), 0);
        break;
      case "zoom-in":
      case "zoom-out":
        const scale2 = event.value === "zoom-in" ? 1 - scrollingStep : 1 + scrollingStep;
        const useAnchorPointX = anchorPointX === "pointer" ? DEFAULT_ANCHOR_POINT_X : anchorPointX;
        const useAnchorPointY = anchorPointY === "pointer" ? DEFAULT_ANCHOR_POINT_Y : anchorPointY;
        zoom2 = scaleZoom(zoom2, isScalingX ? scale2 : 1, isScalingY ? scale2 : 1);
        zoom2.x = scaleZoomAxisWithAnchor(zoom2.x, oldZoom.x, useAnchorPointX);
        zoom2.y = scaleZoomAxisWithAnchor(zoom2.y, oldZoom.y, useAnchorPointY);
        break;
    }
    this.updateZoom(constrainZoom(zoom2));
  }
};
var {
  ARRAY: ARRAY22,
  BOOLEAN: BOOLEAN13,
  NUMBER: NUMBER8,
  RATIO: RATIO10,
  STRING: STRING6,
  UNION: UNION5,
  ActionOnSet: ActionOnSet7,
  ChartAxisDirection: ChartAxisDirection7,
  ChartUpdateType: ChartUpdateType22,
  Validate: Validate25,
  ProxyProperty: ProxyProperty22,
  round: sharedRound
} = import_ag_charts_community48._ModuleSupport;
var round22 = (value) => sharedRound(value, 10);
var ANCHOR_POINT = UNION5(["pointer", "start", "middle", "end"], "an anchor cord");
var CURSOR_ID = "zoom-cursor";
var TOOLTIP_ID = "zoom-tooltip";
var ZoomButtonsProperties = class extends import_ag_charts_community48._ModuleSupport.BaseProperties {
  constructor(onChange) {
    super();
    this.onChange = onChange;
    this.enabled = false;
    this.position = "floating-bottom";
    this.align = "center";
  }
};
__decorateClass2([
  import_ag_charts_community48._ModuleSupport.ObserveChanges((target) => {
    target.onChange();
  }),
  Validate25(BOOLEAN13)
], ZoomButtonsProperties.prototype, "enabled", 2);
__decorateClass2([
  import_ag_charts_community48._ModuleSupport.ObserveChanges((target) => {
    target.onChange();
  }),
  Validate25(ARRAY22, { optional: true })
], ZoomButtonsProperties.prototype, "buttons", 2);
__decorateClass2([
  Validate25(STRING6)
], ZoomButtonsProperties.prototype, "position", 2);
__decorateClass2([
  Validate25(STRING6)
], ZoomButtonsProperties.prototype, "align", 2);
var Zoom = class extends import_ag_charts_community48._ModuleSupport.BaseModuleInstance {
  constructor(ctx) {
    super();
    this.ctx = ctx;
    this.enabled = false;
    this.enableAxisDragging = true;
    this.buttons = new ZoomButtonsProperties(() => this.onZoomButtonsChange(this.enabled));
    this.enableDoubleClickToReset = true;
    this.enablePanning = true;
    this.enableScrolling = true;
    this.enableSelecting = false;
    this.panKey = "alt";
    this.axes = "x";
    this.scrollingStep = (UNIT.max - UNIT.min) / 10;
    this.minVisibleItemsX = 2;
    this.minVisibleItemsY = 2;
    this.anchorPointX = DEFAULT_ANCHOR_POINT_X;
    this.anchorPointY = DEFAULT_ANCHOR_POINT_Y;
    this.rangeX = new ZoomRange(this.onRangeChange.bind(this, ChartAxisDirection7.X));
    this.rangeY = new ZoomRange(this.onRangeChange.bind(this, ChartAxisDirection7.Y));
    this.ratioX = new ZoomRatio(this.onRatioChange.bind(this, ChartAxisDirection7.X));
    this.ratioY = new ZoomRatio(this.onRatioChange.bind(this, ChartAxisDirection7.Y));
    this.axisDragger = new ZoomAxisDragger();
    this.contextMenu = new ZoomContextMenu(
      this.ctx.contextMenuRegistry,
      this.ctx.zoomManager,
      this.updateZoom.bind(this)
    );
    this.panner = new ZoomPanner();
    this.scroller = new ZoomScroller();
    this.scrollPanner = new ZoomScrollPanner();
    this.toolbar = new ZoomToolbar(
      this.ctx.toolbarManager,
      this.ctx.zoomManager,
      this.getResetZoom.bind(this),
      this.updateZoom.bind(this)
    );
    this.deceleration = 1;
    this.dragState = 0;
    this.minRatioX = 0;
    this.minRatioY = 0;
    const selectionRect = new ZoomRect();
    this.selector = new ZoomSelector(selectionRect);
    const { Default: Default6, ZoomDrag, Animation: Animation22 } = import_ag_charts_community48._ModuleSupport.InteractionState;
    const draggableState = Default6 | Animation22 | ZoomDrag;
    const clickableState = Default6 | Animation22;
    const region = ctx.regionManager.getRegion("series");
    this.destroyFns.push(
      ctx.scene.attachNode(selectionRect),
      region.addListener("dblclick", (event) => this.onDoubleClick(event), clickableState),
      region.addListener("drag", (event) => this.onDrag(event), draggableState),
      region.addListener("drag-start", (event) => this.onDragStart(event), draggableState),
      region.addListener("drag-end", () => this.onDragEnd(), draggableState),
      region.addListener("wheel", (event) => this.onWheel(event), clickableState),
      region.addListener("hover", () => this.onAxisLeave(), clickableState),
      region.addListener("leave", () => this.onAxisLeave(), clickableState),
      ctx.chartEventManager.addListener("axis-hover", (event) => this.onAxisHover(event)),
      ctx.gestureDetector.addListener("pinch-move", (event) => this.onPinchMove(event)),
      ctx.toolbarManager.addListener(
        "button-pressed",
        (event) => this.toolbar.onButtonPress(event, this.getModuleProperties())
      ),
      ctx.layoutService.addListener("layout-complete", (event) => this.onLayoutComplete(event)),
      ctx.updateService.addListener("update-complete", (event) => this.onUpdateComplete(event)),
      ctx.zoomManager.addListener("zoom-change", (event) => this.onZoomChange(event)),
      ctx.zoomManager.addListener("zoom-pan-start", (event) => this.onZoomPanStart(event)),
      this.panner.addListener("update", (event) => this.onPanUpdate(event))
    );
  }
  onEnabledChange(enabled) {
    if (!this.contextMenu || !this.toolbar)
      return;
    const zoom2 = this.getZoom();
    const props = this.getModuleProperties({ enabled });
    this.contextMenu.registerActions(enabled, zoom2, props);
    this.onZoomButtonsChange(enabled);
    this.toolbar.toggle(enabled, zoom2, props);
  }
  onZoomButtonsChange(zoomEnabled) {
    if (!this.buttons)
      return;
    const buttonsJson = this.buttons.toJson();
    buttonsJson.enabled && (buttonsJson.enabled = zoomEnabled);
    this.ctx.toolbarManager.proxyGroupOptions("zoom", buttonsJson);
  }
  onRangeChange(direction, rangeZoom) {
    if (!rangeZoom)
      return;
    const zoom2 = this.getZoom();
    zoom2[direction] = rangeZoom;
    this.updateZoom(constrainZoom(zoom2));
  }
  onRatioChange(direction, ratioZoom) {
    if (!ratioZoom)
      return;
    let x = this.ratioX.getRatio();
    let y = this.ratioY.getRatio();
    if (direction === ChartAxisDirection7.X) {
      x = ratioZoom;
    } else {
      y = ratioZoom;
    }
    const newZoom = constrainZoom(definedZoomState({ x, y }));
    this.updateZoom(newZoom);
  }
  onDoubleClick(event) {
    const {
      enabled,
      enableDoubleClickToReset,
      hoveredAxis,
      paddedRect,
      ctx: { highlightManager }
    } = this;
    if (!enabled || !enableDoubleClickToReset)
      return;
    const { x, y } = this.getResetZoom();
    if (hoveredAxis) {
      const { direction } = hoveredAxis;
      const axisZoom = direction === ChartAxisDirection7.X ? x : y;
      this.updateAxisZoom(direction, axisZoom);
    } else if ((paddedRect == null ? void 0 : paddedRect.containsPoint(event.offsetX, event.offsetY)) && highlightManager.getActivePicked() == null) {
      this.updateZoom({ x, y });
    }
  }
  onDragStart(event) {
    const {
      enabled,
      enableAxisDragging,
      enablePanning,
      enableSelecting,
      hoveredAxis,
      paddedRect,
      ctx: { cursorManager, zoomManager }
    } = this;
    if (!enabled || !paddedRect)
      return;
    this.panner.stopInteractions();
    let newDragState = 0;
    if (enableAxisDragging && hoveredAxis) {
      newDragState = 1;
    } else if (paddedRect.containsPoint(event.offsetX, event.offsetY)) {
      const panKeyPressed = this.isPanningKeyPressed(event.sourceEvent);
      if (enablePanning && (!enableSelecting || panKeyPressed)) {
        cursorManager.updateCursor(CURSOR_ID, "grabbing");
        newDragState = 2;
        this.panner.start();
      } else if (enableSelecting) {
        const fullyZoomedIn = this.isMinZoom(this.getZoom());
        if (!fullyZoomedIn && !panKeyPressed) {
          newDragState = 3;
        }
      }
    }
    if ((this.dragState = newDragState) !== 0) {
      zoomManager.fireZoomPanStartEvent("zoom");
    }
  }
  onDrag(event) {
    const {
      anchorPointX,
      anchorPointY,
      axisDragger,
      dragState,
      enabled,
      paddedRect,
      panner,
      selector,
      seriesRect,
      hoveredAxis,
      ctx: { interactionManager, tooltipManager, updateService, zoomManager }
    } = this;
    if (!enabled || !paddedRect || !seriesRect)
      return;
    interactionManager.pushState(import_ag_charts_community48._ModuleSupport.InteractionState.ZoomDrag);
    const zoom2 = this.getZoom();
    switch (dragState) {
      case 1:
        if (!hoveredAxis)
          break;
        const { id: axisId, direction } = hoveredAxis;
        const anchor = direction === import_ag_charts_community48._ModuleSupport.ChartAxisDirection.X ? anchorPointX : anchorPointY;
        const axisZoom = zoomManager.getAxisZoom(axisId);
        const newZoom = axisDragger.update(event, direction, anchor, seriesRect, zoom2, axisZoom);
        this.updateAxisZoom(direction, newZoom);
        break;
      case 2:
        panner.update(event);
        break;
      case 3:
        selector.update(event, this.getModuleProperties(), paddedRect, zoom2);
        break;
      case 0:
        return;
    }
    tooltipManager.updateTooltip(TOOLTIP_ID);
    updateService.update(ChartUpdateType22.PERFORM_LAYOUT, { skipAnimations: true });
  }
  onDragEnd() {
    const {
      axisDragger,
      dragState,
      enabled,
      panner,
      selector,
      ctx: { cursorManager, interactionManager, tooltipManager }
    } = this;
    interactionManager.popState(import_ag_charts_community48._ModuleSupport.InteractionState.ZoomDrag);
    if (!enabled || dragState === 0)
      return;
    switch (dragState) {
      case 1:
        axisDragger.stop();
        break;
      case 2:
        panner.stop();
        break;
      case 3:
        if (!selector.didUpdate())
          break;
        const zoom2 = this.getZoom();
        if (this.isMinZoom(zoom2))
          break;
        const newZoom = selector.stop(this.seriesRect, this.paddedRect, zoom2);
        this.updateZoom(newZoom);
        break;
    }
    this.dragState = 0;
    cursorManager.updateCursor(CURSOR_ID);
    tooltipManager.removeTooltip(TOOLTIP_ID);
  }
  onWheel(event) {
    const {
      enabled,
      enableAxisDragging,
      enablePanning,
      enableScrolling,
      hoveredAxis,
      paddedRect,
      scroller,
      scrollingStep,
      scrollPanner,
      seriesRect,
      ctx: { zoomManager }
    } = this;
    if (!enabled || !enableScrolling || !paddedRect || !seriesRect)
      return;
    const isSeriesScrolling = paddedRect.containsPoint(event.offsetX, event.offsetY);
    const isAxisScrolling = enableAxisDragging && hoveredAxis != null;
    let isScalingX = this.isScalingX();
    let isScalingY = this.isScalingY();
    if (isAxisScrolling) {
      isScalingX = hoveredAxis.direction === import_ag_charts_community48._ModuleSupport.ChartAxisDirection.X;
      isScalingY = !isScalingX;
    }
    const sourceEvent = event.sourceEvent;
    const { deltaX, deltaY } = sourceEvent;
    const isHorizontalScrolling = deltaX != null && deltaY != null && Math.abs(deltaX) > Math.abs(deltaY);
    if (enablePanning && isHorizontalScrolling) {
      event.consume();
      event.sourceEvent.preventDefault();
      const newZooms = scrollPanner.update(event, scrollingStep, seriesRect, zoomManager.getAxisZooms());
      for (const { direction, zoom: newZoom2 } of Object.values(newZooms)) {
        this.updateAxisZoom(direction, newZoom2);
      }
      return;
    }
    if (!isSeriesScrolling && !isAxisScrolling)
      return;
    event.consume();
    event.sourceEvent.preventDefault();
    const newZoom = scroller.update(
      event,
      this.getModuleProperties({ isScalingX, isScalingY }),
      seriesRect,
      this.getZoom()
    );
    this.updateZoom(newZoom);
  }
  onAxisLeave() {
    const {
      enabled,
      ctx: { cursorManager }
    } = this;
    if (!enabled)
      return;
    this.hoveredAxis = void 0;
    cursorManager.updateCursor(CURSOR_ID);
  }
  onAxisHover(event) {
    const {
      enabled,
      enableAxisDragging,
      ctx: { cursorManager }
    } = this;
    if (!enabled)
      return;
    this.hoveredAxis = {
      id: event.axisId,
      direction: event.direction
    };
    if (enableAxisDragging) {
      cursorManager.updateCursor(CURSOR_ID, event.direction === ChartAxisDirection7.X ? "ew-resize" : "ns-resize");
    }
  }
  onPinchMove(event) {
    const { enabled, enableScrolling, paddedRect, seriesRect } = this;
    if (!enabled || !enableScrolling || !paddedRect || !seriesRect)
      return;
    const oldZoom = this.getZoom();
    const newZoom = this.getZoom();
    const delta3 = event.deltaDistance * -0.01;
    const origin = pointToRatio(seriesRect, event.origin.x, event.origin.y);
    if (this.isScalingX()) {
      newZoom.x.max += delta3 * dx(oldZoom);
      newZoom.x = scaleZoomAxisWithPoint(newZoom.x, oldZoom.x, origin.x);
    }
    if (this.isScalingY()) {
      newZoom.y.max += delta3 * (oldZoom.y.max - oldZoom.y.min);
      newZoom.y = scaleZoomAxisWithPoint(newZoom.y, oldZoom.y, origin.y);
    }
    this.updateZoom(constrainZoom(newZoom));
  }
  onLayoutComplete(event) {
    const { enabled, rangeX, rangeY } = this;
    if (!enabled)
      return;
    const {
      series: { rect, paddedRect, shouldFlipXY },
      axes
    } = event;
    this.seriesRect = rect;
    this.paddedRect = paddedRect;
    this.contextMenu.rect = paddedRect;
    this.shouldFlipXY = shouldFlipXY;
    if (!axes)
      return;
    const [axesX, axesY] = import_ag_charts_community48._Util.bifurcate((axis) => axis.direction === ChartAxisDirection7.X, axes);
    const rangeXAxisChanged = rangeX.updateAxis(axesX);
    const rangeYAxisChanged = rangeY.updateAxis(axesY);
    if (!rangeXAxisChanged && !rangeYAxisChanged)
      return;
    const newZoom = {};
    newZoom.x = rangeX.getRange();
    newZoom.y = rangeY.getRange();
    if (newZoom.x != null || newZoom.y != null) {
      this.updateZoom(constrainZoom(definedZoomState(newZoom)));
    }
  }
  onUpdateComplete({ minRect, minVisibleRect }) {
    const { enabled, minVisibleItemsX, minVisibleItemsY, paddedRect, shouldFlipXY } = this;
    if (!enabled || !paddedRect || !minRect || !minVisibleRect)
      return;
    const zoom2 = this.getZoom();
    const minVisibleItemsWidth = shouldFlipXY ? minVisibleItemsY : minVisibleItemsX;
    const minVisibleItemsHeight = shouldFlipXY ? minVisibleItemsX : minVisibleItemsY;
    const widthRatio = minVisibleRect.width * minVisibleItemsWidth / paddedRect.width;
    const heightRatio = minVisibleRect.height * minVisibleItemsHeight / paddedRect.height;
    const ratioX = round22(widthRatio * dx(zoom2));
    const ratioY = round22(heightRatio * dy(zoom2));
    if (this.isScalingX()) {
      this.minRatioX = Math.min(1, ratioX);
    }
    if (this.isScalingY()) {
      this.minRatioY = Math.min(1, ratioY);
    }
    this.minRatioX || (this.minRatioX = this.minRatioY || 0);
    this.minRatioY || (this.minRatioY = this.minRatioX || 0);
  }
  onZoomChange(event) {
    if (event.callerId !== "zoom") {
      this.panner.stopInteractions();
    }
    const zoom2 = this.getZoom();
    const props = this.getModuleProperties();
    this.contextMenu.toggleActions(zoom2, props);
    this.toolbar.toggleButtons(zoom2, props);
  }
  onZoomPanStart(event) {
    if (event.callerId === "zoom") {
      this.panner.stopInteractions();
    }
  }
  onPanUpdate(event) {
    const {
      panner,
      seriesRect,
      ctx: { tooltipManager, updateService, zoomManager }
    } = this;
    if (!seriesRect)
      return;
    const newZooms = panner.translateZooms(seriesRect, zoomManager.getAxisZooms(), event.deltaX, event.deltaY);
    for (const { direction: panDirection, zoom: panZoom } of Object.values(newZooms)) {
      this.updateAxisZoom(panDirection, panZoom);
    }
    tooltipManager.updateTooltip(TOOLTIP_ID);
    updateService.update(ChartUpdateType22.PERFORM_LAYOUT, { skipAnimations: true });
  }
  isPanningKeyPressed(event) {
    switch (this.panKey) {
      case "alt":
        return event.altKey;
      case "ctrl":
        return event.ctrlKey;
      case "shift":
        return event.shiftKey;
      case "meta":
        return event.metaKey;
    }
  }
  isScalingX() {
    if (this.axes === "xy")
      return true;
    return this.shouldFlipXY ? this.axes === "y" : this.axes === "x";
  }
  isScalingY() {
    if (this.axes === "xy")
      return true;
    return this.shouldFlipXY ? this.axes === "x" : this.axes === "y";
  }
  getAnchorPointX() {
    return this.shouldFlipXY ? this.anchorPointY : this.anchorPointX;
  }
  getAnchorPointY() {
    return this.shouldFlipXY ? this.anchorPointX : this.anchorPointY;
  }
  isMinZoom(zoom2) {
    return isZoomLess(zoom2, this.minRatioX, this.minRatioY);
  }
  updateZoom(zoom2) {
    const {
      minRatioX,
      minRatioY,
      ctx: { zoomManager }
    } = this;
    const dx_ = dx(zoom2);
    const dy_ = dy(zoom2);
    const oldZoom = this.getZoom();
    const zoomedInTooFarX = dx_ <= dx(oldZoom) && dx_ < minRatioX;
    const zoomedInTooFarY = dy_ <= dy(oldZoom) && dy_ < minRatioY;
    if (zoomedInTooFarX) {
      zoom2.x = constrainAxisWithOld(zoom2.x, oldZoom.x, minRatioX);
    }
    if (zoomedInTooFarY) {
      zoom2.y = constrainAxisWithOld(zoom2.y, oldZoom.y, minRatioY);
    }
    zoomManager.updateZoom("zoom", zoom2);
  }
  updateAxisZoom(direction, partialZoom) {
    if (!partialZoom)
      return;
    const fullZoom = this.getZoom();
    fullZoom[direction] = partialZoom;
    this.updateZoom(fullZoom);
  }
  getZoom() {
    return definedZoomState(this.ctx.zoomManager.getZoom());
  }
  getResetZoom() {
    var _a2, _b, _c, _d;
    const x = (_b = (_a2 = this.rangeX.getInitialRange()) != null ? _a2 : this.ratioX.getInitialRatio()) != null ? _b : UNIT;
    const y = (_d = (_c = this.rangeY.getInitialRange()) != null ? _c : this.ratioY.getInitialRatio()) != null ? _d : UNIT;
    return { x, y };
  }
  getModuleProperties(overrides) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i;
    return {
      anchorPointX: (_a2 = overrides == null ? void 0 : overrides.anchorPointX) != null ? _a2 : this.getAnchorPointX(),
      anchorPointY: (_b = overrides == null ? void 0 : overrides.anchorPointY) != null ? _b : this.getAnchorPointY(),
      enabled: (_c = overrides == null ? void 0 : overrides.enabled) != null ? _c : this.enabled,
      isScalingX: (_d = overrides == null ? void 0 : overrides.isScalingX) != null ? _d : this.isScalingX(),
      isScalingY: (_e = overrides == null ? void 0 : overrides.isScalingY) != null ? _e : this.isScalingY(),
      minRatioX: (_f = overrides == null ? void 0 : overrides.minRatioX) != null ? _f : this.minRatioX,
      minRatioY: (_g = overrides == null ? void 0 : overrides.minRatioY) != null ? _g : this.minRatioY,
      rangeX: (_h = overrides == null ? void 0 : overrides.rangeX) != null ? _h : this.rangeX,
      scrollingStep: (_i = overrides == null ? void 0 : overrides.scrollingStep) != null ? _i : this.scrollingStep
    };
  }
};
__decorateClass2([
  ActionOnSet7({
    newValue(enabled) {
      this.onEnabledChange(enabled);
    }
  }),
  Validate25(BOOLEAN13)
], Zoom.prototype, "enabled", 2);
__decorateClass2([
  Validate25(BOOLEAN13)
], Zoom.prototype, "enableAxisDragging", 2);
__decorateClass2([
  Validate25(BOOLEAN13)
], Zoom.prototype, "enableDoubleClickToReset", 2);
__decorateClass2([
  Validate25(BOOLEAN13)
], Zoom.prototype, "enablePanning", 2);
__decorateClass2([
  Validate25(BOOLEAN13)
], Zoom.prototype, "enableScrolling", 2);
__decorateClass2([
  Validate25(BOOLEAN13)
], Zoom.prototype, "enableSelecting", 2);
__decorateClass2([
  Validate25(UNION5(["alt", "ctrl", "meta", "shift"], "a pan key"))
], Zoom.prototype, "panKey", 2);
__decorateClass2([
  Validate25(UNION5(["x", "y", "xy"], "an axis"))
], Zoom.prototype, "axes", 2);
__decorateClass2([
  Validate25(RATIO10)
], Zoom.prototype, "scrollingStep", 2);
__decorateClass2([
  Validate25(NUMBER8.restrict({ min: 1 }))
], Zoom.prototype, "minVisibleItemsX", 2);
__decorateClass2([
  Validate25(NUMBER8.restrict({ min: 1 }))
], Zoom.prototype, "minVisibleItemsY", 2);
__decorateClass2([
  Validate25(ANCHOR_POINT)
], Zoom.prototype, "anchorPointX", 2);
__decorateClass2([
  Validate25(ANCHOR_POINT)
], Zoom.prototype, "anchorPointY", 2);
__decorateClass2([
  ProxyProperty22("panner.deceleration"),
  Validate25(NUMBER8.restrict({ min: 1e-4, max: 1 }))
], Zoom.prototype, "deceleration", 2);
var ZoomModule = {
  type: "root",
  optionsKey: "zoom",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  dependencies: ["toolbar"],
  instanceConstructor: Zoom,
  themeTemplate: {
    zoom: {
      anchorPointX: "end",
      anchorPointY: "middle",
      axes: "x",
      buttons: {
        enabled: true,
        buttons: [
          {
            icon: "zoom-out",
            tooltip: "Zoom out",
            value: "zoom-out"
          },
          {
            icon: "zoom-in",
            tooltip: "Zoom in",
            value: "zoom-in"
          },
          {
            icon: "pan-left",
            tooltip: "Pan left",
            value: "pan-left"
          },
          {
            icon: "pan-right",
            tooltip: "Pan right",
            value: "pan-right"
          },
          {
            icon: "reset",
            tooltip: "Reset the zoom",
            value: "reset"
          }
        ]
      },
      enabled: false,
      enableAxisDragging: true,
      enableDoubleClickToReset: true,
      enablePanning: true,
      enableScrolling: true,
      enableSelecting: false,
      minVisibleItemsX: 2,
      minVisibleItemsY: 2,
      panKey: "alt",
      scrollingStep: 0.1
    }
  }
};
var import_ag_charts_community50 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community49 = (init_main(), __toCommonJS(main_exports));
var {
  BOOLEAN: BOOLEAN14,
  Layers: Layers5,
  POSITION: POSITION3,
  Validate: Validate26,
  Default: Default5,
  MIN_SPACING: MIN_SPACING4,
  MAX_SPACING: MAX_SPACING3,
  POSITIVE_NUMBER: POSITIVE_NUMBER9,
  ProxyProperty: ProxyProperty3,
  DeprecatedAndRenamedTo: DeprecatedAndRenamedTo2
} = import_ag_charts_community49._ModuleSupport;
var { BBox: BBox5, Group: Group5, Rect: Rect2, LinearGradientFill: LinearGradientFill2, Triangle: Triangle2 } = import_ag_charts_community49._Scene;
var { createId: createId3 } = import_ag_charts_community49._Util;
var GradientBar = class {
  constructor() {
    this.thickness = 16;
    this.preferredLength = 100;
  }
};
__decorateClass2([
  Validate26(POSITIVE_NUMBER9)
], GradientBar.prototype, "thickness", 2);
__decorateClass2([
  Validate26(POSITIVE_NUMBER9)
], GradientBar.prototype, "preferredLength", 2);
var GradientLegendAxisTick = class extends import_ag_charts_community49._ModuleSupport.AxisTick {
  constructor() {
    super(...arguments);
    this.enabled = false;
    this.size = 0;
    this.minSpacing = NaN;
    this.maxSpacing = NaN;
  }
};
__decorateClass2([
  Validate26(MIN_SPACING4),
  Default5(NaN)
], GradientLegendAxisTick.prototype, "minSpacing", 2);
__decorateClass2([
  Validate26(MAX_SPACING3),
  Default5(NaN)
], GradientLegendAxisTick.prototype, "maxSpacing", 2);
var GradientLegendAxis = class extends import_ag_charts_community49._ModuleSupport.CartesianAxis {
  constructor(ctx) {
    super(ctx, new import_ag_charts_community49._Scale.LinearScale(), { respondsToZoom: false });
    this.colorDomain = [];
    this.nice = false;
    this.line.enabled = false;
  }
  calculateDomain() {
    this.setDomain(this.colorDomain);
  }
  createTick() {
    return new GradientLegendAxisTick();
  }
};
var GradientLegendLabel = class {
  constructor(label) {
    this.label = label;
  }
};
__decorateClass2([
  ProxyProperty3("label.fontStyle")
], GradientLegendLabel.prototype, "fontStyle", 2);
__decorateClass2([
  ProxyProperty3("label.fontWeight")
], GradientLegendLabel.prototype, "fontWeight", 2);
__decorateClass2([
  ProxyProperty3("label.fontSize")
], GradientLegendLabel.prototype, "fontSize", 2);
__decorateClass2([
  ProxyProperty3("label.fontFamily")
], GradientLegendLabel.prototype, "fontFamily", 2);
__decorateClass2([
  ProxyProperty3("label.color")
], GradientLegendLabel.prototype, "color", 2);
__decorateClass2([
  ProxyProperty3("label.format")
], GradientLegendLabel.prototype, "format", 2);
__decorateClass2([
  ProxyProperty3("label.formatter")
], GradientLegendLabel.prototype, "formatter", 2);
var GradientLegendInterval = class {
  constructor(tick) {
    this.tick = tick;
  }
};
__decorateClass2([
  ProxyProperty3("tick.values")
], GradientLegendInterval.prototype, "values", 2);
__decorateClass2([
  ProxyProperty3("tick.minSpacing")
], GradientLegendInterval.prototype, "minSpacing", 2);
__decorateClass2([
  ProxyProperty3("tick.maxSpacing")
], GradientLegendInterval.prototype, "maxSpacing", 2);
__decorateClass2([
  ProxyProperty3("tick.interval")
], GradientLegendInterval.prototype, "step", 2);
var GradientLegendScale = class {
  constructor(axis) {
    this.axis = axis;
    this.label = new GradientLegendLabel(axis.label);
    this.interval = new GradientLegendInterval(axis.tick);
  }
};
__decorateClass2([
  ProxyProperty3("axis.seriesAreaPadding")
], GradientLegendScale.prototype, "padding", 2);
var GradientLegend = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.id = createId3(this);
    this.group = new Group5({ name: "legend", layer: true, zIndex: Layers5.LEGEND_ZINDEX });
    this.gradient = new GradientBar();
    this.destroyFns = [];
    this.enabled = false;
    this.position = "bottom";
    this.reverseOrder = void 0;
    this.pagination = void 0;
    this.spacing = 20;
    this.data = [];
    this.listeners = {};
    this.latestGradientBox = void 0;
    this.layoutService = ctx.layoutService;
    this.destroyFns.push(this.layoutService.addListener("start-layout", (e) => this.update(e.shrinkRect)));
    this.highlightManager = ctx.highlightManager;
    this.destroyFns.push(this.highlightManager.addListener("highlight-change", () => this.onChartHoverChange()));
    this.gradientRect = new Rect2();
    this.gradientFill = new LinearGradientFill2();
    this.gradientFill.mask = this.gradientRect;
    this.group.append(this.gradientFill);
    this.arrow = new Triangle2();
    this.group.append(this.arrow);
    this.axisGridGroup = new Group5({ name: "legend-axis-grid-group" });
    this.group.append(this.axisGridGroup);
    this.axisGroup = new Group5({ name: "legend-axis-group" });
    this.group.append(this.axisGroup);
    this.axis = new GradientLegendAxis(ctx);
    this.axis.attachAxis(this.axisGroup, this.axisGridGroup);
    this.scale = new GradientLegendScale(this.axis);
    this.stop = this.scale;
    this.destroyFns.push(() => this.detachLegend());
  }
  getOrientation() {
    switch (this.position) {
      case "right":
      case "left":
        return "vertical";
      case "bottom":
      case "top":
        return "horizontal";
    }
  }
  destroy() {
    this.destroyFns.forEach((f) => f());
  }
  attachLegend(scene) {
    scene.appendChild(this.group);
  }
  detachLegend() {
    var _a2;
    (_a2 = this.group.parent) == null ? void 0 : _a2.removeChild(this.group);
  }
  update(shrinkRect) {
    const data = this.data[0];
    if (!this.enabled || !data || !data.enabled) {
      this.group.visible = false;
      return { shrinkRect: shrinkRect.clone() };
    }
    const { colorRange } = this.normalizeColorArrays(data);
    const gradientBox = this.updateGradientRect(shrinkRect, colorRange);
    const axisBox = this.updateAxis(data, gradientBox);
    const { newShrinkRect, translateX, translateY } = this.getMeasurements(shrinkRect, gradientBox, axisBox);
    this.updateArrow(gradientBox);
    this.group.visible = true;
    this.group.translationX = translateX;
    this.group.translationY = translateY;
    this.latestGradientBox = gradientBox;
    return { shrinkRect: newShrinkRect };
  }
  normalizeColorArrays(data) {
    let colorDomain = data.colorDomain.slice();
    const colorRange = data.colorRange.slice();
    if (colorDomain.length === colorRange.length) {
      return { colorDomain, colorRange };
    }
    if (colorDomain.length > colorRange.length) {
      colorRange.splice(colorDomain.length);
    }
    const count = colorRange.length;
    colorDomain = colorRange.map((_, i) => {
      const [d0, d1] = colorDomain;
      if (i === 0)
        return d0;
      if (i === count - 1)
        return d1;
      return d0 + (d1 - d0) * i / (count - 1);
    });
    return { colorDomain, colorRange };
  }
  updateGradientRect(shrinkRect, colorRange) {
    const { preferredLength: gradientLength, thickness } = this.gradient;
    const gradientBox = new BBox5(0, 0, 0, 0);
    const vertical = this.getOrientation() === "vertical";
    if (vertical) {
      const maxHeight = shrinkRect.height;
      const preferredHeight = gradientLength;
      gradientBox.x = 0;
      gradientBox.y = 0;
      gradientBox.width = thickness;
      gradientBox.height = Math.min(maxHeight, preferredHeight);
    } else {
      const maxWidth = shrinkRect.width;
      const preferredWidth = gradientLength;
      gradientBox.x = 0;
      gradientBox.y = 0;
      gradientBox.width = Math.min(maxWidth, preferredWidth);
      gradientBox.height = thickness;
    }
    if (this.reverseOrder) {
      colorRange = colorRange.slice().reverse();
    }
    this.gradientFill.stops = colorRange;
    this.gradientFill.direction = vertical ? "to-bottom" : "to-right";
    this.gradientRect.x = gradientBox.x;
    this.gradientRect.y = gradientBox.y;
    this.gradientRect.width = gradientBox.width;
    this.gradientRect.height = gradientBox.height;
    return gradientBox;
  }
  updateAxis(data, gradientBox) {
    const { reverseOrder, axis } = this;
    const vertical = this.getOrientation() === "vertical";
    axis.position = vertical ? "right" : "bottom";
    axis.colorDomain = reverseOrder ? data.colorDomain.slice().reverse() : data.colorDomain;
    axis.calculateDomain();
    axis.range = vertical ? [0, gradientBox.height] : [0, gradientBox.width];
    axis.gridLength = 0;
    axis.translation.x = gradientBox.x + (vertical ? gradientBox.width : 0);
    axis.translation.y = gradientBox.y + (vertical ? 0 : gradientBox.height);
    const axisBox = axis.calculateLayout().bbox;
    axis.update();
    return axisBox;
  }
  updateArrow(gradientBox) {
    var _a2;
    const {
      arrow,
      axis: { label, scale: scale2 }
    } = this;
    const highlighted = this.highlightManager.getActiveHighlight();
    const colorValue = highlighted == null ? void 0 : highlighted.colorValue;
    if (highlighted == null || colorValue == null) {
      arrow.visible = false;
      return;
    }
    const vertical = this.getOrientation() === "vertical";
    const size = (_a2 = label.fontSize) != null ? _a2 : 0;
    const t = scale2.convert(colorValue);
    let x;
    let y;
    let rotation;
    if (vertical) {
      x = gradientBox.x - size / 2;
      y = gradientBox.y + t;
      rotation = Math.PI / 2;
    } else {
      x = gradientBox.x + t;
      y = gradientBox.y - size / 2;
      rotation = Math.PI;
    }
    arrow.fill = label.color;
    arrow.size = size;
    arrow.translationX = x;
    arrow.translationY = y;
    arrow.rotation = rotation;
    arrow.visible = true;
  }
  getMeasurements(shrinkRect, gradientBox, axisBox) {
    let width;
    let height;
    const vertical = this.getOrientation() === "vertical";
    if (vertical) {
      width = gradientBox.width + axisBox.width;
      height = gradientBox.height;
    } else {
      width = gradientBox.width;
      height = gradientBox.height + axisBox.height;
    }
    const { spacing } = this;
    const newShrinkRect = shrinkRect.clone();
    let left;
    let top;
    if (this.position === "left") {
      left = shrinkRect.x;
      top = shrinkRect.y + shrinkRect.height / 2 - height / 2;
      newShrinkRect.shrink(width + spacing, "left");
    } else if (this.position === "right") {
      left = shrinkRect.x + shrinkRect.width - width;
      top = shrinkRect.y + shrinkRect.height / 2 - height / 2;
      newShrinkRect.shrink(width + spacing, "right");
    } else if (this.position === "top") {
      left = shrinkRect.x + shrinkRect.width / 2 - width / 2;
      top = shrinkRect.y;
      newShrinkRect.shrink(height + spacing, "top");
    } else {
      left = shrinkRect.x + shrinkRect.width / 2 - width / 2;
      top = shrinkRect.y + shrinkRect.height - height;
      newShrinkRect.shrink(height + spacing, "bottom");
    }
    return {
      translateX: left,
      translateY: top,
      gradientBox,
      newShrinkRect
    };
  }
  computeBBox() {
    return this.group.computeBBox();
  }
  onChartHoverChange() {
    if (this.enabled && this.latestGradientBox != null) {
      this.updateArrow(this.latestGradientBox);
    }
  }
};
GradientLegend.className = "GradientLegend";
__decorateClass2([
  Validate26(BOOLEAN14)
], GradientLegend.prototype, "enabled", 2);
__decorateClass2([
  Validate26(POSITION3)
], GradientLegend.prototype, "position", 2);
__decorateClass2([
  Validate26(BOOLEAN14, { optional: true })
], GradientLegend.prototype, "reverseOrder", 2);
__decorateClass2([
  Validate26(POSITIVE_NUMBER9)
], GradientLegend.prototype, "spacing", 2);
__decorateClass2([
  DeprecatedAndRenamedTo2("scale")
], GradientLegend.prototype, "stop", 2);
var GradientLegendModule = {
  type: "legend",
  optionsKey: "gradientLegend",
  packageType: "enterprise",
  chartTypes: ["cartesian", "polar", "hierarchy", "topology"],
  identifier: "gradient",
  instanceConstructor: GradientLegend,
  themeTemplate: {
    enabled: false,
    position: "bottom",
    spacing: 20,
    scale: {
      padding: 8,
      label: {
        color: import_ag_charts_community50._Theme.DEFAULT_LABEL_COLOUR,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: import_ag_charts_community50._Theme.DEFAULT_FONT_FAMILY,
        formatter: void 0
      },
      interval: {
        minSpacing: 1
      }
    },
    gradient: {
      preferredLength: 100,
      thickness: 16
    },
    reverseOrder: false
  }
};
var MD5 = class {
  constructor() {
    this.ieCompatibility = false;
  }
  init() {
    this.ieCompatibility = this.md5("hello") != "5d41402abc4b2a76b9719d911017c592";
  }
  md5cycle(x, k) {
    let a = x[0], b = x[1], c = x[2], d = x[3];
    a = this.ff(a, b, c, d, k[0], 7, -680876936);
    d = this.ff(d, a, b, c, k[1], 12, -389564586);
    c = this.ff(c, d, a, b, k[2], 17, 606105819);
    b = this.ff(b, c, d, a, k[3], 22, -1044525330);
    a = this.ff(a, b, c, d, k[4], 7, -176418897);
    d = this.ff(d, a, b, c, k[5], 12, 1200080426);
    c = this.ff(c, d, a, b, k[6], 17, -1473231341);
    b = this.ff(b, c, d, a, k[7], 22, -45705983);
    a = this.ff(a, b, c, d, k[8], 7, 1770035416);
    d = this.ff(d, a, b, c, k[9], 12, -1958414417);
    c = this.ff(c, d, a, b, k[10], 17, -42063);
    b = this.ff(b, c, d, a, k[11], 22, -1990404162);
    a = this.ff(a, b, c, d, k[12], 7, 1804603682);
    d = this.ff(d, a, b, c, k[13], 12, -40341101);
    c = this.ff(c, d, a, b, k[14], 17, -1502002290);
    b = this.ff(b, c, d, a, k[15], 22, 1236535329);
    a = this.gg(a, b, c, d, k[1], 5, -165796510);
    d = this.gg(d, a, b, c, k[6], 9, -1069501632);
    c = this.gg(c, d, a, b, k[11], 14, 643717713);
    b = this.gg(b, c, d, a, k[0], 20, -373897302);
    a = this.gg(a, b, c, d, k[5], 5, -701558691);
    d = this.gg(d, a, b, c, k[10], 9, 38016083);
    c = this.gg(c, d, a, b, k[15], 14, -660478335);
    b = this.gg(b, c, d, a, k[4], 20, -405537848);
    a = this.gg(a, b, c, d, k[9], 5, 568446438);
    d = this.gg(d, a, b, c, k[14], 9, -1019803690);
    c = this.gg(c, d, a, b, k[3], 14, -187363961);
    b = this.gg(b, c, d, a, k[8], 20, 1163531501);
    a = this.gg(a, b, c, d, k[13], 5, -1444681467);
    d = this.gg(d, a, b, c, k[2], 9, -51403784);
    c = this.gg(c, d, a, b, k[7], 14, 1735328473);
    b = this.gg(b, c, d, a, k[12], 20, -1926607734);
    a = this.hh(a, b, c, d, k[5], 4, -378558);
    d = this.hh(d, a, b, c, k[8], 11, -2022574463);
    c = this.hh(c, d, a, b, k[11], 16, 1839030562);
    b = this.hh(b, c, d, a, k[14], 23, -35309556);
    a = this.hh(a, b, c, d, k[1], 4, -1530992060);
    d = this.hh(d, a, b, c, k[4], 11, 1272893353);
    c = this.hh(c, d, a, b, k[7], 16, -155497632);
    b = this.hh(b, c, d, a, k[10], 23, -1094730640);
    a = this.hh(a, b, c, d, k[13], 4, 681279174);
    d = this.hh(d, a, b, c, k[0], 11, -358537222);
    c = this.hh(c, d, a, b, k[3], 16, -722521979);
    b = this.hh(b, c, d, a, k[6], 23, 76029189);
    a = this.hh(a, b, c, d, k[9], 4, -640364487);
    d = this.hh(d, a, b, c, k[12], 11, -421815835);
    c = this.hh(c, d, a, b, k[15], 16, 530742520);
    b = this.hh(b, c, d, a, k[2], 23, -995338651);
    a = this.ii(a, b, c, d, k[0], 6, -198630844);
    d = this.ii(d, a, b, c, k[7], 10, 1126891415);
    c = this.ii(c, d, a, b, k[14], 15, -1416354905);
    b = this.ii(b, c, d, a, k[5], 21, -57434055);
    a = this.ii(a, b, c, d, k[12], 6, 1700485571);
    d = this.ii(d, a, b, c, k[3], 10, -1894986606);
    c = this.ii(c, d, a, b, k[10], 15, -1051523);
    b = this.ii(b, c, d, a, k[1], 21, -2054922799);
    a = this.ii(a, b, c, d, k[8], 6, 1873313359);
    d = this.ii(d, a, b, c, k[15], 10, -30611744);
    c = this.ii(c, d, a, b, k[6], 15, -1560198380);
    b = this.ii(b, c, d, a, k[13], 21, 1309151649);
    a = this.ii(a, b, c, d, k[4], 6, -145523070);
    d = this.ii(d, a, b, c, k[11], 10, -1120210379);
    c = this.ii(c, d, a, b, k[2], 15, 718787259);
    b = this.ii(b, c, d, a, k[9], 21, -343485551);
    x[0] = this.add32(a, x[0]);
    x[1] = this.add32(b, x[1]);
    x[2] = this.add32(c, x[2]);
    x[3] = this.add32(d, x[3]);
  }
  cmn(q, a, b, x, s, t) {
    a = this.add32(this.add32(a, q), this.add32(x, t));
    return this.add32(a << s | a >>> 32 - s, b);
  }
  ff(a, b, c, d, x, s, t) {
    return this.cmn(b & c | ~b & d, a, b, x, s, t);
  }
  gg(a, b, c, d, x, s, t) {
    return this.cmn(b & d | c & ~d, a, b, x, s, t);
  }
  hh(a, b, c, d, x, s, t) {
    return this.cmn(b ^ c ^ d, a, b, x, s, t);
  }
  ii(a, b, c, d, x, s, t) {
    return this.cmn(c ^ (b | ~d), a, b, x, s, t);
  }
  md51(s) {
    const n = s.length;
    const state = [1732584193, -271733879, -1732584194, 271733878];
    let i;
    for (i = 64; i <= s.length; i += 64) {
      this.md5cycle(state, this.md5blk(s.substring(i - 64, i)));
    }
    s = s.substring(i - 64);
    const tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (i = 0; i < s.length; i++) {
      tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
    }
    tail[i >> 2] |= 128 << (i % 4 << 3);
    if (i > 55) {
      this.md5cycle(state, tail);
      for (i = 0; i < 16; i++) {
        tail[i] = 0;
      }
    }
    tail[14] = n * 8;
    this.md5cycle(state, tail);
    return state;
  }
  /* there needs to be support for Unicode here, * unless we pretend that we can redefine the MD-5
   * algorithm for multi-byte characters (perhaps by adding every four 16-bit characters and
   * shortening the sum to 32 bits). Otherwise I suthis.ggest performing MD-5 as if every character
   * was two bytes--e.g., 0040 0025 = @%--but then how will an ordinary MD-5 sum be matched?
   * There is no way to standardize text to something like UTF-8 before transformation; speed cost is
   * utterly prohibitive. The JavaScript standard itself needs to look at this: it should start
   * providing access to strings as preformed UTF-8 8-bit unsigned value arrays.
   */
  md5blk(s) {
    const md5blks = [];
    for (let i = 0; i < 64; i += 4) {
      md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
    }
    return md5blks;
  }
  rhex(n) {
    const hex_chr = "0123456789abcdef".split("");
    let s = "", j = 0;
    for (; j < 4; j++) {
      s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
    }
    return s;
  }
  hex(x) {
    for (let i = 0; i < x.length; i++) {
      x[i] = this.rhex(x[i]);
    }
    return x.join("");
  }
  md5(s) {
    return this.hex(this.md51(s));
  }
  add32(a, b) {
    return this.ieCompatibility ? this.add32Compat(a, b) : this.add32Std(a, b);
  }
  /* this function is much faster, so if possible we use it. Some IEs are the only ones I know of that
   need the idiotic second function, generated by an if clause.  */
  add32Std(a, b) {
    return a + b & 4294967295;
  }
  add32Compat(x, y) {
    const lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
};
function missingOrEmpty(value) {
  return value == null || value.length === 0;
}
var LICENSE_TYPES = {
  "01": "GRID",
  "02": "CHARTS",
  "0102": "BOTH"
};
var _LicenseManager = class _LicenseManager2 {
  constructor(document2) {
    this.gridContext = false;
    this.watermarkMessage = void 0;
    this.totalMessageLength = 124;
    this.document = document2;
    this.md5 = new MD5();
    this.md5.init();
  }
  validateLicense() {
    const licenseDetails = this.getLicenseDetails(this.licenseKey, this.gridContext);
    const currentLicenseName = `AG ${licenseDetails.currentLicenseType === "BOTH" ? "Grid and " : ""}Charts Enterprise`;
    const suppliedLicenseName = licenseDetails.suppliedLicenseType === void 0 ? "" : `AG ${licenseDetails.suppliedLicenseType === "BOTH" ? "Grid and AG Charts" : licenseDetails.suppliedLicenseType === "GRID" ? "Grid" : "Charts"} Enterprise`;
    if (licenseDetails.missing) {
      if (!this.isWebsiteUrl() || this.isForceWatermark()) {
        this.outputMissingLicenseKey(currentLicenseName);
      }
    } else if (licenseDetails.expired) {
      const gridReleaseDate = _LicenseManager2.getChartsReleaseDate();
      const formattedReleaseDate = _LicenseManager2.formatDate(gridReleaseDate);
      this.outputExpiredKey(licenseDetails.expiry, formattedReleaseDate, suppliedLicenseName);
    } else if (!licenseDetails.valid) {
      this.outputInvalidLicenseKey(
        !!licenseDetails.incorrectLicenseType,
        currentLicenseName,
        suppliedLicenseName
      );
    } else if (licenseDetails.isTrial && licenseDetails.trialExpired) {
      this.outputExpiredTrialKey(licenseDetails.expiry, currentLicenseName, suppliedLicenseName);
    }
  }
  static extractExpiry(license) {
    const restrictionHashed = license.substring(license.lastIndexOf("_") + 1, license.length);
    return new Date(parseInt(_LicenseManager2.decode(restrictionHashed), 10));
  }
  static extractLicenseComponents(licenseKey) {
    let cleanedLicenseKey = licenseKey.replace(/[\u200B-\u200D\uFEFF]/g, "");
    cleanedLicenseKey = cleanedLicenseKey.replace(/\r?\n|\r/g, "");
    if (licenseKey.length <= 32) {
      return { md5: null, license: licenseKey, version: null, isTrial: null };
    }
    const hashStart = cleanedLicenseKey.length - 32;
    const md5 = cleanedLicenseKey.substring(hashStart);
    const license = cleanedLicenseKey.substring(0, hashStart);
    const [version, isTrial, type] = _LicenseManager2.extractBracketedInformation(cleanedLicenseKey);
    return { md5, license, version, isTrial, type };
  }
  getLicenseDetails(licenseKey, gridContext = false) {
    const currentLicenseType = "CHARTS";
    if (missingOrEmpty(licenseKey)) {
      return {
        licenseKey,
        valid: false,
        missing: true,
        currentLicenseType
      };
    }
    const chartsReleaseDate = _LicenseManager2.getChartsReleaseDate();
    const { md5, license, version, isTrial, type } = _LicenseManager2.extractLicenseComponents(licenseKey);
    let valid = md5 === this.md5.md5(license) && licenseKey.indexOf("For_Trialing_ag-Grid_Only") === -1;
    let trialExpired = void 0;
    let expired = void 0;
    let expiry = null;
    let incorrectLicenseType = false;
    let suppliedLicenseType = void 0;
    function handleTrial() {
      const now = /* @__PURE__ */ new Date();
      trialExpired = expiry < now;
      expired = void 0;
    }
    if (valid) {
      expiry = _LicenseManager2.extractExpiry(license);
      valid = !isNaN(expiry.getTime());
      if (valid) {
        expired = chartsReleaseDate > expiry;
        switch (version) {
          case "legacy":
          case "2": {
            valid = false;
            break;
          }
          case "3": {
            if (missingOrEmpty(type)) {
              valid = false;
            } else {
              suppliedLicenseType = type;
              if (type !== LICENSE_TYPES["02"] && type !== LICENSE_TYPES["0102"]) {
                valid = false;
                incorrectLicenseType = true;
              } else if (isTrial) {
                handleTrial();
              }
            }
          }
        }
      }
    }
    if (!valid) {
      return {
        licenseKey,
        valid,
        incorrectLicenseType,
        currentLicenseType,
        suppliedLicenseType
      };
    }
    return {
      licenseKey,
      valid,
      expiry: _LicenseManager2.formatDate(expiry),
      expired,
      version,
      isTrial,
      trialExpired,
      invalidLicenseTypeForCombo: gridContext ? suppliedLicenseType !== "BOTH" : void 0,
      incorrectLicenseType,
      currentLicenseType,
      suppliedLicenseType
    };
  }
  isDisplayWatermark() {
    return this.isForceWatermark() || !this.isLocalhost() && !this.isWebsiteUrl() && !missingOrEmpty(this.watermarkMessage);
  }
  getWatermarkMessage() {
    return this.watermarkMessage || "";
  }
  getHostname() {
    if (!this.document) {
      return "localhost";
    }
    const win = this.document.defaultView || window;
    if (!win) {
      return "localhost";
    }
    const loc = win.location;
    const { hostname = "" } = loc;
    return hostname;
  }
  isForceWatermark() {
    var _a2, _b;
    if (!this.document) {
      return false;
    }
    const win = ((_b = (_a2 = this.document) == null ? void 0 : _a2.defaultView) != null ? _b : typeof window != "undefined") ? window : void 0;
    if (!win) {
      return false;
    }
    const { pathname } = win.location;
    return pathname ? pathname.indexOf("forceWatermark") !== -1 : false;
  }
  isWebsiteUrl() {
    const hostname = this.getHostname();
    return hostname.match(/^((?:[\w-]+\.)?ag-grid\.com)$/) !== null;
  }
  isLocalhost() {
    const hostname = this.getHostname();
    return hostname.match(/^(?:127\.0\.0\.1|localhost)$/) !== null;
  }
  static formatDate(date) {
    const monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    const day2 = date.getDate();
    const monthIndex = date.getMonth();
    const year2 = date.getFullYear();
    return day2 + " " + monthNames[monthIndex] + " " + year2;
  }
  static getChartsReleaseDate() {
    return new Date(parseInt(_LicenseManager2.decode(_LicenseManager2.RELEASE_INFORMATION), 10));
  }
  static decode(input) {
    const keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let t = "";
    let n, r, i;
    let s, o, u, a;
    let f = 0;
    const e = input.replace(/[^A-Za-z0-9+/=]/g, "");
    while (f < e.length) {
      s = keystr.indexOf(e.charAt(f++));
      o = keystr.indexOf(e.charAt(f++));
      u = keystr.indexOf(e.charAt(f++));
      a = keystr.indexOf(e.charAt(f++));
      n = s << 2 | o >> 4;
      r = (o & 15) << 4 | u >> 2;
      i = (u & 3) << 6 | a;
      t = t + String.fromCharCode(n);
      if (u != 64) {
        t = t + String.fromCharCode(r);
      }
      if (a != 64) {
        t = t + String.fromCharCode(i);
      }
    }
    t = _LicenseManager2.utf8_decode(t);
    return t;
  }
  static utf8_decode(input) {
    input = input.replace(/rn/g, "n");
    let t = "";
    for (let n = 0; n < input.length; n++) {
      const r = input.charCodeAt(n);
      if (r < 128) {
        t += String.fromCharCode(r);
      } else if (r > 127 && r < 2048) {
        t += String.fromCharCode(r >> 6 | 192);
        t += String.fromCharCode(r & 63 | 128);
      } else {
        t += String.fromCharCode(r >> 12 | 224);
        t += String.fromCharCode(r >> 6 & 63 | 128);
        t += String.fromCharCode(r & 63 | 128);
      }
    }
    return t;
  }
  setLicenseKey(licenseKey, gridContext = false) {
    this.gridContext = gridContext;
    this.licenseKey = licenseKey;
  }
  static extractBracketedInformation(licenseKey) {
    if (!licenseKey.includes("[")) {
      return ["legacy", false, void 0];
    }
    const matches = licenseKey.match(/\[(.*?)\]/g).map((match) => match.replace("[", "").replace("]", ""));
    if (!matches || matches.length === 0) {
      return ["legacy", false, void 0];
    }
    const isTrial = matches.filter((match) => match === "TRIAL").length === 1;
    const rawVersion = matches.filter((match) => match.indexOf("v") === 0)[0];
    const version = rawVersion ? rawVersion.replace("v", "") : "legacy";
    const type = LICENSE_TYPES[matches.filter((match) => LICENSE_TYPES[match])[0]];
    return [version, isTrial, type];
  }
  centerPadAndOutput(input) {
    const paddingRequired = this.totalMessageLength - input.length;
    console.error(input.padStart(paddingRequired / 2 + input.length, "*").padEnd(this.totalMessageLength, "*"));
  }
  padAndOutput(input, padding = "*", terminateWithPadding = "") {
    console.error(
      input.padEnd(this.totalMessageLength - terminateWithPadding.length, padding) + terminateWithPadding
    );
  }
  outputInvalidLicenseKey(incorrectLicenseType, currentLicenseName, suppliedLicenseName) {
    if (!this.gridContext) {
      if (incorrectLicenseType) {
        this.centerPadAndOutput("");
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(" Incompatible License Key ");
        this.padAndOutput(
          `* Your license key is for ${suppliedLicenseName} only and does not cover you for ${currentLicenseName}.`,
          " ",
          "*"
        );
        this.padAndOutput("* Please contact info@ag-grid.com to obtain a combined license key.", " ", "*");
        this.centerPadAndOutput("");
        this.centerPadAndOutput("");
      } else {
        this.centerPadAndOutput("");
        this.centerPadAndOutput(` ${currentLicenseName} License `);
        this.centerPadAndOutput(" Invalid License Key ");
        this.padAndOutput(
          `* Your license key is not valid - please contact info@ag-grid.com to obtain a valid license.`,
          " ",
          "*"
        );
        this.centerPadAndOutput("");
        this.centerPadAndOutput("");
      }
    }
    this.watermarkMessage = "Invalid License";
  }
  outputExpiredTrialKey(formattedExpiryDate, currentLicenseName, suppliedLicenseName) {
    if (!this.gridContext) {
      this.centerPadAndOutput("");
      this.centerPadAndOutput(` ${currentLicenseName} License `);
      this.centerPadAndOutput(" Trial Period Expired. ");
      this.padAndOutput(
        `* Your trial only license for ${suppliedLicenseName} expired on ${formattedExpiryDate}.`,
        " ",
        "*"
      );
      this.padAndOutput("* Please email info@ag-grid.com to purchase a license.", " ", "*");
      this.centerPadAndOutput("");
      this.centerPadAndOutput("");
    }
    this.watermarkMessage = "Trial Period Expired";
  }
  outputMissingLicenseKey(currentLicenseName) {
    if (!this.gridContext) {
      this.centerPadAndOutput("");
      this.centerPadAndOutput(` ${currentLicenseName} License `);
      this.centerPadAndOutput(" License Key Not Found ");
      this.padAndOutput(`* All ${currentLicenseName} features are unlocked for trial.`, " ", "*");
      this.padAndOutput(
        "* If you want to hide the watermark please email info@ag-grid.com for a trial license key.",
        " ",
        "*"
      );
      this.centerPadAndOutput("");
      this.centerPadAndOutput("");
    }
    this.watermarkMessage = "For Trial Use Only";
  }
  outputExpiredKey(formattedExpiryDate, formattedReleaseDate, currentLicenseName) {
    if (!this.gridContext) {
      this.centerPadAndOutput("");
      this.centerPadAndOutput(` ${currentLicenseName} License `);
      this.centerPadAndOutput(" Incompatible Software Version ");
      this.padAndOutput(
        `* Your license key works with versions of ${currentLicenseName} released before ${formattedExpiryDate}.`,
        " ",
        "*"
      );
      this.padAndOutput(`* The version you are trying to use was released on ${formattedReleaseDate}.`, " ", "*");
      this.padAndOutput("* Please contact info@ag-grid.com to renew your license key.", " ", "*");
      this.centerPadAndOutput("");
      this.centerPadAndOutput("");
    }
    this.watermarkMessage = "License Expired";
  }
};
_LicenseManager.RELEASE_INFORMATION = "MTcyMTExNTk3ODAyNA==";
var LicenseManager = _LicenseManager;
var import_ag_charts_community51 = (init_main(), __toCommonJS(main_exports));
var { createElement: createElement4, injectStyle: injectStyle3 } = import_ag_charts_community51._ModuleSupport;
var watermarkStyles = `
.ag-watermark {
    position: absolute;
    bottom: 20px;
    right: 25px;
    font-weight: bold;
    font-family: Impact, sans-serif;
    font-size: 19px;
    opacity: 0.7;
    animation: 1s ease-out 3s ag-watermark-fadeout;
    color: #9B9B9B;
    pointer-events: none;

    &::before {
        content: '';
        display: block;
        height: 40px;
        width: 170px;
        background-image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=);
        background-repeat: no-repeat;
        background-size: 170px 40px;
    }

    > span {
        padding-left: 0.7rem;
    }
}

@keyframes ag-watermark-fadeout {
    from { opacity: 0.5; }
    to { opacity: 0; }
}
`;
function injectWatermark(parentElement, text) {
  injectStyle3(watermarkStyles, "watermark");
  const element2 = createElement4("div");
  const textElement = createElement4("span");
  textElement.innerText = text;
  element2.addEventListener("animationend", () => parentElement.removeChild(element2));
  element2.classList.add("ag-watermark");
  element2.appendChild(textElement);
  parentElement.appendChild(element2);
}
var import_ag_charts_community56 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community54 = (init_main(), __toCommonJS(main_exports));
function prepareBoxPlotFromTo(isVertical) {
  const from = isVertical ? { scalingX: 1, scalingY: 0 } : { scalingX: 0, scalingY: 1 };
  const to = { scalingX: 1, scalingY: 1 };
  return { from, to };
}
function resetBoxPlotSelectionsScalingCenterFn(isVertical) {
  return (_node, datum) => {
    if (isVertical) {
      return { scalingCenterY: datum.scaledValues.medianValue };
    }
    return { scalingCenterX: datum.scaledValues.medianValue };
  };
}
var import_ag_charts_community52 = (init_main(), __toCommonJS(main_exports));
var { Group: Group6, Rect: Rect22, Line: Line3, BBox: BBox6, Selection: Selection22 } = import_ag_charts_community52._Scene;
var { Logger: Logger3 } = import_ag_charts_community52._Util;
var BoxPlotGroup = class extends Group6 {
  constructor() {
    super();
    this.append([
      new Rect22({
        tag: 0
        /* Box */
      }),
      new Rect22({
        tag: 0
        /* Box */
      }),
      new Rect22({
        tag: 2
        /* Outline */
      }),
      new Rect22({
        tag: 1
        /* Median */
      }),
      new Line3({
        tag: 3
        /* Whisker */
      }),
      new Line3({
        tag: 3
        /* Whisker */
      }),
      new Line3({
        tag: 4
        /* Cap */
      }),
      new Line3({
        tag: 4
        /* Cap */
      })
    ]);
  }
  updateDatumStyles(datum, activeStyles, isVertical, isReversedValueAxis, cornerRadius) {
    const {
      bandwidth,
      scaledValues: { xValue: axisValue, medianValue }
    } = datum;
    let { minValue, q1Value, q3Value, maxValue } = datum.scaledValues;
    if (isVertical && !isReversedValueAxis || !isVertical && isReversedValueAxis) {
      [maxValue, q3Value, q1Value, minValue] = [minValue, q1Value, q3Value, maxValue];
    }
    const position = (x, y, width, height) => isVertical ? { y: x, x: y, width: height, height: width } : { x, y, width, height };
    const hPosition = (x1, x2, y) => isVertical ? { y1: x1, y2: x2, x: y } : { x1, x2, y };
    const vPosition = (x, y1, y2) => isVertical ? { x1: y1, x2: y2, y: x } : { x, y1, y2 };
    const bbox = (x, y, width, height) => {
      ({ x, y, width, height } = position(x, y, width, height));
      return new BBox6(x, y, width, height);
    };
    const {
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cap,
      whisker: whiskerStyles
    } = activeStyles;
    const selection = Selection22.select(this, Rect22);
    const boxes = selection.selectByTag(
      0
      /* Box */
    );
    const [outline] = selection.selectByTag(
      2
      /* Outline */
    );
    const [median] = selection.selectByTag(
      1
      /* Median */
    );
    const whiskers = selection.selectByTag(
      3
      /* Whisker */
    );
    const caps = selection.selectByTag(
      4
      /* Cap */
    );
    if (whiskerStyles.strokeWidth > bandwidth) {
      whiskerStyles.strokeWidth = bandwidth;
    }
    const boxesPosition = position(q1Value, axisValue, q3Value - q1Value, bandwidth);
    outline.setProperties(boxesPosition);
    boxes[0].setProperties(boxesPosition);
    boxes[0].setProperties({
      cornerRadius,
      clipBBox: bbox(q1Value, axisValue, Math.round(medianValue - q1Value + strokeWidth / 2), bandwidth)
    });
    boxes[1].setProperties(boxesPosition);
    boxes[1].setProperties({
      cornerRadius,
      clipBBox: bbox(
        Math.round(medianValue - strokeWidth / 2),
        axisValue,
        Math.floor(q3Value - medianValue + strokeWidth / 2),
        bandwidth
      )
    });
    const medianStart = Math.max(Math.round(medianValue - strokeWidth / 2), q1Value + strokeWidth);
    const medianEnd = Math.min(Math.round(medianValue + strokeWidth / 2), q3Value - strokeWidth);
    median.setProperties(boxesPosition);
    median.setProperties({
      visible: medianStart < medianEnd,
      cornerRadius,
      clipBBox: bbox(
        medianStart,
        axisValue + strokeWidth,
        medianEnd - medianStart,
        Math.max(0, bandwidth - strokeWidth * 2)
      )
    });
    const capStart = Math.floor(axisValue + bandwidth * (1 - cap.lengthRatio) / 2);
    const capEnd = Math.ceil(axisValue + bandwidth * (1 + cap.lengthRatio) / 2);
    caps[0].setProperties(vPosition(minValue, capStart, capEnd));
    caps[1].setProperties(vPosition(maxValue, capStart, capEnd));
    whiskers[0].setProperties(
      hPosition(
        Math.round(minValue + whiskerStyles.strokeWidth / 2),
        q1Value,
        Math.floor(axisValue + bandwidth / 2)
      )
    );
    whiskers[1].setProperties(
      hPosition(
        q3Value,
        Math.round(maxValue - whiskerStyles.strokeWidth / 2),
        Math.floor(axisValue + bandwidth / 2)
      )
    );
    for (const element2 of boxes) {
      element2.setProperties({ fill, fillOpacity, strokeWidth: strokeWidth * 2, strokeOpacity: 0 });
    }
    median.setProperties({ fill: stroke, fillOpacity: strokeOpacity, strokeWidth: 0 });
    for (const element2 of [...whiskers, ...caps]) {
      element2.setProperties(whiskerStyles);
    }
    outline.setProperties({
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cornerRadius,
      fillOpacity: 0
    });
  }
  distanceSquared(x, y) {
    const nodes = Selection22.selectByClass(this, Rect22, Line3);
    return import_ag_charts_community52._Scene.nearestSquared(x, y, nodes).distanceSquared;
  }
  get midPoint() {
    const datum = this.datum;
    if (datum.midPoint === void 0) {
      Logger3.error("BoxPlotGroup.datum.midPoint is undefined");
      return { x: NaN, y: NaN };
    }
    return datum.midPoint;
  }
};
var import_ag_charts_community53 = (init_main(), __toCommonJS(main_exports));
var {
  BaseProperties: BaseProperties6,
  AbstractBarSeriesProperties: AbstractBarSeriesProperties2,
  SeriesTooltip: SeriesTooltip2,
  Validate: Validate27,
  COLOR_STRING: COLOR_STRING6,
  FUNCTION: FUNCTION4,
  LINE_DASH: LINE_DASH5,
  OBJECT: OBJECT5,
  POSITIVE_NUMBER: POSITIVE_NUMBER10,
  RATIO: RATIO11,
  STRING: STRING7,
  mergeDefaults: mergeDefaults3
} = import_ag_charts_community53._ModuleSupport;
var BoxPlotSeriesCap = class extends BaseProperties6 {
  constructor() {
    super(...arguments);
    this.lengthRatio = 0.5;
  }
};
__decorateClass2([
  Validate27(RATIO11)
], BoxPlotSeriesCap.prototype, "lengthRatio", 2);
var BoxPlotSeriesWhisker = class extends BaseProperties6 {
};
__decorateClass2([
  Validate27(COLOR_STRING6, { optional: true })
], BoxPlotSeriesWhisker.prototype, "stroke", 2);
__decorateClass2([
  Validate27(POSITIVE_NUMBER10)
], BoxPlotSeriesWhisker.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate27(RATIO11)
], BoxPlotSeriesWhisker.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate27(LINE_DASH5, { optional: true })
], BoxPlotSeriesWhisker.prototype, "lineDash", 2);
__decorateClass2([
  Validate27(POSITIVE_NUMBER10)
], BoxPlotSeriesWhisker.prototype, "lineDashOffset", 2);
var BoxPlotSeriesProperties = class extends AbstractBarSeriesProperties2 {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.fillOpacity = 1;
    this.stroke = "#333";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.cap = new BoxPlotSeriesCap();
    this.whisker = new BoxPlotSeriesWhisker();
    this.tooltip = new SeriesTooltip2();
  }
  toJson() {
    const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this;
    const properties = super.toJson();
    properties.whisker = mergeDefaults3(properties.whisker, {
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    });
    return properties;
  }
};
__decorateClass2([
  Validate27(STRING7)
], BoxPlotSeriesProperties.prototype, "xKey", 2);
__decorateClass2([
  Validate27(STRING7)
], BoxPlotSeriesProperties.prototype, "minKey", 2);
__decorateClass2([
  Validate27(STRING7)
], BoxPlotSeriesProperties.prototype, "q1Key", 2);
__decorateClass2([
  Validate27(STRING7)
], BoxPlotSeriesProperties.prototype, "medianKey", 2);
__decorateClass2([
  Validate27(STRING7)
], BoxPlotSeriesProperties.prototype, "q3Key", 2);
__decorateClass2([
  Validate27(STRING7)
], BoxPlotSeriesProperties.prototype, "maxKey", 2);
__decorateClass2([
  Validate27(STRING7, { optional: true })
], BoxPlotSeriesProperties.prototype, "xName", 2);
__decorateClass2([
  Validate27(STRING7, { optional: true })
], BoxPlotSeriesProperties.prototype, "yName", 2);
__decorateClass2([
  Validate27(STRING7, { optional: true })
], BoxPlotSeriesProperties.prototype, "minName", 2);
__decorateClass2([
  Validate27(STRING7, { optional: true })
], BoxPlotSeriesProperties.prototype, "q1Name", 2);
__decorateClass2([
  Validate27(STRING7, { optional: true })
], BoxPlotSeriesProperties.prototype, "medianName", 2);
__decorateClass2([
  Validate27(STRING7, { optional: true })
], BoxPlotSeriesProperties.prototype, "q3Name", 2);
__decorateClass2([
  Validate27(STRING7, { optional: true })
], BoxPlotSeriesProperties.prototype, "maxName", 2);
__decorateClass2([
  Validate27(COLOR_STRING6, { optional: true })
], BoxPlotSeriesProperties.prototype, "fill", 2);
__decorateClass2([
  Validate27(RATIO11)
], BoxPlotSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate27(COLOR_STRING6)
], BoxPlotSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate27(POSITIVE_NUMBER10)
], BoxPlotSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate27(RATIO11)
], BoxPlotSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate27(LINE_DASH5)
], BoxPlotSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate27(POSITIVE_NUMBER10)
], BoxPlotSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate27(POSITIVE_NUMBER10)
], BoxPlotSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass2([
  Validate27(FUNCTION4, { optional: true })
], BoxPlotSeriesProperties.prototype, "formatter", 2);
__decorateClass2([
  Validate27(OBJECT5)
], BoxPlotSeriesProperties.prototype, "cap", 2);
__decorateClass2([
  Validate27(OBJECT5)
], BoxPlotSeriesProperties.prototype, "whisker", 2);
__decorateClass2([
  Validate27(OBJECT5)
], BoxPlotSeriesProperties.prototype, "tooltip", 2);
var {
  extent: extent2,
  extractDecoratedProperties: extractDecoratedProperties2,
  fixNumericExtent: fixNumericExtent22,
  keyProperty: keyProperty2,
  mergeDefaults: mergeDefaults4,
  SeriesNodePickMode: SeriesNodePickMode2,
  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL2,
  valueProperty: valueProperty22,
  diff: diff2,
  animationValidation: animationValidation2,
  convertValuesToScaleByDefs: convertValuesToScaleByDefs2,
  isFiniteNumber: isFiniteNumber3,
  computeBarFocusBounds: computeBarFocusBounds2
} = import_ag_charts_community54._ModuleSupport;
var { motion: motion2 } = import_ag_charts_community54._Scene;
var { ContinuousScale: ContinuousScale2 } = import_ag_charts_community54._Scale;
var BoxPlotSeriesNodeEvent = class extends import_ag_charts_community54._ModuleSupport.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.minKey = series.properties.minKey;
    this.q1Key = series.properties.q1Key;
    this.medianKey = series.properties.medianKey;
    this.q3Key = series.properties.q3Key;
    this.maxKey = series.properties.maxKey;
  }
};
var BoxPlotSeries = class extends import_ag_charts_community54._ModuleSupport.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode2.EXACT_SHAPE_MATCH],
      directionKeys: {
        x: ["xKey"],
        y: ["medianKey", "q1Key", "q3Key", "minKey", "maxKey"]
      },
      directionNames: {
        x: ["xName"],
        y: ["medianName", "q1Name", "q3Name", "minName", "maxName"]
      },
      pathsPerSeries: 1,
      hasHighlightedLabels: true
    });
    this.properties = new BoxPlotSeriesProperties();
    this.NodeEvent = BoxPlotSeriesNodeEvent;
  }
  processData(dataController) {
    return __async2(this, null, function* () {
      var _a2, _b, _c;
      if (!this.properties.isValid() || !this.visible)
        return;
      const { xKey, minKey, q1Key, medianKey, q3Key, maxKey } = this.properties;
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      const xScale = (_a2 = this.getCategoryAxis()) == null ? void 0 : _a2.scale;
      const yScale = (_b = this.getValueAxis()) == null ? void 0 : _b.scale;
      const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
      const extraProps = [];
      if (animationEnabled && this.processedData) {
        extraProps.push(diff2(this.processedData));
      }
      if (animationEnabled) {
        extraProps.push(animationValidation2());
      }
      const { processedData } = yield this.requestDataModel(dataController, this.data, {
        props: [
          keyProperty2(xKey, xScaleType, { id: `xValue` }),
          valueProperty22(minKey, yScaleType, { id: `minValue` }),
          valueProperty22(q1Key, yScaleType, { id: `q1Value` }),
          valueProperty22(medianKey, yScaleType, { id: `medianValue` }),
          valueProperty22(q3Key, yScaleType, { id: `q3Value` }),
          valueProperty22(maxKey, yScaleType, { id: `maxValue` }),
          ...isContinuousX ? [SMALLEST_KEY_INTERVAL2] : [],
          ...extraProps
        ]
      });
      this.smallestDataInterval = (_c = processedData.reduced) == null ? void 0 : _c.smallestKeyInterval;
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    var _a2;
    const { processedData, dataModel, smallestDataInterval } = this;
    if (!(processedData && dataModel))
      return [];
    if (direction === this.getBarDirection()) {
      const minValues = dataModel.getDomain(this, `minValue`, "value", processedData);
      const maxValues = dataModel.getDomain(this, `maxValue`, "value", processedData);
      return fixNumericExtent22([Math.min(...minValues), Math.max(...maxValues)], this.getValueAxis());
    }
    const { index, def } = dataModel.resolveProcessedDataDefById(this, `xValue`);
    const keys = processedData.domain.keys[index];
    if (def.type === "key" && def.valueType === "category") {
      return keys;
    }
    const categoryAxis = this.getCategoryAxis();
    const keysExtent = (_a2 = extent2(keys)) != null ? _a2 : [NaN, NaN];
    const scalePadding = isFiniteNumber3(smallestDataInterval) ? smallestDataInterval * 0.5 : 0;
    const d0 = keysExtent[0] + -scalePadding;
    const d1 = keysExtent[1] + scalePadding;
    return fixNumericExtent22([d0, d1], categoryAxis);
  }
  createNodeData() {
    return __async2(this, null, function* () {
      const { visible, dataModel } = this;
      const xAxis = this.getCategoryAxis();
      const yAxis = this.getValueAxis();
      if (!(dataModel && xAxis && yAxis)) {
        return;
      }
      const { xKey, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cap, whisker } = this.properties;
      const nodeData = [];
      const defs = dataModel.resolveProcessedDataDefsByIds(this, [
        "xValue",
        "minValue",
        "q1Value",
        `medianValue`,
        `q3Value`,
        `maxValue`
      ]);
      const { barWidth, groupIndex } = this.updateGroupScale(xAxis);
      const barOffset = ContinuousScale2.is(xAxis.scale) ? barWidth * -0.5 : 0;
      const { groupScale, processedData } = this;
      const isVertical = this.isVertical();
      const context = {
        itemId: xKey,
        nodeData,
        labelData: [],
        scales: this.calculateScaling(),
        visible: this.visible
      };
      if (!visible)
        return context;
      processedData == null ? void 0 : processedData.data.forEach(({ datum, keys, values }) => {
        const { xValue, minValue, q1Value, medianValue, q3Value, maxValue } = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });
        if ([minValue, q1Value, medianValue, q3Value, maxValue].some((value) => typeof value !== "number") || minValue > q1Value || q1Value > medianValue || medianValue > q3Value || q3Value > maxValue) {
          return;
        }
        const scaledValues = convertValuesToScaleByDefs2({
          defs,
          values: {
            xValue,
            minValue,
            q1Value,
            medianValue,
            q3Value,
            maxValue
          },
          xAxis,
          yAxis
        });
        scaledValues.xValue += Math.round(groupScale.convert(String(groupIndex))) + barOffset;
        const bandwidth = Math.round(barWidth);
        const height = Math.abs(scaledValues.q3Value - scaledValues.q1Value);
        const midX = scaledValues.xValue + bandwidth / 2;
        const midY = Math.min(scaledValues.q3Value, scaledValues.q1Value) + height / 2;
        const midPoint = {
          x: isVertical ? midX : midY,
          y: isVertical ? midY : midX
        };
        const focusRectWidth = isVertical ? bandwidth : height;
        const focusRectHeight = isVertical ? height : bandwidth;
        nodeData.push({
          series: this,
          itemId: xValue,
          datum,
          xKey,
          bandwidth,
          scaledValues,
          cap,
          whisker,
          fill,
          fillOpacity,
          stroke,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset,
          midPoint,
          focusRect: {
            x: midPoint.x - focusRectWidth / 2,
            y: midPoint.y - focusRectHeight / 2,
            width: focusRectWidth,
            height: focusRectHeight
          }
        });
      });
      return context;
    });
  }
  getLegendData(legendType) {
    var _a2;
    const { id, data } = this;
    const {
      xKey,
      yName,
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      strokeOpacity,
      showInLegend,
      legendItemName,
      visible
    } = this.properties;
    if (!showInLegend || !(data == null ? void 0 : data.length) || !xKey || legendType !== "category") {
      return [];
    }
    return [
      {
        legendType: "category",
        id,
        itemId: id,
        seriesId: id,
        enabled: visible,
        label: {
          text: (_a2 = legendItemName != null ? legendItemName : yName) != null ? _a2 : id
        },
        marker: { fill, fillOpacity, stroke, strokeOpacity, strokeWidth },
        legendItemName
      }
    ];
  }
  getTooltipHtml(nodeDatum) {
    const {
      xKey,
      minKey,
      q1Key,
      medianKey,
      q3Key,
      maxKey,
      xName,
      yName,
      minName,
      q1Name,
      medianName,
      q3Name,
      maxName,
      tooltip,
      fill
    } = this.properties;
    const { datum, itemId } = nodeDatum;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!xAxis || !yAxis || !this.properties.isValid())
      return import_ag_charts_community54._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    const title = import_ag_charts_community54._Util.sanitizeHtml(yName);
    const contentData = [
      [xKey, xName, xAxis],
      [minKey, minName, yAxis],
      [q1Key, q1Name, yAxis],
      [medianKey, medianName, yAxis],
      [q3Key, q3Name, yAxis],
      [maxKey, maxName, yAxis]
    ];
    const content = contentData.map(([key, name, axis]) => import_ag_charts_community54._Util.sanitizeHtml(`${name != null ? name : key}: ${axis.formatDatum(datum[key])}`)).join(title ? "<br/>" : ", ");
    const { fill: formatFill } = this.getFormattedStyles(nodeDatum);
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: fill },
      {
        seriesId: this.id,
        itemId,
        datum,
        fill,
        xKey,
        minKey,
        q1Key,
        medianKey,
        q3Key,
        maxKey,
        xName,
        minName,
        q1Name,
        medianName,
        q3Name,
        maxName,
        yName,
        title,
        color: fill != null ? fill : formatFill
      }
    );
  }
  animateEmptyUpdateReady({
    datumSelection
  }) {
    const isVertical = this.isVertical();
    const { from, to } = prepareBoxPlotFromTo(isVertical);
    motion2.resetMotion([datumSelection], resetBoxPlotSelectionsScalingCenterFn(isVertical));
    motion2.staticFromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], from, to, {
      phase: "initial"
    });
  }
  isLabelEnabled() {
    return false;
  }
  updateDatumSelection(opts) {
    return __async2(this, null, function* () {
      var _a2;
      const data = (_a2 = opts.nodeData) != null ? _a2 : [];
      return opts.datumSelection.update(data);
    });
  }
  updateDatumNodes(_0) {
    return __async2(this, arguments, function* ({
      datumSelection,
      isHighlight: highlighted
    }) {
      var _a2;
      const isVertical = this.isVertical();
      const isReversedValueAxis = (_a2 = this.getValueAxis()) == null ? void 0 : _a2.isReversed();
      const { cornerRadius } = this.properties;
      datumSelection.each((boxPlotGroup, nodeDatum) => {
        let activeStyles = this.getFormattedStyles(nodeDatum, highlighted);
        if (highlighted) {
          activeStyles = mergeDefaults4(this.properties.highlightStyle.item, activeStyles);
        }
        const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = activeStyles;
        activeStyles.whisker = mergeDefaults4(activeStyles.whisker, {
          stroke,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset
        });
        boxPlotGroup.updateDatumStyles(
          nodeDatum,
          activeStyles,
          isVertical,
          isReversedValueAxis,
          cornerRadius
        );
      });
    });
  }
  updateLabelNodes(_opts) {
    return __async2(this, null, function* () {
    });
  }
  updateLabelSelection(opts) {
    return __async2(this, null, function* () {
      const { labelData, labelSelection } = opts;
      return labelSelection.update(labelData);
    });
  }
  nodeFactory() {
    return new BoxPlotGroup();
  }
  getFormattedStyles(nodeDatum, highlighted = false) {
    const {
      id: seriesId,
      ctx: { callbackCache }
    } = this;
    const { xKey, minKey, q1Key, medianKey, q3Key, maxKey, formatter } = this.properties;
    const { datum, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cap, whisker } = nodeDatum;
    const activeStyles = {
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      cap: extractDecoratedProperties2(cap),
      whisker: extractDecoratedProperties2(whisker)
    };
    if (formatter) {
      const formatStyles = callbackCache.call(formatter, __spreadProps2(__spreadValues2({
        datum,
        seriesId,
        highlighted
      }, activeStyles), {
        xKey,
        minKey,
        q1Key,
        medianKey,
        q3Key,
        maxKey
      }));
      if (formatStyles) {
        return mergeDefaults4(formatStyles, activeStyles);
      }
    }
    return activeStyles;
  }
  computeFocusBounds({ datumIndex, seriesRect }) {
    var _a2;
    return computeBarFocusBounds2(
      (_a2 = this.contextNodeData) == null ? void 0 : _a2.nodeData[datumIndex].focusRect,
      this.contentGroup,
      seriesRect
    );
  }
};
BoxPlotSeries.className = "BoxPlotSeries";
BoxPlotSeries.type = "box-plot";
var import_ag_charts_community55 = (init_main(), __toCommonJS(main_exports));
var BOX_PLOT_SERIES_THEME = {
  series: {
    __extends__: import_ag_charts_community55._Theme.EXTENDS_SERIES_DEFAULTS,
    direction: "vertical",
    strokeWidth: 2
  },
  axes: {
    [import_ag_charts_community55._Theme.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: {
        snap: false
      }
    },
    [import_ag_charts_community55._Theme.CARTESIAN_AXIS_TYPE.CATEGORY]: {
      groupPaddingInner: 0.2,
      crosshair: {
        enabled: false,
        snap: false
      }
    }
  }
};
var BoxPlotModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "box-plot",
  instanceConstructor: BoxPlotSeries,
  defaultAxes: [
    {
      type: import_ag_charts_community56._Theme.CARTESIAN_AXIS_TYPE.NUMBER,
      position: import_ag_charts_community56._Theme.POSITION.LEFT
    },
    {
      type: import_ag_charts_community56._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: import_ag_charts_community56._Theme.POSITION.BOTTOM
    }
  ],
  themeTemplate: BOX_PLOT_SERIES_THEME,
  groupable: true,
  paletteFactory: ({ takeColors, userPalette, themeTemplateParameters }) => {
    var _a2;
    const themeBackgroundColor = themeTemplateParameters.properties.get(import_ag_charts_community56._Theme.DEFAULT_BACKGROUND_COLOUR);
    const backgroundFill = (_a2 = Array.isArray(themeBackgroundColor) ? themeBackgroundColor[0] : themeBackgroundColor) != null ? _a2 : "white";
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return {
      fill: userPalette ? fill : import_ag_charts_community56._Util.Color.interpolate(fill, backgroundFill)(0.7),
      stroke
    };
  },
  swapDefaultAxesCondition: ({ direction }) => direction === "horizontal"
};
var import_ag_charts_community60 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community58 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community57 = (init_main(), __toCommonJS(main_exports));
var {
  AbstractBarSeriesProperties: AbstractBarSeriesProperties22,
  BaseProperties: BaseProperties7,
  PropertiesArray: PropertiesArray22,
  SeriesTooltip: SeriesTooltip22,
  Validate: Validate28,
  ARRAY: ARRAY3,
  COLOR_STRING: COLOR_STRING7,
  LINE_DASH: LINE_DASH6,
  OBJECT: OBJECT6,
  POSITIVE_NUMBER: POSITIVE_NUMBER11,
  RATIO: RATIO12,
  STRING: STRING8
} = import_ag_charts_community57._ModuleSupport;
var TargetStyle = class extends BaseProperties7 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.lengthRatio = 0.75;
  }
};
__decorateClass2([
  Validate28(COLOR_STRING7)
], TargetStyle.prototype, "fill", 2);
__decorateClass2([
  Validate28(RATIO12)
], TargetStyle.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate28(COLOR_STRING7)
], TargetStyle.prototype, "stroke", 2);
__decorateClass2([
  Validate28(POSITIVE_NUMBER11)
], TargetStyle.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate28(RATIO12)
], TargetStyle.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate28(LINE_DASH6)
], TargetStyle.prototype, "lineDash", 2);
__decorateClass2([
  Validate28(POSITIVE_NUMBER11)
], TargetStyle.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate28(RATIO12)
], TargetStyle.prototype, "lengthRatio", 2);
var BulletScale = class extends BaseProperties7 {
};
__decorateClass2([
  Validate28(POSITIVE_NUMBER11, { optional: true })
], BulletScale.prototype, "max", 2);
var BulletColorRange = class extends BaseProperties7 {
  constructor() {
    super(...arguments);
    this.color = "lightgrey";
  }
};
__decorateClass2([
  Validate28(COLOR_STRING7)
], BulletColorRange.prototype, "color", 2);
__decorateClass2([
  Validate28(POSITIVE_NUMBER11, { optional: true })
], BulletColorRange.prototype, "stop", 2);
var BulletSeriesProperties = class extends AbstractBarSeriesProperties22 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.widthRatio = 0.5;
    this.colorRanges = new PropertiesArray22(BulletColorRange);
    this.target = new TargetStyle();
    this.scale = new BulletScale();
    this.tooltip = new SeriesTooltip22();
    this.backgroundFill = "white";
  }
};
__decorateClass2([
  Validate28(STRING8)
], BulletSeriesProperties.prototype, "valueKey", 2);
__decorateClass2([
  Validate28(STRING8, { optional: true })
], BulletSeriesProperties.prototype, "valueName", 2);
__decorateClass2([
  Validate28(STRING8, { optional: true })
], BulletSeriesProperties.prototype, "targetKey", 2);
__decorateClass2([
  Validate28(STRING8, { optional: true })
], BulletSeriesProperties.prototype, "targetName", 2);
__decorateClass2([
  Validate28(COLOR_STRING7)
], BulletSeriesProperties.prototype, "fill", 2);
__decorateClass2([
  Validate28(RATIO12)
], BulletSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate28(COLOR_STRING7)
], BulletSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate28(POSITIVE_NUMBER11)
], BulletSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate28(RATIO12)
], BulletSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate28(LINE_DASH6)
], BulletSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate28(POSITIVE_NUMBER11)
], BulletSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate28(RATIO12)
], BulletSeriesProperties.prototype, "widthRatio", 2);
__decorateClass2([
  Validate28(ARRAY3.restrict({ minLength: 0 }))
], BulletSeriesProperties.prototype, "colorRanges", 2);
__decorateClass2([
  Validate28(OBJECT6)
], BulletSeriesProperties.prototype, "target", 2);
__decorateClass2([
  Validate28(OBJECT6)
], BulletSeriesProperties.prototype, "scale", 2);
__decorateClass2([
  Validate28(OBJECT6)
], BulletSeriesProperties.prototype, "tooltip", 2);
__decorateClass2([
  Validate28(COLOR_STRING7)
], BulletSeriesProperties.prototype, "backgroundFill", 2);
var {
  animationValidation: animationValidation22,
  collapsedStartingBarPosition: collapsedStartingBarPosition2,
  diff: diff22,
  keyProperty: keyProperty22,
  partialAssign: partialAssign22,
  prepareBarAnimationFunctions: prepareBarAnimationFunctions2,
  resetBarSelectionsFn: resetBarSelectionsFn2,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation2,
  valueProperty: valueProperty3,
  createDatumId: createDatumId2,
  computeBarFocusBounds: computeBarFocusBounds22
} = import_ag_charts_community58._ModuleSupport;
var { fromToMotion: fromToMotion2 } = import_ag_charts_community58._Scene.motion;
var { sanitizeHtml: sanitizeHtml2 } = import_ag_charts_community58._Util;
var STYLING_KEYS = [
  "fill",
  "fillOpacity",
  "stroke",
  "strokeWidth",
  "strokeOpacity",
  "lineDash",
  "lineDashOffset"
];
var BulletSeries = class _BulletSeries extends import_ag_charts_community58._ModuleSupport.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: { y: ["targetKey", "valueKey"] },
      directionNames: { y: ["targetName", "valueName"] },
      pickModes: [import_ag_charts_community58._ModuleSupport.SeriesNodePickMode.EXACT_SHAPE_MATCH],
      hasHighlightedLabels: true,
      animationResetFns: {
        datum: resetBarSelectionsFn2
      }
    });
    this.properties = new BulletSeriesProperties();
    this.normalizedColorRanges = [];
    this.colorRangesGroup = new import_ag_charts_community58._Scene.Group({ name: `${this.id}-colorRanges` });
    this.colorRangesSelection = import_ag_charts_community58._Scene.Selection.select(this.colorRangesGroup, import_ag_charts_community58._Scene.Rect, false);
    this.rootGroup.append(this.colorRangesGroup);
    this.targetLinesSelection = import_ag_charts_community58._Scene.Selection.select(this.annotationGroup, import_ag_charts_community58._Scene.Line, false);
  }
  destroy() {
    this.rootGroup.removeChild(this.colorRangesGroup);
    super.destroy();
  }
  processData(dataController) {
    return __async2(this, null, function* () {
      var _a2, _b;
      if (!this.properties.isValid() || !this.data || !this.visible)
        return;
      const { valueKey, targetKey } = this.properties;
      const xScale = (_a2 = this.getCategoryAxis()) == null ? void 0 : _a2.scale;
      const yScale = (_b = this.getValueAxis()) == null ? void 0 : _b.scale;
      const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
      const extraProps = [];
      if (targetKey !== void 0) {
        extraProps.push(valueProperty3(targetKey, yScaleType, { id: "target" }));
      }
      if (!this.ctx.animationManager.isSkipped()) {
        if (this.processedData !== void 0) {
          extraProps.push(diff22(this.processedData));
        }
        extraProps.push(animationValidation22());
      }
      yield this.requestDataModel(dataController, this.data.slice(0, 1), {
        props: [
          keyProperty22(valueKey, xScaleType, { id: "xValue" }),
          valueProperty3(valueKey, yScaleType, { id: "value" }),
          ...extraProps
        ],
        groupByKeys: true
      });
      this.animationState.transition("updateData");
    });
  }
  getBandScalePadding() {
    return { inner: 0, outer: 0 };
  }
  getMaxValue() {
    var _a2, _b;
    return Math.max(...(_b = (_a2 = this.getValueAxis()) == null ? void 0 : _a2.dataDomain.domain) != null ? _b : [0]);
  }
  getSeriesDomain(direction) {
    var _a2, _b;
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return [];
    }
    const { valueKey, targetKey, valueName, scale: scale2 } = this.properties;
    if (direction === this.getCategoryDirection()) {
      return [valueName != null ? valueName : valueKey];
    }
    if (direction == ((_a2 = this.getValueAxis()) == null ? void 0 : _a2.direction)) {
      const valueDomain = dataModel.getDomain(this, "value", "value", processedData);
      const targetDomain = targetKey === void 0 ? [] : dataModel.getDomain(this, "target", "value", processedData);
      return [0, (_b = scale2.max) != null ? _b : Math.max(...valueDomain, ...targetDomain)];
    }
    throw new Error(`unknown direction ${direction}`);
  }
  getKeys(direction) {
    if (direction === this.getBarDirection()) {
      return [this.properties.valueKey];
    }
    return super.getKeys(direction);
  }
  createNodeData() {
    return __async2(this, null, function* () {
      var _a2, _b, _c, _d;
      const { dataModel, processedData } = this;
      const {
        valueKey,
        targetKey,
        widthRatio,
        target: { lengthRatio }
      } = this.properties;
      const xScale = (_a2 = this.getCategoryAxis()) == null ? void 0 : _a2.scale;
      const yScale = (_b = this.getValueAxis()) == null ? void 0 : _b.scale;
      if (!valueKey || !dataModel || !processedData || !xScale || !yScale)
        return;
      if (widthRatio === void 0 || lengthRatio === void 0)
        return;
      const multiplier = (_c = xScale.bandwidth) != null ? _c : NaN;
      const maxValue = this.getMaxValue();
      const valueIndex = dataModel.resolveProcessedDataIndexById(this, "value");
      const targetIndex = targetKey === void 0 ? NaN : dataModel.resolveProcessedDataIndexById(this, "target");
      const context = {
        itemId: valueKey,
        nodeData: [],
        labelData: [],
        scales: this.calculateScaling(),
        visible: this.visible
      };
      if (!this.visible)
        return context;
      for (const { datum, values } of processedData.data) {
        if (!Array.isArray(datum) || datum.length < 1) {
          continue;
        }
        if (values[0][valueIndex] < 0) {
          import_ag_charts_community58._Util.Logger.warnOnce("negative values are not supported, clipping to 0.");
        }
        const xValue = (_d = this.properties.valueName) != null ? _d : this.properties.valueKey;
        const yValue = Math.min(maxValue, Math.max(0, values[0][valueIndex]));
        const y = yScale.convert(yValue);
        const barWidth = widthRatio * multiplier;
        const bottomY = yScale.convert(0);
        const barAlongX = this.getBarDirection() === import_ag_charts_community58._ModuleSupport.ChartAxisDirection.X;
        const rect = {
          x: multiplier * (1 - widthRatio) / 2,
          y: Math.min(y, bottomY),
          width: barWidth,
          height: Math.abs(bottomY - y)
        };
        if (barAlongX) {
          [rect.x, rect.y, rect.width, rect.height] = [rect.y, rect.x, rect.height, rect.width];
        }
        let target;
        if (values[0][targetIndex] < 0) {
          import_ag_charts_community58._Util.Logger.warnOnce("negative targets are not supported, ignoring.");
        }
        if (this.properties.targetKey && values[0][targetIndex] >= 0) {
          const targetLineLength = lengthRatio * multiplier;
          const targetValue = Math.min(maxValue, values[0][targetIndex]);
          if (!isNaN(targetValue) && targetValue !== void 0) {
            const convertedY = yScale.convert(targetValue);
            let x1 = multiplier * (1 - lengthRatio) / 2;
            let x2 = x1 + targetLineLength;
            let [y1, y2] = [convertedY, convertedY];
            if (barAlongX) {
              [x1, x2, y1, y2] = [y1, y2, x1, x2];
            }
            target = { value: targetValue, x1, x2, y1, y2 };
          }
        }
        const nodeData = __spreadProps2(__spreadValues2({
          series: this,
          datum: datum[0],
          xKey: valueKey,
          xValue,
          yKey: valueKey,
          yValue,
          cumulativeValue: yValue,
          target
        }, rect), {
          midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },
          opacity: 1
        });
        context.nodeData.push(nodeData);
      }
      const sortedRanges = [...this.getColorRanges()].sort((a, b) => {
        var _a3, _b2;
        return ((_a3 = a.stop) != null ? _a3 : maxValue) - ((_b2 = b.stop) != null ? _b2 : maxValue);
      });
      let start = 0;
      this.normalizedColorRanges = sortedRanges.map((item) => {
        var _a3;
        const stop = Math.min(maxValue, (_a3 = item.stop) != null ? _a3 : Infinity);
        const result = { color: item.color, start, stop };
        start = stop;
        return result;
      });
      return context;
    });
  }
  getColorRanges() {
    const { colorRanges, fill, backgroundFill } = this.properties;
    if (colorRanges !== void 0 && colorRanges.length > 0) {
      return colorRanges;
    }
    const defaultColorRange = new BulletColorRange();
    defaultColorRange.color = import_ag_charts_community58._Util.Color.interpolate(fill, backgroundFill)(0.7);
    return [defaultColorRange];
  }
  getLegendData(_legendType) {
    return [];
  }
  getTooltipHtml(nodeDatum) {
    const { valueKey, valueName, targetKey, targetName } = this.properties;
    const axis = this.getValueAxis();
    const { yValue: valueValue, target: { value: targetValue } = { value: void 0 }, datum, itemId } = nodeDatum;
    if (valueKey === void 0 || valueValue === void 0 || axis === void 0) {
      return import_ag_charts_community58._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const makeLine = (key, name, value) => {
      const nameString = sanitizeHtml2(name != null ? name : key);
      const valueString = sanitizeHtml2(axis.formatDatum(value));
      return `<b>${nameString}</b>: ${valueString}`;
    };
    const title = void 0;
    const content = targetKey === void 0 || targetValue === void 0 ? makeLine(valueKey, valueName, valueValue) : `${makeLine(valueKey, valueName, valueValue)}<br/>${makeLine(targetKey, targetName, targetValue)}`;
    return this.properties.tooltip.toTooltipHtml(
      { title, content, backgroundColor: this.properties.fill },
      { datum, itemId, title, seriesId: this.id, valueKey, valueName, targetKey, targetName, color: void 0 }
    );
  }
  isLabelEnabled() {
    return false;
  }
  nodeFactory() {
    return new import_ag_charts_community58._Scene.Rect();
  }
  updateDatumSelection(opts) {
    return __async2(this, null, function* () {
      this.targetLinesSelection.update(opts.nodeData, void 0, void 0);
      return opts.datumSelection.update(opts.nodeData, void 0, void 0);
    });
  }
  updateDatumNodes(opts) {
    return __async2(this, null, function* () {
      for (const { node } of opts.datumSelection) {
        const style = this.properties;
        partialAssign22(STYLING_KEYS, node, style);
      }
      for (const { node, datum } of this.targetLinesSelection) {
        if (datum.target === void 0) {
          node.visible = false;
        } else {
          const style = this.properties.target;
          partialAssign22(["x1", "x2", "y1", "y2"], node, datum.target);
          partialAssign22(STYLING_KEYS, node, style);
        }
      }
    });
  }
  updateColorRanges() {
    return __async2(this, null, function* () {
      const valAxis = this.getValueAxis();
      const catAxis = this.getCategoryAxis();
      if (!valAxis || !catAxis)
        return;
      const [min, max] = [0, Math.max(...catAxis.scale.range)];
      const computeRect = this.getBarDirection() === import_ag_charts_community58._ModuleSupport.ChartAxisDirection.Y ? (rect, colorRange) => {
        rect.x = min;
        rect.y = valAxis.scale.convert(colorRange.stop);
        rect.height = valAxis.scale.convert(colorRange.start) - rect.y;
        rect.width = max;
      } : (rect, colorRange) => {
        rect.x = valAxis.scale.convert(colorRange.start);
        rect.y = min;
        rect.height = max;
        rect.width = valAxis.scale.convert(colorRange.stop) - rect.x;
      };
      this.colorRangesSelection.update(this.normalizedColorRanges);
      for (const { node, datum } of this.colorRangesSelection) {
        computeRect(node, datum);
        node.fill = datum.color;
      }
    });
  }
  updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {
    return __async2(this, null, function* () {
      yield __superGet2(_BulletSeries.prototype, this, "updateNodes").call(this, highlightedItems, seriesHighlighted, anySeriesItemEnabled);
      yield this.updateColorRanges();
    });
  }
  updateLabelSelection(opts) {
    return __async2(this, null, function* () {
      return opts.labelSelection;
    });
  }
  updateLabelNodes(_opts) {
    return __async2(this, null, function* () {
    });
  }
  animateEmptyUpdateReady(data) {
    const { datumSelection, annotationSelections } = data;
    const fns = prepareBarAnimationFunctions2(collapsedStartingBarPosition2(this.isVertical(), this.axes, "normal"));
    fromToMotion2(this.id, "nodes", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation2(this, "annotations", this.ctx.animationManager, ...annotationSelections);
  }
  animateWaitingUpdateReady(data) {
    var _a2, _b, _c;
    const { datumSelection, annotationSelections } = data;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const dataDiff = (_b = (_a2 = this.processedData) == null ? void 0 : _a2.reduced) == null ? void 0 : _b.diff;
    const fns = prepareBarAnimationFunctions2(collapsedStartingBarPosition2(this.isVertical(), this.axes, "normal"));
    fromToMotion2(
      this.id,
      "nodes",
      this.ctx.animationManager,
      [datumSelection],
      fns,
      (_, datum) => createDatumId2(datum.xValue),
      dataDiff
    );
    const hasMotion = (_c = dataDiff == null ? void 0 : dataDiff.changed) != null ? _c : true;
    if (hasMotion) {
      seriesLabelFadeInAnimation2(this, "annotations", this.ctx.animationManager, ...annotationSelections);
    }
  }
  computeFocusBounds({ datumIndex, seriesRect }) {
    var _a2;
    return computeBarFocusBounds22((_a2 = this.contextNodeData) == null ? void 0 : _a2.nodeData[datumIndex], this.contentGroup, seriesRect);
  }
};
var import_ag_charts_community59 = (init_main(), __toCommonJS(main_exports));
var BULLET_SERIES_THEME = {
  series: {
    direction: "vertical",
    strokeWidth: 0,
    strokeOpacity: 1,
    fillOpacity: 1,
    widthRatio: 0.5,
    target: {
      strokeWidth: 3,
      strokeOpacity: 1,
      lengthRatio: 0.75
    }
  },
  axes: {
    [import_ag_charts_community59._Theme.CARTESIAN_AXIS_TYPE.NUMBER]: {
      nice: false,
      crosshair: {
        enabled: false
      }
    }
  }
};
var BulletModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "bullet",
  solo: true,
  instanceConstructor: BulletSeries,
  defaultAxes: [
    {
      type: import_ag_charts_community60._Theme.CARTESIAN_AXIS_TYPE.NUMBER,
      position: import_ag_charts_community60._Theme.POSITION.LEFT
    },
    {
      type: import_ag_charts_community60._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: import_ag_charts_community60._Theme.POSITION.BOTTOM
    }
  ],
  themeTemplate: BULLET_SERIES_THEME,
  swapDefaultAxesCondition: (series) => (series == null ? void 0 : series.direction) === "horizontal",
  paletteFactory: ({ takeColors, colorsCount, themeTemplateParameters }) => {
    var _a2;
    const { properties } = themeTemplateParameters;
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(colorsCount);
    const themeBackgroundColor = themeTemplateParameters.properties.get(import_ag_charts_community60._Theme.DEFAULT_BACKGROUND_COLOUR);
    const backgroundFill = (_a2 = Array.isArray(themeBackgroundColor) ? themeBackgroundColor[0] : themeBackgroundColor) != null ? _a2 : "white";
    const targetStroke = properties.get(import_ag_charts_community60._Theme.DEFAULT_CROSS_LINES_COLOUR);
    return {
      fill,
      stroke,
      target: { stroke: targetStroke },
      backgroundFill
    };
  }
};
var import_ag_charts_community67 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community65 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community61 = (init_main(), __toCommonJS(main_exports));
var { SceneChangeDetection: SceneChangeDetection2, BBox: BBox7, RedrawType: RedrawType2 } = import_ag_charts_community61._Scene;
var CandlestickBaseGroup = class extends import_ag_charts_community61._Scene.Group {
  constructor() {
    super(...arguments);
    this.x = 0;
    this.y = 0;
    this.yBottom = 0;
    this.yHigh = 0;
    this.yLow = 0;
    this.width = 0;
    this.height = 0;
  }
  distanceSquared(x, y) {
    const nodes = import_ag_charts_community61._Scene.Selection.selectByClass(this, import_ag_charts_community61._Scene.Rect, import_ag_charts_community61._Scene.Line);
    return import_ag_charts_community61._Scene.nearestSquared(x, y, nodes).distanceSquared;
  }
  get midPoint() {
    const datum = this.datum;
    if (datum.midPoint === void 0) {
      import_ag_charts_community61._Util.Logger.error("CandlestickBaseGroup.datum.midPoint is undefined");
      return { x: NaN, y: NaN };
    }
    return datum.midPoint;
  }
  render(renderCtx) {
    this.updateCoordinates();
    super.render(renderCtx);
  }
};
__decorateClass2([
  SceneChangeDetection2({ redraw: RedrawType2.MAJOR })
], CandlestickBaseGroup.prototype, "x", 2);
__decorateClass2([
  SceneChangeDetection2({ redraw: RedrawType2.MAJOR })
], CandlestickBaseGroup.prototype, "y", 2);
__decorateClass2([
  SceneChangeDetection2({ redraw: RedrawType2.MAJOR })
], CandlestickBaseGroup.prototype, "yBottom", 2);
__decorateClass2([
  SceneChangeDetection2({ redraw: RedrawType2.MAJOR })
], CandlestickBaseGroup.prototype, "yHigh", 2);
__decorateClass2([
  SceneChangeDetection2({ redraw: RedrawType2.MAJOR })
], CandlestickBaseGroup.prototype, "yLow", 2);
__decorateClass2([
  SceneChangeDetection2({ redraw: RedrawType2.MAJOR })
], CandlestickBaseGroup.prototype, "width", 2);
__decorateClass2([
  SceneChangeDetection2({ redraw: RedrawType2.MAJOR })
], CandlestickBaseGroup.prototype, "height", 2);
var CandlestickGroup = class extends CandlestickBaseGroup {
  constructor() {
    super();
    this.append([
      new import_ag_charts_community61._Scene.Rect({
        tag: 0
        /* Body */
      }),
      new import_ag_charts_community61._Scene.Line({
        tag: 1
        /* LowWick */
      }),
      new import_ag_charts_community61._Scene.Line({
        tag: 2
        /* HighWick */
      })
    ]);
  }
  updateCoordinates() {
    const { x, y, yBottom, yHigh, yLow, width, height } = this;
    const selection = import_ag_charts_community61._Scene.Selection.select(this, import_ag_charts_community61._Scene.Rect);
    const [body] = selection.selectByTag(
      0
      /* Body */
    );
    const [lowWick] = selection.selectByTag(
      1
      /* LowWick */
    );
    const [highWick] = selection.selectByTag(
      2
      /* HighWick */
    );
    if (width === 0 || height === 0) {
      body.visible = false;
      lowWick.visible = false;
      highWick.visible = false;
      return;
    }
    body.visible = true;
    lowWick.visible = true;
    highWick.visible = true;
    body.setProperties({
      x,
      y,
      width,
      height,
      crisp: true,
      clipBBox: new BBox7(x, y, width, height)
    });
    const halfWidth = width / 2;
    lowWick.setProperties({
      y1: Math.round(yLow + lowWick.strokeWidth / 2),
      y2: yBottom,
      x: x + halfWidth
    });
    highWick.setProperties({
      y1: Math.round(yHigh + highWick.strokeWidth / 2),
      y2: y,
      x: x + halfWidth
    });
  }
  updateDatumStyles(datum, activeStyles) {
    var _a2;
    const { bandwidth } = datum;
    const {
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      wick: wickStyles = {},
      cornerRadius
    } = activeStyles;
    (_a2 = wickStyles.strokeWidth) != null ? _a2 : wickStyles.strokeWidth = 1;
    const selection = import_ag_charts_community61._Scene.Selection.select(this, import_ag_charts_community61._Scene.Rect);
    const [body] = selection.selectByTag(
      0
      /* Body */
    );
    const [lowWick] = selection.selectByTag(
      1
      /* LowWick */
    );
    const [highWick] = selection.selectByTag(
      2
      /* HighWick */
    );
    if (wickStyles.strokeWidth > bandwidth) {
      wickStyles.strokeWidth = bandwidth;
    }
    body.setProperties({
      fill,
      fillOpacity,
      strokeWidth,
      strokeOpacity,
      stroke,
      lineDash,
      lineDashOffset,
      cornerRadius
    });
    lowWick.setProperties(wickStyles);
    highWick.setProperties(wickStyles);
  }
};
var import_ag_charts_community63 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community62 = (init_main(), __toCommonJS(main_exports));
var { computeBarFocusBounds: computeBarFocusBounds3, NODE_UPDATE_STATE_TO_PHASE_MAPPING: NODE_UPDATE_STATE_TO_PHASE_MAPPING2 } = import_ag_charts_community62._ModuleSupport;
function resetCandlestickSelectionsFn(_node, datum) {
  return getCoordinates(datum);
}
function prepareCandlestickAnimationFunctions(initial) {
  const fromFn = (candlestickGroup, datum, status) => {
    const phase = initial ? "initial" : NODE_UPDATE_STATE_TO_PHASE_MAPPING2[status];
    if (status === "unknown" || status === "added" && datum != null) {
      const { x, y, yLow, yHigh, width, height } = getCoordinates(datum);
      let collapsedY = datum.itemId === "up" ? yLow : yHigh;
      if (status === "unknown") {
        collapsedY = y + height / 2;
      }
      return {
        x,
        y: collapsedY,
        yBottom: collapsedY,
        yHigh: collapsedY,
        yLow: collapsedY,
        width,
        height: 0,
        phase
      };
    }
    return {
      x: candlestickGroup.x,
      y: candlestickGroup.y,
      yBottom: candlestickGroup.yBottom,
      yHigh: candlestickGroup.yHigh,
      yLow: candlestickGroup.yLow,
      width: candlestickGroup.width,
      height: candlestickGroup.height,
      phase
    };
  };
  const toFn = (_, datum, status) => {
    if (status === "removed") {
      const { x, yLow, yHigh, width } = getCoordinates(datum);
      const collapsedY = datum.itemId === "up" ? yLow : yHigh;
      return { x, y: collapsedY, yBottom: collapsedY, yHigh: collapsedY, yLow: collapsedY, width, height: 0 };
    }
    return getCoordinates(datum);
  };
  return { toFn, fromFn };
}
function getCoordinates(datum) {
  const {
    bandwidth,
    scaledValues: { xValue: x, openValue, closeValue, highValue, lowValue }
  } = datum;
  const y = Math.min(openValue, closeValue);
  const yBottom = isNaN(openValue) ? closeValue : Math.max(openValue, closeValue);
  const yHigh = Math.min(highValue, lowValue);
  const yLow = Math.max(highValue, lowValue);
  return {
    x,
    y,
    yBottom,
    yHigh,
    yLow,
    width: bandwidth,
    height: Math.max(yBottom - y, 1e-3)
    // This is to differentiate between animation setting height 0 and data values resulting in height 0
  };
}
function computeCandleFocusBounds(series, opts) {
  var _a2;
  const candleDatum = (_a2 = series.getNodeData()) == null ? void 0 : _a2.at(opts.datumIndex);
  const datum = !candleDatum ? void 0 : {
    x: candleDatum.scaledValues.xValue,
    y: candleDatum.scaledValues.highValue,
    width: candleDatum.bandwidth,
    height: candleDatum.scaledValues.lowValue - candleDatum.scaledValues.highValue
  };
  return computeBarFocusBounds3(datum, series.contentGroup, opts.seriesRect);
}
var { motion: motion22 } = import_ag_charts_community63._Scene;
var {
  extent: extent22,
  fixNumericExtent: fixNumericExtent3,
  keyProperty: keyProperty3,
  SeriesNodePickMode: SeriesNodePickMode22,
  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL22,
  valueProperty: valueProperty4,
  diff: diff3,
  animationValidation: animationValidation3,
  convertValuesToScaleByDefs: convertValuesToScaleByDefs22,
  mergeDefaults: mergeDefaults5,
  isFiniteNumber: isFiniteNumber4
} = import_ag_charts_community63._ModuleSupport;
var { sanitizeHtml: sanitizeHtml22, Logger: Logger4 } = import_ag_charts_community63._Util;
var { ContinuousScale: ContinuousScale22 } = import_ag_charts_community63._Scale;
var CandlestickSeriesNodeEvent = class extends import_ag_charts_community63._ModuleSupport.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.openKey = series.properties.openKey;
    this.closeKey = series.properties.closeKey;
    this.highKey = series.properties.highKey;
    this.lowKey = series.properties.lowKey;
  }
};
var CandlestickSeriesBase = class extends import_ag_charts_community63._ModuleSupport.AbstractBarSeries {
  constructor(moduleCtx, datumAnimationResetFnc) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode22.NEAREST_BY_MAIN_AXIS_FIRST, SeriesNodePickMode22.EXACT_SHAPE_MATCH],
      directionKeys: {
        x: ["xKey"],
        y: ["lowKey", "highKey", "openKey", "closeKey"]
      },
      directionNames: {
        x: ["xName"],
        y: ["lowName", "highName", "openName", "closeName"]
      },
      pathsPerSeries: 1,
      datumSelectionGarbageCollection: false,
      animationAlwaysUpdateSelections: true,
      animationResetFns: {
        datum: datumAnimationResetFnc
      }
    });
    this.NodeEvent = CandlestickSeriesNodeEvent;
  }
  animateEmptyUpdateReady({
    datumSelection
  }) {
    const animationFns = prepareCandlestickAnimationFunctions(true);
    motion22.fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], animationFns);
  }
  animateWaitingUpdateReady({
    datumSelection
  }) {
    var _a2;
    const { processedData } = this;
    const difference = (_a2 = processedData == null ? void 0 : processedData.reduced) == null ? void 0 : _a2.diff;
    const animationFns = prepareCandlestickAnimationFunctions(false);
    motion22.fromToMotion(
      this.id,
      "datums",
      this.ctx.animationManager,
      [datumSelection],
      animationFns,
      (_, datum) => String(datum.xValue),
      difference
    );
  }
  processData(dataController) {
    return __async2(this, null, function* () {
      var _a2, _b, _c;
      if (!this.properties.isValid() || !this.visible)
        return;
      const { xKey, openKey, closeKey, highKey, lowKey } = this.properties;
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      const xScale = (_a2 = this.getCategoryAxis()) == null ? void 0 : _a2.scale;
      const yScale = (_b = this.getValueAxis()) == null ? void 0 : _b.scale;
      const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
      const extraProps = [];
      if (animationEnabled) {
        if (this.processedData) {
          extraProps.push(diff3(this.processedData));
        }
        extraProps.push(animationValidation3());
      }
      if (openKey) {
        extraProps.push(
          valueProperty4(openKey, yScaleType, {
            id: `openValue`,
            invalidValue: void 0,
            missingValue: void 0
          })
        );
      }
      const { processedData } = yield this.requestDataModel(dataController, this.data, {
        props: [
          keyProperty3(xKey, xScaleType, { id: `xValue` }),
          valueProperty4(closeKey, yScaleType, { id: `closeValue` }),
          valueProperty4(highKey, yScaleType, { id: `highValue` }),
          valueProperty4(lowKey, yScaleType, { id: `lowValue` }),
          ...isContinuousX ? [SMALLEST_KEY_INTERVAL22] : [],
          ...extraProps
        ]
      });
      this.smallestDataInterval = (_c = processedData.reduced) == null ? void 0 : _c.smallestKeyInterval;
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    var _a2;
    const { processedData, dataModel, smallestDataInterval } = this;
    if (!(processedData && dataModel))
      return [];
    const { openKey } = this.properties;
    if (direction === this.getBarDirection()) {
      const lowValues = dataModel.getDomain(this, `lowValue`, "value", processedData);
      const highValues = dataModel.getDomain(this, `highValue`, "value", processedData);
      const openValues = openKey ? dataModel.getDomain(this, `openValue`, "value", processedData) : [];
      const closeValues = dataModel.getDomain(this, `closeValue`, "value", processedData);
      return fixNumericExtent3(
        [
          Math.min(...lowValues, ...highValues, ...openValues, ...closeValues),
          Math.max(...highValues, ...lowValues, ...openValues, ...closeValues)
        ],
        this.getValueAxis()
      );
    }
    const { index, def } = dataModel.resolveProcessedDataDefById(this, `xValue`);
    const keys = processedData.domain.keys[index];
    if (def.type === "key" && def.valueType === "category") {
      return keys;
    }
    const categoryAxis = this.getCategoryAxis();
    const keysExtent = (_a2 = extent22(keys)) != null ? _a2 : [NaN, NaN];
    const scalePadding = isFiniteNumber4(smallestDataInterval) ? smallestDataInterval : 0;
    const d0 = keysExtent[0] + -scalePadding;
    const d1 = keysExtent[1] + scalePadding;
    return fixNumericExtent3([d0, d1], categoryAxis);
  }
  createBaseNodeData() {
    const { visible, dataModel } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!(dataModel && xAxis && yAxis)) {
      return;
    }
    const { xKey, openKey, closeKey, highKey, lowKey } = this.properties;
    const nodeData = [];
    const ids = ["xValue", "closeValue", "highValue", "lowValue"];
    if (openKey) {
      ids.push("openValue");
    }
    const defs = dataModel.resolveProcessedDataDefsByIds(this, ids);
    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);
    const barOffset = ContinuousScale22.is(xAxis.scale) ? barWidth * -0.5 : 0;
    const { groupScale, processedData } = this;
    const context = {
      itemId: xKey,
      nodeData,
      labelData: [],
      scales: this.calculateScaling(),
      visible: this.visible
    };
    if (!visible)
      return context;
    processedData == null ? void 0 : processedData.data.forEach(({ datum, keys, values }) => {
      const { xValue, openValue, closeValue, highValue, lowValue } = dataModel.resolveProcessedDataDefsValues(
        defs,
        { keys, values }
      );
      const hasOpenValue = openValue !== void 0;
      const validLowValue = lowValue !== void 0 && (!hasOpenValue || lowValue <= openValue) && lowValue <= closeValue;
      const validHighValue = highValue !== void 0 && (!hasOpenValue || highValue >= openValue) && highValue >= closeValue;
      if (!validLowValue) {
        Logger4.warnOnce(
          `invalid low value for key [${lowKey}] in data element, low value cannot be higher than datum open or close values`
        );
        return;
      }
      if (!validHighValue) {
        Logger4.warnOnce(
          `invalid high value for key [${highKey}] in data element, high value cannot be lower than datum open or close values.`
        );
        return;
      }
      const scaledValues = convertValuesToScaleByDefs22({
        defs,
        values: {
          xValue,
          openValue,
          closeValue,
          highValue,
          lowValue
        },
        xAxis,
        yAxis
      });
      scaledValues.xValue += Math.round(groupScale.convert(String(groupIndex))) + barOffset;
      const isRising = !hasOpenValue || closeValue > openValue;
      const itemId = this.getSeriesItemType(isRising);
      const [y1, y2] = hasOpenValue ? [scaledValues.openValue, scaledValues.closeValue] : [scaledValues.lowValue, scaledValues.highValue];
      const y = Math.min(y1, y2);
      const yBottom = Math.max(y1, y2);
      const height = yBottom - y;
      const midPoint = {
        x: scaledValues.xValue + Math.round(barWidth) / 2,
        y: y + height / 2
      };
      nodeData.push({
        series: this,
        itemId,
        datum,
        xKey,
        xValue,
        openKey,
        closeKey,
        highKey,
        lowKey,
        openValue,
        closeValue,
        highValue,
        lowValue,
        bandwidth: Math.round(barWidth),
        scaledValues,
        midPoint,
        aggregatedValue: closeValue
      });
    });
    return context;
  }
  getSeriesItemType(isRising) {
    return isRising ? "up" : "down";
  }
  getItemConfig(seriesItemType) {
    return this.properties.item[seriesItemType];
  }
  getLegendData(_legendType) {
    return [];
  }
  getTooltipHtml(nodeDatum) {
    const {
      xKey,
      openKey,
      closeKey,
      highKey,
      lowKey,
      xName,
      yName,
      openName,
      closeName,
      highName,
      lowName,
      tooltip
    } = this.properties;
    const { datum, itemId } = nodeDatum;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!xAxis || !yAxis || !this.properties.isValid())
      return import_ag_charts_community63._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    const capitalise = (text) => text.charAt(0).toUpperCase() + text.substring(1);
    const title = sanitizeHtml22(yName);
    const contentData = [
      [xKey, xName, xAxis],
      [highKey, highName, yAxis],
      [lowKey, lowName, yAxis],
      [closeKey, closeName, yAxis]
    ];
    if (openKey) {
      contentData.splice(1, 0, [openKey, openName, yAxis]);
    }
    const content = contentData.map(([key, name, axis]) => sanitizeHtml22(`${name != null ? name : capitalise(key)}: ${axis.formatDatum(datum[key])}`)).join("<br/>");
    const styles = this.getFormattedStyles(nodeDatum);
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: styles.stroke },
      __spreadProps2(__spreadValues2({
        seriesId: this.id,
        datum
      }, styles), {
        xKey,
        openKey: openKey != null ? openKey : "",
        closeKey,
        highKey,
        lowKey,
        xName,
        yName,
        openName,
        closeName,
        highName,
        lowName,
        title,
        color: styles.fill,
        fill: styles.fill,
        itemId
      })
    );
  }
  isVertical() {
    return true;
  }
  isLabelEnabled() {
    return false;
  }
  updateDatumSelection(opts) {
    return __async2(this, null, function* () {
      var _a2;
      const data = (_a2 = opts.nodeData) != null ? _a2 : [];
      return opts.datumSelection.update(data);
    });
  }
  updateDatumNodes(_0) {
    return __async2(this, arguments, function* ({
      datumSelection,
      isHighlight: highlighted
    }) {
      datumSelection.each((group2, nodeDatum) => {
        const activeStyles = this.getActiveStyles(nodeDatum, highlighted);
        group2.updateDatumStyles(nodeDatum, activeStyles);
      });
    });
  }
  updateLabelNodes(_opts) {
    return __async2(this, null, function* () {
    });
  }
  updateLabelSelection(opts) {
    return __async2(this, null, function* () {
      const { labelData, labelSelection } = opts;
      return labelSelection.update(labelData);
    });
  }
  getFormattedStyles(nodeDatum, highlighted = false) {
    const {
      id: seriesId,
      ctx: { callbackCache }
    } = this;
    const { xKey, openKey = "", closeKey, highKey, lowKey, formatter } = this.properties;
    if (formatter) {
      const formatStyles = callbackCache.call(
        formatter,
        this.getFormatterParams(__spreadProps2(__spreadValues2({}, nodeDatum), {
          seriesId,
          highlighted,
          xKey,
          openKey,
          closeKey,
          highKey,
          lowKey
        }))
      );
      if (formatStyles) {
        return mergeDefaults5(formatStyles, this.getSeriesStyles(nodeDatum));
      }
    }
    return this.getSeriesStyles(nodeDatum);
  }
};
var import_ag_charts_community64 = (init_main(), __toCommonJS(main_exports));
var {
  BaseProperties: BaseProperties8,
  AbstractBarSeriesProperties: AbstractBarSeriesProperties3,
  SeriesTooltip: SeriesTooltip3,
  Validate: Validate29,
  COLOR_STRING: COLOR_STRING8,
  FUNCTION: FUNCTION5,
  LINE_DASH: LINE_DASH7,
  OBJECT: OBJECT7,
  POSITIVE_NUMBER: POSITIVE_NUMBER12,
  RATIO: RATIO13,
  STRING: STRING9
} = import_ag_charts_community64._ModuleSupport;
var CandlestickSeriesWick = class extends BaseProperties8 {
};
__decorateClass2([
  Validate29(COLOR_STRING8, { optional: true })
], CandlestickSeriesWick.prototype, "stroke", 2);
__decorateClass2([
  Validate29(POSITIVE_NUMBER12)
], CandlestickSeriesWick.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate29(RATIO13)
], CandlestickSeriesWick.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate29(LINE_DASH7, { optional: true })
], CandlestickSeriesWick.prototype, "lineDash", 2);
__decorateClass2([
  Validate29(POSITIVE_NUMBER12)
], CandlestickSeriesWick.prototype, "lineDashOffset", 2);
var CandlestickSeriesItem = class extends BaseProperties8 {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.fillOpacity = 1;
    this.stroke = "#333";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.wick = new CandlestickSeriesWick();
  }
};
__decorateClass2([
  Validate29(COLOR_STRING8, { optional: true })
], CandlestickSeriesItem.prototype, "fill", 2);
__decorateClass2([
  Validate29(RATIO13)
], CandlestickSeriesItem.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate29(COLOR_STRING8)
], CandlestickSeriesItem.prototype, "stroke", 2);
__decorateClass2([
  Validate29(POSITIVE_NUMBER12)
], CandlestickSeriesItem.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate29(RATIO13)
], CandlestickSeriesItem.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate29(LINE_DASH7)
], CandlestickSeriesItem.prototype, "lineDash", 2);
__decorateClass2([
  Validate29(POSITIVE_NUMBER12)
], CandlestickSeriesItem.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate29(POSITIVE_NUMBER12)
], CandlestickSeriesItem.prototype, "cornerRadius", 2);
__decorateClass2([
  Validate29(FUNCTION5, { optional: true })
], CandlestickSeriesItem.prototype, "formatter", 2);
__decorateClass2([
  Validate29(OBJECT7)
], CandlestickSeriesItem.prototype, "wick", 2);
var CandlestickSeriesItems = class extends BaseProperties8 {
  constructor() {
    super(...arguments);
    this.up = new CandlestickSeriesItem();
    this.down = new CandlestickSeriesItem();
  }
};
__decorateClass2([
  Validate29(OBJECT7)
], CandlestickSeriesItems.prototype, "up", 2);
__decorateClass2([
  Validate29(OBJECT7)
], CandlestickSeriesItems.prototype, "down", 2);
var CandlestickSeriesBaseProperties = class extends AbstractBarSeriesProperties3 {
  constructor(item, formatter) {
    super();
    this.tooltip = new SeriesTooltip3();
    this.item = item;
    this.formatter = formatter;
  }
};
__decorateClass2([
  Validate29(STRING9)
], CandlestickSeriesBaseProperties.prototype, "xKey", 2);
__decorateClass2([
  Validate29(STRING9)
], CandlestickSeriesBaseProperties.prototype, "openKey", 2);
__decorateClass2([
  Validate29(STRING9)
], CandlestickSeriesBaseProperties.prototype, "closeKey", 2);
__decorateClass2([
  Validate29(STRING9)
], CandlestickSeriesBaseProperties.prototype, "highKey", 2);
__decorateClass2([
  Validate29(STRING9)
], CandlestickSeriesBaseProperties.prototype, "lowKey", 2);
__decorateClass2([
  Validate29(STRING9, { optional: true })
], CandlestickSeriesBaseProperties.prototype, "xName", 2);
__decorateClass2([
  Validate29(STRING9, { optional: true })
], CandlestickSeriesBaseProperties.prototype, "yName", 2);
__decorateClass2([
  Validate29(STRING9, { optional: true })
], CandlestickSeriesBaseProperties.prototype, "openName", 2);
__decorateClass2([
  Validate29(STRING9, { optional: true })
], CandlestickSeriesBaseProperties.prototype, "closeName", 2);
__decorateClass2([
  Validate29(STRING9, { optional: true })
], CandlestickSeriesBaseProperties.prototype, "highName", 2);
__decorateClass2([
  Validate29(STRING9, { optional: true })
], CandlestickSeriesBaseProperties.prototype, "lowName", 2);
__decorateClass2([
  Validate29(OBJECT7)
], CandlestickSeriesBaseProperties.prototype, "tooltip", 2);
__decorateClass2([
  Validate29(OBJECT7)
], CandlestickSeriesBaseProperties.prototype, "item", 2);
__decorateClass2([
  Validate29(FUNCTION5, { optional: true })
], CandlestickSeriesBaseProperties.prototype, "formatter", 2);
var CandlestickSeriesProperties = class extends CandlestickSeriesBaseProperties {
  constructor() {
    super(new CandlestickSeriesItems());
  }
};
__decorateClass2([
  Validate29(STRING9)
], CandlestickSeriesProperties.prototype, "openKey", 2);
var { extractDecoratedProperties: extractDecoratedProperties22, mergeDefaults: mergeDefaults6 } = import_ag_charts_community65._ModuleSupport;
var CandlestickSeries = class extends CandlestickSeriesBase {
  constructor(moduleCtx) {
    super(moduleCtx, resetCandlestickSelectionsFn);
    this.properties = new CandlestickSeriesProperties();
  }
  createNodeData() {
    return __async2(this, null, function* () {
      const baseNodeData = this.createBaseNodeData();
      if (!baseNodeData) {
        return;
      }
      const nodeData = baseNodeData.nodeData.map((datum) => {
        const {
          fill,
          fillOpacity,
          stroke,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset,
          wick,
          cornerRadius
        } = this.getItemConfig(datum.itemId);
        return __spreadProps2(__spreadValues2({}, datum), {
          fill,
          fillOpacity,
          stroke,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset,
          wick,
          cornerRadius
        });
      });
      return __spreadProps2(__spreadValues2({}, baseNodeData), { nodeData });
    });
  }
  nodeFactory() {
    return new CandlestickGroup();
  }
  getSeriesStyles(nodeDatum) {
    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, wick, cornerRadius } = nodeDatum;
    return {
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset,
      wick: extractDecoratedProperties22(wick),
      cornerRadius
    };
  }
  getActiveStyles(nodeDatum, highlighted) {
    let activeStyles = this.getFormattedStyles(nodeDatum, highlighted);
    if (highlighted) {
      activeStyles = mergeDefaults6(this.properties.highlightStyle.item, activeStyles);
    }
    const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = activeStyles;
    activeStyles.wick = mergeDefaults6(activeStyles.wick, {
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    });
    return activeStyles;
  }
  getFormatterParams(params) {
    return params;
  }
  computeFocusBounds(opts) {
    return computeCandleFocusBounds(this, opts);
  }
};
CandlestickSeries.className = "CandleStickSeries";
CandlestickSeries.type = "candlestick";
var import_ag_charts_community66 = (init_main(), __toCommonJS(main_exports));
var CANDLESTICK_SERIES_THEME = {
  series: {
    __extends__: import_ag_charts_community66._Theme.EXTENDS_SERIES_DEFAULTS,
    highlightStyle: {
      item: {
        strokeWidth: 3
      }
    },
    direction: "vertical"
  },
  animation: { enabled: false },
  axes: {
    [import_ag_charts_community66._Theme.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: {
        snap: false
      }
    },
    [import_ag_charts_community66._Theme.CARTESIAN_AXIS_TYPE.ORDINAL_TIME]: {
      groupPaddingInner: 0,
      crosshair: {
        enabled: true
      }
    }
  }
};
var CandlestickModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "candlestick",
  instanceConstructor: CandlestickSeries,
  defaultAxes: [
    {
      type: import_ag_charts_community67._Theme.CARTESIAN_AXIS_TYPE.NUMBER,
      position: import_ag_charts_community67._Theme.POSITION.LEFT
    },
    {
      type: import_ag_charts_community67._Theme.CARTESIAN_AXIS_TYPE.ORDINAL_TIME,
      position: import_ag_charts_community67._Theme.POSITION.BOTTOM
    }
  ],
  themeTemplate: CANDLESTICK_SERIES_THEME,
  groupable: false,
  paletteFactory: ({ takeColors, colorsCount, userPalette, themeTemplateParameters }) => {
    const { properties } = themeTemplateParameters;
    const { fills, strokes } = takeColors(colorsCount);
    const { fills: DEFAULT_FILLS2, strokes: DEFAULT_STROKES2 } = properties.get(
      import_ag_charts_community67._Theme.DEFAULT_COLOURS
    );
    return {
      item: {
        up: {
          fill: userPalette ? "transparent" : DEFAULT_FILLS2.GREEN,
          stroke: userPalette ? strokes[0] : DEFAULT_STROKES2.GREEN
        },
        down: {
          fill: userPalette ? fills[0] : DEFAULT_FILLS2.RED,
          stroke: userPalette ? strokes[0] : DEFAULT_STROKES2.RED
        }
      }
    };
  }
};
var import_ag_charts_community72 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community70 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community68 = (init_main(), __toCommonJS(main_exports));
var { Validate: Validate30, NUMBER: NUMBER9, TEXT_WRAP: TEXT_WRAP2, OVERFLOW_STRATEGY: OVERFLOW_STRATEGY2 } = import_ag_charts_community68._ModuleSupport;
var { Logger: Logger5 } = import_ag_charts_community68._Util;
var { Text: Text5, Label: Label2 } = import_ag_charts_community68._Scene;
var BaseAutoSizedLabel = class extends Label2 {
  constructor() {
    super(...arguments);
    this.wrapping = "on-space";
    this.overflowStrategy = "ellipsis";
  }
  static lineHeight(fontSize) {
    return Math.ceil(fontSize * Text5.defaultLineHeightRatio);
  }
};
__decorateClass2([
  Validate30(TEXT_WRAP2)
], BaseAutoSizedLabel.prototype, "wrapping", 2);
__decorateClass2([
  Validate30(OVERFLOW_STRATEGY2)
], BaseAutoSizedLabel.prototype, "overflowStrategy", 2);
__decorateClass2([
  Validate30(NUMBER9, { optional: true })
], BaseAutoSizedLabel.prototype, "minimumFontSize", 2);
var AutoSizedLabel = class extends BaseAutoSizedLabel {
  constructor() {
    super(...arguments);
    this.spacing = 0;
  }
};
__decorateClass2([
  Validate30(NUMBER9)
], AutoSizedLabel.prototype, "spacing", 2);
var AutoSizeableSecondaryLabel = class extends BaseAutoSizedLabel {
};
function generateLabelSecondaryLabelFontSizeCandidates(label, secondaryLabel) {
  const { fontSize: labelFontSize, minimumFontSize: labelMinimumFontSize = labelFontSize } = label;
  const {
    fontSize: secondaryLabelFontSize,
    minimumFontSize: secondaryLabelMinimumFontSize = secondaryLabelFontSize
  } = secondaryLabel;
  const labelTracks = labelFontSize - labelMinimumFontSize;
  const secondaryLabelTracks = secondaryLabelFontSize - secondaryLabelMinimumFontSize;
  let currentLabelFontSize = label.fontSize;
  let currentSecondaryLabelFontSize = secondaryLabel.fontSize;
  const out = [{ labelFontSize, secondaryLabelFontSize }];
  while (currentLabelFontSize > labelMinimumFontSize || currentSecondaryLabelFontSize > secondaryLabelMinimumFontSize) {
    const labelProgress = labelTracks > 0 ? (currentLabelFontSize - labelMinimumFontSize) / labelTracks : -1;
    const secondaryLabelProgress = secondaryLabelTracks > 0 ? (currentSecondaryLabelFontSize - secondaryLabelMinimumFontSize) / secondaryLabelTracks : -1;
    if (labelProgress > secondaryLabelProgress) {
      currentLabelFontSize--;
    } else {
      currentSecondaryLabelFontSize--;
    }
    out.push({
      labelFontSize: currentLabelFontSize,
      secondaryLabelFontSize: currentSecondaryLabelFontSize
    });
  }
  out.reverse();
  return out;
}
function maximumValueSatisfying(from, to, iteratee) {
  if (from > to) {
    return;
  }
  let min = from;
  let max = to;
  let found;
  while (max >= min) {
    const index = (max + min) / 2 | 0;
    const value = iteratee(index);
    if (value == null) {
      max = index - 1;
    } else {
      found = value;
      min = index + 1;
    }
  }
  return found;
}
function formatStackedLabels(labelValue, labelProps, secondaryLabelValue, secondaryLabelProps, { padding }, sizeFittingHeight) {
  var _a2, _b;
  const { spacing } = labelProps;
  const widthAdjust = 2 * padding;
  const heightAdjust = 2 * padding + spacing;
  const minimumHeight = ((_a2 = labelProps.minimumFontSize) != null ? _a2 : labelProps.fontSize) + ((_b = secondaryLabelProps.minimumFontSize) != null ? _b : secondaryLabelProps.fontSize);
  if (minimumHeight > sizeFittingHeight(minimumHeight + heightAdjust, false).height - heightAdjust) {
    return;
  }
  const fontSizeCandidates = generateLabelSecondaryLabelFontSizeCandidates(labelProps, secondaryLabelProps);
  const labelTextNode = new Text5();
  labelTextNode.setFont(labelProps);
  const labelTextSizeProps = {
    fontFamily: labelProps.fontFamily,
    fontSize: labelProps.fontSize,
    fontStyle: labelProps.fontStyle,
    fontWeight: labelProps.fontWeight
  };
  const secondaryLabelTextNode = new Text5();
  secondaryLabelTextNode.setFont(secondaryLabelProps);
  const secondaryLabelTextSizeProps = {
    fontFamily: secondaryLabelProps.fontFamily,
    fontSize: secondaryLabelProps.fontSize,
    fontStyle: secondaryLabelProps.fontStyle,
    fontWeight: secondaryLabelProps.fontWeight
  };
  let label;
  let secondaryLabel;
  return maximumValueSatisfying(0, fontSizeCandidates.length - 1, (index) => {
    const { labelFontSize, secondaryLabelFontSize } = fontSizeCandidates[index];
    const allowTruncation = index === 0;
    const labelLineHeight = AutoSizedLabel.lineHeight(labelFontSize);
    const secondaryLabelLineHeight = AutoSizeableSecondaryLabel.lineHeight(secondaryLabelFontSize);
    const sizeFitting = sizeFittingHeight(
      labelLineHeight + secondaryLabelLineHeight + heightAdjust,
      allowTruncation
    );
    const availableWidth = sizeFitting.width - widthAdjust;
    const availableHeight = sizeFitting.height - heightAdjust;
    if (labelLineHeight + secondaryLabelLineHeight > availableHeight) {
      return;
    }
    if (label == null || label.fontSize !== labelFontSize) {
      labelTextSizeProps.fontSize = labelFontSize;
      const { lines: labelLines } = Text5.wrapLines(
        labelValue,
        availableWidth,
        availableHeight,
        labelTextSizeProps,
        labelProps.wrapping,
        allowTruncation ? labelProps.overflowStrategy : "hide"
      );
      if (labelLines == null) {
        label = void 0;
      } else {
        const labelText = labelLines.join("\n");
        labelTextNode.text = labelText;
        labelTextNode.fontSize = labelFontSize;
        labelTextNode.lineHeight = labelFontSize;
        const labelWidth = labelTextNode.computeBBox().width;
        const labelHeight = labelLines.length * labelLineHeight;
        label = {
          text: labelText,
          fontSize: labelFontSize,
          lineHeight: labelLineHeight,
          width: labelWidth,
          height: labelHeight
        };
      }
    }
    if (label == null || label.width > availableWidth || label.height > availableHeight) {
      return;
    }
    if (secondaryLabel == null || secondaryLabel.fontSize !== secondaryLabelFontSize) {
      secondaryLabelTextSizeProps.fontSize = secondaryLabelFontSize;
      const { lines: secondaryLabelLines } = Text5.wrapLines(
        secondaryLabelValue,
        availableWidth,
        availableHeight,
        secondaryLabelTextSizeProps,
        secondaryLabelProps.wrapping,
        allowTruncation ? secondaryLabelProps.overflowStrategy : "hide"
      );
      if (secondaryLabelLines == null) {
        secondaryLabel = void 0;
      } else {
        const secondaryLabelText = secondaryLabelLines.join("\n");
        secondaryLabelTextNode.text = secondaryLabelText;
        secondaryLabelTextNode.fontSize = secondaryLabelFontSize;
        secondaryLabelTextNode.lineHeight = secondaryLabelLineHeight;
        const secondaryLabelWidth = secondaryLabelTextNode.computeBBox().width;
        const secondaryLabelHeight = secondaryLabelLines.length * secondaryLabelLineHeight;
        secondaryLabel = {
          text: secondaryLabelText,
          fontSize: secondaryLabelFontSize,
          lineHeight: secondaryLabelLineHeight,
          width: secondaryLabelWidth,
          height: secondaryLabelHeight
        };
      }
    }
    if (secondaryLabel == null) {
      return;
    }
    const totalLabelHeight = label.height + secondaryLabel.height;
    if (secondaryLabel.width > availableWidth || totalLabelHeight > availableHeight) {
      return;
    }
    return {
      width: Math.max(label.width, secondaryLabel.width),
      height: totalLabelHeight + spacing,
      meta: sizeFitting.meta,
      label,
      secondaryLabel
    };
  });
}
function formatSingleLabel(value, props, { padding }, sizeFittingHeight) {
  var _a2;
  const sizeAdjust = 2 * padding;
  const minimumFontSize = Math.min((_a2 = props.minimumFontSize) != null ? _a2 : props.fontSize, props.fontSize);
  const textNode = new Text5();
  textNode.setFont(props);
  const textSizeProps = {
    fontFamily: props.fontFamily,
    fontSize: props.fontSize,
    fontStyle: props.fontStyle,
    fontWeight: props.fontWeight
  };
  return maximumValueSatisfying(minimumFontSize, props.fontSize, (fontSize) => {
    const lineHeight = AutoSizedLabel.lineHeight(fontSize);
    const allowTruncation = fontSize === minimumFontSize;
    const sizeFitting = sizeFittingHeight(lineHeight + sizeAdjust, allowTruncation);
    const availableWidth = sizeFitting.width - sizeAdjust;
    const availableHeight = sizeFitting.height - sizeAdjust;
    if (lineHeight > availableHeight) {
      return;
    }
    textSizeProps.fontSize = fontSize;
    const { lines } = Text5.wrapLines(
      value,
      availableWidth,
      availableHeight,
      textSizeProps,
      props.wrapping,
      allowTruncation ? props.overflowStrategy : "hide"
    );
    if (lines == null) {
      return;
    }
    const text = lines.join("\n");
    textNode.text = text;
    textNode.fontSize = fontSize;
    textNode.lineHeight = lineHeight;
    const size = textNode.computeBBox();
    const width = textNode.computeBBox().width;
    const height = lineHeight * lines.length;
    if (size.width > availableWidth || height > availableHeight) {
      return;
    }
    return [{ text, fontSize, lineHeight, width, height }, sizeFitting.meta];
  });
}
function hasInvalidFontSize(label) {
  return (label == null ? void 0 : label.minimumFontSize) != null && (label == null ? void 0 : label.fontSize) && (label == null ? void 0 : label.minimumFontSize) > (label == null ? void 0 : label.fontSize);
}
function formatLabels(baseLabelValue, labelProps, baseSecondaryLabelValue, secondaryLabelProps, layoutParams, sizeFittingHeight) {
  const labelValue = labelProps.enabled ? baseLabelValue : void 0;
  const secondaryLabelValue = secondaryLabelProps.enabled ? baseSecondaryLabelValue : void 0;
  if (hasInvalidFontSize(labelProps) || hasInvalidFontSize(secondaryLabelProps)) {
    Logger5.warnOnce(`minimumFontSize should be set to a value less than or equal to the font size`);
  }
  let value;
  if (labelValue != null && secondaryLabelValue != null) {
    value = formatStackedLabels(
      labelValue,
      labelProps,
      secondaryLabelValue,
      secondaryLabelProps,
      layoutParams,
      sizeFittingHeight
    );
  }
  let labelMeta;
  if (value == null && labelValue != null) {
    labelMeta = formatSingleLabel(labelValue, labelProps, layoutParams, sizeFittingHeight);
  }
  if (labelMeta != null) {
    const [label, meta] = labelMeta;
    value = {
      width: label.width,
      height: label.height,
      meta,
      label,
      secondaryLabel: void 0
    };
  }
  let secondaryLabelMeta;
  if (value == null && labelValue == null && secondaryLabelValue != null) {
    secondaryLabelMeta = formatSingleLabel(
      secondaryLabelValue,
      secondaryLabelProps,
      layoutParams,
      sizeFittingHeight
    );
  }
  if (secondaryLabelMeta != null) {
    const [secondaryLabel, meta] = secondaryLabelMeta;
    value = {
      width: secondaryLabel.width,
      height: secondaryLabel.height,
      meta,
      label: void 0,
      secondaryLabel
    };
  }
  return value;
}
var import_ag_charts_community69 = (init_main(), __toCommonJS(main_exports));
var {
  CartesianSeriesProperties: CartesianSeriesProperties2,
  SeriesTooltip: SeriesTooltip4,
  Validate: Validate31,
  AND: AND7,
  ARRAY: ARRAY4,
  COLOR_STRING: COLOR_STRING9,
  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY2,
  FUNCTION: FUNCTION6,
  OBJECT: OBJECT8,
  POSITIVE_NUMBER: POSITIVE_NUMBER13,
  RATIO: RATIO14,
  STRING: STRING10,
  TEXT_ALIGN: TEXT_ALIGN2,
  VERTICAL_ALIGN: VERTICAL_ALIGN2
} = import_ag_charts_community69._ModuleSupport;
var HeatmapSeriesProperties = class extends CartesianSeriesProperties2 {
  constructor() {
    super(...arguments);
    this.colorRange = ["black", "black"];
    this.stroke = "black";
    this.strokeWidth = 0;
    this.textAlign = "center";
    this.verticalAlign = "middle";
    this.itemPadding = 0;
    this.label = new AutoSizedLabel();
    this.tooltip = new SeriesTooltip4();
  }
};
__decorateClass2([
  Validate31(STRING10, { optional: true })
], HeatmapSeriesProperties.prototype, "title", 2);
__decorateClass2([
  Validate31(STRING10)
], HeatmapSeriesProperties.prototype, "xKey", 2);
__decorateClass2([
  Validate31(STRING10)
], HeatmapSeriesProperties.prototype, "yKey", 2);
__decorateClass2([
  Validate31(STRING10, { optional: true })
], HeatmapSeriesProperties.prototype, "colorKey", 2);
__decorateClass2([
  Validate31(STRING10, { optional: true })
], HeatmapSeriesProperties.prototype, "xName", 2);
__decorateClass2([
  Validate31(STRING10, { optional: true })
], HeatmapSeriesProperties.prototype, "yName", 2);
__decorateClass2([
  Validate31(STRING10, { optional: true })
], HeatmapSeriesProperties.prototype, "colorName", 2);
__decorateClass2([
  Validate31(AND7(COLOR_STRING_ARRAY2, ARRAY4.restrict({ minLength: 1 })))
], HeatmapSeriesProperties.prototype, "colorRange", 2);
__decorateClass2([
  Validate31(COLOR_STRING9, { optional: true })
], HeatmapSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate31(RATIO14, { optional: true })
], HeatmapSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate31(POSITIVE_NUMBER13, { optional: true })
], HeatmapSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate31(TEXT_ALIGN2)
], HeatmapSeriesProperties.prototype, "textAlign", 2);
__decorateClass2([
  Validate31(VERTICAL_ALIGN2)
], HeatmapSeriesProperties.prototype, "verticalAlign", 2);
__decorateClass2([
  Validate31(POSITIVE_NUMBER13)
], HeatmapSeriesProperties.prototype, "itemPadding", 2);
__decorateClass2([
  Validate31(FUNCTION6, { optional: true })
], HeatmapSeriesProperties.prototype, "formatter", 2);
__decorateClass2([
  Validate31(OBJECT8)
], HeatmapSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Validate31(OBJECT8)
], HeatmapSeriesProperties.prototype, "tooltip", 2);
var {
  SeriesNodePickMode: SeriesNodePickMode3,
  computeBarFocusBounds: computeBarFocusBounds4,
  getMissCount: getMissCount2,
  valueProperty: valueProperty5,
  ChartAxisDirection: ChartAxisDirection8,
  DEFAULT_CARTESIAN_DIRECTION_KEYS: DEFAULT_CARTESIAN_DIRECTION_KEYS2,
  DEFAULT_CARTESIAN_DIRECTION_NAMES: DEFAULT_CARTESIAN_DIRECTION_NAMES2
} = import_ag_charts_community70._ModuleSupport;
var { Rect: Rect3, PointerEvents: PointerEvents2 } = import_ag_charts_community70._Scene;
var { ColorScale: ColorScale2 } = import_ag_charts_community70._Scale;
var { sanitizeHtml: sanitizeHtml3, Color: Color2, Logger: Logger6 } = import_ag_charts_community70._Util;
var HeatmapSeriesNodeEvent = class extends import_ag_charts_community70._ModuleSupport.CartesianSeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.colorKey = series.properties.colorKey;
  }
};
var textAlignFactors = {
  left: -0.5,
  center: 0,
  right: -0.5
};
var verticalAlignFactors = {
  top: -0.5,
  middle: 0,
  bottom: -0.5
};
var HeatmapSeries = class extends import_ag_charts_community70._ModuleSupport.CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS2,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES2,
      pickModes: [SeriesNodePickMode3.EXACT_SHAPE_MATCH],
      pathsPerSeries: 0,
      hasMarkers: false,
      hasHighlightedLabels: true
    });
    this.properties = new HeatmapSeriesProperties();
    this.NodeEvent = HeatmapSeriesNodeEvent;
    this.colorScale = new ColorScale2();
    this.seriesItemEnabled = [];
  }
  processData(dataController) {
    return __async2(this, null, function* () {
      var _a2, _b, _c;
      const xAxis = this.axes[ChartAxisDirection8.X];
      const yAxis = this.axes[ChartAxisDirection8.Y];
      if (!xAxis || !yAxis || !this.properties.isValid() || !((_a2 = this.data) == null ? void 0 : _a2.length)) {
        return;
      }
      const { xKey, yKey, colorRange, colorKey } = this.properties;
      const xScale = (_b = this.axes[ChartAxisDirection8.X]) == null ? void 0 : _b.scale;
      const yScale = (_c = this.axes[ChartAxisDirection8.Y]) == null ? void 0 : _c.scale;
      const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
      const colorScaleType = this.colorScale.type;
      const { dataModel, processedData } = yield this.requestDataModel(dataController, this.data, {
        props: [
          valueProperty5(xKey, xScaleType, { id: "xValue" }),
          valueProperty5(yKey, yScaleType, { id: "yValue" }),
          ...colorKey ? [valueProperty5(colorKey, colorScaleType, { id: "colorValue" })] : []
        ]
      });
      if (this.isColorScaleValid()) {
        const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
        this.colorScale.domain = processedData.domain.values[colorKeyIdx];
        this.colorScale.range = colorRange;
        this.colorScale.update();
      }
    });
  }
  isColorScaleValid() {
    const { colorKey } = this.properties;
    if (!colorKey) {
      return false;
    }
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return false;
    }
    const colorDataIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
    const dataCount = processedData.data.length;
    const missCount = getMissCount2(this, processedData.defs.values[colorDataIdx].missing);
    const colorDataMissing = dataCount === 0 || dataCount === missCount;
    return !colorDataMissing;
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData)
      return [];
    if (direction === ChartAxisDirection8.X) {
      return dataModel.getDomain(this, `xValue`, "value", processedData);
    } else {
      return dataModel.getDomain(this, `yValue`, "value", processedData);
    }
  }
  createNodeData() {
    return __async2(this, null, function* () {
      var _a2, _b, _c, _d, _e, _f, _g;
      const { data, visible, axes, dataModel } = this;
      const xAxis = axes[ChartAxisDirection8.X];
      const yAxis = axes[ChartAxisDirection8.Y];
      if (!(data && dataModel && visible && xAxis && yAxis)) {
        return;
      }
      if (xAxis.type !== "category" || yAxis.type !== "category") {
        Logger6.warnOnce(
          `Heatmap series expected axes to have "category" type, but received "${xAxis.type}" and "${yAxis.type}" instead.`
        );
        return;
      }
      const {
        xKey,
        xName,
        yKey,
        yName,
        colorKey,
        colorName,
        textAlign,
        verticalAlign,
        itemPadding,
        colorRange,
        label
      } = this.properties;
      const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);
      const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);
      const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : void 0;
      const xScale = xAxis.scale;
      const yScale = yAxis.scale;
      const xOffset = ((_a2 = xScale.bandwidth) != null ? _a2 : 0) / 2;
      const yOffset = ((_b = yScale.bandwidth) != null ? _b : 0) / 2;
      const colorScaleValid = this.isColorScaleValid();
      const nodeData = [];
      const labelData = [];
      const width = (_c = xScale.bandwidth) != null ? _c : 10;
      const height = (_d = yScale.bandwidth) != null ? _d : 10;
      const textAlignFactor = (width - 2 * itemPadding) * textAlignFactors[textAlign];
      const verticalAlignFactor = (height - 2 * itemPadding) * verticalAlignFactors[verticalAlign];
      const sizeFittingHeight = () => ({ width, height, meta: null });
      const { seriesItemEnabled } = this;
      seriesItemEnabled.length = 0;
      for (const { values, datum } of (_f = (_e = this.processedData) == null ? void 0 : _e.data) != null ? _f : []) {
        const xDatum = values[xDataIdx];
        const yDatum = values[yDataIdx];
        const x = xScale.convert(xDatum) + xOffset;
        const y = yScale.convert(yDatum) + yOffset;
        const colorValue = values[colorDataIdx != null ? colorDataIdx : -1];
        const fill = colorScaleValid && colorValue != null ? this.colorScale.convert(colorValue) : colorRange[0];
        seriesItemEnabled.push(colorValue != null);
        const labelText = colorValue == null ? void 0 : this.getLabelText(label, {
          value: colorValue,
          datum,
          colorKey,
          colorName,
          xKey,
          yKey,
          xName,
          yName
        });
        const labels = formatLabels(
          labelText,
          this.properties.label,
          void 0,
          this.properties.label,
          { padding: itemPadding },
          sizeFittingHeight
        );
        const point = { x, y, size: 0 };
        nodeData.push({
          series: this,
          itemId: yKey,
          yKey,
          xKey,
          xValue: xDatum,
          yValue: yDatum,
          colorValue,
          datum,
          point,
          width,
          height,
          fill,
          midPoint: { x, y }
        });
        if ((labels == null ? void 0 : labels.label) != null) {
          const { text, fontSize, lineHeight, height: labelHeight } = labels.label;
          const { fontStyle, fontFamily, fontWeight, color } = this.properties.label;
          const lx = point.x + textAlignFactor * (width - 2 * itemPadding);
          const ly = point.y + verticalAlignFactor * (height - 2 * itemPadding) - (labels.height - labelHeight) * 0.5;
          labelData.push({
            series: this,
            itemId: yKey,
            datum,
            text,
            fontSize,
            lineHeight,
            fontStyle,
            fontFamily,
            fontWeight,
            color,
            textAlign,
            verticalAlign,
            x: lx,
            y: ly
          });
        }
      }
      return {
        itemId: (_g = this.properties.yKey) != null ? _g : this.id,
        nodeData,
        labelData,
        scales: this.calculateScaling(),
        visible: this.visible
      };
    });
  }
  nodeFactory() {
    return new Rect3();
  }
  updateDatumSelection(opts) {
    return __async2(this, null, function* () {
      const { nodeData, datumSelection } = opts;
      const data = nodeData != null ? nodeData : [];
      return datumSelection.update(data);
    });
  }
  updateDatumNodes(opts) {
    return __async2(this, null, function* () {
      var _a2;
      const { isHighlight: isDatumHighlighted } = opts;
      const {
        id: seriesId,
        ctx: { callbackCache }
      } = this;
      const {
        xKey,
        yKey,
        colorKey,
        formatter,
        highlightStyle: {
          item: {
            fill: highlightedFill,
            stroke: highlightedStroke,
            strokeWidth: highlightedDatumStrokeWidth,
            strokeOpacity: highlightedDatumStrokeOpacity,
            fillOpacity: highlightedFillOpacity
          }
        }
      } = this.properties;
      const xAxis = this.axes[ChartAxisDirection8.X];
      const [visibleMin, visibleMax] = (_a2 = xAxis == null ? void 0 : xAxis.visibleRange) != null ? _a2 : [];
      const isZoomed = visibleMin !== 0 || visibleMax !== 1;
      const crisp = !isZoomed;
      opts.datumSelection.each((rect, datum) => {
        var _a3, _b, _c, _d, _e;
        const { point, width, height } = datum;
        const fill = isDatumHighlighted && highlightedFill !== void 0 ? Color2.interpolate(datum.fill, highlightedFill)(highlightedFillOpacity != null ? highlightedFillOpacity : 1) : datum.fill;
        const stroke = isDatumHighlighted && highlightedStroke !== void 0 ? highlightedStroke : this.properties.stroke;
        const strokeOpacity = isDatumHighlighted && highlightedDatumStrokeOpacity !== void 0 ? highlightedDatumStrokeOpacity : this.properties.strokeOpacity;
        const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== void 0 ? highlightedDatumStrokeWidth : this.properties.strokeWidth;
        let format2;
        if (formatter) {
          format2 = callbackCache.call(formatter, {
            datum: datum.datum,
            fill,
            stroke,
            strokeOpacity,
            strokeWidth,
            highlighted: isDatumHighlighted,
            xKey,
            yKey,
            colorKey,
            seriesId
          });
        }
        rect.crisp = crisp;
        rect.x = Math.floor(point.x - width / 2);
        rect.y = Math.floor(point.y - height / 2);
        rect.width = Math.ceil(width);
        rect.height = Math.ceil(height);
        rect.fill = (_a3 = format2 == null ? void 0 : format2.fill) != null ? _a3 : fill;
        rect.stroke = (_b = format2 == null ? void 0 : format2.stroke) != null ? _b : stroke;
        rect.strokeOpacity = (_d = (_c = format2 == null ? void 0 : format2.strokeOpacity) != null ? _c : strokeOpacity) != null ? _d : 1;
        rect.strokeWidth = (_e = format2 == null ? void 0 : format2.strokeWidth) != null ? _e : strokeWidth;
      });
    });
  }
  updateLabelSelection(opts) {
    return __async2(this, null, function* () {
      const { labelData, labelSelection } = opts;
      const { enabled } = this.properties.label;
      const data = enabled ? labelData : [];
      return labelSelection.update(data);
    });
  }
  updateLabelNodes(opts) {
    return __async2(this, null, function* () {
      opts.labelSelection.each((text, datum) => {
        text.text = datum.text;
        text.fontSize = datum.fontSize;
        text.lineHeight = datum.lineHeight;
        text.fontStyle = datum.fontStyle;
        text.fontFamily = datum.fontFamily;
        text.fontWeight = datum.fontWeight;
        text.fill = datum.color;
        text.textAlign = datum.textAlign;
        text.textBaseline = datum.verticalAlign;
        text.x = datum.x;
        text.y = datum.y;
        text.pointerEvents = PointerEvents2.None;
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    var _a2, _b, _c;
    const xAxis = this.axes[ChartAxisDirection8.X];
    const yAxis = this.axes[ChartAxisDirection8.Y];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return import_ag_charts_community70._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const { xKey, yKey, colorKey, xName, yName, colorName, stroke, strokeWidth, colorRange, formatter, tooltip } = this.properties;
    const {
      colorScale,
      id: seriesId,
      ctx: { callbackCache }
    } = this;
    const { datum, xValue, yValue, colorValue, itemId } = nodeDatum;
    const fill = this.isColorScaleValid() ? colorScale.convert(colorValue) : colorRange[0];
    let format2;
    if (formatter) {
      format2 = callbackCache.call(formatter, {
        datum: nodeDatum,
        xKey,
        yKey,
        colorKey,
        fill,
        stroke,
        strokeWidth,
        highlighted: false,
        seriesId
      });
    }
    const color = (_b = (_a2 = format2 == null ? void 0 : format2.fill) != null ? _a2 : fill) != null ? _b : "gray";
    const title = (_c = this.properties.title) != null ? _c : yName;
    const xString = sanitizeHtml3(xAxis.formatDatum(xValue));
    const yString = sanitizeHtml3(yAxis.formatDatum(yValue));
    let content = `<b>${sanitizeHtml3(xName != null ? xName : xKey)}</b>: ${xString}<br><b>${sanitizeHtml3(yName != null ? yName : yKey)}</b>: ${yString}`;
    if (colorKey) {
      content = `<b>${sanitizeHtml3(colorName != null ? colorName : colorKey)}</b>: ${sanitizeHtml3(colorValue)}<br>` + content;
    }
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        seriesId,
        datum,
        xKey,
        yKey,
        xName,
        yName,
        title,
        color,
        colorKey,
        colorName,
        itemId
      }
    );
  }
  getLegendData(legendType) {
    var _a2;
    if (legendType !== "gradient" || !((_a2 = this.data) == null ? void 0 : _a2.length) || !this.properties.isValid() || !this.isColorScaleValid() || !this.dataModel) {
      return [];
    }
    return [
      {
        legendType: "gradient",
        enabled: this.visible,
        seriesId: this.id,
        colorName: this.properties.colorName,
        colorDomain: this.processedData.domain.values[this.dataModel.resolveProcessedDataIndexById(this, "colorValue")],
        colorRange: this.properties.colorRange
      }
    ];
  }
  isLabelEnabled() {
    return this.properties.label.enabled && Boolean(this.properties.colorKey);
  }
  getBandScalePadding() {
    return { inner: 0, outer: 0 };
  }
  computeFocusBounds({ datumIndex, seriesRect }) {
    var _a2;
    const datum = (_a2 = this.contextNodeData) == null ? void 0 : _a2.nodeData[datumIndex];
    if (datum === void 0)
      return void 0;
    const { width, height, midPoint } = datum;
    const focusRect = { x: midPoint.x - width / 2, y: midPoint.y - height / 2, width, height };
    return computeBarFocusBounds4(focusRect, this.contentGroup, seriesRect);
  }
};
HeatmapSeries.className = "HeatmapSeries";
HeatmapSeries.type = "heatmap";
var import_ag_charts_community71 = (init_main(), __toCommonJS(main_exports));
var HEATMAP_SERIES_THEME = {
  series: {
    __extends__: import_ag_charts_community71._Theme.EXTENDS_SERIES_DEFAULTS,
    label: {
      enabled: false,
      color: import_ag_charts_community71._Theme.DEFAULT_LABEL_COLOUR,
      fontSize: import_ag_charts_community71._Theme.FONT_SIZE.SMALL,
      fontFamily: import_ag_charts_community71._Theme.DEFAULT_FONT_FAMILY,
      wrapping: "on-space",
      overflowStrategy: "ellipsis"
    },
    itemPadding: 3
  },
  gradientLegend: {
    enabled: true
  }
};
var HeatmapModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "heatmap",
  instanceConstructor: HeatmapSeries,
  defaultAxes: [
    {
      type: import_ag_charts_community72._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: import_ag_charts_community72._Theme.POSITION.LEFT
    },
    {
      type: import_ag_charts_community72._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: import_ag_charts_community72._Theme.POSITION.BOTTOM
    }
  ],
  themeTemplate: HEATMAP_SERIES_THEME,
  paletteFactory: ({ takeColors, colorsCount, userPalette, themeTemplateParameters }) => {
    var _a2;
    const { properties } = themeTemplateParameters;
    const defaultColorRange = properties.get(import_ag_charts_community72._Theme.DEFAULT_DIVERGING_SERIES_COLOUR_RANGE);
    const defaultBackgroundColor = properties.get(import_ag_charts_community72._Theme.DEFAULT_BACKGROUND_COLOUR);
    const backgroundFill = (_a2 = Array.isArray(defaultBackgroundColor) ? defaultBackgroundColor[0] : defaultBackgroundColor) != null ? _a2 : "white";
    const { fills, strokes } = takeColors(colorsCount);
    return {
      stroke: userPalette ? strokes[0] : backgroundFill,
      colorRange: userPalette ? [fills[0], fills[1]] : defaultColorRange
    };
  }
};
var import_ag_charts_community78 = (init_main(), __toCommonJS(main_exports));
var MAP_THEME_DEFAULTS = {
  // zoom: {
  //     axes: 'xy',
  //     anchorPointX: 'pointer',
  //     anchorPointY: 'pointer',
  //     deceleration: 0.01,
  // },
  legend: {
    enabled: false
  },
  gradientLegend: {
    enabled: false
  },
  tooltip: {
    range: "exact"
  }
};
var import_ag_charts_community77 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community74 = (init_main(), __toCommonJS(main_exports));
var delta2 = 1e-9;
function lineSegmentDistanceToPointSquared(a, b, x, y) {
  const [ax, ay] = a;
  const [bx, by] = b;
  const abx = bx - ax;
  const aby = by - ay;
  const l = abx * abx + aby * aby;
  let x0;
  let y0;
  if (Math.abs(l) < delta2) {
    x0 = ax;
    y0 = ay;
  } else {
    let t = ((x - ax) * abx + (y - ay) * aby) / l;
    t = Math.max(0, Math.min(1, t));
    x0 = ax + t * (bx - ax);
    y0 = ay + t * (by - ay);
  }
  const dx2 = x - x0;
  const dy2 = y - y0;
  return dx2 * dx2 + dy2 * dy2;
}
function lineStringDistance(lineString, x, y) {
  let minDistanceSquared = Infinity;
  let p0 = lineString[lineString.length - 1];
  for (const p1 of lineString) {
    minDistanceSquared = Math.min(minDistanceSquared, lineSegmentDistanceToPointSquared(p0, p1, x, y));
    p0 = p1;
  }
  return Math.sqrt(minDistanceSquared);
}
function lineStringLength(lineSegment) {
  let [x0, y0] = lineSegment[0];
  let totalDistance = 0;
  for (let i = 1; i < lineSegment.length; i += 1) {
    const [x1, y1] = lineSegment[i];
    const distance2 = Math.hypot(x1 - x0, y1 - y0);
    totalDistance += distance2;
    x0 = x1;
    y0 = y1;
  }
  return totalDistance;
}
function lineStringCenter(lineSegment) {
  if (lineSegment.length === 0)
    return;
  const targetDistance = lineStringLength(lineSegment) / 2;
  let [x0, y0] = lineSegment[0];
  let totalDistance = 0;
  for (let i = 1; i < lineSegment.length; i += 1) {
    const [x1, y1] = lineSegment[i];
    const segmentDistance = Math.hypot(x1 - x0, y1 - y0);
    const nextDistance = totalDistance + segmentDistance;
    if (nextDistance > targetDistance) {
      const ratio = (targetDistance - totalDistance) / segmentDistance;
      const point = [x0 + (x1 - x0) * ratio, y0 + (y1 - y0) * ratio];
      const angle = Math.atan2(y1 - y0, x1 - x0);
      return { point, angle };
    }
    totalDistance = nextDistance;
    x0 = x1;
    y0 = y1;
  }
}
var import_ag_charts_community73 = (init_main(), __toCommonJS(main_exports));
var { LonLatBBox: LonLatBBox2 } = import_ag_charts_community73._ModuleSupport;
function extendBbox(into, lon0, lat0, lon1, lat1) {
  if (into == null) {
    into = new LonLatBBox2(lon0, lat0, lon1, lat1);
  } else {
    into.lon0 = Math.min(into.lon0, lon0);
    into.lat0 = Math.min(into.lat0, lat0);
    into.lon1 = Math.max(into.lon1, lon1);
    into.lat1 = Math.max(into.lat1, lat1);
  }
  return into;
}
var insertManySorted = (list, items, cmp) => {
  let head = list;
  let current = head;
  for (const value of items) {
    if (head == null || cmp(head.value, value) > 0) {
      head = { value, next: head };
      current = head;
    } else {
      current = current;
      while (current.next != null && cmp(current.next.value, value) <= 0) {
        current = current.next;
      }
      current.next = { value, next: current.next };
    }
  }
  return head;
};
function polygonBbox(polygon, into) {
  polygon.forEach((coordinates) => {
    const [lon, lat] = coordinates;
    into = extendBbox(into, lon, lat, lon, lat);
  });
  return into;
}
function polygonCentroid(polygon) {
  if (polygon.length === 0)
    return;
  let x = 0;
  let y = 0;
  let k = 0;
  let [x0, y0] = polygon[polygon.length - 1];
  for (const [x1, y1] of polygon) {
    const c = x0 * y1 - x1 * y0;
    k += c;
    x += (x0 + x1) * c;
    y += (y0 + y1) * c;
    x0 = x1;
    y0 = y1;
  }
  k *= 3;
  return [x / k, y / k];
}
function polygonDistance(polygons, x, y) {
  let inside = false;
  let minDistanceSquared = Infinity;
  for (const polygon of polygons) {
    let p0 = polygon[polygon.length - 1];
    let [x0, y0] = p0;
    for (const p1 of polygon) {
      const [x1, y1] = p1;
      if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1) {
        inside = !inside;
      }
      minDistanceSquared = Math.min(minDistanceSquared, lineSegmentDistanceToPointSquared(p0, p1, x, y));
      p0 = p1;
      x0 = x1;
      y0 = y1;
    }
  }
  return (inside ? -1 : 1) * Math.sqrt(minDistanceSquared);
}
var { Path: Path5, ExtendedPath2D: ExtendedPath2D2, BBox: BBox8, ScenePathChangeDetection: ScenePathChangeDetection2 } = import_ag_charts_community74._Scene;
var GeoGeometry = class extends Path5 {
  constructor() {
    super(...arguments);
    this.projectedGeometry = void 0;
    this.renderMode = 3;
    this.strokePath = new ExtendedPath2D2();
  }
  computeBBox() {
    var _a2;
    if (this.dirtyPath || this.isDirtyPath()) {
      this.updatePath();
      this.dirtyPath = false;
    }
    return (_a2 = this.bbox) == null ? void 0 : _a2.clone();
  }
  updatePath() {
    const { projectedGeometry } = this;
    this.strokePath.clear();
    this.path.clear();
    this.bbox = projectedGeometry != null ? this.drawGeometry(projectedGeometry, void 0) : void 0;
  }
  drawPath(ctx) {
    super.drawPath(ctx);
    this.renderStroke(ctx, this.strokePath.getPath2D());
  }
  containsPoint(x, y) {
    const { projectedGeometry } = this;
    if (projectedGeometry == null)
      return false;
    ({ x, y } = this.transformPoint(x, y));
    if (!this.getCachedBBox().containsPoint(x, y))
      return false;
    return this.geometryDistance(projectedGeometry, x, y) <= 0;
  }
  distanceToPoint(x, y) {
    const { projectedGeometry } = this;
    ({ x, y } = this.transformPoint(x, y));
    return projectedGeometry != null ? this.geometryDistance(projectedGeometry, x, y) : Infinity;
  }
  geometryDistance(geometry, x, y) {
    const { renderMode, strokeWidth } = this;
    const drawPolygons = (renderMode & 1) !== 0;
    const drawLines = (renderMode & 2) !== 0;
    const minStrokeDistance = Math.max(strokeWidth / 2, 1) + 1;
    switch (geometry.type) {
      case "GeometryCollection":
        return geometry.geometries.reduce(
          (minDistance, g) => Math.min(minDistance, this.geometryDistance(g, x, y)),
          Infinity
        );
      case "MultiPolygon":
        return drawPolygons ? geometry.coordinates.reduce(
          (minDistance, polygon) => Math.min(minDistance, Math.max(polygonDistance(polygon, x, y), 0)),
          Infinity
        ) : Infinity;
      case "Polygon":
        return drawPolygons ? Math.max(polygonDistance(geometry.coordinates, x, y), 0) : Infinity;
      case "MultiLineString":
        return drawLines ? geometry.coordinates.reduce((minDistance, lineString) => {
          return Math.min(
            minDistance,
            Math.max(lineStringDistance(lineString, x, y) - minStrokeDistance, 0)
          );
        }, Infinity) : Infinity;
      case "LineString":
        return drawLines ? Math.max(lineStringDistance(geometry.coordinates, x, y) - minStrokeDistance, 0) : Infinity;
      case "MultiPoint":
      case "Point":
      default:
        return Infinity;
    }
  }
  drawGeometry(geometry, bbox) {
    const { renderMode, path, strokePath } = this;
    const drawPolygons = (renderMode & 1) !== 0;
    const drawLines = (renderMode & 2) !== 0;
    switch (geometry.type) {
      case "GeometryCollection":
        geometry.geometries.forEach((g) => {
          bbox = this.drawGeometry(g, bbox);
        });
        break;
      case "MultiPolygon":
        if (drawPolygons) {
          geometry.coordinates.forEach((coordinates) => {
            bbox = this.drawPolygon(path, coordinates, bbox);
          });
        }
        break;
      case "Polygon":
        if (drawPolygons) {
          bbox = this.drawPolygon(path, geometry.coordinates, bbox);
        }
        break;
      case "LineString":
        if (drawLines) {
          bbox = this.drawLineString(strokePath, geometry.coordinates, bbox, false);
        }
        break;
      case "MultiLineString":
        if (drawLines) {
          geometry.coordinates.forEach((coordinates) => {
            bbox = this.drawLineString(strokePath, coordinates, bbox, false);
          });
        }
        break;
      case "Point":
      case "MultiPoint":
        break;
    }
    return bbox;
  }
  drawPolygon(path, polygons, bbox) {
    if (polygons.length < 1)
      return bbox;
    bbox = this.drawLineString(path, polygons[0], bbox, true);
    for (let i = 1; i < polygons.length; i += 1) {
      const enclave = polygons[i];
      this.drawLineString(path, enclave, void 0, true);
    }
    return bbox;
  }
  drawLineString(path, coordinates, bbox, isClosed) {
    if (coordinates.length < 2)
      return bbox;
    const end = isClosed ? coordinates.length - 1 : coordinates.length;
    for (let i = 0; i < end; i += 1) {
      const [x, y] = coordinates[i];
      if (i === 0) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
      if (bbox == null) {
        bbox = new BBox8(x, y, 0, 0);
      } else {
        const { x: x0, y: y0 } = bbox;
        const x1 = x0 + bbox.width;
        const y1 = y0 + bbox.height;
        bbox.x = Math.min(x0, x);
        bbox.y = Math.min(y0, y);
        bbox.width = Math.max(x1, x) - bbox.x;
        bbox.height = Math.max(y1, y) - bbox.y;
      }
    }
    if (isClosed) {
      path.closePath();
    }
    return bbox;
  }
};
__decorateClass2([
  ScenePathChangeDetection2()
], GeoGeometry.prototype, "projectedGeometry", 2);
__decorateClass2([
  ScenePathChangeDetection2()
], GeoGeometry.prototype, "renderMode", 2);
function geometryBbox(geometry, into) {
  if (geometry.bbox != null) {
    const [lon0, lat0, lon1, lat1] = geometry.bbox;
    into = extendBbox(into, lon0, lat0, lon1, lat1);
    return into;
  }
  switch (geometry.type) {
    case "GeometryCollection":
      geometry.geometries.forEach((g) => {
        into = geometryBbox(g, into);
      });
      break;
    case "MultiPolygon":
      geometry.coordinates.forEach((c) => {
        if (c.length > 0) {
          into = polygonBbox(c[0], into);
        }
      });
      break;
    case "Polygon":
      if (geometry.coordinates.length > 0) {
        into = polygonBbox(geometry.coordinates[0], into);
      }
      break;
    case "MultiLineString":
      geometry.coordinates.forEach((c) => {
        into = polygonBbox(c, into);
      });
      break;
    case "LineString":
      into = polygonBbox(geometry.coordinates, into);
      break;
    case "MultiPoint":
      geometry.coordinates.forEach((p) => {
        const [lon, lat] = p;
        into = extendBbox(into, lon, lat, lon, lat);
      });
      break;
    case "Point": {
      const [lon, lat] = geometry.coordinates;
      into = extendBbox(into, lon, lat, lon, lat);
      break;
    }
  }
  return into;
}
function largestPolygon(geometry) {
  switch (geometry.type) {
    case "GeometryCollection": {
      let maxArea;
      let maxPolygon;
      geometry.geometries.map((g) => {
        const polygon = largestPolygon(g);
        if (polygon == null)
          return;
        const bbox = polygonBbox(polygon[0], void 0);
        if (bbox == null)
          return;
        const area2 = Math.abs(bbox.lat1 - bbox.lat0) * Math.abs(bbox.lon1 - bbox.lon0);
        if (maxArea == null || area2 > maxArea) {
          maxArea = area2;
          maxPolygon = polygon;
        }
      });
      return maxPolygon;
    }
    case "MultiPolygon": {
      let maxArea;
      let maxPolygon;
      geometry.coordinates.forEach((polygon) => {
        const bbox = polygonBbox(polygon[0], void 0);
        if (bbox == null)
          return;
        const area2 = Math.abs(bbox.lat1 - bbox.lat0) * Math.abs(bbox.lon1 - bbox.lon0);
        if (maxArea == null || area2 > maxArea) {
          maxArea = area2;
          maxPolygon = polygon;
        }
      });
      return maxPolygon;
    }
    case "Polygon":
      return geometry.coordinates;
    case "MultiLineString":
    case "LineString":
    case "MultiPoint":
    case "Point":
      return;
  }
}
function largestLineString(geometry) {
  switch (geometry.type) {
    case "GeometryCollection": {
      let maxLength;
      let maxLineString;
      geometry.geometries.map((g) => {
        const lineString = largestLineString(g);
        if (lineString == null)
          return;
        const length = lineStringLength(lineString);
        if (length == null)
          return;
        if (maxLength == null || length > maxLength) {
          maxLength = length;
          maxLineString = lineString;
        }
      });
      return maxLineString;
    }
    case "MultiLineString": {
      let maxLength = 0;
      let maxLineString;
      geometry.coordinates.forEach((lineString) => {
        const length = lineStringLength(lineString);
        if (length > maxLength) {
          maxLength = length;
          maxLineString = lineString;
        }
      });
      return maxLineString;
    }
    case "LineString":
      return geometry.coordinates;
    case "MultiPolygon":
    case "Polygon":
    case "MultiPoint":
    case "Point":
      return;
  }
}
function containsType(geometry, type) {
  if (geometry == null)
    return false;
  switch (geometry.type) {
    case "GeometryCollection":
      return geometry.geometries.some((g) => containsType(g, type));
    case "MultiPolygon":
    case "Polygon":
      return (type & 1) !== 0;
    case "MultiLineString":
    case "LineString":
      return (type & 2) !== 0;
    case "MultiPoint":
    case "Point":
      return (type & 4) !== 0;
  }
}
function projectGeometry(geometry, scale2) {
  switch (geometry.type) {
    case "GeometryCollection":
      return {
        type: "GeometryCollection",
        geometries: geometry.geometries.map((g) => projectGeometry(g, scale2))
      };
    case "Polygon":
      return {
        type: "Polygon",
        coordinates: projectPolygon(geometry.coordinates, scale2)
      };
    case "MultiPolygon":
      return {
        type: "MultiPolygon",
        coordinates: projectMultiPolygon(geometry.coordinates, scale2)
      };
    case "MultiLineString":
      return {
        type: "MultiLineString",
        coordinates: projectPolygon(geometry.coordinates, scale2)
      };
    case "LineString":
      return {
        type: "LineString",
        coordinates: projectLineString(geometry.coordinates, scale2)
      };
    case "MultiPoint":
      return {
        type: "MultiPoint",
        coordinates: projectLineString(geometry.coordinates, scale2)
      };
    case "Point":
      return {
        type: "Point",
        coordinates: scale2.convert(geometry.coordinates)
      };
  }
}
function projectMultiPolygon(multiPolygon, scale2) {
  return multiPolygon.map((polygon) => projectPolygon(polygon, scale2));
}
function projectPolygon(polygon, scale2) {
  return polygon.map((lineString) => projectLineString(lineString, scale2));
}
function projectLineString(lineString, scale2) {
  return lineString.map((lonLat) => scale2.convert(lonLat));
}
var import_ag_charts_community75 = (init_main(), __toCommonJS(main_exports));
function isValidCoordinate(v) {
  return Array.isArray(v) && v.length >= 2 && v.every(import_ag_charts_community75._ModuleSupport.isFiniteNumber);
}
function isValidCoordinates(v) {
  return Array.isArray(v) && v.length >= 2 && v.every(isValidCoordinate);
}
var delta22 = 1e-3;
function hasSameStartEndPoint(c) {
  return Math.abs(c[0][0] - c[c.length - 1][0]) < delta22 && Math.abs(c[0][1] - c[c.length - 1][1]) < delta22;
}
function isValidPolygon(v) {
  return Array.isArray(v) && v.every(isValidCoordinates) && v.every(hasSameStartEndPoint);
}
function isValidGeometry(v) {
  if (v === null)
    return true;
  if (typeof v !== "object" || v.type == null)
    return false;
  const { type, coordinates } = v;
  switch (type) {
    case "GeometryCollection":
      return Array.isArray(v.geometries) && v.geometries.every(isValidGeometry);
    case "MultiPolygon":
      return Array.isArray(coordinates) && coordinates.every(isValidPolygon);
    case "Polygon":
      return isValidPolygon(coordinates);
    case "MultiLineString":
      return Array.isArray(coordinates) && coordinates.every(isValidCoordinates);
    case "LineString":
      return isValidCoordinates(coordinates);
    case "MultiPoint":
      return isValidCoordinates(coordinates);
    case "Point":
      return isValidCoordinate(coordinates);
  }
}
function isValidFeature(v) {
  return v !== null && typeof v === "object" && v.type === "Feature" && isValidGeometry(v.geometry);
}
function isValidFeatureCollection(v) {
  return v !== null && typeof v === "object" && v.type === "FeatureCollection" && Array.isArray(v.features) && v.features.every(isValidFeature);
}
var GEOJSON_OBJECT = import_ag_charts_community75._ModuleSupport.predicateWithMessage(isValidFeatureCollection, "a GeoJSON object");
var import_ag_charts_community76 = (init_main(), __toCommonJS(main_exports));
var { COLOR_STRING: COLOR_STRING10, LINE_DASH: LINE_DASH8, OBJECT: OBJECT9, POSITIVE_NUMBER: POSITIVE_NUMBER14, RATIO: RATIO15, Validate: Validate32, SeriesProperties: SeriesProperties2, SeriesTooltip: SeriesTooltip5 } = import_ag_charts_community76._ModuleSupport;
var MapLineBackgroundSeriesProperties = class extends SeriesProperties2 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.tooltip = new SeriesTooltip5();
  }
};
__decorateClass2([
  Validate32(GEOJSON_OBJECT, { optional: true })
], MapLineBackgroundSeriesProperties.prototype, "topology", 2);
__decorateClass2([
  Validate32(COLOR_STRING10)
], MapLineBackgroundSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate32(RATIO15)
], MapLineBackgroundSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate32(POSITIVE_NUMBER14)
], MapLineBackgroundSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate32(LINE_DASH8)
], MapLineBackgroundSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate32(POSITIVE_NUMBER14)
], MapLineBackgroundSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate32(OBJECT9)
], MapLineBackgroundSeriesProperties.prototype, "tooltip", 2);
var { createDatumId: createDatumId22, DataModelSeries: DataModelSeries2, SeriesNodePickMode: SeriesNodePickMode4, Validate: Validate33 } = import_ag_charts_community77._ModuleSupport;
var { Group: Group7, Selection: Selection3, PointerEvents: PointerEvents22 } = import_ag_charts_community77._Scene;
var { Logger: Logger7 } = import_ag_charts_community77._Util;
var MapLineBackgroundSeries = class extends DataModelSeries2 {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: false,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode4.EXACT_SHAPE_MATCH]
    });
    this.properties = new MapLineBackgroundSeriesProperties();
    this._chartTopology = void 0;
    this.itemGroup = this.contentGroup.appendChild(new Group7({ name: "itemGroup" }));
    this.datumSelection = Selection3.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
  }
  getNodeData() {
    var _a2;
    return (_a2 = this.contextNodeData) == null ? void 0 : _a2.nodeData;
  }
  get topology() {
    var _a2;
    return (_a2 = this.properties.topology) != null ? _a2 : this._chartTopology;
  }
  setOptionsData() {
  }
  setChartData() {
  }
  get hasData() {
    return false;
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  nodeFactory() {
    const geoGeometry = new GeoGeometry();
    geoGeometry.renderMode = 2;
    geoGeometry.lineJoin = "round";
    geoGeometry.lineCap = "round";
    geoGeometry.pointerEvents = PointerEvents22.None;
    return geoGeometry;
  }
  processData() {
    return __async2(this, null, function* () {
      const { topology } = this;
      this.topologyBounds = topology == null ? void 0 : topology.features.reduce((current, feature) => {
        const geometry = feature.geometry;
        if (geometry == null)
          return current;
        return geometryBbox(geometry, current);
      }, void 0);
      if (topology == null) {
        Logger7.warnOnce(`no topology was provided for [MapShapeBackgroundSeries]; nothing will be rendered.`);
      }
    });
  }
  createNodeData() {
    return __async2(this, null, function* () {
      const { id: seriesId, topology, scale: scale2 } = this;
      if (topology == null)
        return;
      const nodeData = [];
      const labelData = [];
      topology.features.forEach((feature, index) => {
        const { geometry } = feature;
        const projectedGeometry = geometry != null && scale2 != null ? projectGeometry(geometry, scale2) : void 0;
        if (projectedGeometry == null)
          return;
        nodeData.push({
          series: this,
          itemId: index,
          datum: feature,
          index,
          projectedGeometry
        });
      });
      return {
        itemId: seriesId,
        nodeData,
        labelData
      };
    });
  }
  updateSelections() {
    return __async2(this, null, function* () {
      if (this.nodeDataRefresh) {
        this.contextNodeData = yield this.createNodeData();
        this.nodeDataRefresh = false;
      }
    });
  }
  update() {
    return __async2(this, null, function* () {
      var _a2;
      const { datumSelection } = this;
      yield this.updateSelections();
      this.contentGroup.visible = this.visible;
      const { nodeData = [] } = (_a2 = this.contextNodeData) != null ? _a2 : {};
      this.datumSelection = yield this.updateDatumSelection({ nodeData, datumSelection });
      yield this.updateDatumNodes({ datumSelection });
    });
  }
  updateDatumSelection(opts) {
    return __async2(this, null, function* () {
      return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId22(datum.index));
    });
  }
  updateDatumNodes(opts) {
    return __async2(this, null, function* () {
      const { properties } = this;
      const { datumSelection } = opts;
      const { stroke, strokeOpacity, lineDash, lineDashOffset } = properties;
      const strokeWidth = this.getStrokeWidth(properties.strokeWidth);
      datumSelection.each((geoGeometry, datum) => {
        const { projectedGeometry } = datum;
        if (projectedGeometry == null) {
          geoGeometry.visible = false;
          geoGeometry.projectedGeometry = void 0;
          return;
        }
        geoGeometry.visible = true;
        geoGeometry.projectedGeometry = projectedGeometry;
        geoGeometry.stroke = stroke;
        geoGeometry.strokeWidth = strokeWidth;
        geoGeometry.strokeOpacity = strokeOpacity;
        geoGeometry.lineDash = lineDash;
        geoGeometry.lineDashOffset = lineDashOffset;
      });
    });
  }
  resetAnimation() {
  }
  getLabelData() {
    return [];
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  getLegendData() {
    return [];
  }
  getTooltipHtml() {
    return import_ag_charts_community77._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
  }
  computeFocusBounds(_opts) {
    return void 0;
  }
};
MapLineBackgroundSeries.className = "MapLineBackgroundSeries";
MapLineBackgroundSeries.type = "map-line-background";
__decorateClass2([
  Validate33(GEOJSON_OBJECT, { optional: true, property: "topology" })
], MapLineBackgroundSeries.prototype, "_chartTopology", 2);
var { EXTENDS_SERIES_DEFAULTS: EXTENDS_SERIES_DEFAULTS2, DEFAULT_HIERARCHY_STROKES: DEFAULT_HIERARCHY_STROKES2 } = import_ag_charts_community78._Theme;
var MapLineBackgroundModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-line-background",
  instanceConstructor: MapLineBackgroundSeries,
  themeTemplate: __spreadProps2(__spreadValues2({}, MAP_THEME_DEFAULTS), {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS2,
      strokeWidth: 1,
      lineDash: [0],
      lineDashOffset: 0
    }
  }),
  paletteFactory: ({ themeTemplateParameters }) => {
    var _a2;
    const { properties } = themeTemplateParameters;
    return {
      stroke: (_a2 = properties.get(DEFAULT_HIERARCHY_STROKES2)) == null ? void 0 : _a2[1]
    };
  }
};
var import_ag_charts_community81 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community80 = (init_main(), __toCommonJS(main_exports));
function prepareMapMarkerAnimationFunctions() {
  const fromFn = (marker, _datum, status) => {
    if (status === "removed") {
      return { scalingX: 1, scalingY: 1 };
    } else if (marker.previousDatum == null) {
      return { scalingX: 0, scalingY: 0 };
    }
    return { scalingX: marker.scalingX, scalingY: marker.scalingY };
  };
  const toFn = (_marker, _datum, status) => {
    if (status === "removed") {
      return { scalingX: 0, scalingY: 0 };
    }
    return { scalingX: 1, scalingY: 1 };
  };
  return { fromFn, toFn };
}
function computeGeoFocusBounds(series, opts) {
  var _a2;
  const datum = (_a2 = series.contextNodeData) == null ? void 0 : _a2.nodeData[opts.datumIndex];
  if (datum === void 0)
    return void 0;
  for (const node of series.datumSelection.nodes()) {
    if (node.datum === datum) {
      return node.computeTransformedBBox();
    }
  }
  return void 0;
}
var import_ag_charts_community79 = (init_main(), __toCommonJS(main_exports));
var {
  AND: AND8,
  ARRAY: ARRAY5,
  COLOR_STRING: COLOR_STRING11,
  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY22,
  FUNCTION: FUNCTION7,
  LINE_DASH: LINE_DASH9,
  NUMBER_ARRAY: NUMBER_ARRAY2,
  OBJECT: OBJECT10,
  POSITIVE_NUMBER: POSITIVE_NUMBER15,
  RATIO: RATIO16,
  STRING: STRING11,
  Validate: Validate34,
  SeriesProperties: SeriesProperties22,
  SeriesTooltip: SeriesTooltip6
} = import_ag_charts_community79._ModuleSupport;
var { Label: Label22 } = import_ag_charts_community79._Scene;
var MapLineSeriesProperties = class extends SeriesProperties22 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.idKey = "";
    this.topologyIdKey = "name";
    this.idName = void 0;
    this.labelKey = void 0;
    this.labelName = void 0;
    this.colorRange = void 0;
    this.maxStrokeWidth = void 0;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.label = new Label22();
    this.tooltip = new SeriesTooltip6();
  }
};
__decorateClass2([
  Validate34(GEOJSON_OBJECT, { optional: true })
], MapLineSeriesProperties.prototype, "topology", 2);
__decorateClass2([
  Validate34(STRING11, { optional: true })
], MapLineSeriesProperties.prototype, "title", 2);
__decorateClass2([
  Validate34(STRING11, { optional: true })
], MapLineSeriesProperties.prototype, "legendItemName", 2);
__decorateClass2([
  Validate34(STRING11)
], MapLineSeriesProperties.prototype, "idKey", 2);
__decorateClass2([
  Validate34(STRING11)
], MapLineSeriesProperties.prototype, "topologyIdKey", 2);
__decorateClass2([
  Validate34(STRING11, { optional: true })
], MapLineSeriesProperties.prototype, "idName", 2);
__decorateClass2([
  Validate34(STRING11, { optional: true })
], MapLineSeriesProperties.prototype, "labelKey", 2);
__decorateClass2([
  Validate34(STRING11, { optional: true })
], MapLineSeriesProperties.prototype, "labelName", 2);
__decorateClass2([
  Validate34(STRING11, { optional: true })
], MapLineSeriesProperties.prototype, "sizeKey", 2);
__decorateClass2([
  Validate34(STRING11, { optional: true })
], MapLineSeriesProperties.prototype, "sizeName", 2);
__decorateClass2([
  Validate34(STRING11, { optional: true })
], MapLineSeriesProperties.prototype, "colorKey", 2);
__decorateClass2([
  Validate34(STRING11, { optional: true })
], MapLineSeriesProperties.prototype, "colorName", 2);
__decorateClass2([
  Validate34(NUMBER_ARRAY2, { optional: true })
], MapLineSeriesProperties.prototype, "sizeDomain", 2);
__decorateClass2([
  Validate34(AND8(COLOR_STRING_ARRAY22, ARRAY5.restrict({ minLength: 1 })), { optional: true })
], MapLineSeriesProperties.prototype, "colorRange", 2);
__decorateClass2([
  Validate34(POSITIVE_NUMBER15, { optional: true })
], MapLineSeriesProperties.prototype, "maxStrokeWidth", 2);
__decorateClass2([
  Validate34(COLOR_STRING11)
], MapLineSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate34(RATIO16)
], MapLineSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate34(POSITIVE_NUMBER15)
], MapLineSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate34(LINE_DASH9)
], MapLineSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate34(POSITIVE_NUMBER15)
], MapLineSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate34(FUNCTION7, { optional: true })
], MapLineSeriesProperties.prototype, "formatter", 2);
__decorateClass2([
  Validate34(OBJECT10)
], MapLineSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Validate34(OBJECT10)
], MapLineSeriesProperties.prototype, "tooltip", 2);
var { getMissCount: getMissCount22, createDatumId: createDatumId3, DataModelSeries: DataModelSeries22, SeriesNodePickMode: SeriesNodePickMode5, valueProperty: valueProperty6, Validate: Validate35 } = import_ag_charts_community80._ModuleSupport;
var { ColorScale: ColorScale22, LinearScale: LinearScale3 } = import_ag_charts_community80._Scale;
var { Selection: Selection4, Text: Text6 } = import_ag_charts_community80._Scene;
var { sanitizeHtml: sanitizeHtml4, Logger: Logger8 } = import_ag_charts_community80._Util;
var MapLineSeries = class extends DataModelSeries22 {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: false,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode5.EXACT_SHAPE_MATCH, SeriesNodePickMode5.NEAREST_NODE]
    });
    this.properties = new MapLineSeriesProperties();
    this._chartTopology = void 0;
    this.colorScale = new ColorScale22();
    this.sizeScale = new LinearScale3();
    this.datumSelection = Selection4.select(
      this.contentGroup,
      () => this.nodeFactory()
    );
    this.labelSelection = Selection4.select(
      this.labelGroup,
      Text6
    );
    this.highlightDatumSelection = Selection4.select(
      this.highlightNode,
      () => this.nodeFactory()
    );
    this._previousDatumMidPoint = void 0;
  }
  getNodeData() {
    var _a2;
    return (_a2 = this.contextNodeData) == null ? void 0 : _a2.nodeData;
  }
  get topology() {
    var _a2;
    return (_a2 = this.properties.topology) != null ? _a2 : this._chartTopology;
  }
  get hasData() {
    return super.hasData && this.topology != null;
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager.addListener("legend-item-click", (event) => {
        this.onLegendItemClick(event);
      }),
      this.ctx.chartEventManager.addListener("legend-item-double-click", (event) => {
        this.onLegendItemDoubleClick(event);
      })
    );
  }
  isLabelEnabled() {
    return this.properties.labelKey != null && this.properties.label.enabled;
  }
  nodeFactory() {
    const geoGeometry = new GeoGeometry();
    geoGeometry.renderMode = 2;
    geoGeometry.lineJoin = "round";
    geoGeometry.lineCap = "round";
    return geoGeometry;
  }
  processData(dataController) {
    return __async2(this, null, function* () {
      var _a2, _b;
      if (this.data == null || !this.properties.isValid()) {
        return;
      }
      const { data, topology, sizeScale, colorScale } = this;
      const { topologyIdKey, idKey, sizeKey, colorKey, labelKey, sizeDomain, colorRange } = this.properties;
      const featureById = /* @__PURE__ */ new Map();
      topology == null ? void 0 : topology.features.forEach((feature) => {
        var _a3;
        const property = (_a3 = feature.properties) == null ? void 0 : _a3[topologyIdKey];
        if (property == null || !containsType(
          feature.geometry,
          2
          /* LineString */
        ))
          return;
        featureById.set(property, feature);
      });
      const sizeScaleType = this.sizeScale.type;
      const colorScaleType = this.colorScale.type;
      const mercatorScaleType = (_a2 = this.scale) == null ? void 0 : _a2.type;
      const { dataModel, processedData } = yield this.requestDataModel(dataController, data, {
        props: [
          valueProperty6(idKey, mercatorScaleType, { id: "idValue", includeProperty: false }),
          valueProperty6(idKey, mercatorScaleType, {
            id: "featureValue",
            includeProperty: false,
            processor: () => (datum) => featureById.get(datum)
          }),
          ...labelKey != null ? [valueProperty6(labelKey, "band", { id: "labelValue" })] : [],
          ...sizeKey != null ? [valueProperty6(sizeKey, sizeScaleType, { id: "sizeValue" })] : [],
          ...colorKey != null ? [valueProperty6(colorKey, colorScaleType, { id: "colorValue" })] : []
        ]
      });
      const featureIdx = dataModel.resolveProcessedDataIndexById(this, `featureValue`);
      this.topologyBounds = processedData.data.reduce(
        (current, { values }) => {
          const feature = values[featureIdx];
          const geometry = feature == null ? void 0 : feature.geometry;
          if (geometry == null)
            return current;
          return geometryBbox(geometry, current);
        },
        void 0
      );
      if (sizeKey != null) {
        const sizeIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);
        const processedSize = (_b = processedData.domain.values[sizeIdx]) != null ? _b : [];
        sizeScale.domain = sizeDomain != null ? sizeDomain : processedSize;
      }
      if (colorRange != null && this.isColorScaleValid()) {
        const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
        colorScale.domain = processedData.domain.values[colorKeyIdx];
        colorScale.range = colorRange;
        colorScale.update();
      }
      if (topology == null) {
        Logger8.warnOnce(`no topology was provided for [MapLineSeries]; nothing will be rendered.`);
      }
    });
  }
  isColorScaleValid() {
    const { colorKey } = this.properties;
    if (!colorKey) {
      return false;
    }
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return false;
    }
    const colorIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
    const dataCount = processedData.data.length;
    const missCount = getMissCount22(this, processedData.defs.values[colorIdx].missing);
    const colorDataMissing = dataCount === 0 || dataCount === missCount;
    return !colorDataMissing;
  }
  getLabelDatum(datum, labelValue, projectedGeometry, font) {
    if (labelValue == null || projectedGeometry == null)
      return;
    const lineString = largestLineString(projectedGeometry);
    if (lineString == null)
      return;
    const { idKey, idName, sizeKey, sizeName, colorKey, colorName, labelKey, labelName, label } = this.properties;
    const labelText = this.getLabelText(label, {
      value: labelValue,
      datum,
      idKey,
      idName,
      sizeKey,
      sizeName,
      colorKey,
      colorName,
      labelKey,
      labelName
    });
    if (labelText == null)
      return;
    const labelSize = Text6.getTextSize(String(labelText), font);
    const labelCenter = lineStringCenter(lineString);
    if (labelCenter == null)
      return;
    const [x, y] = labelCenter.point;
    const { width, height } = labelSize;
    return {
      point: { x, y, size: 0 },
      label: { width, height, text: labelText },
      marker: void 0,
      placement: void 0
    };
  }
  createNodeData() {
    return __async2(this, null, function* () {
      var _a2;
      const { id: seriesId, dataModel, processedData, sizeScale, colorScale, properties, scale: scale2 } = this;
      const { idKey, sizeKey, colorKey, labelKey, label } = properties;
      if (dataModel == null || processedData == null)
        return;
      const colorScaleValid = this.isColorScaleValid();
      const idIdx = dataModel.resolveProcessedDataIndexById(this, `idValue`);
      const featureIdx = dataModel.resolveProcessedDataIndexById(this, `featureValue`);
      const labelIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : void 0;
      const sizeIdx = sizeKey != null ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : void 0;
      const colorIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : void 0;
      const maxStrokeWidth = (_a2 = properties.maxStrokeWidth) != null ? _a2 : properties.strokeWidth;
      sizeScale.range = [Math.min(properties.strokeWidth, maxStrokeWidth), maxStrokeWidth];
      const font = label.getFont();
      const projectedGeometries = /* @__PURE__ */ new Map();
      processedData.data.forEach(({ values }) => {
        var _a3;
        const id = values[idIdx];
        const geometry = (_a3 = values[featureIdx]) == null ? void 0 : _a3.geometry;
        const projectedGeometry = geometry != null && scale2 != null ? projectGeometry(geometry, scale2) : void 0;
        if (id != null && projectedGeometry != null) {
          projectedGeometries.set(id, projectedGeometry);
        }
      });
      const nodeData = [];
      const labelData = [];
      const missingGeometries = [];
      processedData.data.forEach(({ datum, values }) => {
        const idValue = values[idIdx];
        const colorValue = colorIdx != null ? values[colorIdx] : void 0;
        const sizeValue = sizeIdx != null ? values[sizeIdx] : void 0;
        const labelValue = labelIdx != null ? values[labelIdx] : void 0;
        const color = colorScaleValid && colorValue != null ? colorScale.convert(colorValue) : void 0;
        const size = sizeValue != null ? sizeScale.convert(sizeValue, { clampMode: "clamped" }) : void 0;
        const projectedGeometry = projectedGeometries.get(idValue);
        if (projectedGeometry == null) {
          missingGeometries.push(idValue);
        }
        const labelDatum = this.getLabelDatum(datum, labelValue, projectedGeometry, font);
        if (labelDatum != null) {
          labelData.push(labelDatum);
        }
        nodeData.push({
          series: this,
          itemId: idKey,
          datum,
          stroke: color,
          strokeWidth: size,
          idValue,
          labelValue,
          colorValue,
          sizeValue,
          projectedGeometry
        });
      });
      const missingGeometriesCap = 10;
      if (missingGeometries.length > missingGeometriesCap) {
        const excessItems = missingGeometries.length - missingGeometriesCap;
        missingGeometries.length = missingGeometriesCap;
        missingGeometries.push(`(+${excessItems} more)`);
      }
      if (missingGeometries.length > 0) {
        Logger8.warnOnce(`some data items do not have matches in the provided topology`, missingGeometries);
      }
      return {
        itemId: seriesId,
        nodeData,
        labelData
      };
    });
  }
  updateSelections() {
    return __async2(this, null, function* () {
      if (this.nodeDataRefresh) {
        this.contextNodeData = yield this.createNodeData();
        this.nodeDataRefresh = false;
      }
    });
  }
  update() {
    return __async2(this, null, function* () {
      var _a2, _b, _c;
      const { datumSelection, labelSelection, highlightDatumSelection } = this;
      yield this.updateSelections();
      this.contentGroup.visible = this.visible;
      this.contentGroup.opacity = this.getOpacity();
      let highlightedDatum = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight();
      if (highlightedDatum != null && (highlightedDatum.series !== this || highlightedDatum.datum == null)) {
        highlightedDatum = void 0;
      }
      const nodeData = (_c = (_b = this.contextNodeData) == null ? void 0 : _b.nodeData) != null ? _c : [];
      this.datumSelection = yield this.updateDatumSelection({ nodeData, datumSelection });
      yield this.updateDatumNodes({ datumSelection, isHighlight: false });
      this.labelSelection = yield this.updateLabelSelection({ labelSelection });
      yield this.updateLabelNodes({ labelSelection });
      this.highlightDatumSelection = yield this.updateDatumSelection({
        nodeData: highlightedDatum != null ? [highlightedDatum] : [],
        datumSelection: highlightDatumSelection
      });
      yield this.updateDatumNodes({ datumSelection: highlightDatumSelection, isHighlight: true });
    });
  }
  updateDatumSelection(opts) {
    return __async2(this, null, function* () {
      return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId3(datum.idValue));
    });
  }
  updateDatumNodes(opts) {
    return __async2(this, null, function* () {
      const {
        id: seriesId,
        properties,
        ctx: { callbackCache }
      } = this;
      const { datumSelection, isHighlight } = opts;
      const { idKey, labelKey, sizeKey, colorKey, stroke, strokeOpacity, lineDash, lineDashOffset, formatter } = properties;
      const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;
      const strokeWidth = this.getStrokeWidth(properties.strokeWidth);
      datumSelection.each((geoGeometry, datum) => {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
        const { projectedGeometry } = datum;
        if (projectedGeometry == null) {
          geoGeometry.visible = false;
          geoGeometry.projectedGeometry = void 0;
          return;
        }
        let format2;
        if (formatter != null) {
          const params = {
            seriesId,
            datum: datum.datum,
            itemId: datum.itemId,
            idKey,
            labelKey,
            sizeKey,
            colorKey,
            strokeOpacity,
            stroke,
            strokeWidth,
            lineDash,
            lineDashOffset,
            highlighted: isHighlight
          };
          format2 = callbackCache.call(formatter, params);
        }
        geoGeometry.visible = true;
        geoGeometry.projectedGeometry = projectedGeometry;
        geoGeometry.stroke = (_c = (_b = (_a2 = highlightStyle == null ? void 0 : highlightStyle.stroke) != null ? _a2 : format2 == null ? void 0 : format2.stroke) != null ? _b : datum.stroke) != null ? _c : stroke;
        geoGeometry.strokeWidth = Math.max(
          (_d = highlightStyle == null ? void 0 : highlightStyle.strokeWidth) != null ? _d : 0,
          (_f = (_e = format2 == null ? void 0 : format2.strokeWidth) != null ? _e : datum.strokeWidth) != null ? _f : strokeWidth
        );
        geoGeometry.strokeOpacity = (_h = (_g = highlightStyle == null ? void 0 : highlightStyle.strokeOpacity) != null ? _g : format2 == null ? void 0 : format2.strokeOpacity) != null ? _h : strokeOpacity;
        geoGeometry.lineDash = (_j = (_i = highlightStyle == null ? void 0 : highlightStyle.lineDash) != null ? _i : format2 == null ? void 0 : format2.lineDash) != null ? _j : lineDash;
        geoGeometry.lineDashOffset = (_l = (_k = highlightStyle == null ? void 0 : highlightStyle.lineDashOffset) != null ? _k : format2 == null ? void 0 : format2.lineDashOffset) != null ? _l : lineDashOffset;
      });
    });
  }
  updateLabelSelection(opts) {
    return __async2(this, null, function* () {
      var _a2, _b;
      const placedLabels = (_b = this.isLabelEnabled() ? (_a2 = this.chart) == null ? void 0 : _a2.placeLabels().get(this) : void 0) != null ? _b : [];
      return opts.labelSelection.update(placedLabels);
    });
  }
  updateLabelNodes(opts) {
    return __async2(this, null, function* () {
      const { labelSelection } = opts;
      const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = this.properties.label;
      labelSelection.each((label, { x, y, width, height, text }) => {
        label.visible = true;
        label.x = x + width / 2;
        label.y = y + height / 2;
        label.text = text;
        label.fill = fill;
        label.fontStyle = fontStyle;
        label.fontWeight = fontWeight;
        label.fontSize = fontSize;
        label.fontFamily = fontFamily;
        label.textAlign = "center";
        label.textBaseline = "middle";
      });
    });
  }
  onLegendItemClick(event) {
    const { legendItemName } = this.properties;
    const { enabled, itemId, series } = event;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const { legendItemName } = this.properties;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, true);
    } else if (enabled && numVisibleItems === 1) {
      this.toggleSeriesItem(itemId, true);
    } else {
      this.toggleSeriesItem(itemId, false);
    }
  }
  resetAnimation() {
  }
  getLabelData() {
    var _a2, _b;
    return (_b = (_a2 = this.contextNodeData) == null ? void 0 : _a2.labelData) != null ? _b : [];
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  pickNodeClosestDatum({ x, y }) {
    let minDistance = Infinity;
    let minDatum;
    this.datumSelection.each((node, datum) => {
      const distance2 = node.distanceToPoint(x, y);
      if (distance2 < minDistance) {
        minDistance = distance2;
        minDatum = datum;
      }
    });
    return minDatum != null ? { datum: minDatum, distance: minDistance } : void 0;
  }
  datumMidPoint(datum) {
    var _a2;
    const { _previousDatumMidPoint } = this;
    if ((_previousDatumMidPoint == null ? void 0 : _previousDatumMidPoint.datum) === datum) {
      return _previousDatumMidPoint.point;
    }
    const projectedGeometry = datum.projectedGeometry;
    const lineString = projectedGeometry != null ? largestLineString(projectedGeometry) : void 0;
    const center = lineString != null ? (_a2 = lineStringCenter(lineString)) == null ? void 0 : _a2.point : void 0;
    const point = center != null ? { x: center[0], y: center[1] } : void 0;
    this._previousDatumMidPoint = { datum, point };
    return point;
  }
  getLegendData(legendType) {
    var _a2, _b, _c, _d;
    const { processedData, dataModel } = this;
    if (processedData == null || dataModel == null)
      return [];
    const {
      title,
      legendItemName,
      idKey,
      idName,
      colorKey,
      colorName,
      colorRange,
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      visible
    } = this.properties;
    if (legendType === "gradient" && colorKey != null && colorRange != null) {
      const colorDomain = processedData.domain.values[dataModel.resolveProcessedDataIndexById(this, "colorValue")];
      const legendDatum = {
        legendType: "gradient",
        enabled: visible,
        seriesId: this.id,
        colorName,
        colorRange,
        colorDomain
      };
      return [legendDatum];
    } else if (legendType === "category") {
      const legendDatum = {
        legendType: "category",
        id: this.id,
        itemId: (_b = (_a2 = legendItemName != null ? legendItemName : title) != null ? _a2 : idName) != null ? _b : idKey,
        seriesId: this.id,
        enabled: visible,
        label: { text: (_d = (_c = legendItemName != null ? legendItemName : title) != null ? _c : idName) != null ? _d : idKey },
        marker: {
          fill: stroke,
          fillOpacity: strokeOpacity,
          stroke: void 0,
          strokeWidth: 0,
          strokeOpacity: 0,
          enabled: false
        },
        line: {
          stroke,
          strokeOpacity,
          strokeWidth,
          lineDash
        },
        legendItemName
      };
      return [legendDatum];
    } else {
      return [];
    }
  }
  getTooltipHtml(nodeDatum) {
    var _a2, _b, _c, _d, _e;
    const {
      id: seriesId,
      processedData,
      properties,
      ctx: { callbackCache }
    } = this;
    if (!processedData || !properties.isValid()) {
      return import_ag_charts_community80._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const {
      legendItemName,
      idKey,
      idName,
      colorKey,
      colorName,
      sizeKey,
      sizeName,
      labelKey,
      labelName,
      formatter,
      tooltip
    } = properties;
    const { datum, stroke, idValue, colorValue, sizeValue, labelValue, itemId } = nodeDatum;
    const title = (_b = sanitizeHtml4((_a2 = properties.title) != null ? _a2 : legendItemName)) != null ? _b : "";
    const contentLines = [];
    contentLines.push(sanitizeHtml4((idName != null ? `${idName}: ` : "") + idValue));
    if (colorValue != null) {
      contentLines.push(sanitizeHtml4((colorName != null ? colorName : colorKey) + ": " + colorValue));
    }
    if (sizeValue != null) {
      contentLines.push(sanitizeHtml4((sizeName != null ? sizeName : sizeKey) + ": " + sizeValue));
    }
    if (labelValue != null && labelKey !== idKey) {
      contentLines.push(sanitizeHtml4((labelName != null ? labelName : labelKey) + ": " + labelValue));
    }
    const content = contentLines.join("<br>");
    let format2;
    if (formatter) {
      format2 = callbackCache.call(formatter, {
        seriesId,
        datum,
        idKey,
        stroke,
        strokeWidth: this.getStrokeWidth((_c = nodeDatum.strokeWidth) != null ? _c : properties.strokeWidth),
        highlighted: false
      });
    }
    const color = (_e = (_d = format2 == null ? void 0 : format2.stroke) != null ? _d : stroke) != null ? _e : properties.stroke;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      __spreadValues2({
        seriesId,
        datum,
        idKey,
        title,
        color,
        itemId,
        sizeKey,
        colorKey,
        colorName,
        idName,
        labelKey,
        labelName,
        sizeName
      }, this.getModuleTooltipParams())
    );
  }
  computeFocusBounds(opts) {
    return computeGeoFocusBounds(this, opts);
  }
};
MapLineSeries.className = "MapLineSeries";
MapLineSeries.type = "map-line";
__decorateClass2([
  Validate35(GEOJSON_OBJECT, { optional: true, property: "topology" })
], MapLineSeries.prototype, "_chartTopology", 2);
var {
  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE2,
  EXTENDS_SERIES_DEFAULTS: EXTENDS_SERIES_DEFAULTS22,
  DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY2,
  DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR2,
  singleSeriesPaletteFactory: singleSeriesPaletteFactory2
} = import_ag_charts_community81._Theme;
var MapLineModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-line",
  instanceConstructor: MapLineSeries,
  themeTemplate: __spreadProps2(__spreadValues2({}, MAP_THEME_DEFAULTS), {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS22,
      strokeWidth: 1,
      maxStrokeWidth: 3,
      lineDash: [0],
      lineDashOffset: 0,
      label: {
        enabled: true,
        fontStyle: void 0,
        fontWeight: void 0,
        fontSize: 12,
        fontFamily: DEFAULT_FONT_FAMILY2,
        color: DEFAULT_LABEL_COLOUR2
      }
    }
  }),
  paletteFactory: (opts) => {
    const { takeColors, colorsCount, userPalette, themeTemplateParameters } = opts;
    const { fill } = singleSeriesPaletteFactory2(opts);
    const { properties } = themeTemplateParameters;
    const defaultColorRange = properties.get(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE2);
    const { fills } = takeColors(colorsCount);
    return {
      colorRange: userPalette ? [fills[0], fills[1]] : defaultColorRange,
      stroke: fill
    };
  }
};
var import_ag_charts_community84 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community83 = (init_main(), __toCommonJS(main_exports));
function polygonPointSearch(polygons, precision, valueFn) {
  const bbox = polygonBbox(polygons[0], void 0);
  if (bbox == null)
    return;
  const boundingXCenter = (bbox.lon0 + bbox.lon1) / 2;
  const boundingYCenter = (bbox.lat0 + bbox.lat1) / 2;
  const boundingWidth = Math.abs(bbox.lon1 - bbox.lon0);
  const boundingHeight = Math.abs(bbox.lat1 - bbox.lat0);
  const centroid = polygonCentroid(polygons[0]);
  const [cx, cy] = centroid;
  const centroidDistanceToPolygon = -polygonDistance(polygons, cx, cy);
  let bestResult;
  const cellValue = (distanceToPolygon, distanceToCentroid) => {
    const centroidDriftFactor = 0.5;
    const centroidDrift = Math.max(distanceToCentroid - centroidDistanceToPolygon, 0);
    return distanceToPolygon - centroidDriftFactor * centroidDrift;
  };
  const createLabelPlacement = (x2, y2, stride) => {
    const { distance: distance22, maxDistance } = valueFn(polygons, x2, y2, stride);
    const distanceToCentroid = Math.hypot(cx - x2, cy - y2);
    const maxXTowardsCentroid = Math.min(Math.max(cx, x2 - stride / 2), x2 + stride / 2);
    const maxYTowardsCentroid = Math.min(Math.max(cy, y2 - stride / 2), y2 + stride / 2);
    const minDistanceToCentroid = Math.hypot(cx - maxXTowardsCentroid, cy - maxYTowardsCentroid);
    const value = cellValue(distance22, distanceToCentroid);
    const maxValue = cellValue(maxDistance, minDistanceToCentroid);
    return { distance: distance22, maxDistance, value, maxValue, x: x2, y: y2, stride };
  };
  const appendLabelPlacement = (into, x2, y2, stride) => {
    const labelPlacement = createLabelPlacement(x2, y2, stride);
    if (labelPlacement.maxDistance >= 0) {
      into.push(labelPlacement);
    }
  };
  const initialStride = Math.min(boundingWidth, boundingHeight) / 2;
  let queue = {
    value: createLabelPlacement(boundingXCenter, boundingYCenter, initialStride),
    next: null
  };
  while (queue != null) {
    const item = queue.value;
    const { distance: distance22, value, maxValue, x: x2, y: y2, stride } = item;
    queue = queue.next;
    if (distance22 > 0 && (bestResult == null || value > bestResult.value)) {
      bestResult = item;
    }
    if (bestResult != null && maxValue - bestResult.value <= precision) {
      continue;
    }
    const nextStride = stride / 2;
    const newLabelPlacements = [];
    appendLabelPlacement(newLabelPlacements, x2 - nextStride, y2 - nextStride, nextStride);
    appendLabelPlacement(newLabelPlacements, x2 + nextStride, y2 - nextStride, nextStride);
    appendLabelPlacement(newLabelPlacements, x2 - nextStride, y2 + nextStride, nextStride);
    appendLabelPlacement(newLabelPlacements, x2 + nextStride, y2 + nextStride, nextStride);
    newLabelPlacements.sort(labelPlacementCmp);
    queue = insertManySorted(queue, newLabelPlacements, labelPlacementCmp);
  }
  if (bestResult == null)
    return;
  const { distance: distance2, x, y } = bestResult;
  return { x, y, distance: distance2 };
}
var labelPlacementCmp = (a, b) => b.maxValue - a.maxValue;
function polygonMarkerCenter(polygons, precision) {
  const result = polygonPointSearch(polygons, precision, (p, x2, y2, stride) => {
    const distance2 = -polygonDistance(p, x2, y2);
    const maxDistance = distance2 + stride * Math.SQRT2;
    return { distance: distance2, maxDistance };
  });
  if (result == null)
    return;
  const { x, y } = result;
  return [x, y];
}
function markerPositions(geometry, precision) {
  var _a2, _b;
  let center;
  switch (geometry.type) {
    case "GeometryCollection":
      return geometry.geometries.flatMap((g) => markerPositions(g, precision));
    case "MultiPoint":
      return geometry.coordinates;
    case "Point":
      return [geometry.coordinates];
    case "MultiPolygon": {
      const polygon = largestPolygon(geometry);
      center = polygon != null ? polygonMarkerCenter(polygon, precision) : void 0;
      break;
    }
    case "Polygon": {
      const polygon = geometry.coordinates;
      center = polygon != null ? polygonMarkerCenter(polygon, precision) : void 0;
      break;
    }
    case "MultiLineString": {
      const lineString = largestLineString(geometry);
      center = lineString != null ? (_a2 = lineStringCenter(lineString)) == null ? void 0 : _a2.point : void 0;
      break;
    }
    case "LineString": {
      const lineString = geometry.coordinates;
      center = (_b = lineStringCenter(lineString)) == null ? void 0 : _b.point;
      break;
    }
  }
  return center != null ? [center] : [];
}
var import_ag_charts_community82 = (init_main(), __toCommonJS(main_exports));
var {
  AND: AND9,
  ARRAY: ARRAY6,
  COLOR_STRING: COLOR_STRING12,
  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY3,
  FUNCTION: FUNCTION8,
  NUMBER_ARRAY: NUMBER_ARRAY22,
  OBJECT: OBJECT11,
  POSITIVE_NUMBER: POSITIVE_NUMBER16,
  RATIO: RATIO17,
  STRING: STRING12,
  MARKER_SHAPE: MARKER_SHAPE2,
  Validate: Validate36,
  SeriesProperties: SeriesProperties3,
  SeriesTooltip: SeriesTooltip7
} = import_ag_charts_community82._ModuleSupport;
var { Label: Label3, Circle: Circle2 } = import_ag_charts_community82._Scene;
var { Logger: Logger9 } = import_ag_charts_community82._Util;
var MapMarkerSeriesLabel = class extends Label3 {
  constructor() {
    super(...arguments);
    this.placement = "bottom";
  }
};
__decorateClass2([
  Validate36(STRING12)
], MapMarkerSeriesLabel.prototype, "placement", 2);
var MapMarkerSeriesProperties = class extends SeriesProperties3 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.idKey = void 0;
    this.topologyIdKey = "name";
    this.idName = void 0;
    this.latitudeKey = void 0;
    this.latitudeName = void 0;
    this.longitudeKey = void 0;
    this.longitudeName = void 0;
    this.labelKey = void 0;
    this.labelName = void 0;
    this.colorRange = void 0;
    this.shape = Circle2;
    this.size = 6;
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.label = new MapMarkerSeriesLabel();
    this.tooltip = new SeriesTooltip7();
  }
  isValid() {
    const superIsValid = super.isValid();
    const hasTopology = this.idKey != null;
    const hasLatLon = this.latitudeKey != null && this.longitudeKey != null;
    if (!hasTopology && !hasLatLon) {
      Logger9.warnOnce(
        "Either both [topology] and [idKey] or both [latitudeKey] and [longitudeKey] must be set to render a map marker series."
      );
      return false;
    }
    return superIsValid;
  }
};
__decorateClass2([
  Validate36(GEOJSON_OBJECT, { optional: true })
], MapMarkerSeriesProperties.prototype, "topology", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "title", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "legendItemName", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "idKey", 2);
__decorateClass2([
  Validate36(STRING12)
], MapMarkerSeriesProperties.prototype, "topologyIdKey", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "idName", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "latitudeKey", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "latitudeName", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "longitudeKey", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "longitudeName", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "labelKey", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "labelName", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "sizeKey", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "sizeName", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "colorKey", 2);
__decorateClass2([
  Validate36(STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "colorName", 2);
__decorateClass2([
  Validate36(AND9(COLOR_STRING_ARRAY3, ARRAY6.restrict({ minLength: 1 })), { optional: true })
], MapMarkerSeriesProperties.prototype, "colorRange", 2);
__decorateClass2([
  Validate36(MARKER_SHAPE2)
], MapMarkerSeriesProperties.prototype, "shape", 2);
__decorateClass2([
  Validate36(POSITIVE_NUMBER16)
], MapMarkerSeriesProperties.prototype, "size", 2);
__decorateClass2([
  Validate36(POSITIVE_NUMBER16, { optional: true })
], MapMarkerSeriesProperties.prototype, "maxSize", 2);
__decorateClass2([
  Validate36(NUMBER_ARRAY22, { optional: true })
], MapMarkerSeriesProperties.prototype, "sizeDomain", 2);
__decorateClass2([
  Validate36(COLOR_STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "fill", 2);
__decorateClass2([
  Validate36(RATIO17)
], MapMarkerSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate36(COLOR_STRING12, { optional: true })
], MapMarkerSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate36(POSITIVE_NUMBER16)
], MapMarkerSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate36(RATIO17)
], MapMarkerSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate36(FUNCTION8, { optional: true })
], MapMarkerSeriesProperties.prototype, "formatter", 2);
__decorateClass2([
  Validate36(OBJECT11)
], MapMarkerSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Validate36(OBJECT11)
], MapMarkerSeriesProperties.prototype, "tooltip", 2);
var {
  Validate: Validate37,
  fromToMotion: fromToMotion22,
  StateMachine: StateMachine2,
  getMissCount: getMissCount3,
  createDatumId: createDatumId4,
  DataModelSeries: DataModelSeries3,
  SeriesNodePickMode: SeriesNodePickMode6,
  Layers: Layers6,
  valueProperty: valueProperty7,
  computeMarkerFocusBounds: computeMarkerFocusBounds2
} = import_ag_charts_community83._ModuleSupport;
var { ColorScale: ColorScale3, LinearScale: LinearScale4 } = import_ag_charts_community83._Scale;
var { Group: Group8, Selection: Selection5, Text: Text7, getMarker: getMarker2 } = import_ag_charts_community83._Scene;
var { sanitizeHtml: sanitizeHtml5, Logger: Logger10 } = import_ag_charts_community83._Util;
var MapMarkerSeries = class extends DataModelSeries3 {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: true,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode6.EXACT_SHAPE_MATCH, SeriesNodePickMode6.NEAREST_NODE]
    });
    this.properties = new MapMarkerSeriesProperties();
    this._chartTopology = void 0;
    this.colorScale = new ColorScale3();
    this.sizeScale = new LinearScale4();
    this.markerGroup = this.contentGroup.appendChild(
      new Group8({
        name: "markerGroup",
        layer: true,
        isVirtual: false,
        zIndex: Layers6.SERIES_LAYER_ZINDEX,
        zIndexSubOrder: this.getGroupZIndexSubOrder("marker")
      })
    );
    this.labelSelection = Selection5.select(
      this.labelGroup,
      Text7,
      false
    );
    this.markerSelection = Selection5.select(
      this.markerGroup,
      () => this.markerFactory(),
      false
    );
    this.highlightMarkerSelection = Selection5.select(
      this.highlightNode,
      () => this.markerFactory()
    );
    this.animationState = new StateMachine2(
      "empty",
      {
        empty: {
          update: {
            target: "ready",
            action: () => this.animateMarkers()
          },
          reset: "empty",
          skip: "ready"
        },
        ready: {
          updateData: "waiting",
          clear: "clearing",
          resize: () => this.resetAllAnimation(),
          reset: "empty",
          skip: "ready"
        },
        waiting: {
          update: {
            target: "ready",
            action: () => this.animateMarkers()
          },
          reset: "empty",
          skip: "ready"
        },
        clearing: {
          update: {
            target: "empty",
            action: () => this.resetAllAnimation()
          },
          reset: "empty",
          skip: "ready"
        }
      },
      () => this.checkProcessedDataAnimatable()
    );
  }
  getNodeData() {
    var _a2;
    return (_a2 = this.contextNodeData) == null ? void 0 : _a2.nodeData;
  }
  get topology() {
    var _a2;
    return (_a2 = this.properties.topology) != null ? _a2 : this._chartTopology;
  }
  get hasData() {
    const hasLatLon = this.properties.latitudeKey != null && this.properties.longitudeKey != null;
    return super.hasData && (this.topology != null || hasLatLon);
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager.addListener("legend-item-click", (event) => {
        this.onLegendItemClick(event);
      }),
      this.ctx.chartEventManager.addListener("legend-item-double-click", (event) => {
        this.onLegendItemDoubleClick(event);
      })
    );
  }
  isLabelEnabled() {
    return this.properties.labelKey != null && this.properties.label.enabled;
  }
  markerFactory() {
    const { shape } = this.properties;
    const MarkerShape = getMarker2(shape);
    return new MarkerShape();
  }
  processData(dataController) {
    return __async2(this, null, function* () {
      var _a2, _b;
      if (this.data == null || !this.properties.isValid()) {
        return;
      }
      const { data, topology, sizeScale, colorScale } = this;
      const { topologyIdKey, idKey, latitudeKey, longitudeKey, sizeKey, colorKey, labelKey, sizeDomain, colorRange } = this.properties;
      const featureById = /* @__PURE__ */ new Map();
      topology == null ? void 0 : topology.features.forEach((feature) => {
        var _a3;
        const property = (_a3 = feature.properties) == null ? void 0 : _a3[topologyIdKey];
        if (property == null)
          return;
        featureById.set(property, feature);
      });
      const sizeScaleType = this.sizeScale.type;
      const colorScaleType = this.colorScale.type;
      const mercatorScaleType = (_a2 = this.scale) == null ? void 0 : _a2.type;
      const hasLatLon = latitudeKey != null && longitudeKey != null;
      const { dataModel, processedData } = yield this.requestDataModel(dataController, data, {
        props: [
          ...idKey != null ? [
            valueProperty7(idKey, mercatorScaleType, { id: "idValue", includeProperty: false }),
            valueProperty7(idKey, mercatorScaleType, {
              id: "featureValue",
              includeProperty: false,
              processor: () => (datum) => featureById.get(datum)
            })
          ] : [],
          ...hasLatLon ? [
            valueProperty7(latitudeKey, mercatorScaleType, { id: "latValue" }),
            valueProperty7(longitudeKey, mercatorScaleType, { id: "lonValue" })
          ] : [],
          ...labelKey ? [valueProperty7(labelKey, "band", { id: "labelValue" })] : [],
          ...sizeKey ? [valueProperty7(sizeKey, sizeScaleType, { id: "sizeValue" })] : [],
          ...colorKey ? [valueProperty7(colorKey, colorScaleType, { id: "colorValue" })] : []
        ]
      });
      const featureIdx = idKey != null ? dataModel.resolveProcessedDataIndexById(this, `featureValue`) : void 0;
      const latIdx = hasLatLon ? dataModel.resolveProcessedDataIndexById(this, `latValue`) : void 0;
      const lonIdx = hasLatLon ? dataModel.resolveProcessedDataIndexById(this, `lonValue`) : void 0;
      this.topologyBounds = processedData.data.reduce(
        (current, { values }) => {
          const feature = featureIdx != null ? values[featureIdx] : void 0;
          const geometry = feature == null ? void 0 : feature.geometry;
          if (geometry != null) {
            current = geometryBbox(geometry, current);
          }
          if (latIdx != null && lonIdx != null) {
            const lon = values[lonIdx];
            const lat = values[latIdx];
            current = extendBbox(current, lon, lat, lon, lat);
          }
          return current;
        },
        void 0
      );
      if (sizeKey != null) {
        const sizeIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);
        const processedSize = (_b = processedData.domain.values[sizeIdx]) != null ? _b : [];
        sizeScale.domain = sizeDomain != null ? sizeDomain : processedSize;
      }
      if (colorRange != null && this.isColorScaleValid()) {
        const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
        colorScale.domain = processedData.domain.values[colorKeyIdx];
        colorScale.range = colorRange;
        colorScale.update();
      }
      this.animationState.transition("updateData");
    });
  }
  isColorScaleValid() {
    const { colorKey } = this.properties;
    if (!colorKey) {
      return false;
    }
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return false;
    }
    const colorIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
    const dataCount = processedData.data.length;
    const missCount = getMissCount3(this, processedData.defs.values[colorIdx].missing);
    const colorDataMissing = dataCount === 0 || dataCount === missCount;
    return !colorDataMissing;
  }
  getLabelDatum(datum, labelValue, x, y, size, font) {
    if (labelValue == null)
      return;
    const {
      idKey,
      idName,
      latitudeKey,
      latitudeName,
      longitudeKey,
      longitudeName,
      sizeKey,
      sizeName,
      colorKey,
      colorName,
      labelKey,
      labelName,
      label
    } = this.properties;
    const { placement } = label;
    const labelText = this.getLabelText(label, {
      value: labelValue,
      datum,
      idKey,
      idName,
      latitudeKey,
      latitudeName,
      longitudeKey,
      longitudeName,
      sizeKey,
      sizeName,
      colorKey,
      colorName,
      labelKey,
      labelName
    });
    if (labelText == null)
      return;
    const { width, height } = Text7.getTextSize(String(labelText), font);
    return {
      point: { x, y, size },
      label: { width, height, text: labelText },
      marker: getMarker2(this.properties.shape),
      placement
    };
  }
  createNodeData() {
    return __async2(this, null, function* () {
      var _a2;
      const { id: seriesId, dataModel, processedData, colorScale, sizeScale, properties, scale: scale2 } = this;
      const { idKey, latitudeKey, longitudeKey, sizeKey, colorKey, labelKey, label } = properties;
      if (dataModel == null || processedData == null || scale2 == null)
        return;
      const colorScaleValid = this.isColorScaleValid();
      const hasLatLon = latitudeKey != null && longitudeKey != null;
      const idIdx = idKey != null ? dataModel.resolveProcessedDataIndexById(this, `idValue`) : void 0;
      const featureIdx = idKey != null ? dataModel.resolveProcessedDataIndexById(this, `featureValue`) : void 0;
      const latIdx = hasLatLon ? dataModel.resolveProcessedDataIndexById(this, `latValue`) : void 0;
      const lonIdx = hasLatLon ? dataModel.resolveProcessedDataIndexById(this, `lonValue`) : void 0;
      const labelIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : void 0;
      const sizeIdx = sizeKey != null ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : void 0;
      const colorIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : void 0;
      const markerMaxSize = (_a2 = properties.maxSize) != null ? _a2 : properties.size;
      sizeScale.range = [Math.min(properties.size, markerMaxSize), markerMaxSize];
      const font = label.getFont();
      let projectedGeometries;
      if (idIdx != null && featureIdx != null) {
        projectedGeometries = /* @__PURE__ */ new Map();
        processedData.data.forEach(({ values }) => {
          var _a3;
          const id = values[idIdx];
          const geometry = (_a3 = values[featureIdx]) == null ? void 0 : _a3.geometry;
          const projectedGeometry = geometry != null && scale2 != null ? projectGeometry(geometry, scale2) : void 0;
          if (id != null && projectedGeometry != null) {
            projectedGeometries.set(id, projectedGeometry);
          }
        });
      }
      const nodeData = [];
      const labelData = [];
      const missingGeometries = [];
      processedData.data.forEach(({ datum, values }) => {
        const idValue = idIdx != null ? values[idIdx] : void 0;
        const lonValue = lonIdx != null ? values[lonIdx] : void 0;
        const latValue = latIdx != null ? values[latIdx] : void 0;
        const colorValue = colorIdx != null ? values[colorIdx] : void 0;
        const sizeValue = sizeIdx != null ? values[sizeIdx] : void 0;
        const labelValue = labelIdx != null ? values[labelIdx] : void 0;
        const color = colorScaleValid && colorValue != null ? colorScale.convert(colorValue) : void 0;
        const size = sizeValue != null ? sizeScale.convert(sizeValue, { clampMode: "clamped" }) : properties.size;
        const projectedGeometry = idValue != null ? projectedGeometries == null ? void 0 : projectedGeometries.get(idValue) : void 0;
        if (idValue != null && projectGeometry == null) {
          missingGeometries.push(idValue);
        }
        if (lonValue != null && latValue != null) {
          const [x, y] = scale2.convert([lonValue, latValue]);
          const labelDatum = this.getLabelDatum(datum, labelValue, x, y, size, font);
          if (labelDatum) {
            labelData.push(labelDatum);
          }
          nodeData.push({
            series: this,
            itemId: latitudeKey,
            datum,
            index: -1,
            fill: color,
            idValue,
            lonValue,
            latValue,
            labelValue,
            sizeValue,
            colorValue,
            point: { x, y, size },
            midPoint: { x, y }
          });
        } else if (projectedGeometry != null) {
          markerPositions(projectedGeometry, 1).forEach(([x, y], index) => {
            const labelDatum = this.getLabelDatum(datum, labelValue, x, y, size, font);
            if (labelDatum) {
              labelData.push(labelDatum);
            }
            nodeData.push({
              series: this,
              itemId: latitudeKey,
              datum,
              index,
              fill: color,
              idValue,
              lonValue,
              latValue,
              labelValue,
              sizeValue,
              colorValue,
              point: { x, y, size },
              midPoint: { x, y }
            });
          });
        }
      });
      const missingGeometriesCap = 10;
      if (missingGeometries.length > missingGeometriesCap) {
        const excessItems = missingGeometries.length - missingGeometriesCap;
        missingGeometries.length = missingGeometriesCap;
        missingGeometries.push(`(+${excessItems} more)`);
      }
      if (missingGeometries.length > 0) {
        Logger10.warnOnce(`some data items do not have matches in the provided topology`, missingGeometries);
      }
      return {
        itemId: seriesId,
        nodeData,
        labelData
      };
    });
  }
  updateSelections() {
    return __async2(this, null, function* () {
      if (this.nodeDataRefresh) {
        this.contextNodeData = yield this.createNodeData();
        this.nodeDataRefresh = false;
      }
    });
  }
  update(_0) {
    return __async2(this, arguments, function* ({ seriesRect }) {
      var _a2, _b, _c;
      const { labelSelection, markerSelection, highlightMarkerSelection } = this;
      yield this.updateSelections();
      this.contentGroup.visible = this.visible;
      this.contentGroup.opacity = this.getOpacity();
      let highlightedDatum = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight();
      if (highlightedDatum != null && (highlightedDatum.series !== this || highlightedDatum.datum == null)) {
        highlightedDatum = void 0;
      }
      const nodeData = (_c = (_b = this.contextNodeData) == null ? void 0 : _b.nodeData) != null ? _c : [];
      this.labelSelection = yield this.updateLabelSelection({ labelSelection });
      yield this.updateLabelNodes({ labelSelection });
      this.markerSelection = yield this.updateMarkerSelection({ markerData: nodeData, markerSelection });
      yield this.updateMarkerNodes({ markerSelection, isHighlight: false, highlightedDatum });
      this.highlightMarkerSelection = yield this.updateMarkerSelection({
        markerData: highlightedDatum != null ? [highlightedDatum] : [],
        markerSelection: highlightMarkerSelection
      });
      yield this.updateMarkerNodes({
        markerSelection: highlightMarkerSelection,
        isHighlight: true,
        highlightedDatum
      });
      const resize = this.checkResize(seriesRect);
      if (resize) {
        this.animationState.transition("resize");
      }
      this.animationState.transition("update");
    });
  }
  updateLabelSelection(opts) {
    return __async2(this, null, function* () {
      var _a2, _b;
      const placedLabels = (_b = this.isLabelEnabled() ? (_a2 = this.chart) == null ? void 0 : _a2.placeLabels().get(this) : void 0) != null ? _b : [];
      return opts.labelSelection.update(placedLabels);
    });
  }
  updateLabelNodes(opts) {
    return __async2(this, null, function* () {
      const { labelSelection } = opts;
      const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = this.properties.label;
      labelSelection.each((label, { x, y, width, height, text }) => {
        label.visible = true;
        label.x = x + width / 2;
        label.y = y + height / 2;
        label.text = text;
        label.fill = fill;
        label.fontStyle = fontStyle;
        label.fontWeight = fontWeight;
        label.fontSize = fontSize;
        label.fontFamily = fontFamily;
        label.textAlign = "center";
        label.textBaseline = "middle";
      });
    });
  }
  updateMarkerSelection(opts) {
    return __async2(this, null, function* () {
      const { markerData, markerSelection } = opts;
      return markerSelection.update(
        markerData,
        void 0,
        (datum) => createDatumId4([datum.index, datum.idValue, datum.lonValue, datum.latValue])
      );
    });
  }
  updateMarkerNodes(opts) {
    return __async2(this, null, function* () {
      const {
        id: seriesId,
        properties,
        ctx: { callbackCache }
      } = this;
      const { markerSelection, isHighlight, highlightedDatum } = opts;
      const {
        idKey,
        latitudeKey,
        longitudeKey,
        labelKey,
        sizeKey,
        colorKey,
        fill,
        fillOpacity,
        stroke,
        strokeOpacity,
        formatter
      } = properties;
      const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;
      const strokeWidth = this.getStrokeWidth(properties.strokeWidth);
      markerSelection.each((marker, markerDatum) => {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        const { datum, point } = markerDatum;
        let format2;
        if (formatter != null) {
          const params = {
            seriesId,
            datum: markerDatum.datum,
            itemId: markerDatum.itemId,
            size: point.size,
            idKey,
            latitudeKey,
            longitudeKey,
            labelKey,
            sizeKey,
            colorKey,
            fill,
            fillOpacity,
            stroke,
            strokeWidth,
            strokeOpacity,
            highlighted: isHighlight
          };
          format2 = callbackCache.call(
            formatter,
            params
          );
        }
        marker.size = point.size;
        marker.fill = (_c = (_b = (_a2 = highlightStyle == null ? void 0 : highlightStyle.fill) != null ? _a2 : format2 == null ? void 0 : format2.fill) != null ? _b : markerDatum.fill) != null ? _c : fill;
        marker.fillOpacity = (_e = (_d = highlightStyle == null ? void 0 : highlightStyle.fillOpacity) != null ? _d : format2 == null ? void 0 : format2.fillOpacity) != null ? _e : fillOpacity;
        marker.stroke = (_g = (_f = highlightStyle == null ? void 0 : highlightStyle.stroke) != null ? _f : format2 == null ? void 0 : format2.stroke) != null ? _g : stroke;
        marker.strokeWidth = (_i = (_h = highlightStyle == null ? void 0 : highlightStyle.strokeWidth) != null ? _h : format2 == null ? void 0 : format2.strokeWidth) != null ? _i : strokeWidth;
        marker.strokeOpacity = (_k = (_j = highlightStyle == null ? void 0 : highlightStyle.strokeOpacity) != null ? _j : format2 == null ? void 0 : format2.strokeOpacity) != null ? _k : strokeOpacity;
        marker.translationX = point.x;
        marker.translationY = point.y;
        marker.zIndex = !isHighlight && highlightedDatum != null && datum === highlightedDatum.datum ? 1 : 0;
      });
    });
  }
  onLegendItemClick(event) {
    const { legendItemName } = this.properties;
    const { enabled, itemId, series } = event;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const { legendItemName } = this.properties;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, true);
    } else if (enabled && numVisibleItems === 1) {
      this.toggleSeriesItem(itemId, true);
    } else {
      this.toggleSeriesItem(itemId, false);
    }
  }
  isProcessedDataAnimatable() {
    return true;
  }
  resetAnimation(phase) {
    if (phase === "initial") {
      this.animationState.transition("reset");
    } else if (phase === "ready") {
      this.animationState.transition("skip");
    }
  }
  resetAllAnimation() {
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    this.ctx.animationManager.skipCurrentBatch();
    this.labelSelection.cleanup();
    this.markerSelection.cleanup();
    this.highlightMarkerSelection.cleanup();
  }
  animateMarkers() {
    const { animationManager } = this.ctx;
    const fns = prepareMapMarkerAnimationFunctions();
    fromToMotion22(this.id, "markers", animationManager, [this.markerSelection, this.highlightMarkerSelection], fns);
  }
  getLabelData() {
    var _a2, _b;
    return (_b = (_a2 = this.contextNodeData) == null ? void 0 : _a2.labelData) != null ? _b : [];
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  pickNodeClosestDatum(p) {
    var _a2;
    const { x: x0, y: y0 } = this.rootGroup.transformPoint(p.x, p.y);
    let minDistanceSquared = Infinity;
    let minDatum;
    (_a2 = this.contextNodeData) == null ? void 0 : _a2.nodeData.forEach((datum) => {
      const { x, y, size } = datum.point;
      const dx2 = Math.max(Math.abs(x - x0) - size, 0);
      const dy2 = Math.max(Math.abs(y - y0) - size, 0);
      const distanceSquared2 = dx2 * dx2 + dy2 * dy2;
      if (distanceSquared2 < minDistanceSquared) {
        minDistanceSquared = distanceSquared2;
        minDatum = datum;
      }
    });
    return minDatum != null ? { datum: minDatum, distance: Math.sqrt(minDistanceSquared) } : void 0;
  }
  getLegendData(legendType) {
    var _a2, _b, _c, _d, _e, _f;
    const { processedData, dataModel } = this;
    if (processedData == null || dataModel == null)
      return [];
    const {
      title,
      legendItemName,
      idName,
      idKey,
      colorKey,
      colorName,
      colorRange,
      visible,
      shape,
      fill,
      stroke,
      fillOpacity,
      strokeOpacity,
      strokeWidth
    } = this.properties;
    if (legendType === "gradient" && colorKey != null && colorRange != null) {
      const colorDomain = processedData.domain.values[dataModel.resolveProcessedDataIndexById(this, "colorValue")];
      const legendDatum = {
        legendType: "gradient",
        enabled: visible,
        seriesId: this.id,
        colorName,
        colorRange,
        colorDomain
      };
      return [legendDatum];
    } else if (legendType === "category") {
      const legendDatum = {
        legendType: "category",
        id: this.id,
        itemId: (_c = (_b = (_a2 = legendItemName != null ? legendItemName : title) != null ? _a2 : idName) != null ? _b : idKey) != null ? _c : this.id,
        seriesId: this.id,
        enabled: visible,
        label: { text: (_f = (_e = (_d = legendItemName != null ? legendItemName : title) != null ? _d : idName) != null ? _e : idKey) != null ? _f : this.id },
        marker: {
          shape,
          fill,
          fillOpacity,
          stroke,
          strokeWidth,
          strokeOpacity
        },
        legendItemName
      };
      return [legendDatum];
    } else {
      return [];
    }
  }
  getTooltipHtml(nodeDatum) {
    var _a2, _b, _c, _d;
    const {
      id: seriesId,
      processedData,
      ctx: { callbackCache },
      properties
    } = this;
    if (!processedData || !this.properties.isValid()) {
      return import_ag_charts_community83._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const {
      legendItemName,
      idKey,
      idName,
      latitudeKey,
      longitudeKey,
      sizeKey,
      sizeName,
      colorKey,
      colorName,
      labelKey,
      labelName,
      formatter,
      tooltip,
      latitudeName,
      longitudeName
    } = properties;
    const { datum, fill, idValue, latValue, lonValue, sizeValue, colorValue, labelValue, itemId } = nodeDatum;
    const title = (_b = sanitizeHtml5((_a2 = properties.title) != null ? _a2 : legendItemName)) != null ? _b : "";
    const contentLines = [];
    if (idValue != null) {
      contentLines.push(sanitizeHtml5((idName != null ? `${idName}: ` : "") + idValue));
    }
    if (colorValue != null) {
      contentLines.push(sanitizeHtml5((colorName != null ? colorName : colorKey) + ": " + colorValue));
    }
    if (sizeValue != null) {
      contentLines.push(sanitizeHtml5((sizeName != null ? sizeName : sizeKey) + ": " + sizeValue));
    }
    if (labelValue != null && (idKey == null || idKey !== labelKey)) {
      contentLines.push(sanitizeHtml5((labelName != null ? labelName : labelKey) + ": " + labelValue));
    }
    if (latValue != null && lonValue != null) {
      contentLines.push(
        sanitizeHtml5(
          `${Math.abs(latValue).toFixed(4)}\xB0 ${latValue >= 0 ? "N" : "S"}, ${Math.abs(lonValue).toFixed(4)}\xB0 ${latValue >= 0 ? "W" : "E"}`
        )
      );
    }
    const content = contentLines.join("<br>");
    let format2;
    if (formatter) {
      format2 = callbackCache.call(formatter, {
        seriesId,
        datum,
        latitudeKey,
        longitudeKey,
        fill,
        highlighted: false
      });
    }
    const color = (_d = (_c = format2 == null ? void 0 : format2.fill) != null ? _c : fill) != null ? _d : properties.fill;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      __spreadValues2({
        seriesId,
        datum,
        idKey,
        latitudeKey,
        longitudeKey,
        title,
        color,
        colorKey,
        colorName,
        idName,
        itemId,
        labelKey,
        labelName,
        latitudeName,
        longitudeName,
        sizeKey,
        sizeName
      }, this.getModuleTooltipParams())
    );
  }
  getFormattedMarkerStyle(markerDatum) {
    const {
      id: seriesId,
      properties,
      ctx: { callbackCache }
    } = this;
    const { datum, point } = markerDatum;
    const {
      idKey,
      latitudeKey,
      longitudeKey,
      labelKey,
      sizeKey,
      colorKey,
      fill,
      fillOpacity,
      stroke,
      strokeOpacity,
      formatter
    } = properties;
    const strokeWidth = this.getStrokeWidth(properties.strokeWidth);
    const params = {
      seriesId,
      datum: datum.datum,
      itemId: datum.itemId,
      size: point.size,
      idKey,
      latitudeKey,
      longitudeKey,
      labelKey,
      sizeKey,
      colorKey,
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      strokeOpacity,
      highlighted: true
    };
    if (formatter !== void 0) {
      const style = callbackCache.call(
        formatter,
        params
      );
      if ((style == null ? void 0 : style.size) !== void 0) {
        return { size: style.size };
      }
    }
    return { size: markerDatum.point.size };
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds2(this, opts);
  }
};
MapMarkerSeries.className = "MapMarkerSeries";
MapMarkerSeries.type = "map-marker";
__decorateClass2([
  Validate37(GEOJSON_OBJECT, { optional: true, property: "topology" })
], MapMarkerSeries.prototype, "_chartTopology", 2);
var {
  EXTENDS_SERIES_DEFAULTS: EXTENDS_SERIES_DEFAULTS3,
  DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR22,
  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE22,
  singleSeriesPaletteFactory: singleSeriesPaletteFactory22
} = import_ag_charts_community84._Theme;
var MapMarkerModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-marker",
  instanceConstructor: MapMarkerSeries,
  themeTemplate: __spreadProps2(__spreadValues2({}, MAP_THEME_DEFAULTS), {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS3,
      maxSize: 30,
      fillOpacity: 0.5,
      label: {
        color: DEFAULT_LABEL_COLOUR22
      }
    }
  }),
  paletteFactory: (opts) => {
    const { takeColors, colorsCount, userPalette, themeTemplateParameters } = opts;
    const { fill, stroke } = singleSeriesPaletteFactory22(opts);
    const { properties } = themeTemplateParameters;
    const defaultColorRange = properties.get(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE22);
    const { fills } = takeColors(colorsCount);
    return {
      fill,
      stroke,
      colorRange: userPalette ? [fills[0], fills[1]] : defaultColorRange
    };
  }
};
var import_ag_charts_community87 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community86 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community85 = (init_main(), __toCommonJS(main_exports));
var { COLOR_STRING: COLOR_STRING13, LINE_DASH: LINE_DASH10, OBJECT: OBJECT12, POSITIVE_NUMBER: POSITIVE_NUMBER17, RATIO: RATIO18, Validate: Validate38, SeriesProperties: SeriesProperties4, SeriesTooltip: SeriesTooltip8 } = import_ag_charts_community85._ModuleSupport;
var MapShapeBackgroundSeriesProperties = class extends SeriesProperties4 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.tooltip = new SeriesTooltip8();
  }
};
__decorateClass2([
  Validate38(GEOJSON_OBJECT, { optional: true })
], MapShapeBackgroundSeriesProperties.prototype, "topology", 2);
__decorateClass2([
  Validate38(COLOR_STRING13)
], MapShapeBackgroundSeriesProperties.prototype, "fill", 2);
__decorateClass2([
  Validate38(RATIO18)
], MapShapeBackgroundSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate38(COLOR_STRING13)
], MapShapeBackgroundSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate38(RATIO18)
], MapShapeBackgroundSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate38(POSITIVE_NUMBER17)
], MapShapeBackgroundSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate38(LINE_DASH10)
], MapShapeBackgroundSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate38(POSITIVE_NUMBER17)
], MapShapeBackgroundSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate38(OBJECT12)
], MapShapeBackgroundSeriesProperties.prototype, "tooltip", 2);
var { createDatumId: createDatumId5, Series: Series2, SeriesNodePickMode: SeriesNodePickMode7, Validate: Validate39 } = import_ag_charts_community86._ModuleSupport;
var { Selection: Selection6, Group: Group9, PointerEvents: PointerEvents3 } = import_ag_charts_community86._Scene;
var { Logger: Logger11 } = import_ag_charts_community86._Util;
var MapShapeBackgroundSeries = class extends Series2 {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: false,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode7.EXACT_SHAPE_MATCH]
    });
    this.properties = new MapShapeBackgroundSeriesProperties();
    this._chartTopology = void 0;
    this.itemGroup = this.contentGroup.appendChild(new Group9({ name: "itemGroup" }));
    this.datumSelection = Selection6.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
  }
  get topology() {
    var _a2;
    return (_a2 = this.properties.topology) != null ? _a2 : this._chartTopology;
  }
  setOptionsData() {
  }
  setChartData() {
  }
  get hasData() {
    return false;
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  nodeFactory() {
    const geoGeometry = new GeoGeometry();
    geoGeometry.renderMode = 1;
    geoGeometry.lineJoin = "round";
    geoGeometry.pointerEvents = PointerEvents3.None;
    return geoGeometry;
  }
  processData() {
    return __async2(this, null, function* () {
      const { topology } = this;
      this.topologyBounds = topology == null ? void 0 : topology.features.reduce((current, feature) => {
        const geometry = feature.geometry;
        if (geometry == null)
          return current;
        return geometryBbox(geometry, current);
      }, void 0);
      if (topology == null) {
        Logger11.warnOnce(`no topology was provided for [MapShapeBackgroundSeries]; nothing will be rendered.`);
      }
    });
  }
  createNodeData() {
    return __async2(this, null, function* () {
      const { id: seriesId, topology, scale: scale2 } = this;
      if (topology == null)
        return;
      const nodeData = [];
      const labelData = [];
      topology.features.forEach((feature, index) => {
        const { geometry } = feature;
        const projectedGeometry = geometry != null && scale2 != null ? projectGeometry(geometry, scale2) : void 0;
        if (projectedGeometry == null)
          return;
        nodeData.push({
          series: this,
          itemId: index,
          datum: feature,
          index,
          projectedGeometry
        });
      });
      return {
        itemId: seriesId,
        nodeData,
        labelData
      };
    });
  }
  updateSelections() {
    return __async2(this, null, function* () {
      if (this.nodeDataRefresh) {
        this.contextNodeData = yield this.createNodeData();
        this.nodeDataRefresh = false;
      }
    });
  }
  update() {
    return __async2(this, null, function* () {
      var _a2;
      const { datumSelection } = this;
      yield this.updateSelections();
      this.contentGroup.visible = this.visible;
      const { nodeData = [] } = (_a2 = this.contextNodeData) != null ? _a2 : {};
      this.datumSelection = yield this.updateDatumSelection({ nodeData, datumSelection });
      yield this.updateDatumNodes({ datumSelection });
    });
  }
  updateDatumSelection(opts) {
    return __async2(this, null, function* () {
      return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId5(datum.index));
    });
  }
  updateDatumNodes(opts) {
    return __async2(this, null, function* () {
      const { properties } = this;
      const { datumSelection } = opts;
      const { fill, fillOpacity, stroke, strokeOpacity, lineDash, lineDashOffset } = properties;
      const strokeWidth = this.getStrokeWidth(properties.strokeWidth);
      datumSelection.each((geoGeometry, datum) => {
        const { projectedGeometry } = datum;
        if (projectedGeometry == null) {
          geoGeometry.visible = false;
          geoGeometry.projectedGeometry = void 0;
          return;
        }
        geoGeometry.visible = true;
        geoGeometry.projectedGeometry = projectedGeometry;
        geoGeometry.fill = fill;
        geoGeometry.fillOpacity = fillOpacity;
        geoGeometry.stroke = stroke;
        geoGeometry.strokeWidth = strokeWidth;
        geoGeometry.strokeOpacity = strokeOpacity;
        geoGeometry.lineDash = lineDash;
        geoGeometry.lineDashOffset = lineDashOffset;
      });
    });
  }
  resetAnimation() {
  }
  getLabelData() {
    return [];
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  getLegendData() {
    return [];
  }
  getTooltipHtml() {
    return import_ag_charts_community86._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
  }
  pickFocus(_opts) {
    return void 0;
  }
};
MapShapeBackgroundSeries.className = "MapShapeBackgroundSeries";
MapShapeBackgroundSeries.type = "map-shape-background";
__decorateClass2([
  Validate39(GEOJSON_OBJECT, { optional: true, property: "topology" })
], MapShapeBackgroundSeries.prototype, "_chartTopology", 2);
var { DEFAULT_BACKGROUND_COLOUR: DEFAULT_BACKGROUND_COLOUR2, DEFAULT_HIERARCHY_FILLS: DEFAULT_HIERARCHY_FILLS2 } = import_ag_charts_community87._Theme;
var MapShapeBackgroundModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-shape-background",
  instanceConstructor: MapShapeBackgroundSeries,
  themeTemplate: __spreadProps2(__spreadValues2({}, MAP_THEME_DEFAULTS), {
    series: {
      stroke: DEFAULT_BACKGROUND_COLOUR2,
      strokeWidth: 1
    }
  }),
  paletteFactory: ({ themeTemplateParameters }) => {
    var _a2;
    const { properties } = themeTemplateParameters;
    return {
      fill: (_a2 = properties.get(DEFAULT_HIERARCHY_FILLS2)) == null ? void 0 : _a2[1]
    };
  }
};
var import_ag_charts_community90 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community89 = (init_main(), __toCommonJS(main_exports));
function preferredLabelCenter(polygons, { aspectRatio, precision }) {
  const result = polygonPointSearch(polygons, precision, (p, cx, cy, stride) => {
    const width = maxWidthOfRectConstrainedByCenterAndAspectRatioToPolygon(p, cx, cy, aspectRatio);
    const maxWidth2 = width + 2 * stride * aspectRatio;
    const distance22 = width * Math.SQRT2;
    const maxDistance = maxWidth2 * Math.SQRT2;
    return { distance: distance22, maxDistance };
  });
  if (result == null)
    return;
  const { x, y, distance: distance2 } = result;
  const maxWidth = distance2 / Math.SQRT2;
  return { x, y, maxWidth };
}
function maxWidthOfRectConstrainedByCenterAndAspectRatioToLineSegment(a, b, cx, cy, aspectRatio) {
  const [ax, ay] = a;
  const [bx, by] = b;
  const positiveM = 1 / aspectRatio;
  const abx = bx - ax;
  const aby = by - ay;
  const [topPointX, topPointY] = ay <= by ? a : b;
  const [leftPointX, leftPointY] = ax <= bx ? a : b;
  const [bottomPointX, bottomPointY] = ay <= by ? b : a;
  const [rightPointX, rightPointY] = ax <= bx ? b : a;
  let maxWidth = Infinity;
  if (abx !== 0) {
    const abm = aby / abx;
    for (let i = 0; i <= 1; i += 1) {
      const m = i === 0 ? positiveM : -positiveM;
      const x = (abm * ax - ay - m * cx + cy) / (abm - m);
      if (x >= leftPointX && x <= rightPointX) {
        const width = Math.abs(cx - x) * 2;
        maxWidth = Math.min(maxWidth, width);
      }
    }
  } else {
    for (let i = 0; i <= 1; i += 1) {
      const m = i === 0 ? positiveM : -positiveM;
      const y = m * (ax - cx) + cy;
      if (y >= topPointY && y <= bottomPointY) {
        const height = Math.abs(cy - y) * 2;
        const width = height * aspectRatio;
        maxWidth = Math.min(maxWidth, width);
      }
    }
  }
  const positiveMRecip = aspectRatio;
  const centerToTopMRecip = Math.abs((topPointX - cx) / (topPointY - cy));
  const centerToBottomMRecip = Math.abs((bottomPointX - cx) / (bottomPointY - cy));
  if (bottomPointY < cy && centerToBottomMRecip < positiveMRecip) {
    const height = Math.abs(cy - bottomPointY) * 2;
    const width = height * aspectRatio;
    maxWidth = Math.min(maxWidth, width);
  } else if (topPointY > cy && centerToTopMRecip < positiveMRecip) {
    const height = Math.abs(cy - topPointY) * 2;
    const width = height * aspectRatio;
    maxWidth = Math.min(maxWidth, width);
  }
  const centerToLeftM = Math.abs((leftPointY - cy) / (leftPointX - cx));
  const centerToRightM = Math.abs((rightPointY - cy) / (rightPointX - cx));
  if (rightPointX < cx && centerToRightM < positiveM) {
    const width = Math.abs(cx - rightPointX) * 2;
    maxWidth = Math.min(maxWidth, width);
  } else if (leftPointX > cx && centerToLeftM < positiveM) {
    const width = Math.abs(cx - leftPointX) * 2;
    maxWidth = Math.min(maxWidth, width);
  }
  return maxWidth;
}
function maxWidthOfRectConstrainedByCenterAndAspectRatioToPolygon(polygons, cx, cy, aspectRatio) {
  let inside = false;
  let minWidth = Infinity;
  for (const polygon of polygons) {
    let p0 = polygon[polygon.length - 1];
    let [x0, y0] = p0;
    for (const p1 of polygon) {
      const [x1, y1] = p1;
      if (y1 > cy !== y0 > cy && cx < (x0 - x1) * (cy - y1) / (y0 - y1) + x1) {
        inside = !inside;
      }
      const width = maxWidthOfRectConstrainedByCenterAndAspectRatioToLineSegment(p0, p1, cx, cy, aspectRatio);
      minWidth = Math.min(minWidth, width);
      p0 = p1;
      x0 = x1;
      y0 = y1;
    }
  }
  return (inside ? 1 : -1) * minWidth;
}
function applyX(into, cx, x) {
  if (x >= cx) {
    into.maxX = Math.min(into.maxX, x - cx);
  }
  if (x <= cx) {
    into.minX = Math.max(into.minX, x - cx);
  }
}
function xExtentsOfRectConstrainedByCenterAndHeightToLineSegment(into, a, b, cx, cy, height) {
  const ry0 = cy - height / 2;
  const ry1 = cy + height / 2;
  const [ax, ay] = a;
  const [bx, by] = b;
  const abx = bx - ax;
  const aby = by - ay;
  const [leftPointX, leftPointY] = ax <= bx ? a : b;
  const [rightPointX, rightPointY] = ax <= bx ? b : a;
  if (abx !== 0) {
    const abm = aby / abx;
    for (let i = 0; i <= 1; i += 1) {
      const y = i === 0 ? ry0 : ry1;
      const x = (y - ay) / abm + ax;
      if (x >= leftPointX && x <= rightPointX) {
        applyX(into, cx, x);
      }
    }
  } else if (Math.max(ry0, Math.min(ay, by)) <= Math.min(ry1, Math.max(ay, by))) {
    applyX(into, cx, ax);
  }
  if (rightPointX < cx && rightPointY >= ry0 && rightPointY <= ry1) {
    applyX(into, cx, rightPointX);
  } else if (leftPointX > cx && leftPointY >= ry0 && leftPointY <= ry1) {
    applyX(into, cx, leftPointX);
  }
  return into;
}
function maxWidthInPolygonForRectOfHeight(polygons, cx, cy, height) {
  const result = {
    minX: -Infinity,
    maxX: Infinity
  };
  for (const polygon of polygons) {
    let p0 = polygon[polygon.length - 1];
    for (const p1 of polygon) {
      xExtentsOfRectConstrainedByCenterAndHeightToLineSegment(result, p0, p1, cx, cy, height);
      p0 = p1;
    }
  }
  const { minX, maxX } = result;
  if (Number.isFinite(minX) && Number.isFinite(maxX)) {
    return { x: cx + (minX + maxX) / 2, width: maxX - minX };
  } else {
    return { x: cx, width: 0 };
  }
}
var import_ag_charts_community88 = (init_main(), __toCommonJS(main_exports));
var {
  AND: AND10,
  ARRAY: ARRAY7,
  COLOR_STRING: COLOR_STRING14,
  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY4,
  FUNCTION: FUNCTION9,
  LINE_DASH: LINE_DASH11,
  OBJECT: OBJECT13,
  POSITIVE_NUMBER: POSITIVE_NUMBER18,
  RATIO: RATIO19,
  STRING: STRING13,
  Validate: Validate40,
  SeriesProperties: SeriesProperties5,
  SeriesTooltip: SeriesTooltip9
} = import_ag_charts_community88._ModuleSupport;
var MapShapeSeriesProperties = class extends SeriesProperties5 {
  constructor() {
    super(...arguments);
    this.topology = void 0;
    this.idKey = "";
    this.idName = void 0;
    this.topologyIdKey = "name";
    this.labelKey = void 0;
    this.labelName = void 0;
    this.colorRange = void 0;
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.strokeWidth = 0;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.padding = 0;
    this.label = new AutoSizeableSecondaryLabel();
    this.tooltip = new SeriesTooltip9();
  }
};
__decorateClass2([
  Validate40(GEOJSON_OBJECT, { optional: true })
], MapShapeSeriesProperties.prototype, "topology", 2);
__decorateClass2([
  Validate40(STRING13, { optional: true })
], MapShapeSeriesProperties.prototype, "title", 2);
__decorateClass2([
  Validate40(STRING13, { optional: true })
], MapShapeSeriesProperties.prototype, "legendItemName", 2);
__decorateClass2([
  Validate40(STRING13)
], MapShapeSeriesProperties.prototype, "idKey", 2);
__decorateClass2([
  Validate40(STRING13, { optional: true })
], MapShapeSeriesProperties.prototype, "idName", 2);
__decorateClass2([
  Validate40(STRING13)
], MapShapeSeriesProperties.prototype, "topologyIdKey", 2);
__decorateClass2([
  Validate40(STRING13, { optional: true })
], MapShapeSeriesProperties.prototype, "labelKey", 2);
__decorateClass2([
  Validate40(STRING13, { optional: true })
], MapShapeSeriesProperties.prototype, "labelName", 2);
__decorateClass2([
  Validate40(STRING13, { optional: true })
], MapShapeSeriesProperties.prototype, "colorKey", 2);
__decorateClass2([
  Validate40(STRING13, { optional: true })
], MapShapeSeriesProperties.prototype, "colorName", 2);
__decorateClass2([
  Validate40(AND10(COLOR_STRING_ARRAY4, ARRAY7.restrict({ minLength: 1 })), { optional: true })
], MapShapeSeriesProperties.prototype, "colorRange", 2);
__decorateClass2([
  Validate40(COLOR_STRING14)
], MapShapeSeriesProperties.prototype, "fill", 2);
__decorateClass2([
  Validate40(RATIO19)
], MapShapeSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate40(COLOR_STRING14)
], MapShapeSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate40(RATIO19)
], MapShapeSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate40(POSITIVE_NUMBER18)
], MapShapeSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate40(LINE_DASH11)
], MapShapeSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate40(POSITIVE_NUMBER18)
], MapShapeSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate40(POSITIVE_NUMBER18)
], MapShapeSeriesProperties.prototype, "padding", 2);
__decorateClass2([
  Validate40(FUNCTION9, { optional: true })
], MapShapeSeriesProperties.prototype, "formatter", 2);
__decorateClass2([
  Validate40(OBJECT13)
], MapShapeSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Validate40(OBJECT13)
], MapShapeSeriesProperties.prototype, "tooltip", 2);
var { getMissCount: getMissCount4, createDatumId: createDatumId6, DataModelSeries: DataModelSeries4, SeriesNodePickMode: SeriesNodePickMode8, valueProperty: valueProperty8, Validate: Validate41 } = import_ag_charts_community89._ModuleSupport;
var { ColorScale: ColorScale4 } = import_ag_charts_community89._Scale;
var { Group: Group10, Selection: Selection7, Text: Text8, PointerEvents: PointerEvents4 } = import_ag_charts_community89._Scene;
var { sanitizeHtml: sanitizeHtml6, Logger: Logger12 } = import_ag_charts_community89._Util;
var fixedScale = import_ag_charts_community89._ModuleSupport.MercatorScale.fixedScale();
var MapShapeSeries = class extends DataModelSeries4 {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      contentGroupVirtual: false,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode8.EXACT_SHAPE_MATCH, SeriesNodePickMode8.NEAREST_NODE]
    });
    this.properties = new MapShapeSeriesProperties();
    this._chartTopology = void 0;
    this.colorScale = new ColorScale4();
    this.itemGroup = this.contentGroup.appendChild(new Group10({ name: "itemGroup" }));
    this.itemLabelGroup = this.contentGroup.appendChild(new Group10({ name: "itemLabelGroup" }));
    this.datumSelection = Selection7.select(
      this.itemGroup,
      () => this.nodeFactory()
    );
    this.labelSelection = Selection7.select(
      this.itemLabelGroup,
      Text8
    );
    this.highlightDatumSelection = Selection7.select(
      this.highlightNode,
      () => this.nodeFactory()
    );
    this.previousLabelLayouts = void 0;
    this._previousDatumMidPoint = void 0;
    this.itemLabelGroup.pointerEvents = PointerEvents4.None;
    this.showFocusBox = false;
  }
  getNodeData() {
    var _a2;
    return (_a2 = this.contextNodeData) == null ? void 0 : _a2.nodeData;
  }
  get topology() {
    var _a2;
    return (_a2 = this.properties.topology) != null ? _a2 : this._chartTopology;
  }
  get hasData() {
    return super.hasData && this.topology != null;
  }
  setChartTopology(topology) {
    this._chartTopology = topology;
    if (this.topology === topology) {
      this.nodeDataRefresh = true;
    }
  }
  addChartEventListeners() {
    this.destroyFns.push(
      this.ctx.chartEventManager.addListener("legend-item-click", (event) => {
        this.onLegendItemClick(event);
      }),
      this.ctx.chartEventManager.addListener("legend-item-double-click", (event) => {
        this.onLegendItemDoubleClick(event);
      })
    );
  }
  isLabelEnabled() {
    return this.properties.labelKey != null && this.properties.label.enabled;
  }
  nodeFactory() {
    const geoGeometry = new GeoGeometry();
    geoGeometry.renderMode = 1;
    geoGeometry.lineJoin = "round";
    return geoGeometry;
  }
  processData(dataController) {
    return __async2(this, null, function* () {
      var _a2;
      if (this.data == null || !this.properties.isValid()) {
        return;
      }
      const { data, topology, colorScale } = this;
      const { topologyIdKey, idKey, colorKey, labelKey, colorRange } = this.properties;
      const featureById = /* @__PURE__ */ new Map();
      topology == null ? void 0 : topology.features.forEach((feature) => {
        var _a3;
        const property = (_a3 = feature.properties) == null ? void 0 : _a3[topologyIdKey];
        if (property == null || !containsType(
          feature.geometry,
          1
          /* Polygon */
        ))
          return;
        featureById.set(property, feature);
      });
      const colorScaleType = this.colorScale.type;
      const mercatorScaleType = (_a2 = this.scale) == null ? void 0 : _a2.type;
      const { dataModel, processedData } = yield this.requestDataModel(dataController, data, {
        props: [
          valueProperty8(idKey, mercatorScaleType, { id: "idValue", includeProperty: false }),
          valueProperty8(idKey, mercatorScaleType, {
            id: "featureValue",
            includeProperty: false,
            processor: () => (datum) => featureById.get(datum)
          }),
          ...labelKey ? [valueProperty8(labelKey, "band", { id: "labelValue" })] : [],
          ...colorKey ? [valueProperty8(colorKey, colorScaleType, { id: "colorValue" })] : []
        ]
      });
      const featureIdx = dataModel.resolveProcessedDataIndexById(this, `featureValue`);
      this.topologyBounds = processedData.data.reduce(
        (current, { values }) => {
          const feature = values[featureIdx];
          const geometry = feature == null ? void 0 : feature.geometry;
          if (geometry == null)
            return current;
          return geometryBbox(geometry, current);
        },
        void 0
      );
      if (colorRange != null && this.isColorScaleValid()) {
        const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
        colorScale.domain = processedData.domain.values[colorKeyIdx];
        colorScale.range = colorRange;
        colorScale.update();
      }
      if (topology == null) {
        Logger12.warnOnce(`no topology was provided for [MapShapeSeries]; nothing will be rendered.`);
      }
    });
  }
  isColorScaleValid() {
    const { colorKey } = this.properties;
    if (!colorKey) {
      return false;
    }
    const { dataModel, processedData } = this;
    if (!dataModel || !processedData) {
      return false;
    }
    const colorIdx = dataModel.resolveProcessedDataIndexById(this, "colorValue");
    const dataCount = processedData.data.length;
    const missCount = getMissCount4(this, processedData.defs.values[colorIdx].missing);
    const colorDataMissing = dataCount === 0 || dataCount === missCount;
    return !colorDataMissing;
  }
  getLabelLayout(datum, labelValue, font, geometry, previousLabelLayout) {
    if (labelValue == null || geometry == null)
      return;
    const { idKey, idName, colorKey, colorName, labelKey, labelName, padding, label } = this.properties;
    const labelText = this.getLabelText(label, {
      value: labelValue,
      datum,
      idKey,
      idName,
      colorKey,
      colorName,
      labelKey,
      labelName
    });
    if (labelText == null)
      return;
    const baseSize = Text8.getTextSize(String(labelText), font);
    const numLines = labelText.split("\n").length;
    const aspectRatio = (baseSize.width + 2 * padding) / (numLines * AutoSizedLabel.lineHeight(label.fontSize) + 2 * padding);
    if ((previousLabelLayout == null ? void 0 : previousLabelLayout.geometry) === geometry && (previousLabelLayout == null ? void 0 : previousLabelLayout.labelText) === labelText && (previousLabelLayout == null ? void 0 : previousLabelLayout.aspectRatio) === aspectRatio) {
      return previousLabelLayout;
    }
    const fixedGeometry = projectGeometry(geometry, fixedScale);
    const fixedPolygon = largestPolygon(fixedGeometry);
    if (fixedPolygon == null)
      return;
    const labelPlacement = preferredLabelCenter(fixedPolygon, {
      aspectRatio,
      precision: 1e-3
    });
    if (labelPlacement == null)
      return;
    const { x, y, maxWidth } = labelPlacement;
    return { geometry, labelText, aspectRatio, x, y, maxWidth, fixedPolygon };
  }
  getLabelDatum(labelLayout, scaling) {
    const { scale: scale2 } = this;
    if (scale2 == null)
      return;
    const { padding, label } = this.properties;
    const { labelText, aspectRatio, x: untruncatedX, y, maxWidth, fixedPolygon } = labelLayout;
    const maxSizeWithoutTruncation = {
      width: Math.ceil(maxWidth * scaling),
      height: Math.ceil(maxWidth * scaling / aspectRatio),
      meta: untruncatedX
    };
    const labelFormatting = formatSingleLabel(
      labelText,
      label,
      { padding },
      (height, allowTruncation) => {
        if (!allowTruncation)
          return maxSizeWithoutTruncation;
        const result = maxWidthInPolygonForRectOfHeight(fixedPolygon, untruncatedX, y, height / scaling);
        return {
          width: result.width * scaling,
          height,
          meta: result.x
        };
      }
    );
    if (labelFormatting == null)
      return;
    const [{ text, fontSize, lineHeight, width }, formattingX] = labelFormatting;
    if (text === Text8.ellipsis)
      return;
    const x = width < maxSizeWithoutTruncation.width ? untruncatedX : formattingX;
    const position = this.scale.convert(fixedScale.invert([x, y]));
    return {
      x: position[0],
      y: position[1],
      text,
      fontSize,
      lineHeight
    };
  }
  createNodeData() {
    return __async2(this, null, function* () {
      const { id: seriesId, dataModel, processedData, colorScale, properties, scale: scale2, previousLabelLayouts } = this;
      const { idKey, colorKey, labelKey, label, fill: fillProperty } = properties;
      if (dataModel == null || processedData == null)
        return;
      const scaling = scale2 != null ? (scale2.range[1][0] - scale2.range[0][0]) / scale2.bounds.width : NaN;
      const colorScaleValid = this.isColorScaleValid();
      const idIdx = dataModel.resolveProcessedDataIndexById(this, `idValue`);
      const featureIdx = dataModel.resolveProcessedDataIndexById(this, `featureValue`);
      const labelIdx = labelKey != null ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : void 0;
      const colorIdx = colorKey != null ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : void 0;
      const font = label.getFont();
      const labelLayouts = /* @__PURE__ */ new Map();
      this.previousLabelLayouts = labelLayouts;
      const nodeData = [];
      const labelData = [];
      const missingGeometries = [];
      processedData.data.forEach(({ datum, values }) => {
        var _a2;
        const idValue = values[idIdx];
        const colorValue = colorIdx != null ? values[colorIdx] : void 0;
        const labelValue = labelIdx != null ? values[labelIdx] : void 0;
        const geometry = (_a2 = values[featureIdx]) == null ? void 0 : _a2.geometry;
        if (geometry == null) {
          missingGeometries.push(idValue);
        }
        const color = colorScaleValid && colorValue != null ? colorScale.convert(colorValue) : void 0;
        const labelLayout = this.getLabelLayout(
          datum,
          labelValue,
          font,
          geometry,
          previousLabelLayouts == null ? void 0 : previousLabelLayouts.get(idValue)
        );
        if (labelLayout != null) {
          labelLayouts.set(idValue, labelLayout);
        }
        const labelDatum = labelLayout != null && scale2 != null ? this.getLabelDatum(labelLayout, scaling) : void 0;
        if (labelDatum != null) {
          labelData.push(labelDatum);
        }
        const projectedGeometry = geometry != null && scale2 != null ? projectGeometry(geometry, scale2) : void 0;
        nodeData.push({
          series: this,
          itemId: idKey,
          datum,
          idValue,
          colorValue,
          labelValue,
          fill: color != null ? color : fillProperty,
          projectedGeometry
        });
      });
      const missingGeometriesCap = 10;
      if (missingGeometries.length > missingGeometriesCap) {
        const excessItems = missingGeometries.length - missingGeometriesCap;
        missingGeometries.length = missingGeometriesCap;
        missingGeometries.push(`(+${excessItems} more)`);
      }
      if (missingGeometries.length > 0) {
        Logger12.warnOnce(`some data items do not have matches in the provided topology`, missingGeometries);
      }
      return {
        itemId: seriesId,
        nodeData,
        labelData
      };
    });
  }
  updateSelections() {
    return __async2(this, null, function* () {
      if (this.nodeDataRefresh) {
        this.contextNodeData = yield this.createNodeData();
        this.nodeDataRefresh = false;
      }
    });
  }
  update() {
    return __async2(this, null, function* () {
      var _a2, _b, _c, _d, _e;
      const { datumSelection, labelSelection, highlightDatumSelection } = this;
      yield this.updateSelections();
      this.contentGroup.visible = this.visible;
      this.contentGroup.opacity = this.getOpacity();
      let highlightedDatum = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight();
      if (highlightedDatum != null && (highlightedDatum.series !== this || highlightedDatum.datum == null)) {
        highlightedDatum = void 0;
      }
      const nodeData = (_c = (_b = this.contextNodeData) == null ? void 0 : _b.nodeData) != null ? _c : [];
      const labelData = (_e = (_d = this.contextNodeData) == null ? void 0 : _d.labelData) != null ? _e : [];
      this.datumSelection = yield this.updateDatumSelection({ nodeData, datumSelection });
      yield this.updateDatumNodes({ datumSelection, isHighlight: false });
      this.labelSelection = yield this.updateLabelSelection({ labelData, labelSelection });
      yield this.updateLabelNodes({ labelSelection });
      this.highlightDatumSelection = yield this.updateDatumSelection({
        nodeData: highlightedDatum != null ? [highlightedDatum] : [],
        datumSelection: highlightDatumSelection
      });
      yield this.updateDatumNodes({ datumSelection: highlightDatumSelection, isHighlight: true });
    });
  }
  updateDatumSelection(opts) {
    return __async2(this, null, function* () {
      return opts.datumSelection.update(opts.nodeData, void 0, (datum) => createDatumId6(datum.idValue));
    });
  }
  updateDatumNodes(opts) {
    return __async2(this, null, function* () {
      const {
        id: seriesId,
        properties,
        ctx: { callbackCache }
      } = this;
      const { datumSelection, isHighlight } = opts;
      const { idKey, colorKey, labelKey, fillOpacity, stroke, strokeOpacity, lineDash, lineDashOffset, formatter } = properties;
      const highlightStyle = isHighlight ? properties.highlightStyle.item : void 0;
      const strokeWidth = this.getStrokeWidth(properties.strokeWidth);
      datumSelection.each((geoGeometry, datum) => {
        var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
        const { projectedGeometry } = datum;
        if (projectedGeometry == null) {
          geoGeometry.visible = false;
          geoGeometry.projectedGeometry = void 0;
          return;
        }
        let format2;
        if (formatter != null) {
          const params = {
            seriesId,
            datum: datum.datum,
            itemId: datum.itemId,
            idKey,
            colorKey,
            labelKey,
            fill: datum.fill,
            fillOpacity,
            strokeOpacity,
            stroke,
            strokeWidth,
            lineDash,
            lineDashOffset,
            highlighted: isHighlight
          };
          format2 = callbackCache.call(formatter, params);
        }
        geoGeometry.visible = true;
        geoGeometry.projectedGeometry = projectedGeometry;
        geoGeometry.fill = (_b = (_a2 = highlightStyle == null ? void 0 : highlightStyle.fill) != null ? _a2 : format2 == null ? void 0 : format2.fill) != null ? _b : datum.fill;
        geoGeometry.fillOpacity = (_d = (_c = highlightStyle == null ? void 0 : highlightStyle.fillOpacity) != null ? _c : format2 == null ? void 0 : format2.fillOpacity) != null ? _d : fillOpacity;
        geoGeometry.stroke = (_f = (_e = highlightStyle == null ? void 0 : highlightStyle.stroke) != null ? _e : format2 == null ? void 0 : format2.stroke) != null ? _f : stroke;
        geoGeometry.strokeWidth = (_h = (_g = highlightStyle == null ? void 0 : highlightStyle.strokeWidth) != null ? _g : format2 == null ? void 0 : format2.strokeWidth) != null ? _h : strokeWidth;
        geoGeometry.strokeOpacity = (_j = (_i = highlightStyle == null ? void 0 : highlightStyle.strokeOpacity) != null ? _i : format2 == null ? void 0 : format2.strokeOpacity) != null ? _j : strokeOpacity;
        geoGeometry.lineDash = (_l = (_k = highlightStyle == null ? void 0 : highlightStyle.lineDash) != null ? _k : format2 == null ? void 0 : format2.lineDash) != null ? _l : lineDash;
        geoGeometry.lineDashOffset = (_n = (_m = highlightStyle == null ? void 0 : highlightStyle.lineDashOffset) != null ? _m : format2 == null ? void 0 : format2.lineDashOffset) != null ? _n : lineDashOffset;
      });
    });
  }
  updateLabelSelection(opts) {
    return __async2(this, null, function* () {
      const labels = this.isLabelEnabled() ? opts.labelData : [];
      return opts.labelSelection.update(labels);
    });
  }
  updateLabelNodes(opts) {
    return __async2(this, null, function* () {
      const { labelSelection } = opts;
      const { color: fill, fontStyle, fontWeight, fontFamily } = this.properties.label;
      labelSelection.each((label, { x, y, text, fontSize, lineHeight }) => {
        label.visible = true;
        label.x = x;
        label.y = y;
        label.text = text;
        label.fill = fill;
        label.fontStyle = fontStyle;
        label.fontWeight = fontWeight;
        label.fontSize = fontSize;
        label.lineHeight = lineHeight;
        label.fontFamily = fontFamily;
        label.textAlign = "center";
        label.textBaseline = "middle";
      });
    });
  }
  onLegendItemClick(event) {
    const { legendItemName } = this.properties;
    const { enabled, itemId, series } = event;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const { legendItemName } = this.properties;
    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;
    if (series.id === this.id || matchedLegendItemName) {
      this.toggleSeriesItem(itemId, true);
    } else if (enabled && numVisibleItems === 1) {
      this.toggleSeriesItem(itemId, true);
    } else {
      this.toggleSeriesItem(itemId, false);
    }
  }
  resetAnimation() {
  }
  getLabelData() {
    return [];
  }
  getSeriesDomain() {
    return [NaN, NaN];
  }
  pickNodeClosestDatum({ x, y }) {
    let minDistance = Infinity;
    let minDatum;
    this.datumSelection.each((node, datum) => {
      const distance2 = node.distanceToPoint(x, y);
      if (distance2 < minDistance) {
        minDistance = distance2;
        minDatum = datum;
      }
    });
    return minDatum != null ? { datum: minDatum, distance: minDistance } : void 0;
  }
  datumMidPoint(datum) {
    const { _previousDatumMidPoint } = this;
    if ((_previousDatumMidPoint == null ? void 0 : _previousDatumMidPoint.datum) === datum) {
      return _previousDatumMidPoint.point;
    }
    const projectedGeometry = datum.projectedGeometry;
    const polygon = projectedGeometry != null ? largestPolygon(projectedGeometry) : void 0;
    const center = polygon != null ? polygonMarkerCenter(polygon, 2) : void 0;
    const point = center != null ? { x: center[0], y: center[1] } : void 0;
    this._previousDatumMidPoint = { datum, point };
    return point;
  }
  getLegendData(legendType) {
    var _a2, _b, _c, _d;
    const { processedData, dataModel } = this;
    if (processedData == null || dataModel == null)
      return [];
    const {
      title,
      legendItemName,
      idKey,
      idName,
      fill,
      fillOpacity,
      stroke,
      strokeWidth,
      strokeOpacity,
      colorKey,
      colorName,
      colorRange,
      visible
    } = this.properties;
    if (legendType === "gradient" && colorKey != null && colorRange != null) {
      const colorDomain = processedData.domain.values[dataModel.resolveProcessedDataIndexById(this, "colorValue")];
      const legendDatum = {
        legendType: "gradient",
        enabled: visible,
        seriesId: this.id,
        colorName,
        colorRange,
        colorDomain
      };
      return [legendDatum];
    } else if (legendType === "category") {
      const legendDatum = {
        legendType: "category",
        id: this.id,
        itemId: (_b = (_a2 = legendItemName != null ? legendItemName : title) != null ? _a2 : idName) != null ? _b : idKey,
        seriesId: this.id,
        enabled: visible,
        label: { text: (_d = (_c = legendItemName != null ? legendItemName : title) != null ? _c : idName) != null ? _d : idKey },
        marker: {
          fill,
          fillOpacity,
          stroke,
          strokeWidth,
          strokeOpacity
        },
        legendItemName
      };
      return [legendDatum];
    } else {
      return [];
    }
  }
  getTooltipHtml(nodeDatum) {
    var _a2, _b, _c;
    const {
      id: seriesId,
      processedData,
      ctx: { callbackCache },
      properties
    } = this;
    if (!processedData || !properties.isValid()) {
      return import_ag_charts_community89._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const {
      legendItemName,
      idKey,
      idName,
      colorKey,
      colorName,
      labelKey,
      labelName,
      stroke,
      strokeWidth,
      formatter,
      tooltip
    } = properties;
    const { datum, fill, idValue, colorValue, labelValue, itemId } = nodeDatum;
    const title = (_b = sanitizeHtml6((_a2 = properties.title) != null ? _a2 : legendItemName)) != null ? _b : "";
    const contentLines = [];
    contentLines.push(sanitizeHtml6((idName != null ? `${idName}: ` : "") + idValue));
    if (colorValue != null) {
      contentLines.push(sanitizeHtml6((colorName != null ? colorName : colorKey) + ": " + colorValue));
    }
    if (labelValue != null && labelKey !== idKey) {
      contentLines.push(sanitizeHtml6((labelName != null ? labelName : labelKey) + ": " + labelValue));
    }
    const content = contentLines.join("<br>");
    let format2;
    if (formatter) {
      format2 = callbackCache.call(formatter, {
        seriesId,
        datum,
        idKey,
        fill,
        stroke,
        strokeWidth: this.getStrokeWidth(strokeWidth),
        highlighted: false
      });
    }
    const color = (_c = format2 == null ? void 0 : format2.fill) != null ? _c : fill;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      __spreadValues2({
        seriesId,
        datum,
        idKey,
        title,
        color,
        colorKey,
        colorName,
        idName,
        itemId,
        labelKey,
        labelName
      }, this.getModuleTooltipParams())
    );
  }
  computeFocusBounds(opts) {
    return computeGeoFocusBounds(this, opts);
  }
};
MapShapeSeries.className = "MapShapeSeries";
MapShapeSeries.type = "map-shape";
__decorateClass2([
  Validate41(GEOJSON_OBJECT, { optional: true, property: "topology" })
], MapShapeSeries.prototype, "_chartTopology", 2);
var {
  EXTENDS_SERIES_DEFAULTS: EXTENDS_SERIES_DEFAULTS4,
  DEFAULT_INVERTED_LABEL_COLOUR: DEFAULT_INVERTED_LABEL_COLOUR2,
  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE3,
  DEFAULT_BACKGROUND_COLOUR: DEFAULT_BACKGROUND_COLOUR22,
  singleSeriesPaletteFactory: singleSeriesPaletteFactory3
} = import_ag_charts_community90._Theme;
var MapShapeModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["topology"],
  identifier: "map-shape",
  instanceConstructor: MapShapeSeries,
  themeTemplate: __spreadProps2(__spreadValues2({}, MAP_THEME_DEFAULTS), {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS4,
      fillOpacity: 1,
      strokeWidth: 1,
      lineDash: [0],
      lineDashOffset: 0,
      padding: 2,
      label: {
        color: DEFAULT_INVERTED_LABEL_COLOUR2,
        fontWeight: "bold",
        overflowStrategy: "hide"
      }
    }
  }),
  paletteFactory: (opts) => {
    const { takeColors, colorsCount, userPalette, themeTemplateParameters } = opts;
    const { fill } = singleSeriesPaletteFactory3(opts);
    const { properties } = themeTemplateParameters;
    const defaultColorRange = properties.get(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE3);
    const { fills } = takeColors(colorsCount);
    return {
      fill,
      stroke: properties.get(DEFAULT_BACKGROUND_COLOUR22),
      colorRange: userPalette ? [fills[0], fills[1]] : defaultColorRange
    };
  }
};
var import_ag_charts_community98 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community96 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community91 = (init_main(), __toCommonJS(main_exports));
var {
  isDefined: isDefined3,
  ChartAxisDirection: ChartAxisDirection9,
  PolarAxis: PolarAxis2,
  diff: diff4,
  fixNumericExtent: fixNumericExtent4,
  groupAccumulativeValueProperty: groupAccumulativeValueProperty22,
  keyProperty: keyProperty4,
  normaliseGroupTo: normaliseGroupTo2,
  resetLabelFn: resetLabelFn2,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation22,
  seriesLabelFadeOutAnimation: seriesLabelFadeOutAnimation2,
  valueProperty: valueProperty9,
  animationValidation: animationValidation4,
  isFiniteNumber: isFiniteNumber5,
  SeriesNodePickMode: SeriesNodePickMode9,
  computeSectorFocusBounds: computeSectorFocusBounds2
} = import_ag_charts_community91._ModuleSupport;
var { BandScale: BandScale3 } = import_ag_charts_community91._Scale;
var { motion: motion3 } = import_ag_charts_community91._Scene;
var { isNumber: isNumber2, normalizeAngle360: normalizeAngle3605, sanitizeHtml: sanitizeHtml7 } = import_ag_charts_community91._Util;
var RadialColumnSeriesNodeEvent = class extends import_ag_charts_community91._ModuleSupport.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
  }
};
var RadialColumnSeriesBase = class extends import_ag_charts_community91._ModuleSupport.PolarSeries {
  constructor(moduleCtx, {
    animationResetFns
  }) {
    super({
      moduleCtx,
      useLabelLayer: true,
      canHaveAxes: true,
      pickModes: [SeriesNodePickMode9.EXACT_SHAPE_MATCH],
      animationResetFns: __spreadProps2(__spreadValues2({}, animationResetFns), {
        label: resetLabelFn2
      })
    });
    this.NodeEvent = RadialColumnSeriesNodeEvent;
    this.groupScale = new BandScale3();
    this.circleCache = { r: 0, cx: 0, cy: 0 };
  }
  addChartEventListeners() {
    var _a2, _b;
    this.destroyFns.push(
      (_a2 = this.ctx.chartEventManager) == null ? void 0 : _a2.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
      (_b = this.ctx.chartEventManager) == null ? void 0 : _b.addListener(
        "legend-item-double-click",
        (event) => this.onLegendItemDoubleClick(event)
      )
    );
  }
  getSeriesDomain(direction) {
    const { axes, dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    if (direction === ChartAxisDirection9.X) {
      return dataModel.getDomain(this, "angleValue", "key", processedData);
    } else {
      const radiusAxis = axes[ChartAxisDirection9.Y];
      const yExtent = dataModel.getDomain(this, "radiusValue-end", "value", processedData);
      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];
      return fixNumericExtent4(fixedYExtent, radiusAxis);
    }
  }
  processData(dataController) {
    return __async2(this, null, function* () {
      var _a2, _b;
      const { angleKey, radiusKey, normalizedTo, visible } = this.properties;
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      if (!this.properties.isValid() || !(visible || animationEnabled))
        return;
      const stackGroupId = this.getStackId();
      const stackGroupTrailingId = `${stackGroupId}-trailing`;
      const extraProps = [];
      if (isDefined3(normalizedTo)) {
        extraProps.push(normaliseGroupTo2([stackGroupId, stackGroupTrailingId], Math.abs(normalizedTo), "range"));
      }
      if (animationEnabled && this.processedData) {
        extraProps.push(diff4(this.processedData));
      }
      if (animationEnabled) {
        extraProps.push(animationValidation4());
      }
      const visibleProps = visible || !animationEnabled ? {} : { forceValue: 0 };
      const radiusScaleType = (_a2 = this.axes[ChartAxisDirection9.Y]) == null ? void 0 : _a2.scale.type;
      const angleScaleType = (_b = this.axes[ChartAxisDirection9.X]) == null ? void 0 : _b.scale.type;
      yield this.requestDataModel(dataController, this.data, {
        props: [
          keyProperty4(angleKey, angleScaleType, { id: "angleValue" }),
          valueProperty9(radiusKey, radiusScaleType, __spreadValues2({
            id: "radiusValue-raw",
            invalidValue: null
          }, visibleProps)),
          ...groupAccumulativeValueProperty22(
            radiusKey,
            "normal",
            "current",
            __spreadValues2({
              id: `radiusValue-end`,
              rangeId: `radiusValue-range`,
              invalidValue: null,
              groupId: stackGroupId,
              separateNegative: true
            }, visibleProps),
            radiusScaleType
          ),
          ...groupAccumulativeValueProperty22(
            radiusKey,
            "trailing",
            "current",
            __spreadValues2({
              id: `radiusValue-start`,
              invalidValue: null,
              groupId: stackGroupTrailingId,
              separateNegative: true
            }, visibleProps),
            radiusScaleType
          ),
          ...extraProps
        ]
      });
      this.animationState.transition("updateData");
    });
  }
  didCircleChange() {
    const r = this.radius;
    const cx = this.centerX;
    const cy = this.centerY;
    const cache = this.circleCache;
    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {
      this.circleCache = { r, cx, cy };
      return true;
    }
    return false;
  }
  isRadiusAxisReversed() {
    var _a2;
    return (_a2 = this.axes[ChartAxisDirection9.Y]) == null ? void 0 : _a2.isReversed();
  }
  maybeRefreshNodeData() {
    return __async2(this, null, function* () {
      var _a2;
      const circleChanged = this.didCircleChange();
      if (!circleChanged && !this.nodeDataRefresh)
        return;
      const { nodeData = [] } = (_a2 = yield this.createNodeData()) != null ? _a2 : {};
      this.nodeData = nodeData;
      this.nodeDataRefresh = false;
    });
  }
  getAxisInnerRadius() {
    const radiusAxis = this.axes[ChartAxisDirection9.Y];
    return radiusAxis instanceof PolarAxis2 ? this.radius * radiusAxis.innerRadiusRatio : 0;
  }
  createNodeData() {
    return __async2(this, null, function* () {
      var _a2;
      const { processedData, dataModel, groupScale } = this;
      if (!processedData || !dataModel || !this.properties.isValid()) {
        return;
      }
      const angleAxis = this.axes[ChartAxisDirection9.X];
      const radiusAxis = this.axes[ChartAxisDirection9.Y];
      const angleScale = angleAxis == null ? void 0 : angleAxis.scale;
      const radiusScale = radiusAxis == null ? void 0 : radiusAxis.scale;
      if (!angleScale || !radiusScale) {
        return;
      }
      const radiusStartIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-start`);
      const radiusEndIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-end`);
      const radiusRangeIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-range`);
      const radiusRawIndex = dataModel.resolveProcessedDataIndexById(this, `radiusValue-raw`);
      let groupPaddingInner = 0;
      let groupPaddingOuter = 0;
      if (angleAxis instanceof AngleCategoryAxis) {
        groupPaddingInner = angleAxis.groupPaddingInner;
        groupPaddingOuter = angleAxis.paddingInner;
      }
      const groupAngleStep = (_a2 = angleScale.bandwidth) != null ? _a2 : 0;
      const paddedGroupAngleStep = groupAngleStep * (1 - groupPaddingOuter);
      const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
      groupScale.domain = Array.from({ length: visibleGroupCount }).map((_, i) => String(i));
      groupScale.range = [-paddedGroupAngleStep / 2, paddedGroupAngleStep / 2];
      groupScale.paddingInner = visibleGroupCount > 1 ? groupPaddingInner : 0;
      const radiusAxisReversed = this.isRadiusAxisReversed();
      const axisInnerRadius = radiusAxisReversed ? this.radius : this.getAxisInnerRadius();
      const axisOuterRadius = radiusAxisReversed ? this.getAxisInnerRadius() : this.radius;
      const axisTotalRadius = axisOuterRadius + axisInnerRadius;
      const { angleKey, radiusKey, angleName, radiusName, label } = this.properties;
      const getLabelNodeDatum = (datum, radiusDatum, x, y) => {
        const labelText = this.getLabelText(
          label,
          { value: radiusDatum, datum, angleKey, radiusKey, angleName, radiusName },
          (value) => isFiniteNumber5(value) ? value.toFixed(2) : String(value)
        );
        if (labelText) {
          return { x, y, text: labelText, textAlign: "center", textBaseline: "middle" };
        }
      };
      const nodeData = [];
      const context = { itemId: radiusKey, nodeData, labelData: nodeData };
      if (!this.visible)
        return context;
      processedData.data.forEach((group2, index, data) => {
        var _a3;
        const { datum, keys, values, aggValues } = group2;
        const angleDatum = keys[0];
        const radiusDatum = values[radiusRawIndex];
        const isPositive = radiusDatum >= 0 && !Object.is(radiusDatum, -0);
        const innerRadiusDatum = values[radiusStartIndex];
        const outerRadiusDatum = values[radiusEndIndex];
        const radiusRange = (_a3 = aggValues == null ? void 0 : aggValues[radiusRangeIndex][isPositive ? 1 : 0]) != null ? _a3 : 0;
        const negative = isPositive === radiusAxisReversed;
        if (innerRadiusDatum === void 0 || outerRadiusDatum === void 0) {
          return;
        }
        let startAngle;
        let endAngle;
        if (data.length === 1) {
          startAngle = -0.5 * Math.PI;
          endAngle = 1.5 * Math.PI;
        } else {
          const groupAngle = angleScale.convert(angleDatum);
          startAngle = normalizeAngle3605(groupAngle + groupScale.convert(String(groupIndex)));
          endAngle = normalizeAngle3605(startAngle + groupScale.bandwidth);
        }
        const angle = startAngle + groupScale.bandwidth / 2;
        const innerRadius = axisTotalRadius - radiusScale.convert(innerRadiusDatum);
        const outerRadius = axisTotalRadius - radiusScale.convert(outerRadiusDatum);
        const midRadius = (innerRadius + outerRadius) / 2;
        const stackInnerRadius = axisTotalRadius - radiusScale.convert(0);
        const stackOuterRadius = axisTotalRadius - radiusScale.convert(radiusRange);
        const x = Math.cos(angle) * midRadius;
        const y = Math.sin(angle) * midRadius;
        const labelNodeDatum = this.properties.label.enabled ? getLabelNodeDatum(datum, radiusDatum, x, y) : void 0;
        const columnWidth = this.getColumnWidth(startAngle, endAngle);
        nodeData.push({
          series: this,
          datum,
          point: { x, y, size: 0 },
          midPoint: { x, y },
          label: labelNodeDatum,
          angleValue: angleDatum,
          radiusValue: radiusDatum,
          negative,
          innerRadius,
          outerRadius,
          stackInnerRadius,
          stackOuterRadius,
          startAngle,
          endAngle,
          axisInnerRadius,
          axisOuterRadius,
          columnWidth,
          index
        });
      });
      return { itemId: radiusKey, nodeData, labelData: nodeData };
    });
  }
  getColumnWidth(_startAngle, _endAngle) {
    return NaN;
  }
  update(_0) {
    return __async2(this, arguments, function* ({ seriesRect }) {
      const resize = this.checkResize(seriesRect);
      yield this.maybeRefreshNodeData();
      this.contentGroup.translationX = this.centerX;
      this.contentGroup.translationY = this.centerY;
      this.highlightGroup.translationX = this.centerX;
      this.highlightGroup.translationY = this.centerY;
      if (this.labelGroup) {
        this.labelGroup.translationX = this.centerX;
        this.labelGroup.translationY = this.centerY;
      }
      this.updateSectorSelection(this.itemSelection, false);
      this.updateSectorSelection(this.highlightSelection, true);
      this.updateLabels();
      if (resize) {
        this.animationState.transition("resize");
      }
      this.animationState.transition("update");
    });
  }
  updateSectorSelection(selection, highlight) {
    var _a2, _b, _c, _d, _e;
    let selectionData = [];
    if (highlight) {
      const highlighted = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight();
      if ((highlighted == null ? void 0 : highlighted.datum) && highlighted.series === this) {
        selectionData = [highlighted];
      }
    } else {
      selectionData = this.nodeData;
    }
    const highlightedStyle = highlight ? this.properties.highlightStyle.item : void 0;
    const fill = (_b = highlightedStyle == null ? void 0 : highlightedStyle.fill) != null ? _b : this.properties.fill;
    const fillOpacity = (_c = highlightedStyle == null ? void 0 : highlightedStyle.fillOpacity) != null ? _c : this.properties.fillOpacity;
    const stroke = (_d = highlightedStyle == null ? void 0 : highlightedStyle.stroke) != null ? _d : this.properties.stroke;
    const strokeOpacity = this.properties.strokeOpacity;
    const strokeWidth = (_e = highlightedStyle == null ? void 0 : highlightedStyle.strokeWidth) != null ? _e : this.properties.strokeWidth;
    const idFn = (datum) => datum.angleValue;
    selection.update(selectionData, void 0, idFn).each((node, datum) => {
      var _a3, _b2, _c2, _d2;
      const format2 = this.properties.formatter ? this.ctx.callbackCache.call(this.properties.formatter, {
        datum,
        fill,
        stroke,
        strokeWidth,
        highlighted: highlight,
        angleKey: this.properties.angleKey,
        radiusKey: this.properties.radiusKey,
        seriesId: this.id
      }) : void 0;
      this.updateItemPath(node, datum, highlight, format2);
      node.fill = (_a3 = format2 == null ? void 0 : format2.fill) != null ? _a3 : fill;
      node.fillOpacity = (_b2 = format2 == null ? void 0 : format2.fillOpacity) != null ? _b2 : fillOpacity;
      node.stroke = (_c2 = format2 == null ? void 0 : format2.stroke) != null ? _c2 : stroke;
      node.strokeOpacity = strokeOpacity;
      node.strokeWidth = (_d2 = format2 == null ? void 0 : format2.strokeWidth) != null ? _d2 : strokeWidth;
      node.lineDash = this.properties.lineDash;
      node.lineJoin = "round";
    });
  }
  updateLabels() {
    const { label } = this.properties;
    this.labelSelection.update(this.nodeData).each((node, datum) => {
      if (label.enabled && datum.label) {
        node.x = datum.label.x;
        node.y = datum.label.y;
        node.fill = label.color;
        node.fontFamily = label.fontFamily;
        node.fontSize = label.fontSize;
        node.fontStyle = label.fontStyle;
        node.fontWeight = label.fontWeight;
        node.text = datum.label.text;
        node.textAlign = datum.label.textAlign;
        node.textBaseline = datum.label.textBaseline;
        node.visible = true;
      } else {
        node.visible = false;
      }
    });
  }
  animateEmptyUpdateReady() {
    const { labelSelection } = this;
    const fns = this.getColumnTransitionFunctions();
    motion3.fromToMotion(this.id, "datums", this.ctx.animationManager, [this.itemSelection], fns);
    seriesLabelFadeInAnimation22(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateClearingUpdateEmpty() {
    const { itemSelection } = this;
    const { animationManager } = this.ctx;
    const fns = this.getColumnTransitionFunctions();
    motion3.fromToMotion(this.id, "datums", animationManager, [itemSelection], fns);
    seriesLabelFadeOutAnimation2(this, "labels", animationManager, this.labelSelection);
  }
  getTooltipHtml(nodeDatum) {
    var _a2;
    const { id: seriesId, axes, dataModel } = this;
    const { angleKey, radiusKey, angleName, radiusName, fill, stroke, strokeWidth, formatter, tooltip } = this.properties;
    const { angleValue, radiusValue, datum, itemId } = nodeDatum;
    const xAxis = axes[ChartAxisDirection9.X];
    const yAxis = axes[ChartAxisDirection9.Y];
    if (!this.properties.isValid() || !(xAxis && yAxis && isNumber2(radiusValue)) || !dataModel) {
      return import_ag_charts_community91._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const angleString = xAxis.formatDatum(angleValue);
    const radiusString = yAxis.formatDatum(radiusValue);
    const title = sanitizeHtml7(radiusName);
    const content = sanitizeHtml7(`${angleString}: ${radiusString}`);
    const { fill: color } = (_a2 = formatter && this.ctx.callbackCache.call(formatter, {
      seriesId,
      datum,
      fill,
      stroke,
      strokeWidth,
      highlighted: false,
      angleKey,
      radiusKey
    })) != null ? _a2 : { fill };
    return tooltip.toTooltipHtml(
      { title, backgroundColor: fill, content },
      {
        seriesId,
        datum,
        color,
        title,
        angleKey,
        radiusKey,
        angleName,
        radiusName,
        angleValue,
        itemId,
        radiusValue
      }
    );
  }
  pickNodeClosestDatum(point) {
    return this.pickNodeNearestDistantObject(point, this.itemSelection.nodes());
  }
  getLegendData(legendType) {
    var _a2;
    if (!((_a2 = this.data) == null ? void 0 : _a2.length) || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    const { radiusKey, radiusName, fill, stroke, fillOpacity, strokeOpacity, strokeWidth, visible } = this.properties;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: radiusKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: radiusName != null ? radiusName : radiusKey
        },
        marker: {
          fill: fill != null ? fill : "rgba(0, 0, 0, 0)",
          stroke: stroke != null ? stroke : "rgba(0, 0, 0, 0)",
          fillOpacity: fillOpacity != null ? fillOpacity : 1,
          strokeOpacity: strokeOpacity != null ? strokeOpacity : 1,
          strokeWidth
        }
      }
    ];
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const wasClicked = series.id === this.id;
    const newEnabled = wasClicked || enabled && numVisibleItems === 1;
    this.toggleSeriesItem(itemId, newEnabled);
  }
  computeLabelsBBox() {
    return null;
  }
  computeFocusBounds(opts) {
    return computeSectorFocusBounds2(this, opts);
  }
};
var import_ag_charts_community93 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community92 = (init_main(), __toCommonJS(main_exports));
var { Label: Label4 } = import_ag_charts_community92._Scene;
var {
  SeriesProperties: SeriesProperties6,
  SeriesTooltip: SeriesTooltip10,
  Validate: Validate42,
  COLOR_STRING: COLOR_STRING15,
  DEGREE: DEGREE3,
  FUNCTION: FUNCTION10,
  LINE_DASH: LINE_DASH12,
  NUMBER: NUMBER10,
  OBJECT: OBJECT14,
  POSITIVE_NUMBER: POSITIVE_NUMBER19,
  RATIO: RATIO20,
  STRING: STRING14
} = import_ag_charts_community92._ModuleSupport;
var RadialColumnSeriesBaseProperties = class extends SeriesProperties6 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.rotation = 0;
    this.label = new Label4();
    this.tooltip = new SeriesTooltip10();
  }
};
__decorateClass2([
  Validate42(STRING14)
], RadialColumnSeriesBaseProperties.prototype, "angleKey", 2);
__decorateClass2([
  Validate42(STRING14, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "angleName", 2);
__decorateClass2([
  Validate42(STRING14)
], RadialColumnSeriesBaseProperties.prototype, "radiusKey", 2);
__decorateClass2([
  Validate42(STRING14, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "radiusName", 2);
__decorateClass2([
  Validate42(COLOR_STRING15)
], RadialColumnSeriesBaseProperties.prototype, "fill", 2);
__decorateClass2([
  Validate42(RATIO20)
], RadialColumnSeriesBaseProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate42(COLOR_STRING15)
], RadialColumnSeriesBaseProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate42(POSITIVE_NUMBER19)
], RadialColumnSeriesBaseProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate42(RATIO20)
], RadialColumnSeriesBaseProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate42(LINE_DASH12)
], RadialColumnSeriesBaseProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate42(POSITIVE_NUMBER19)
], RadialColumnSeriesBaseProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate42(FUNCTION10, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "formatter", 2);
__decorateClass2([
  Validate42(DEGREE3)
], RadialColumnSeriesBaseProperties.prototype, "rotation", 2);
__decorateClass2([
  Validate42(STRING14, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "stackGroup", 2);
__decorateClass2([
  Validate42(NUMBER10, { optional: true })
], RadialColumnSeriesBaseProperties.prototype, "normalizedTo", 2);
__decorateClass2([
  Validate42(OBJECT14)
], RadialColumnSeriesBaseProperties.prototype, "label", 2);
__decorateClass2([
  Validate42(OBJECT14)
], RadialColumnSeriesBaseProperties.prototype, "tooltip", 2);
var { Validate: Validate43, POSITIVE_NUMBER: POSITIVE_NUMBER20 } = import_ag_charts_community93._ModuleSupport;
var NightingaleSeriesProperties = class extends RadialColumnSeriesBaseProperties {
  constructor() {
    super(...arguments);
    this.cornerRadius = 0;
  }
};
__decorateClass2([
  Validate43(POSITIVE_NUMBER20)
], NightingaleSeriesProperties.prototype, "cornerRadius", 2);
var import_ag_charts_community95 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community94 = (init_main(), __toCommonJS(main_exports));
var { motion: motion4 } = import_ag_charts_community94._Scene;
function createAngleMotionCalculator() {
  const angles = {
    startAngle: /* @__PURE__ */ new Map(),
    endAngle: /* @__PURE__ */ new Map()
  };
  const angleKeys = ["startAngle", "endAngle"];
  const calculate = (node, datum, status) => {
    angleKeys.forEach((key) => {
      var _a2, _b;
      const map = angles[key];
      let from2 = (status === "removed" || status === "updated" ? node : datum)[key];
      let to2 = (status === "removed" ? node : datum)[key];
      if (isNaN(to2)) {
        to2 = (_b = (_a2 = node.previousDatum) == null ? void 0 : _a2[key]) != null ? _b : NaN;
      }
      const diff8 = from2 - to2;
      if (Math.abs(diff8) > Math.PI) {
        from2 -= Math.sign(diff8) * 2 * Math.PI;
      }
      map.set(datum, { from: from2, to: to2 });
    });
  };
  const getAngles = (datum, fromToKey) => {
    return {
      startAngle: angles.startAngle.get(datum)[fromToKey],
      endAngle: angles.endAngle.get(datum)[fromToKey]
    };
  };
  const from = (datum) => getAngles(datum, "from");
  const to = (datum) => getAngles(datum, "to");
  return { calculate, from, to };
}
function fixRadialColumnAnimationStatus(node, datum, status) {
  if (status === "updated") {
    if (node.previousDatum == null || isNaN(node.previousDatum.startAngle) || isNaN(node.previousDatum.endAngle)) {
      return "added";
    }
    if (isNaN(datum.startAngle) || isNaN(datum.endAngle)) {
      return "removed";
    }
  }
  if (status === "added" && node.previousDatum != null) {
    return "updated";
  }
  return status;
}
function prepareRadialColumnAnimationFunctions(axisZeroRadius) {
  const angles = createAngleMotionCalculator();
  const fromFn = (node, datum, status) => {
    status = fixRadialColumnAnimationStatus(node, datum, status);
    angles.calculate(node, datum, status);
    const { startAngle, endAngle } = angles.from(datum);
    let innerRadius;
    let outerRadius;
    let columnWidth;
    let axisInnerRadius;
    let axisOuterRadius;
    if (status === "removed" || status === "updated") {
      innerRadius = node.innerRadius;
      outerRadius = node.outerRadius;
      columnWidth = node.columnWidth;
      axisInnerRadius = node.axisInnerRadius;
      axisOuterRadius = node.axisOuterRadius;
    } else {
      innerRadius = axisZeroRadius;
      outerRadius = axisZeroRadius;
      columnWidth = datum.columnWidth;
      axisInnerRadius = datum.axisInnerRadius;
      axisOuterRadius = datum.axisOuterRadius;
    }
    const phase = motion4.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return {
      innerRadius,
      outerRadius,
      columnWidth,
      axisInnerRadius,
      axisOuterRadius,
      startAngle,
      endAngle,
      phase
    };
  };
  const toFn = (node, datum, status) => {
    const { startAngle, endAngle } = angles.to(datum);
    let innerRadius;
    let outerRadius;
    let columnWidth;
    let axisInnerRadius;
    let axisOuterRadius;
    if (status === "removed") {
      innerRadius = node.innerRadius;
      outerRadius = node.innerRadius;
      columnWidth = node.columnWidth;
      axisInnerRadius = node.axisInnerRadius;
      axisOuterRadius = node.axisOuterRadius;
    } else {
      innerRadius = isNaN(datum.innerRadius) ? axisZeroRadius : datum.innerRadius;
      outerRadius = isNaN(datum.outerRadius) ? axisZeroRadius : datum.outerRadius;
      columnWidth = isNaN(datum.columnWidth) ? node.columnWidth : datum.columnWidth;
      axisInnerRadius = datum.axisInnerRadius;
      axisOuterRadius = datum.axisOuterRadius;
    }
    return { innerRadius, outerRadius, columnWidth, axisInnerRadius, axisOuterRadius, startAngle, endAngle };
  };
  return { toFn, fromFn };
}
function resetRadialColumnSelectionFn(_node, {
  innerRadius,
  outerRadius,
  columnWidth,
  axisInnerRadius,
  axisOuterRadius,
  startAngle,
  endAngle
}) {
  return { innerRadius, outerRadius, columnWidth, axisInnerRadius, axisOuterRadius, startAngle, endAngle };
}
var { SectorBox: SectorBox2, motion: motion5 } = import_ag_charts_community95._Scene;
function getRadii(datum) {
  const { negative, innerRadius, outerRadius, stackInnerRadius, stackOuterRadius } = datum;
  return {
    innerRadius: negative ? stackOuterRadius : stackInnerRadius,
    outerRadius: negative ? stackInnerRadius : stackOuterRadius,
    clipInnerRadius: negative ? outerRadius : innerRadius,
    clipOuterRadius: negative ? innerRadius : outerRadius
  };
}
function prepareNightingaleAnimationFunctions(axisZeroRadius) {
  const angles = createAngleMotionCalculator();
  const fromFn = (sect, datum, status) => {
    status = fixRadialColumnAnimationStatus(sect, datum, status);
    angles.calculate(sect, datum, status);
    const { startAngle, endAngle } = angles.from(datum);
    let innerRadius;
    let outerRadius;
    let clipSector;
    if (status === "removed" || status === "updated") {
      innerRadius = sect.innerRadius;
      outerRadius = sect.outerRadius;
      clipSector = sect.clipSector;
    } else {
      innerRadius = axisZeroRadius;
      outerRadius = axisZeroRadius;
    }
    clipSector != null ? clipSector : clipSector = new SectorBox2(startAngle, endAngle, innerRadius, outerRadius);
    const phase = motion5.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return { innerRadius, outerRadius, startAngle, endAngle, clipSector, phase };
  };
  const toFn = (_sect, datum, status) => {
    const { startAngle, endAngle } = angles.to(datum);
    let innerRadius;
    let outerRadius;
    let clipSector;
    if (status === "removed") {
      innerRadius = axisZeroRadius;
      outerRadius = axisZeroRadius;
      clipSector = new SectorBox2(startAngle, endAngle, innerRadius, outerRadius);
    } else {
      let clipInnerRadius, clipOuterRadius;
      ({ innerRadius, outerRadius, clipInnerRadius, clipOuterRadius } = getRadii(datum));
      if (isNaN(innerRadius))
        innerRadius = axisZeroRadius;
      if (isNaN(outerRadius))
        outerRadius = axisZeroRadius;
      if (isNaN(clipInnerRadius))
        clipInnerRadius = axisZeroRadius;
      if (isNaN(clipOuterRadius))
        clipOuterRadius = axisZeroRadius;
      clipSector = new SectorBox2(startAngle, endAngle, clipInnerRadius, clipOuterRadius);
    }
    return { innerRadius, outerRadius, startAngle, endAngle, clipSector };
  };
  return { toFn, fromFn };
}
function resetNightingaleSelectionFn(_sect, datum) {
  const { startAngle, endAngle } = datum;
  const { innerRadius, outerRadius, clipInnerRadius, clipOuterRadius } = getRadii(datum);
  const clipSector = new SectorBox2(startAngle, endAngle, clipInnerRadius, clipOuterRadius);
  return { innerRadius, outerRadius, startAngle, endAngle, clipSector };
}
var { Sector: Sector3, SectorBox: SectorBox22 } = import_ag_charts_community96._Scene;
var NightingaleSeries = class extends RadialColumnSeriesBase {
  // TODO: Enable once the options contract has been revisited
  // @Validate(POSITIVE_NUMBER)
  // sectorSpacing = 1;
  constructor(moduleCtx) {
    super(moduleCtx, { animationResetFns: { item: resetNightingaleSelectionFn } });
    this.properties = new NightingaleSeriesProperties();
  }
  getStackId() {
    var _a2, _b;
    const groupIndex = (_b = (_a2 = this.seriesGrouping) == null ? void 0 : _a2.groupIndex) != null ? _b : this.id;
    return `nightingale-stack-${groupIndex}-yValues`;
  }
  nodeFactory() {
    return new Sector3();
  }
  updateItemPath(node, datum, highlight, _format) {
    const { negative } = datum;
    node.centerX = 0;
    node.centerY = 0;
    node.startOuterCornerRadius = !negative ? this.properties.cornerRadius : 0;
    node.endOuterCornerRadius = !negative ? this.properties.cornerRadius : 0;
    node.startInnerCornerRadius = negative ? this.properties.cornerRadius : 0;
    node.endInnerCornerRadius = negative ? this.properties.cornerRadius : 0;
    if (highlight) {
      const { startAngle, endAngle } = datum;
      const { innerRadius, outerRadius, clipInnerRadius, clipOuterRadius } = getRadii(datum);
      node.innerRadius = innerRadius;
      node.outerRadius = outerRadius;
      node.startAngle = startAngle;
      node.endAngle = endAngle;
      node.clipSector = new SectorBox22(startAngle, endAngle, clipInnerRadius, clipOuterRadius);
    }
  }
  getColumnTransitionFunctions() {
    const axisZeroRadius = this.isRadiusAxisReversed() ? this.radius : this.getAxisInnerRadius();
    return prepareNightingaleAnimationFunctions(axisZeroRadius);
  }
};
NightingaleSeries.className = "NightingaleSeries";
NightingaleSeries.type = "nightingale";
var import_ag_charts_community97 = (init_main(), __toCommonJS(main_exports));
var NIGHTINGALE_SERIES_THEME = {
  series: {
    __extends__: import_ag_charts_community97._Theme.EXTENDS_SERIES_DEFAULTS,
    strokeWidth: 1,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: import_ag_charts_community97._Theme.DEFAULT_FONT_FAMILY,
      color: import_ag_charts_community97._Theme.DEFAULT_LABEL_COLOUR
    }
  },
  axes: {
    [import_ag_charts_community97._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY]: {
      shape: import_ag_charts_community97._Theme.POLAR_AXIS_SHAPE.CIRCLE,
      groupPaddingInner: 0,
      paddingInner: 0,
      label: {
        padding: 10
      }
    },
    [import_ag_charts_community97._Theme.POLAR_AXIS_TYPE.RADIUS_NUMBER]: {
      shape: import_ag_charts_community97._Theme.POLAR_AXIS_SHAPE.CIRCLE
    }
  }
};
var NightingaleModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "nightingale",
  instanceConstructor: NightingaleSeries,
  defaultAxes: [
    {
      type: import_ag_charts_community98._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY
    },
    {
      type: import_ag_charts_community98._Theme.POLAR_AXIS_TYPE.RADIUS_NUMBER
    }
  ],
  themeTemplate: NIGHTINGALE_SERIES_THEME,
  paletteFactory({ takeColors, userPalette }) {
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return {
      fill,
      stroke: userPalette ? stroke : import_ag_charts_community98._Theme.DEFAULT_POLAR_SERIES_STROKE
    };
  },
  stackable: true,
  groupable: true,
  stackedByDefault: true
};
var import_ag_charts_community103 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community101 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community99 = (init_main(), __toCommonJS(main_exports));
var OhlcGroup = class extends CandlestickBaseGroup {
  constructor() {
    super();
    this.append([
      new import_ag_charts_community99._Scene.Line({
        tag: 0
        /* Body */
      }),
      new import_ag_charts_community99._Scene.Line({
        tag: 1
        /* Open */
      }),
      new import_ag_charts_community99._Scene.Line({
        tag: 2
        /* Close */
      })
    ]);
  }
  updateCoordinates() {
    const {
      x,
      y,
      yBottom,
      yHigh,
      yLow,
      width,
      height,
      datum: { itemId }
    } = this;
    const selection = import_ag_charts_community99._Scene.Selection.select(this, import_ag_charts_community99._Scene.Rect);
    const [body] = selection.selectByTag(
      0
      /* Body */
    );
    const [open] = selection.selectByTag(
      1
      /* Open */
    );
    const [close] = selection.selectByTag(
      2
      /* Close */
    );
    if (width === 0 || height === 0) {
      body.visible = false;
      open.visible = false;
      close.visible = false;
      return;
    }
    body.visible = true;
    open.visible = true;
    close.visible = true;
    const halfWidth = width / 2;
    body.setProperties({
      x1: Math.floor(x + halfWidth),
      x2: Math.floor(x + halfWidth),
      y1: yHigh,
      y2: yLow
    });
    const isRising = itemId === "up";
    const openY = isRising ? yBottom : y;
    const closeY = isRising ? y : yBottom;
    open.setProperties({
      x1: Math.floor(x),
      x2: Math.floor(x + halfWidth),
      y: Math.round(openY)
    });
    close.setProperties({
      x1: Math.floor(x + halfWidth),
      x2: Math.floor(x + width),
      y: Math.round(closeY)
    });
  }
  updateDatumStyles(_datum, activeStyles) {
    const selection = import_ag_charts_community99._Scene.Selection.select(this, import_ag_charts_community99._Scene.Rect);
    const [body] = selection.selectByTag(
      0
      /* Body */
    );
    const [open] = selection.selectByTag(
      1
      /* Open */
    );
    const [close] = selection.selectByTag(
      2
      /* Close */
    );
    body.setProperties(activeStyles);
    open.setProperties(activeStyles);
    close.setProperties(activeStyles);
  }
};
var import_ag_charts_community100 = (init_main(), __toCommonJS(main_exports));
var { BaseProperties: BaseProperties9, Validate: Validate44, COLOR_STRING: COLOR_STRING16, FUNCTION: FUNCTION11, LINE_DASH: LINE_DASH13, OBJECT: OBJECT15, POSITIVE_NUMBER: POSITIVE_NUMBER21, RATIO: RATIO21 } = import_ag_charts_community100._ModuleSupport;
var OhlcSeriesItem = class extends BaseProperties9 {
  constructor() {
    super(...arguments);
    this.stroke = "#333";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
  }
};
__decorateClass2([
  Validate44(COLOR_STRING16)
], OhlcSeriesItem.prototype, "stroke", 2);
__decorateClass2([
  Validate44(POSITIVE_NUMBER21)
], OhlcSeriesItem.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate44(RATIO21)
], OhlcSeriesItem.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate44(LINE_DASH13)
], OhlcSeriesItem.prototype, "lineDash", 2);
__decorateClass2([
  Validate44(POSITIVE_NUMBER21)
], OhlcSeriesItem.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate44(FUNCTION11, { optional: true })
], OhlcSeriesItem.prototype, "formatter", 2);
var OhlcSeriesItems = class extends BaseProperties9 {
  constructor() {
    super(...arguments);
    this.up = new OhlcSeriesItem();
    this.down = new OhlcSeriesItem();
  }
};
__decorateClass2([
  Validate44(OBJECT15)
], OhlcSeriesItems.prototype, "up", 2);
__decorateClass2([
  Validate44(OBJECT15)
], OhlcSeriesItems.prototype, "down", 2);
var OhlcSeriesProperties = class extends CandlestickSeriesBaseProperties {
  constructor() {
    super(new OhlcSeriesItems());
  }
};
var { mergeDefaults: mergeDefaults7 } = import_ag_charts_community101._ModuleSupport;
var OhlcSeries = class extends CandlestickSeriesBase {
  constructor(moduleCtx) {
    super(moduleCtx, resetCandlestickSelectionsFn);
    this.properties = new OhlcSeriesProperties();
  }
  createNodeData() {
    return __async2(this, null, function* () {
      const baseNodeData = this.createBaseNodeData();
      if (!baseNodeData) {
        return;
      }
      const nodeData = baseNodeData.nodeData.map((datum) => {
        const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this.getItemConfig(datum.itemId);
        return __spreadProps2(__spreadValues2({}, datum), {
          stroke,
          strokeWidth,
          strokeOpacity,
          lineDash,
          lineDashOffset
        });
      });
      return __spreadProps2(__spreadValues2({}, baseNodeData), { nodeData });
    });
  }
  nodeFactory() {
    return new OhlcGroup();
  }
  getFormatterParams(params) {
    return params;
  }
  getSeriesStyles(nodeDatum) {
    const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = nodeDatum;
    return {
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      lineDashOffset
    };
  }
  getActiveStyles(nodeDatum, highlighted) {
    const activeStyles = this.getFormattedStyles(nodeDatum, highlighted);
    return highlighted ? mergeDefaults7(this.properties.highlightStyle.item, activeStyles) : activeStyles;
  }
  computeFocusBounds(opts) {
    return computeCandleFocusBounds(this, opts);
  }
};
OhlcSeries.className = "ohlc";
OhlcSeries.type = "ohlc";
var import_ag_charts_community102 = (init_main(), __toCommonJS(main_exports));
var OHLC_SERIES_THEME = {
  series: {
    __extends__: import_ag_charts_community102._Theme.EXTENDS_SERIES_DEFAULTS,
    direction: "vertical"
  },
  animation: { enabled: false },
  axes: {
    [import_ag_charts_community102._Theme.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: {
        snap: false
      }
    },
    [import_ag_charts_community102._Theme.CARTESIAN_AXIS_TYPE.ORDINAL_TIME]: {
      groupPaddingInner: 0,
      crosshair: {
        enabled: true
      }
    }
  }
};
var OhlcModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "ohlc",
  instanceConstructor: OhlcSeries,
  defaultAxes: [
    {
      type: import_ag_charts_community103._Theme.CARTESIAN_AXIS_TYPE.NUMBER,
      position: import_ag_charts_community103._Theme.POSITION.LEFT
    },
    {
      type: import_ag_charts_community103._Theme.CARTESIAN_AXIS_TYPE.ORDINAL_TIME,
      position: import_ag_charts_community103._Theme.POSITION.BOTTOM
    }
  ],
  themeTemplate: OHLC_SERIES_THEME,
  groupable: false,
  paletteFactory: ({ takeColors, colorsCount, userPalette, themeTemplateParameters }) => {
    const {
      strokes: [stroke]
    } = takeColors(colorsCount);
    const { strokes: DEFAULT_STROKES2 } = themeTemplateParameters.properties.get(
      import_ag_charts_community103._Theme.DEFAULT_COLOURS
    );
    return {
      item: {
        up: {
          stroke: userPalette ? stroke : DEFAULT_STROKES2.GREEN
        },
        down: {
          stroke: userPalette ? stroke : DEFAULT_STROKES2.RED
        }
      }
    };
  }
};
var import_ag_charts_community109 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community104 = (init_main(), __toCommonJS(main_exports));
var BASE_RADAR_SERIES_THEME = {
  series: {
    __extends__: import_ag_charts_community104._Theme.EXTENDS_SERIES_DEFAULTS,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: import_ag_charts_community104._Theme.DEFAULT_FONT_FAMILY,
      color: import_ag_charts_community104._Theme.DEFAULT_LABEL_COLOUR
    },
    marker: {
      enabled: true,
      fillOpacity: 1,
      shape: "circle",
      size: 6,
      strokeOpacity: 1,
      strokeWidth: 0
    }
  },
  axes: {
    [import_ag_charts_community104._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY]: {
      label: {
        padding: 10
      }
    }
  }
};
var RADAR_LINE_SERIES_THEME = import_ag_charts_community104._ModuleSupport.mergeDefaults(
  {
    series: {
      strokeWidth: 2
    }
  },
  BASE_RADAR_SERIES_THEME
);
var RADAR_AREA_SERIES_THEME = import_ag_charts_community104._ModuleSupport.mergeDefaults(
  {
    series: {
      fillOpacity: 0.8,
      strokeWidth: 2,
      marker: {
        enabled: false
      }
    }
  },
  BASE_RADAR_SERIES_THEME
);
var import_ag_charts_community108 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community106 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community105 = (init_main(), __toCommonJS(main_exports));
var { Label: Label5 } = import_ag_charts_community105._Scene;
var {
  SeriesMarker: SeriesMarker2,
  SeriesProperties: SeriesProperties7,
  SeriesTooltip: SeriesTooltip11,
  Validate: Validate45,
  BOOLEAN: BOOLEAN15,
  COLOR_STRING: COLOR_STRING17,
  DEGREE: DEGREE4,
  FUNCTION: FUNCTION12,
  LINE_DASH: LINE_DASH14,
  OBJECT: OBJECT16,
  POSITIVE_NUMBER: POSITIVE_NUMBER222,
  RATIO: RATIO222,
  STRING: STRING15
} = import_ag_charts_community105._ModuleSupport;
var RadarSeriesProperties = class extends SeriesProperties7 {
  constructor() {
    super(...arguments);
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.rotation = 0;
    this.marker = new SeriesMarker2();
    this.label = new Label5();
    this.tooltip = new SeriesTooltip11();
    this.connectMissingData = false;
  }
};
__decorateClass2([
  Validate45(STRING15)
], RadarSeriesProperties.prototype, "angleKey", 2);
__decorateClass2([
  Validate45(STRING15)
], RadarSeriesProperties.prototype, "radiusKey", 2);
__decorateClass2([
  Validate45(STRING15, { optional: true })
], RadarSeriesProperties.prototype, "angleName", 2);
__decorateClass2([
  Validate45(STRING15, { optional: true })
], RadarSeriesProperties.prototype, "radiusName", 2);
__decorateClass2([
  Validate45(COLOR_STRING17)
], RadarSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate45(POSITIVE_NUMBER222)
], RadarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate45(RATIO222)
], RadarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate45(LINE_DASH14)
], RadarSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate45(POSITIVE_NUMBER222)
], RadarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate45(FUNCTION12, { optional: true })
], RadarSeriesProperties.prototype, "formatter", 2);
__decorateClass2([
  Validate45(DEGREE4)
], RadarSeriesProperties.prototype, "rotation", 2);
__decorateClass2([
  Validate45(OBJECT16)
], RadarSeriesProperties.prototype, "marker", 2);
__decorateClass2([
  Validate45(OBJECT16)
], RadarSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Validate45(OBJECT16)
], RadarSeriesProperties.prototype, "tooltip", 2);
__decorateClass2([
  Validate45(BOOLEAN15)
], RadarSeriesProperties.prototype, "connectMissingData", 2);
var {
  ChartAxisDirection: ChartAxisDirection10,
  PolarAxis: PolarAxis22,
  SeriesNodePickMode: SeriesNodePickMode10,
  valueProperty: valueProperty10,
  fixNumericExtent: fixNumericExtent5,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation3,
  markerFadeInAnimation: markerFadeInAnimation2,
  resetMarkerFn: resetMarkerFn2,
  animationValidation: animationValidation5,
  isFiniteNumber: isFiniteNumber6,
  computeMarkerFocusBounds: computeMarkerFocusBounds22
} = import_ag_charts_community106._ModuleSupport;
var { BBox: BBox9, Group: Group11, Path: Path6, PointerEvents: PointerEvents5, Selection: Selection8, Text: Text9, getMarker: getMarker22 } = import_ag_charts_community106._Scene;
var { extent: extent3, isNumberEqual: isNumberEqual8, sanitizeHtml: sanitizeHtml8, toFixed: toFixed2 } = import_ag_charts_community106._Util;
var RadarSeriesNodeEvent = class extends import_ag_charts_community106._ModuleSupport.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
  }
};
var RadarSeries = class extends import_ag_charts_community106._ModuleSupport.PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      useLabelLayer: true,
      pickModes: [SeriesNodePickMode10.NEAREST_NODE, SeriesNodePickMode10.EXACT_SHAPE_MATCH],
      canHaveAxes: true,
      animationResetFns: {
        item: resetMarkerFn2
      }
    });
    this.properties = new RadarSeriesProperties();
    this.NodeEvent = RadarSeriesNodeEvent;
    this.resetInvalidToZero = false;
    this.seriesItemEnabled = [];
    this.circleCache = { r: 0, cx: 0, cy: 0 };
    const lineGroup = new Group11();
    this.contentGroup.append(lineGroup);
    this.lineSelection = Selection8.select(lineGroup, Path6);
    lineGroup.zIndexSubOrder = [() => this._declarationOrder, 1];
  }
  nodeFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker22(shape);
    return new MarkerShape();
  }
  addChartEventListeners() {
    var _a2, _b;
    this.destroyFns.push(
      (_a2 = this.ctx.chartEventManager) == null ? void 0 : _a2.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
      (_b = this.ctx.chartEventManager) == null ? void 0 : _b.addListener(
        "legend-item-double-click",
        (event) => this.onLegendItemDoubleClick(event)
      )
    );
  }
  getSeriesDomain(direction) {
    const { dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    if (direction === ChartAxisDirection10.X) {
      return dataModel.getDomain(this, `angleValue`, "value", processedData);
    } else {
      const domain = dataModel.getDomain(this, `radiusValue`, "value", processedData);
      const ext = extent3(domain.length === 0 ? domain : [0].concat(domain));
      return fixNumericExtent5(ext);
    }
  }
  processData(dataController) {
    return __async2(this, null, function* () {
      var _a2, _b;
      if (!this.properties.isValid()) {
        return;
      }
      const { angleKey, radiusKey } = this.properties;
      const extraProps = [];
      if (!this.ctx.animationManager.isSkipped()) {
        extraProps.push(animationValidation5());
      }
      const radiusScaleType = (_a2 = this.axes[ChartAxisDirection10.Y]) == null ? void 0 : _a2.scale.type;
      const angleScaleType = (_b = this.axes[ChartAxisDirection10.X]) == null ? void 0 : _b.scale.type;
      yield this.requestDataModel(dataController, this.data, {
        props: [
          valueProperty10(angleKey, angleScaleType, { id: "angleValue" }),
          valueProperty10(radiusKey, radiusScaleType, { id: "radiusValue", invalidValue: void 0 }),
          ...extraProps
        ]
      });
      this.animationState.transition("updateData");
    });
  }
  didCircleChange() {
    const r = this.radius;
    const cx = this.centerX;
    const cy = this.centerY;
    const cache = this.circleCache;
    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {
      this.circleCache = { r, cx, cy };
      return true;
    }
    return false;
  }
  getAxisInnerRadius() {
    const radiusAxis = this.axes[ChartAxisDirection10.Y];
    return radiusAxis instanceof PolarAxis22 ? this.radius * radiusAxis.innerRadiusRatio : 0;
  }
  maybeRefreshNodeData() {
    return __async2(this, null, function* () {
      var _a2;
      const didCircleChange = this.didCircleChange();
      if (!didCircleChange && !this.nodeDataRefresh)
        return;
      const { nodeData = [] } = (_a2 = yield this.createNodeData()) != null ? _a2 : {};
      this.nodeData = nodeData;
      this.nodeDataRefresh = false;
    });
  }
  createNodeData() {
    return __async2(this, null, function* () {
      var _a2, _b;
      const { processedData, dataModel } = this;
      if (!processedData || !dataModel || !this.properties.isValid()) {
        return;
      }
      const { angleKey, radiusKey, angleName, radiusName, marker, label } = this.properties;
      const angleScale = (_a2 = this.axes[ChartAxisDirection10.X]) == null ? void 0 : _a2.scale;
      const radiusScale = (_b = this.axes[ChartAxisDirection10.Y]) == null ? void 0 : _b.scale;
      if (!angleScale || !radiusScale) {
        return;
      }
      const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);
      const radiusIdx = dataModel.resolveProcessedDataIndexById(this, `radiusValue`);
      const axisInnerRadius = this.getAxisInnerRadius();
      const { seriesItemEnabled } = this;
      seriesItemEnabled.length = 0;
      const nodeData = processedData.data.map((group2) => {
        const { datum, values } = group2;
        const angleDatum = values[angleIdx];
        const radiusDatum = values[radiusIdx];
        const angle = angleScale.convert(angleDatum);
        const radius = this.radius + axisInnerRadius - radiusScale.convert(radiusDatum);
        if (import_ag_charts_community106._Util.isNumber(angle) && import_ag_charts_community106._Util.isNumber(radius)) {
          seriesItemEnabled.push(true);
        } else {
          seriesItemEnabled.push(false);
        }
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const x = cos * radius;
        const y = sin * radius;
        let labelNodeDatum;
        if (label.enabled) {
          const labelText = this.getLabelText(
            label,
            { value: radiusDatum, datum, angleKey, radiusKey, angleName, radiusName },
            (value) => isFiniteNumber6(value) ? value.toFixed(2) : String(value)
          );
          if (labelText) {
            let textAlign = "right";
            if (isNumberEqual8(cos, 0)) {
              textAlign = "center";
            } else if (cos > 0) {
              textAlign = "left";
            }
            let textBaseline = "bottom";
            if (isNumberEqual8(sin, 0)) {
              textBaseline = "middle";
            } else if (sin > 0) {
              textBaseline = "top";
            }
            labelNodeDatum = {
              x: x + cos * marker.size,
              y: y + sin * marker.size,
              text: labelText,
              textAlign,
              textBaseline
            };
          }
        }
        return {
          series: this,
          datum,
          point: { x, y, size: marker.size },
          midPoint: { x, y },
          label: labelNodeDatum,
          angleValue: angleDatum,
          radiusValue: radiusDatum
        };
      });
      return { itemId: radiusKey, nodeData, labelData: nodeData };
    });
  }
  update(_0) {
    return __async2(this, arguments, function* ({ seriesRect }) {
      var _a2, _b;
      const resize = this.checkResize(seriesRect);
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      const { series } = (_b = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight()) != null ? _b : {};
      this.highlightGroup.visible = (animationEnabled || this.visible) && !!(series === this);
      yield this.maybeRefreshNodeData();
      this.contentGroup.translationX = this.centerX;
      this.contentGroup.translationY = this.centerY;
      this.highlightGroup.translationX = this.centerX;
      this.highlightGroup.translationY = this.centerY;
      if (this.labelGroup) {
        this.labelGroup.translationX = this.centerX;
        this.labelGroup.translationY = this.centerY;
      }
      this.updatePathSelections();
      this.updateMarkerSelection();
      this.updateMarkers(this.itemSelection, false);
      this.updateMarkers(this.highlightSelection, true);
      this.updateLabels();
      if (resize) {
        this.animationState.transition("resize");
      }
      this.animationState.transition("update");
    });
  }
  updatePathSelections() {
    const pathData = this.visible ? [true] : [];
    this.lineSelection.update(pathData);
  }
  updateMarkerSelection() {
    if (this.properties.marker.isDirty()) {
      this.itemSelection.clear();
      this.itemSelection.cleanup();
      this.itemSelection = Selection8.select(this.itemGroup, () => this.nodeFactory(), false);
    }
    this.itemSelection.update(this.properties.marker.enabled ? this.nodeData : []);
  }
  getMarkerFill(highlightedStyle) {
    var _a2;
    return (_a2 = highlightedStyle == null ? void 0 : highlightedStyle.fill) != null ? _a2 : this.properties.marker.fill;
  }
  updateMarkers(selection, highlight) {
    var _a2;
    const { angleKey, radiusKey, marker, visible } = this.properties;
    let selectionData = [];
    if (visible && marker.shape && marker.enabled) {
      if (highlight) {
        const highlighted = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight();
        if (highlighted == null ? void 0 : highlighted.datum) {
          selectionData = [highlighted];
        }
      } else {
        selectionData = this.nodeData;
      }
    }
    const highlightedStyle = highlight ? this.properties.highlightStyle.item : void 0;
    selection.update(selectionData).each((node, datum) => {
      var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      const fill = this.getMarkerFill(highlightedStyle);
      const stroke = (_b = (_a3 = highlightedStyle == null ? void 0 : highlightedStyle.stroke) != null ? _a3 : marker.stroke) != null ? _b : this.properties.stroke;
      const strokeWidth = (_e = (_d = (_c = highlightedStyle == null ? void 0 : highlightedStyle.strokeWidth) != null ? _c : marker.strokeWidth) != null ? _d : this.properties.strokeWidth) != null ? _e : 1;
      const format2 = marker.formatter ? this.ctx.callbackCache.call(marker.formatter, {
        datum: datum.datum,
        angleKey,
        radiusKey,
        fill,
        stroke,
        strokeWidth,
        size: marker.size,
        highlighted: highlight,
        seriesId: this.id
      }) : void 0;
      node.fill = (_f = format2 == null ? void 0 : format2.fill) != null ? _f : fill;
      node.stroke = (_g = format2 == null ? void 0 : format2.stroke) != null ? _g : stroke;
      node.strokeWidth = (_h = format2 == null ? void 0 : format2.strokeWidth) != null ? _h : strokeWidth;
      node.fillOpacity = (_j = (_i = highlightedStyle == null ? void 0 : highlightedStyle.fillOpacity) != null ? _i : marker.fillOpacity) != null ? _j : 1;
      node.strokeOpacity = (_l = (_k = marker.strokeOpacity) != null ? _k : this.properties.strokeOpacity) != null ? _l : 1;
      node.size = (_m = format2 == null ? void 0 : format2.size) != null ? _m : marker.size;
      const { x, y } = datum.point;
      node.translationX = x;
      node.translationY = y;
      node.visible = visible && node.size > 0 && !isNaN(x) && !isNaN(y);
    });
  }
  updateLabels() {
    const { label } = this.properties;
    this.labelSelection.update(this.nodeData).each((node, datum) => {
      if (label.enabled && datum.label) {
        node.x = datum.label.x;
        node.y = datum.label.y;
        node.fill = label.color;
        node.fontFamily = label.fontFamily;
        node.fontSize = label.fontSize;
        node.fontStyle = label.fontStyle;
        node.fontWeight = label.fontWeight;
        node.text = datum.label.text;
        node.textAlign = datum.label.textAlign;
        node.textBaseline = datum.label.textBaseline;
        node.visible = true;
      } else {
        node.visible = false;
      }
    });
  }
  getTooltipHtml(nodeDatum) {
    var _a2;
    if (!this.properties.isValid()) {
      return import_ag_charts_community106._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const { id: seriesId } = this;
    const { angleKey, radiusKey, angleName, radiusName, marker, tooltip } = this.properties;
    const { datum, angleValue, radiusValue, itemId } = nodeDatum;
    const formattedAngleValue = typeof angleValue === "number" ? toFixed2(angleValue) : String(angleValue);
    const formattedRadiusValue = typeof radiusValue === "number" ? toFixed2(radiusValue) : String(radiusValue);
    const title = sanitizeHtml8(radiusName);
    const content = sanitizeHtml8(`${formattedAngleValue}: ${formattedRadiusValue}`);
    const { formatter: markerFormatter, fill, stroke, strokeWidth: markerStrokeWidth, size } = marker;
    const strokeWidth = markerStrokeWidth != null ? markerStrokeWidth : this.properties.strokeWidth;
    const { fill: color } = (_a2 = markerFormatter && this.ctx.callbackCache.call(markerFormatter, {
      datum,
      angleKey,
      radiusKey,
      fill,
      stroke,
      strokeWidth,
      size,
      highlighted: false,
      seriesId
    })) != null ? _a2 : { fill };
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        datum,
        angleKey,
        angleName,
        radiusKey,
        radiusName,
        title,
        color,
        seriesId,
        itemId
      }
    );
  }
  getLegendData(legendType) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    if (!((_a2 = this.data) == null ? void 0 : _a2.length) || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    const { radiusKey, radiusName, stroke, strokeWidth, strokeOpacity, lineDash, visible, marker } = this.properties;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: radiusKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: radiusName != null ? radiusName : radiusKey
        },
        marker: {
          shape: marker.shape,
          fill: (_d = (_c = (_b = this.getMarkerFill()) != null ? _b : marker.stroke) != null ? _c : stroke) != null ? _d : "rgba(0, 0, 0, 0)",
          stroke: (_f = (_e = marker.stroke) != null ? _e : stroke) != null ? _f : "rgba(0, 0, 0, 0)",
          fillOpacity: (_g = marker.fillOpacity) != null ? _g : 1,
          strokeOpacity: (_i = (_h = marker.strokeOpacity) != null ? _h : strokeOpacity) != null ? _i : 1,
          strokeWidth: (_j = marker.strokeWidth) != null ? _j : 0,
          enabled: marker.enabled || strokeWidth <= 0
        },
        line: {
          stroke,
          strokeOpacity,
          strokeWidth,
          lineDash
        }
      }
    ];
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const wasClicked = series.id === this.id;
    const newEnabled = wasClicked || enabled && numVisibleItems === 1;
    this.toggleSeriesItem(itemId, newEnabled);
  }
  pickNodeClosestDatum(point) {
    var _a2, _b;
    const { x, y } = point;
    const { rootGroup, nodeData, centerX: cx, centerY: cy } = this;
    const hitPoint = rootGroup.transformPoint(x, y);
    const radius = this.radius;
    const distanceFromCenter = Math.sqrt(__pow2(x - cx, 2) + __pow2(y - cy, 2));
    if (distanceFromCenter > radius + this.properties.marker.size) {
      return;
    }
    let minDistance = Infinity;
    let closestDatum;
    for (const datum of nodeData) {
      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;
      if (isNaN(datumX) || isNaN(datumY)) {
        continue;
      }
      const distance2 = Math.sqrt(__pow2(hitPoint.x - datumX - cx, 2) + __pow2(hitPoint.y - datumY - cy, 2));
      if (distance2 < minDistance) {
        minDistance = distance2;
        closestDatum = datum;
      }
    }
    if (closestDatum) {
      const distance2 = Math.max(minDistance - ((_b = (_a2 = closestDatum.point) == null ? void 0 : _a2.size) != null ? _b : 0), 0);
      return { datum: closestDatum, distance: distance2 };
    }
  }
  computeLabelsBBox() {
    return __async2(this, null, function* () {
      const { label } = this.properties;
      yield this.maybeRefreshNodeData();
      const textBoxes = [];
      const tempText2 = new Text9();
      this.nodeData.forEach((nodeDatum) => {
        if (!label.enabled || !nodeDatum.label) {
          return;
        }
        tempText2.text = nodeDatum.label.text;
        tempText2.x = nodeDatum.label.x;
        tempText2.y = nodeDatum.label.y;
        tempText2.setFont(label);
        tempText2.setAlign(nodeDatum.label);
        const box = tempText2.computeBBox();
        textBoxes.push(box);
      });
      if (textBoxes.length === 0) {
        return null;
      }
      return BBox9.merge(textBoxes);
    });
  }
  getLineNode() {
    return this.lineSelection.nodes()[0];
  }
  beforePathAnimation() {
    const lineNode = this.getLineNode();
    lineNode.fill = void 0;
    lineNode.lineJoin = "round";
    lineNode.lineCap = "round";
    lineNode.pointerEvents = PointerEvents5.None;
    lineNode.stroke = this.properties.stroke;
    lineNode.strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);
    lineNode.strokeOpacity = this.properties.strokeOpacity;
    lineNode.lineDash = this.properties.lineDash;
    lineNode.lineDashOffset = this.properties.lineDashOffset;
  }
  getLinePoints() {
    const { nodeData, resetInvalidToZero } = this;
    const { connectMissingData } = this.properties;
    if (nodeData.length === 0) {
      return [];
    }
    const radiusAxis = this.axes[ChartAxisDirection10.Y];
    const angleAxis = this.axes[ChartAxisDirection10.X];
    const reversedAngleAxis = angleAxis == null ? void 0 : angleAxis.isReversed();
    const reversedRadiusAxis = radiusAxis == null ? void 0 : radiusAxis.isReversed();
    const data = reversedRadiusAxis && !reversedAngleAxis ? [...nodeData].reverse() : nodeData;
    const points = [];
    let prevPointInvalid = false;
    let firstValid;
    data.forEach((datum, index) => {
      let { x, y } = datum.point;
      const isPointInvalid = isNaN(x) || isNaN(y);
      if (!isPointInvalid) {
        firstValid != null ? firstValid : firstValid = datum;
      }
      if (isPointInvalid && !connectMissingData) {
        x = 0;
        y = 0;
      }
      const moveTo = index === 0 || !resetInvalidToZero && !connectMissingData && (isPointInvalid || prevPointInvalid);
      points.push({ x, y, moveTo });
      prevPointInvalid = isPointInvalid;
    });
    if (firstValid !== void 0) {
      points.push({ x: firstValid.point.x, y: firstValid.point.y, moveTo: false });
    }
    return points;
  }
  animateSinglePath(pathNode, points, ratio) {
    const { path } = pathNode;
    path.clear(true);
    const axisInnerRadius = this.getAxisInnerRadius();
    const radiusAxis = this.axes[ChartAxisDirection10.Y];
    const reversedRadiusAxis = radiusAxis == null ? void 0 : radiusAxis.isReversed();
    const radiusZero = reversedRadiusAxis ? this.radius + axisInnerRadius - (radiusAxis == null ? void 0 : radiusAxis.scale.convert(0)) : axisInnerRadius;
    points.forEach((point) => {
      const { x: x1, y: y1, arc, radius = 0, startAngle = 0, endAngle = 0, moveTo } = point;
      const angle = Math.atan2(y1, x1);
      const x0 = radiusZero * Math.cos(angle);
      const y0 = radiusZero * Math.sin(angle);
      const t = ratio;
      const x = x0 * (1 - t) + x1 * t;
      const y = y0 * (1 - t) + y1 * t;
      if (arc) {
        path.arc(x1, y1, radius, startAngle, endAngle);
      } else if (moveTo) {
        path.moveTo(x, y);
      } else {
        path.lineTo(x, y);
      }
    });
    pathNode.checkPathDirty();
  }
  animatePaths(ratio) {
    const linePoints = this.getLinePoints();
    this.animateSinglePath(this.getLineNode(), linePoints, ratio);
  }
  animateEmptyUpdateReady() {
    const { itemSelection, labelSelection } = this;
    const { animationManager } = this.ctx;
    this.beforePathAnimation();
    animationManager.animate({
      id: `${this.id}_'path`,
      groupId: this.id,
      from: 0,
      to: 1,
      phase: "initial",
      collapsable: false,
      onUpdate: (ratio) => this.animatePaths(ratio),
      onStop: () => this.animatePaths(1)
    });
    markerFadeInAnimation2(this, animationManager, "added", itemSelection);
    seriesLabelFadeInAnimation3(this, "labels", animationManager, labelSelection);
  }
  animateWaitingUpdateReady(data) {
    super.animateWaitingUpdateReady(data);
    this.resetPaths();
  }
  animateReadyResize(data) {
    super.animateReadyResize(data);
    this.resetPaths();
  }
  resetPaths() {
    const lineNode = this.getLineNode();
    if (lineNode) {
      const { path: linePath } = lineNode;
      const linePoints = this.getLinePoints();
      lineNode.fill = void 0;
      lineNode.stroke = this.properties.stroke;
      lineNode.strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);
      lineNode.strokeOpacity = this.properties.strokeOpacity;
      lineNode.lineDash = this.properties.lineDash;
      lineNode.lineDashOffset = this.properties.lineDashOffset;
      linePath.clear(true);
      linePoints.forEach(({ x, y, moveTo }) => {
        if (moveTo) {
          linePath.moveTo(x, y);
        } else {
          linePath.lineTo(x, y);
        }
      });
      lineNode.checkPathDirty();
    }
  }
  getFormattedMarkerStyle(datum) {
    const { angleKey, radiusKey } = this.properties;
    return this.getMarkerStyle(this.properties.marker, { datum, angleKey, radiusKey, highlighted: true });
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds22(this, opts);
  }
};
RadarSeries.className = "RadarSeries";
var import_ag_charts_community107 = (init_main(), __toCommonJS(main_exports));
var { RATIO: RATIO23, COLOR_STRING: COLOR_STRING18, Validate: Validate46 } = import_ag_charts_community107._ModuleSupport;
var RadarAreaSeriesProperties = class extends RadarSeriesProperties {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
  }
};
__decorateClass2([
  Validate46(COLOR_STRING18)
], RadarAreaSeriesProperties.prototype, "fill", 2);
__decorateClass2([
  Validate46(RATIO23)
], RadarAreaSeriesProperties.prototype, "fillOpacity", 2);
var { Group: Group12, Path: Path7, PointerEvents: PointerEvents6, Selection: Selection9 } = import_ag_charts_community108._Scene;
var { ChartAxisDirection: ChartAxisDirection11 } = import_ag_charts_community108._ModuleSupport;
var RadarAreaSeries = class extends RadarSeries {
  constructor(moduleCtx) {
    super(moduleCtx);
    this.properties = new RadarAreaSeriesProperties();
    this.resetInvalidToZero = true;
    const areaGroup = new Group12();
    areaGroup.zIndexSubOrder = [() => this._declarationOrder, 0];
    this.contentGroup.append(areaGroup);
    this.areaSelection = Selection9.select(areaGroup, Path7);
  }
  updatePathSelections() {
    const pathData = this.visible ? [true] : [];
    this.areaSelection.update(pathData);
    super.updatePathSelections();
  }
  getAreaNode() {
    return this.areaSelection.nodes()[0];
  }
  getMarkerFill(highlightedStyle) {
    var _a2, _b;
    return (_b = (_a2 = highlightedStyle == null ? void 0 : highlightedStyle.fill) != null ? _a2 : this.properties.marker.fill) != null ? _b : this.properties.fill;
  }
  beforePathAnimation() {
    super.beforePathAnimation();
    const areaNode = this.getAreaNode();
    areaNode.fill = this.properties.fill;
    areaNode.fillOpacity = this.properties.fillOpacity;
    areaNode.pointerEvents = PointerEvents6.None;
    areaNode.stroke = void 0;
  }
  animatePaths(ratio) {
    super.animatePaths(ratio);
    this.animateSinglePath(this.getAreaNode(), this.getAreaPoints(), ratio);
  }
  getAreaPoints() {
    var _a2, _b;
    const points = this.getLinePoints();
    const getPolarAxis = (direction) => {
      const axis = this.axes[direction];
      return axis instanceof import_ag_charts_community108._ModuleSupport.PolarAxis ? axis : void 0;
    };
    const radiusAxis = getPolarAxis(ChartAxisDirection11.Y);
    const angleAxis = getPolarAxis(ChartAxisDirection11.X);
    const reversedRadiusAxis = radiusAxis == null ? void 0 : radiusAxis.isReversed();
    if (!reversedRadiusAxis) {
      return points;
    }
    const { points: zeroLinePoints = [] } = (_b = (_a2 = angleAxis == null ? void 0 : angleAxis.getAxisLinePoints) == null ? void 0 : _a2.call(angleAxis)) != null ? _b : {};
    return points.concat(...zeroLinePoints);
  }
  resetPaths() {
    super.resetPaths();
    const areaNode = this.getAreaNode();
    if (areaNode) {
      const { path: areaPath } = areaNode;
      const areaPoints = this.getAreaPoints();
      areaNode.fill = this.properties.fill;
      areaNode.fillOpacity = this.properties.fillOpacity;
      areaNode.stroke = void 0;
      areaNode.lineDash = this.properties.lineDash;
      areaNode.lineDashOffset = this.properties.lineDashOffset;
      areaNode.lineJoin = areaNode.lineCap = "round";
      areaPath.clear(true);
      areaPoints.forEach(({ x, y, moveTo, arc, radius = 0, startAngle = 0, endAngle = 0 }) => {
        if (arc) {
          areaPath.arc(x, y, radius, startAngle, endAngle);
        } else if (moveTo) {
          areaPath.moveTo(x, y);
        } else {
          areaPath.lineTo(x, y);
        }
      });
      areaPath.closePath();
      areaNode.checkPathDirty();
    }
  }
};
RadarAreaSeries.className = "RadarAreaSeries";
RadarAreaSeries.type = "radar-area";
var { markerPaletteFactory: markerPaletteFactory2 } = import_ag_charts_community109._ModuleSupport;
var RadarAreaModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radar-area",
  instanceConstructor: RadarAreaSeries,
  defaultAxes: [
    {
      type: import_ag_charts_community109._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY
    },
    {
      type: import_ag_charts_community109._Theme.POLAR_AXIS_TYPE.RADIUS_NUMBER
    }
  ],
  themeTemplate: RADAR_AREA_SERIES_THEME,
  paletteFactory: (params) => {
    const { marker } = markerPaletteFactory2(params);
    return {
      stroke: marker.stroke,
      fill: marker.fill,
      marker
    };
  }
};
var import_ag_charts_community110 = (init_main(), __toCommonJS(main_exports));
var RadarLineSeries = class extends RadarSeries {
  updatePathSelections() {
    this.lineSelection.update(this.visible ? [true] : []);
  }
};
RadarLineSeries.className = "RadarLineSeries";
RadarLineSeries.type = "radar-line";
var RadarLineModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radar-line",
  instanceConstructor: RadarLineSeries,
  defaultAxes: [
    {
      type: import_ag_charts_community110._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY
    },
    {
      type: import_ag_charts_community110._Theme.POLAR_AXIS_TYPE.RADIUS_NUMBER
    }
  ],
  themeTemplate: RADAR_LINE_SERIES_THEME,
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return {
      stroke: fill,
      marker: { fill, stroke }
    };
  }
};
var import_ag_charts_community115 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community113 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community111 = (init_main(), __toCommonJS(main_exports));
var { Label: Label6 } = import_ag_charts_community111._Scene;
var {
  SeriesProperties: SeriesProperties8,
  SeriesTooltip: SeriesTooltip12,
  Validate: Validate47,
  COLOR_STRING: COLOR_STRING19,
  DEGREE: DEGREE5,
  FUNCTION: FUNCTION13,
  LINE_DASH: LINE_DASH15,
  NUMBER: NUMBER11,
  OBJECT: OBJECT17,
  POSITIVE_NUMBER: POSITIVE_NUMBER23,
  RATIO: RATIO24,
  STRING: STRING16
} = import_ag_charts_community111._ModuleSupport;
var RadialBarSeriesProperties = class extends SeriesProperties8 {
  constructor() {
    super(...arguments);
    this.fill = "black";
    this.fillOpacity = 1;
    this.stroke = "black";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.rotation = 0;
    this.label = new Label6();
    this.tooltip = new SeriesTooltip12();
  }
};
__decorateClass2([
  Validate47(STRING16)
], RadialBarSeriesProperties.prototype, "angleKey", 2);
__decorateClass2([
  Validate47(STRING16)
], RadialBarSeriesProperties.prototype, "radiusKey", 2);
__decorateClass2([
  Validate47(STRING16, { optional: true })
], RadialBarSeriesProperties.prototype, "angleName", 2);
__decorateClass2([
  Validate47(STRING16, { optional: true })
], RadialBarSeriesProperties.prototype, "radiusName", 2);
__decorateClass2([
  Validate47(COLOR_STRING19)
], RadialBarSeriesProperties.prototype, "fill", 2);
__decorateClass2([
  Validate47(RATIO24)
], RadialBarSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate47(COLOR_STRING19)
], RadialBarSeriesProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate47(POSITIVE_NUMBER23)
], RadialBarSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate47(RATIO24)
], RadialBarSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate47(LINE_DASH15)
], RadialBarSeriesProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate47(POSITIVE_NUMBER23)
], RadialBarSeriesProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate47(POSITIVE_NUMBER23)
], RadialBarSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass2([
  Validate47(FUNCTION13, { optional: true })
], RadialBarSeriesProperties.prototype, "formatter", 2);
__decorateClass2([
  Validate47(DEGREE5)
], RadialBarSeriesProperties.prototype, "rotation", 2);
__decorateClass2([
  Validate47(STRING16, { optional: true })
], RadialBarSeriesProperties.prototype, "stackGroup", 2);
__decorateClass2([
  Validate47(NUMBER11, { optional: true })
], RadialBarSeriesProperties.prototype, "normalizedTo", 2);
__decorateClass2([
  Validate47(OBJECT17)
], RadialBarSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Validate47(OBJECT17)
], RadialBarSeriesProperties.prototype, "tooltip", 2);
var import_ag_charts_community112 = (init_main(), __toCommonJS(main_exports));
var { SectorBox: SectorBox3, motion: motion6 } = import_ag_charts_community112._Scene;
function fixRadialBarAnimationStatus(node, datum, status) {
  if (status === "updated") {
    if (node.previousDatum == null || isNaN(node.previousDatum.innerRadius) || isNaN(node.previousDatum.outerRadius)) {
      return "added";
    }
    if (isNaN(datum.innerRadius) || isNaN(datum.outerRadius)) {
      return "removed";
    }
  }
  if (status === "added" && node.previousDatum != null) {
    return "updated";
  }
  return status;
}
function prepareRadialBarSeriesAnimationFunctions(axisZeroAngle) {
  const fromFn = (sect, datum, status) => {
    status = fixRadialBarAnimationStatus(sect, datum, status);
    let startAngle;
    let endAngle;
    let innerRadius;
    let outerRadius;
    let clipSector;
    if (status === "removed" || status === "updated") {
      startAngle = sect.startAngle;
      endAngle = sect.endAngle;
      innerRadius = sect.innerRadius;
      outerRadius = sect.outerRadius;
      clipSector = sect.clipSector;
    } else {
      startAngle = axisZeroAngle;
      endAngle = axisZeroAngle;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
    }
    clipSector != null ? clipSector : clipSector = new SectorBox3(startAngle, endAngle, innerRadius, outerRadius);
    const phase = motion6.NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];
    return { startAngle, endAngle, innerRadius, outerRadius, clipSector, phase };
  };
  const toFn = (sect, datum, status) => {
    let startAngle;
    let endAngle;
    let innerRadius;
    let outerRadius;
    let clipSector;
    if (status === "removed") {
      startAngle = axisZeroAngle;
      endAngle = axisZeroAngle;
      innerRadius = datum.innerRadius;
      outerRadius = datum.outerRadius;
      clipSector = new SectorBox3(startAngle, endAngle, innerRadius, outerRadius);
    } else {
      startAngle = datum.startAngle;
      endAngle = datum.endAngle;
      innerRadius = isNaN(datum.innerRadius) ? sect.innerRadius : datum.innerRadius;
      outerRadius = isNaN(datum.outerRadius) ? sect.outerRadius : datum.outerRadius;
      clipSector = datum.clipSector;
    }
    return { startAngle, endAngle, innerRadius, outerRadius, clipSector };
  };
  return { toFn, fromFn };
}
function resetRadialBarSelectionsFn(_node, datum) {
  return {
    centerX: 0,
    centerY: 0,
    innerRadius: datum.innerRadius,
    outerRadius: datum.outerRadius,
    startAngle: datum.startAngle,
    endAngle: datum.endAngle,
    clipSector: datum.clipSector
  };
}
var {
  ChartAxisDirection: ChartAxisDirection12,
  PolarAxis: PolarAxis3,
  diff: diff5,
  isDefined: isDefined4,
  groupAccumulativeValueProperty: groupAccumulativeValueProperty3,
  keyProperty: keyProperty5,
  normaliseGroupTo: normaliseGroupTo22,
  valueProperty: valueProperty11,
  fixNumericExtent: fixNumericExtent6,
  resetLabelFn: resetLabelFn22,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation4,
  seriesLabelFadeOutAnimation: seriesLabelFadeOutAnimation22,
  animationValidation: animationValidation6,
  isFiniteNumber: isFiniteNumber7,
  computeSectorFocusBounds: computeSectorFocusBounds22
} = import_ag_charts_community113._ModuleSupport;
var { BandScale: BandScale4 } = import_ag_charts_community113._Scale;
var { Sector: Sector4, SectorBox: SectorBox4, motion: motion7 } = import_ag_charts_community113._Scene;
var { angleBetween: angleBetween3, isNumber: isNumber22, sanitizeHtml: sanitizeHtml9 } = import_ag_charts_community113._Util;
var RadialBarSeriesNodeEvent = class extends import_ag_charts_community113._ModuleSupport.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.angleKey = series.properties.angleKey;
    this.radiusKey = series.properties.radiusKey;
  }
};
var RadialBarSeries = class extends import_ag_charts_community113._ModuleSupport.PolarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      useLabelLayer: true,
      canHaveAxes: true,
      animationResetFns: {
        item: resetRadialBarSelectionsFn,
        label: resetLabelFn22
      }
    });
    this.properties = new RadialBarSeriesProperties();
    this.NodeEvent = RadialBarSeriesNodeEvent;
    this.groupScale = new BandScale4();
    this.circleCache = { r: 0, cx: 0, cy: 0 };
  }
  nodeFactory() {
    return new Sector4();
  }
  addChartEventListeners() {
    var _a2, _b;
    this.destroyFns.push(
      (_a2 = this.ctx.chartEventManager) == null ? void 0 : _a2.addListener("legend-item-click", (event) => this.onLegendItemClick(event)),
      (_b = this.ctx.chartEventManager) == null ? void 0 : _b.addListener(
        "legend-item-double-click",
        (event) => this.onLegendItemDoubleClick(event)
      )
    );
  }
  getSeriesDomain(direction) {
    const { axes, dataModel, processedData } = this;
    if (!processedData || !dataModel)
      return [];
    if (direction === ChartAxisDirection12.X) {
      const angleAxis = axes[ChartAxisDirection12.X];
      const xExtent = dataModel.getDomain(this, "angleValue-end", "value", processedData);
      const fixedXExtent = [xExtent[0] > 0 ? 0 : xExtent[0], xExtent[1] < 0 ? 0 : xExtent[1]];
      return fixNumericExtent6(fixedXExtent, angleAxis);
    } else {
      return dataModel.getDomain(this, "radiusValue", "key", processedData);
    }
  }
  processData(dataController) {
    return __async2(this, null, function* () {
      var _a2, _b;
      const { angleKey, radiusKey, normalizedTo, visible } = this.properties;
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      if (!this.properties.isValid() || !(visible || animationEnabled))
        return;
      const stackGroupId = this.getStackId();
      const stackGroupTrailingId = `${stackGroupId}-trailing`;
      const extraProps = [];
      if (isDefined4(normalizedTo)) {
        extraProps.push(normaliseGroupTo22([stackGroupId, stackGroupTrailingId], Math.abs(normalizedTo), "range"));
      }
      if (animationEnabled) {
        if (this.processedData) {
          extraProps.push(diff5(this.processedData));
        }
        extraProps.push(animationValidation6());
      }
      const visibleProps = this.visible || !animationEnabled ? {} : { forceValue: 0 };
      const radiusScaleType = (_a2 = this.axes[ChartAxisDirection12.Y]) == null ? void 0 : _a2.scale.type;
      const angleScaleType = (_b = this.axes[ChartAxisDirection12.X]) == null ? void 0 : _b.scale.type;
      yield this.requestDataModel(dataController, this.data, {
        props: [
          keyProperty5(radiusKey, radiusScaleType, { id: "radiusValue" }),
          valueProperty11(angleKey, angleScaleType, __spreadValues2({
            id: "angleValue-raw",
            invalidValue: null
          }, visibleProps)),
          ...groupAccumulativeValueProperty3(
            angleKey,
            "normal",
            "current",
            __spreadValues2({
              id: `angleValue-end`,
              rangeId: `angleValue-range`,
              invalidValue: null,
              groupId: stackGroupId,
              separateNegative: true
            }, visibleProps),
            angleScaleType
          ),
          ...groupAccumulativeValueProperty3(
            angleKey,
            "trailing",
            "current",
            __spreadValues2({
              id: `angleValue-start`,
              invalidValue: null,
              groupId: stackGroupTrailingId,
              separateNegative: true
            }, visibleProps),
            angleScaleType
          ),
          ...extraProps
        ]
      });
      this.animationState.transition("updateData");
    });
  }
  didCircleChange() {
    const r = this.radius;
    const cx = this.centerX;
    const cy = this.centerY;
    const cache = this.circleCache;
    if (!(r === cache.r && cx === cache.cx && cy === cache.cy)) {
      this.circleCache = { r, cx, cy };
      return true;
    }
    return false;
  }
  maybeRefreshNodeData() {
    return __async2(this, null, function* () {
      var _a2;
      const circleChanged = this.didCircleChange();
      if (!circleChanged && !this.nodeDataRefresh)
        return;
      const { nodeData = [] } = (_a2 = yield this.createNodeData()) != null ? _a2 : {};
      this.nodeData = nodeData;
      this.nodeDataRefresh = false;
    });
  }
  getAxisInnerRadius() {
    const radiusAxis = this.axes[ChartAxisDirection12.Y];
    return radiusAxis instanceof PolarAxis3 ? this.radius * radiusAxis.innerRadiusRatio : 0;
  }
  createNodeData() {
    return __async2(this, null, function* () {
      var _a2;
      const { processedData, dataModel } = this;
      if (!processedData || !dataModel || !this.properties.isValid()) {
        return;
      }
      const angleAxis = this.axes[ChartAxisDirection12.X];
      const radiusAxis = this.axes[ChartAxisDirection12.Y];
      const angleScale = angleAxis == null ? void 0 : angleAxis.scale;
      const radiusScale = radiusAxis == null ? void 0 : radiusAxis.scale;
      if (!angleScale || !radiusScale) {
        return;
      }
      const angleStartIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-start`);
      const angleEndIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-end`);
      const angleRangeIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-range`);
      const angleRawIndex = dataModel.resolveProcessedDataIndexById(this, `angleValue-raw`);
      let groupPaddingInner = 0;
      if (radiusAxis instanceof RadiusCategoryAxis) {
        groupPaddingInner = radiusAxis.groupPaddingInner;
      }
      const { groupScale } = this;
      const { index: groupIndex, visibleGroupCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);
      groupScale.domain = Array.from({ length: visibleGroupCount }).map((_, i) => String(i));
      groupScale.range = [0, Math.abs((_a2 = radiusScale.bandwidth) != null ? _a2 : 0)];
      groupScale.paddingInner = visibleGroupCount > 1 ? groupPaddingInner : 0;
      const barWidth = groupScale.bandwidth >= 1 ? groupScale.bandwidth : groupScale.rawBandwidth;
      const angleAxisReversed = angleAxis.isReversed();
      const radiusAxisReversed = radiusAxis.isReversed();
      const axisInnerRadius = radiusAxisReversed ? this.radius : this.getAxisInnerRadius();
      const axisOuterRadius = radiusAxisReversed ? this.getAxisInnerRadius() : this.radius;
      const axisTotalRadius = axisOuterRadius + axisInnerRadius;
      const { angleKey, radiusKey, angleName, radiusName, label } = this.properties;
      const getLabelNodeDatum = (datum, angleDatum, x, y) => {
        const labelText = this.getLabelText(
          label,
          { value: angleDatum, datum, angleKey, radiusKey, angleName, radiusName },
          (value) => isFiniteNumber7(value) ? value.toFixed(2) : String(value)
        );
        if (labelText) {
          return { x, y, text: labelText, textAlign: "center", textBaseline: "middle" };
        }
      };
      const nodeData = [];
      const context = { itemId: radiusKey, nodeData, labelData: nodeData };
      if (!this.visible)
        return context;
      processedData.data.forEach((group2, index) => {
        var _a3;
        const { datum, keys, values, aggValues } = group2;
        const radiusDatum = keys[0];
        const angleDatum = values[angleRawIndex];
        const isPositive = angleDatum >= 0 && !Object.is(angleDatum, -0);
        const angleStartDatum = values[angleStartIndex];
        const angleEndDatum = values[angleEndIndex];
        const angleRange = (_a3 = aggValues == null ? void 0 : aggValues[angleRangeIndex][isPositive ? 1 : 0]) != null ? _a3 : 0;
        const reversed = isPositive === angleAxisReversed;
        let startAngle = angleScale.convert(angleStartDatum, { clampMode: "clamped" });
        let endAngle = angleScale.convert(angleEndDatum, { clampMode: "clamped" });
        let rangeStartAngle = angleScale.convert(0, { clampMode: "clamped" });
        let rangeEndAngle = angleScale.convert(angleRange, { clampMode: "clamped" });
        if (reversed) {
          [rangeStartAngle, rangeEndAngle] = [rangeEndAngle, rangeStartAngle];
          [startAngle, endAngle] = [endAngle, startAngle];
        }
        const dataRadius = axisTotalRadius - radiusScale.convert(radiusDatum);
        const innerRadius = dataRadius + groupScale.convert(String(groupIndex));
        const outerRadius = innerRadius + barWidth;
        const midRadius = (innerRadius + outerRadius) / 2;
        const midAngle = startAngle + angleBetween3(startAngle, endAngle) / 2;
        const x = Math.cos(midAngle) * midRadius;
        const y = Math.sin(midAngle) * midRadius;
        const labelNodeDatum = this.properties.label.enabled ? getLabelNodeDatum(datum, angleDatum, x, y) : void 0;
        const clipSector = new SectorBox4(startAngle, endAngle, innerRadius, outerRadius);
        nodeData.push({
          series: this,
          datum,
          point: { x, y, size: 0 },
          midPoint: { x, y },
          label: labelNodeDatum,
          angleValue: angleDatum,
          radiusValue: radiusDatum,
          innerRadius,
          outerRadius,
          startAngle: rangeStartAngle,
          endAngle: rangeEndAngle,
          clipSector,
          reversed,
          index
        });
      });
      return context;
    });
  }
  update(_0) {
    return __async2(this, arguments, function* ({ seriesRect }) {
      const resize = this.checkResize(seriesRect);
      yield this.maybeRefreshNodeData();
      this.contentGroup.translationX = this.centerX;
      this.contentGroup.translationY = this.centerY;
      this.highlightGroup.translationX = this.centerX;
      this.highlightGroup.translationY = this.centerY;
      if (this.labelGroup) {
        this.labelGroup.translationX = this.centerX;
        this.labelGroup.translationY = this.centerY;
      }
      this.updateSectorSelection(this.itemSelection, false);
      this.updateSectorSelection(this.highlightSelection, true);
      this.updateLabels();
      if (resize) {
        this.animationState.transition("resize");
      }
      this.animationState.transition("update");
    });
  }
  updateSectorSelection(selection, highlight) {
    var _a2, _b, _c, _d, _e;
    let selectionData = [];
    if (highlight) {
      const highlighted = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight();
      if ((highlighted == null ? void 0 : highlighted.datum) && highlighted.series === this) {
        selectionData = [highlighted];
      }
    } else {
      selectionData = this.nodeData;
    }
    const highlightedStyle = highlight ? this.properties.highlightStyle.item : void 0;
    const fill = (_b = highlightedStyle == null ? void 0 : highlightedStyle.fill) != null ? _b : this.properties.fill;
    const fillOpacity = (_c = highlightedStyle == null ? void 0 : highlightedStyle.fillOpacity) != null ? _c : this.properties.fillOpacity;
    const stroke = (_d = highlightedStyle == null ? void 0 : highlightedStyle.stroke) != null ? _d : this.properties.stroke;
    const strokeOpacity = this.properties.strokeOpacity;
    const strokeWidth = (_e = highlightedStyle == null ? void 0 : highlightedStyle.strokeWidth) != null ? _e : this.properties.strokeWidth;
    const cornerRadius = this.properties.cornerRadius;
    const idFn = (datum) => datum.radiusValue;
    selection.update(selectionData, void 0, idFn).each((node, datum) => {
      var _a3, _b2, _c2, _d2, _e2;
      const format2 = this.properties.formatter ? this.ctx.callbackCache.call(this.properties.formatter, {
        datum,
        fill,
        stroke,
        strokeWidth,
        highlighted: highlight,
        angleKey: this.properties.angleKey,
        radiusKey: this.properties.radiusKey,
        seriesId: this.id
      }) : void 0;
      node.fill = (_a3 = format2 == null ? void 0 : format2.fill) != null ? _a3 : fill;
      node.fillOpacity = (_b2 = format2 == null ? void 0 : format2.fillOpacity) != null ? _b2 : fillOpacity;
      node.stroke = (_c2 = format2 == null ? void 0 : format2.stroke) != null ? _c2 : stroke;
      node.strokeOpacity = strokeOpacity;
      node.strokeWidth = (_d2 = format2 == null ? void 0 : format2.strokeWidth) != null ? _d2 : strokeWidth;
      node.lineDash = this.properties.lineDash;
      node.lineJoin = "round";
      node.inset = stroke != null ? ((_e2 = format2 == null ? void 0 : format2.strokeWidth) != null ? _e2 : strokeWidth) / 2 : 0;
      node.startInnerCornerRadius = datum.reversed ? cornerRadius : 0;
      node.startOuterCornerRadius = datum.reversed ? cornerRadius : 0;
      node.endInnerCornerRadius = datum.reversed ? 0 : cornerRadius;
      node.endOuterCornerRadius = datum.reversed ? 0 : cornerRadius;
      if (highlight) {
        node.startAngle = datum.startAngle;
        node.endAngle = datum.endAngle;
        node.clipSector = datum.clipSector;
        node.innerRadius = datum.innerRadius;
        node.outerRadius = datum.outerRadius;
      }
    });
  }
  updateLabels() {
    const { label } = this.properties;
    this.labelSelection.update(this.nodeData).each((node, datum) => {
      if (label.enabled && datum.label) {
        node.x = datum.label.x;
        node.y = datum.label.y;
        node.fill = label.color;
        node.fontFamily = label.fontFamily;
        node.fontSize = label.fontSize;
        node.fontStyle = label.fontStyle;
        node.fontWeight = label.fontWeight;
        node.text = datum.label.text;
        node.textAlign = datum.label.textAlign;
        node.textBaseline = datum.label.textBaseline;
        node.visible = true;
      } else {
        node.visible = false;
      }
    });
  }
  getBarTransitionFunctions() {
    var _a2;
    const angleScale = (_a2 = this.axes[ChartAxisDirection12.X]) == null ? void 0 : _a2.scale;
    let axisZeroAngle = 0;
    if (!angleScale) {
      return prepareRadialBarSeriesAnimationFunctions(axisZeroAngle);
    }
    const d0 = Math.min(angleScale.domain[0], angleScale.domain[1]);
    const d1 = Math.max(angleScale.domain[0], angleScale.domain[1]);
    if (d0 <= 0 && d1 >= 0) {
      axisZeroAngle = angleScale.convert(0);
    }
    return prepareRadialBarSeriesAnimationFunctions(axisZeroAngle);
  }
  animateEmptyUpdateReady() {
    const { labelSelection } = this;
    const fns = this.getBarTransitionFunctions();
    motion7.fromToMotion(this.id, "datums", this.ctx.animationManager, [this.itemSelection], fns);
    seriesLabelFadeInAnimation4(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateClearingUpdateEmpty() {
    const { itemSelection } = this;
    const { animationManager } = this.ctx;
    const fns = this.getBarTransitionFunctions();
    motion7.fromToMotion(this.id, "datums", animationManager, [itemSelection], fns);
    seriesLabelFadeOutAnimation22(this, "labels", animationManager, this.labelSelection);
  }
  getTooltipHtml(nodeDatum) {
    var _a2;
    const { id: seriesId, axes, dataModel } = this;
    const { angleKey, angleName, radiusKey, radiusName, fill, stroke, strokeWidth, formatter, tooltip } = this.properties;
    const { angleValue, radiusValue, datum, itemId } = nodeDatum;
    const xAxis = axes[ChartAxisDirection12.X];
    const yAxis = axes[ChartAxisDirection12.Y];
    if (!this.properties.isValid() || !(xAxis && yAxis && isNumber22(angleValue)) || !dataModel) {
      return import_ag_charts_community113._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const angleString = xAxis.formatDatum(angleValue);
    const radiusString = yAxis.formatDatum(radiusValue);
    const title = sanitizeHtml9(angleName);
    const content = sanitizeHtml9(`${radiusString}: ${angleString}`);
    const { fill: color } = (_a2 = formatter && this.ctx.callbackCache.call(formatter, {
      datum,
      fill,
      stroke,
      strokeWidth,
      highlighted: false,
      angleKey,
      radiusKey,
      seriesId
    })) != null ? _a2 : { fill };
    return tooltip.toTooltipHtml(
      { title, backgroundColor: fill, content },
      {
        seriesId,
        datum,
        color,
        title,
        angleKey,
        radiusKey,
        angleName,
        radiusName,
        angleValue,
        itemId,
        radiusValue
      }
    );
  }
  getLegendData(legendType) {
    var _a2;
    if (!((_a2 = this.data) == null ? void 0 : _a2.length) || !this.properties.isValid() || legendType !== "category") {
      return [];
    }
    const { angleKey, angleName, fill, stroke, fillOpacity, strokeOpacity, strokeWidth, visible } = this.properties;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: angleKey,
        seriesId: this.id,
        enabled: visible,
        label: {
          text: angleName != null ? angleName : angleKey
        },
        marker: {
          fill: fill != null ? fill : "rgba(0, 0, 0, 0)",
          stroke: stroke != null ? stroke : "rgba(0, 0, 0, 0)",
          fillOpacity: fillOpacity != null ? fillOpacity : 1,
          strokeOpacity: strokeOpacity != null ? strokeOpacity : 1,
          strokeWidth
        }
      }
    ];
  }
  onLegendItemClick(event) {
    const { enabled, itemId, series } = event;
    if (series.id === this.id) {
      this.toggleSeriesItem(itemId, enabled);
    }
  }
  onLegendItemDoubleClick(event) {
    const { enabled, itemId, series, numVisibleItems } = event;
    const wasClicked = series.id === this.id;
    const newEnabled = wasClicked || enabled && numVisibleItems === 1;
    this.toggleSeriesItem(itemId, newEnabled);
  }
  computeLabelsBBox() {
    return null;
  }
  getStackId() {
    var _a2, _b;
    const groupIndex = (_b = (_a2 = this.seriesGrouping) == null ? void 0 : _a2.groupIndex) != null ? _b : this.id;
    return `radialBar-stack-${groupIndex}-xValues`;
  }
  computeFocusBounds(opts) {
    return computeSectorFocusBounds22(this, opts);
  }
};
RadialBarSeries.className = "RadialBarSeries";
RadialBarSeries.type = "radial-bar";
var import_ag_charts_community114 = (init_main(), __toCommonJS(main_exports));
var RADIAL_BAR_SERIES_THEME = {
  series: {
    __extends__: import_ag_charts_community114._Theme.EXTENDS_SERIES_DEFAULTS,
    strokeWidth: 0,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: import_ag_charts_community114._Theme.DEFAULT_FONT_FAMILY,
      color: import_ag_charts_community114._Theme.DEFAULT_INVERTED_LABEL_COLOUR
    }
  },
  axes: {
    [import_ag_charts_community114._Theme.POLAR_AXIS_TYPE.RADIUS_CATEGORY]: {
      innerRadiusRatio: 0.2,
      groupPaddingInner: 0.2,
      paddingInner: 0.2,
      paddingOuter: 0.1
    }
  }
};
var RadialBarModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radial-bar",
  instanceConstructor: RadialBarSeries,
  defaultAxes: [
    {
      type: import_ag_charts_community115._Theme.POLAR_AXIS_TYPE.ANGLE_NUMBER
    },
    {
      type: import_ag_charts_community115._Theme.POLAR_AXIS_TYPE.RADIUS_CATEGORY
    }
  ],
  themeTemplate: RADIAL_BAR_SERIES_THEME,
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return {
      fill,
      stroke
    };
  },
  stackable: true,
  groupable: true
};
var import_ag_charts_community119 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community117 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community116 = (init_main(), __toCommonJS(main_exports));
var { Validate: Validate48, RATIO: RATIO25 } = import_ag_charts_community116._ModuleSupport;
var RadialColumnSeriesProperties = class extends RadialColumnSeriesBaseProperties {
};
__decorateClass2([
  Validate48(RATIO25, { optional: true })
], RadialColumnSeriesProperties.prototype, "columnWidthRatio", 2);
__decorateClass2([
  Validate48(RATIO25, { optional: true })
], RadialColumnSeriesProperties.prototype, "maxColumnWidthRatio", 2);
var { ChartAxisDirection: ChartAxisDirection13, PolarAxis: PolarAxis4 } = import_ag_charts_community117._ModuleSupport;
var { RadialColumnShape: RadialColumnShape2, getRadialColumnWidth: getRadialColumnWidth2 } = import_ag_charts_community117._Scene;
var RadialColumnSeries = class extends RadialColumnSeriesBase {
  constructor(moduleCtx) {
    super(moduleCtx, {
      animationResetFns: {
        item: resetRadialColumnSelectionFn
      }
    });
    this.properties = new RadialColumnSeriesProperties();
  }
  getStackId() {
    var _a2, _b;
    const groupIndex = (_b = (_a2 = this.seriesGrouping) == null ? void 0 : _a2.groupIndex) != null ? _b : this.id;
    return `radarColumn-stack-${groupIndex}-yValues`;
  }
  nodeFactory() {
    return new RadialColumnShape2();
  }
  getColumnTransitionFunctions() {
    const axisZeroRadius = this.isRadiusAxisReversed() ? this.radius : this.getAxisInnerRadius();
    return prepareRadialColumnAnimationFunctions(axisZeroRadius);
  }
  isRadiusAxisCircle() {
    const radiusAxis = this.axes[ChartAxisDirection13.Y];
    return radiusAxis instanceof PolarAxis4 ? radiusAxis.shape === "circle" : false;
  }
  updateItemPath(node, datum, highlight) {
    node.isBeveled = this.isRadiusAxisCircle();
    node.isRadiusAxisReversed = this.isRadiusAxisReversed();
    if (highlight) {
      node.innerRadius = datum.innerRadius;
      node.outerRadius = datum.outerRadius;
      node.startAngle = datum.startAngle;
      node.endAngle = datum.endAngle;
      node.columnWidth = datum.columnWidth;
      node.axisInnerRadius = datum.axisInnerRadius;
      node.axisOuterRadius = datum.axisOuterRadius;
    }
  }
  getColumnWidth(startAngle, endAngle) {
    const { columnWidthRatio = 0.5, maxColumnWidthRatio = 0.5 } = this.properties;
    return getRadialColumnWidth2(startAngle, endAngle, this.radius, columnWidthRatio, maxColumnWidthRatio);
  }
};
RadialColumnSeries.className = "RadialColumnSeries";
RadialColumnSeries.type = "radial-column";
var import_ag_charts_community118 = (init_main(), __toCommonJS(main_exports));
var RADIAL_COLUMN_SERIES_THEME = {
  series: {
    __extends__: import_ag_charts_community118._Theme.EXTENDS_SERIES_DEFAULTS,
    columnWidthRatio: 0.5,
    maxColumnWidthRatio: 0.5,
    strokeWidth: 0,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: import_ag_charts_community118._Theme.DEFAULT_FONT_FAMILY,
      color: import_ag_charts_community118._Theme.DEFAULT_LABEL_COLOUR
    }
  },
  axes: {
    [import_ag_charts_community118._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY]: {
      shape: import_ag_charts_community118._Theme.POLAR_AXIS_SHAPE.CIRCLE,
      groupPaddingInner: 0,
      paddingInner: 0,
      label: {
        padding: 10
      }
    },
    [import_ag_charts_community118._Theme.POLAR_AXIS_TYPE.RADIUS_NUMBER]: {
      shape: import_ag_charts_community118._Theme.POLAR_AXIS_SHAPE.CIRCLE,
      innerRadiusRatio: 0.5
    }
  }
};
var RadialColumnModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["polar"],
  identifier: "radial-column",
  instanceConstructor: RadialColumnSeries,
  defaultAxes: [
    {
      type: import_ag_charts_community119._Theme.POLAR_AXIS_TYPE.ANGLE_CATEGORY
    },
    {
      type: import_ag_charts_community119._Theme.POLAR_AXIS_TYPE.RADIUS_NUMBER
    }
  ],
  themeTemplate: RADIAL_COLUMN_SERIES_THEME,
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return {
      fill,
      stroke
    };
  },
  stackable: true,
  groupable: true
};
var import_ag_charts_community123 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community121 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community120 = (init_main(), __toCommonJS(main_exports));
var { DropShadow: DropShadow2, Label: Label7 } = import_ag_charts_community120._Scene;
var {
  CartesianSeriesProperties: CartesianSeriesProperties22,
  SeriesMarker: SeriesMarker22,
  SeriesTooltip: SeriesTooltip13,
  Validate: Validate49,
  BOOLEAN: BOOLEAN16,
  COLOR_STRING: COLOR_STRING20,
  LINE_DASH: LINE_DASH16,
  OBJECT: OBJECT18,
  PLACEMENT: PLACEMENT2,
  POSITIVE_NUMBER: POSITIVE_NUMBER24,
  RATIO: RATIO26,
  STRING: STRING17
} = import_ag_charts_community120._ModuleSupport;
var RangeAreaSeriesLabel = class extends Label7 {
  constructor() {
    super(...arguments);
    this.placement = "outside";
    this.padding = 6;
  }
};
__decorateClass2([
  Validate49(PLACEMENT2)
], RangeAreaSeriesLabel.prototype, "placement", 2);
__decorateClass2([
  Validate49(POSITIVE_NUMBER24)
], RangeAreaSeriesLabel.prototype, "padding", 2);
var RangeAreaProperties = class extends CartesianSeriesProperties22 {
  constructor() {
    super(...arguments);
    this.fill = "#99CCFF";
    this.fillOpacity = 1;
    this.stroke = "#99CCFF";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.shadow = new DropShadow2().set({ enabled: false });
    this.marker = new SeriesMarker22();
    this.label = new RangeAreaSeriesLabel();
    this.tooltip = new SeriesTooltip13();
    this.connectMissingData = false;
  }
};
__decorateClass2([
  Validate49(STRING17)
], RangeAreaProperties.prototype, "xKey", 2);
__decorateClass2([
  Validate49(STRING17)
], RangeAreaProperties.prototype, "yLowKey", 2);
__decorateClass2([
  Validate49(STRING17)
], RangeAreaProperties.prototype, "yHighKey", 2);
__decorateClass2([
  Validate49(STRING17, { optional: true })
], RangeAreaProperties.prototype, "xName", 2);
__decorateClass2([
  Validate49(STRING17, { optional: true })
], RangeAreaProperties.prototype, "yName", 2);
__decorateClass2([
  Validate49(STRING17, { optional: true })
], RangeAreaProperties.prototype, "yLowName", 2);
__decorateClass2([
  Validate49(STRING17, { optional: true })
], RangeAreaProperties.prototype, "yHighName", 2);
__decorateClass2([
  Validate49(COLOR_STRING20)
], RangeAreaProperties.prototype, "fill", 2);
__decorateClass2([
  Validate49(RATIO26)
], RangeAreaProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate49(COLOR_STRING20)
], RangeAreaProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate49(POSITIVE_NUMBER24)
], RangeAreaProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate49(RATIO26)
], RangeAreaProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate49(LINE_DASH16)
], RangeAreaProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate49(POSITIVE_NUMBER24)
], RangeAreaProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate49(OBJECT18)
], RangeAreaProperties.prototype, "shadow", 2);
__decorateClass2([
  Validate49(OBJECT18)
], RangeAreaProperties.prototype, "marker", 2);
__decorateClass2([
  Validate49(OBJECT18)
], RangeAreaProperties.prototype, "label", 2);
__decorateClass2([
  Validate49(OBJECT18)
], RangeAreaProperties.prototype, "tooltip", 2);
__decorateClass2([
  Validate49(BOOLEAN16)
], RangeAreaProperties.prototype, "connectMissingData", 2);
var {
  valueProperty: valueProperty12,
  keyProperty: keyProperty6,
  ChartAxisDirection: ChartAxisDirection14,
  mergeDefaults: mergeDefaults8,
  updateLabelNode: updateLabelNode2,
  fixNumericExtent: fixNumericExtent7,
  AreaSeriesTag: AreaSeriesTag2,
  buildResetPathFn: buildResetPathFn2,
  resetLabelFn: resetLabelFn3,
  resetMarkerFn: resetMarkerFn22,
  resetMarkerPositionFn: resetMarkerPositionFn2,
  pathSwipeInAnimation: pathSwipeInAnimation2,
  resetMotion: resetMotion2,
  markerSwipeScaleInAnimation: markerSwipeScaleInAnimation2,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation5,
  animationValidation: animationValidation7,
  diff: diff6,
  updateClipPath: updateClipPath2,
  isFiniteNumber: isFiniteNumber8,
  computeMarkerFocusBounds: computeMarkerFocusBounds3
} = import_ag_charts_community121._ModuleSupport;
var { getMarker: getMarker3, PointerEvents: PointerEvents7 } = import_ag_charts_community121._Scene;
var { sanitizeHtml: sanitizeHtml10, extent: extent4 } = import_ag_charts_community121._Util;
var RangeAreaSeriesNodeEvent = class extends import_ag_charts_community121._ModuleSupport.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.yLowKey = series.properties.yLowKey;
    this.yHighKey = series.properties.yHighKey;
  }
};
var RangeAreaSeries = class extends import_ag_charts_community121._ModuleSupport.CartesianSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      hasMarkers: true,
      pathsPerSeries: 2,
      directionKeys: {
        [ChartAxisDirection14.X]: ["xKey"],
        [ChartAxisDirection14.Y]: ["yLowKey", "yHighKey"]
      },
      directionNames: {
        [ChartAxisDirection14.X]: ["xName"],
        [ChartAxisDirection14.Y]: ["yLowName", "yHighName", "yName"]
      },
      animationResetFns: {
        path: buildResetPathFn2({ getOpacity: () => this.getOpacity() }),
        label: resetLabelFn3,
        marker: (node, datum) => __spreadValues2(__spreadValues2({}, resetMarkerFn22(node)), resetMarkerPositionFn2(node, datum))
      }
    });
    this.properties = new RangeAreaProperties();
    this.NodeEvent = RangeAreaSeriesNodeEvent;
  }
  processData(dataController) {
    return __async2(this, null, function* () {
      var _a2, _b;
      if (!this.properties.isValid() || !this.visible)
        return;
      const { xKey, yLowKey, yHighKey } = this.properties;
      const xScale = (_a2 = this.axes[ChartAxisDirection14.X]) == null ? void 0 : _a2.scale;
      const yScale = (_b = this.axes[ChartAxisDirection14.Y]) == null ? void 0 : _b.scale;
      const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
      const extraProps = [];
      const animationEnabled = !this.ctx.animationManager.isSkipped();
      if (!this.ctx.animationManager.isSkipped() && this.processedData) {
        extraProps.push(diff6(this.processedData));
      }
      if (animationEnabled) {
        extraProps.push(animationValidation7());
      }
      yield this.requestDataModel(dataController, this.data, {
        props: [
          keyProperty6(xKey, xScaleType, { id: `xValue` }),
          valueProperty12(yLowKey, yScaleType, { id: `yLowValue`, invalidValue: void 0 }),
          valueProperty12(yHighKey, yScaleType, { id: `yHighValue`, invalidValue: void 0 }),
          ...extraProps
        ]
      });
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    const { processedData, dataModel, axes } = this;
    if (!(processedData && dataModel))
      return [];
    const {
      domain: {
        keys: [keys],
        values
      }
    } = processedData;
    if (direction === ChartAxisDirection14.X) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      const xAxis = axes[ChartAxisDirection14.X];
      if ((keyDef == null ? void 0 : keyDef.def.type) === "key" && keyDef.def.valueType === "category") {
        return keys;
      }
      return fixNumericExtent7(extent4(keys), xAxis);
    } else {
      const yLowIndex = dataModel.resolveProcessedDataIndexById(this, "yLowValue");
      const yLowExtent = values[yLowIndex];
      const yHighIndex = dataModel.resolveProcessedDataIndexById(this, "yHighValue");
      const yHighExtent = values[yHighIndex];
      const fixedYExtent = [
        yLowExtent[0] > yHighExtent[0] ? yHighExtent[0] : yLowExtent[0],
        yHighExtent[1] < yLowExtent[1] ? yLowExtent[1] : yHighExtent[1]
      ];
      return fixNumericExtent7(fixedYExtent);
    }
  }
  createNodeData() {
    return __async2(this, null, function* () {
      var _a2, _b;
      const { data, dataModel, axes, visible } = this;
      const xAxis = axes[ChartAxisDirection14.X];
      const yAxis = axes[ChartAxisDirection14.Y];
      if (!(data && visible && xAxis && yAxis && dataModel)) {
        return;
      }
      const xScale = xAxis.scale;
      const yScale = yAxis.scale;
      const { xKey, yLowKey, yHighKey, connectMissingData, marker } = this.properties;
      const itemId = `${yLowKey}-${yHighKey}`;
      const xOffset = ((_a2 = xScale.bandwidth) != null ? _a2 : 0) / 2;
      const defs = dataModel.resolveProcessedDataDefsByIds(this, [`xValue`, `yHighValue`, `yLowValue`]);
      const createCoordinates = (xValue, yHigh, yLow) => {
        const x = xScale.convert(xValue) + xOffset;
        const yHighCoordinate = yScale.convert(yHigh);
        const yLowCoordinate = yScale.convert(yLow);
        return [
          { point: { x, y: yHighCoordinate }, size: marker.size, itemId: `high`, yValue: yHigh, xValue },
          { point: { x, y: yLowCoordinate }, size: marker.size, itemId: `low`, yValue: yLow, xValue }
        ];
      };
      const createMovePoint = (plainPoint) => {
        const _a3 = plainPoint, { point } = _a3, stroke = __objRest2(_a3, ["point"]);
        return __spreadProps2(__spreadValues2({}, stroke), { point: __spreadProps2(__spreadValues2({}, point), { moveTo: true }) });
      };
      const labelData = [];
      const markerData = [];
      const strokeData = { itemId, points: [] };
      const fillData = { itemId, points: [] };
      const context = {
        itemId,
        labelData,
        nodeData: markerData,
        fillData,
        strokeData,
        scales: this.calculateScaling(),
        visible: this.visible
      };
      if (!this.visible)
        return context;
      const fillHighPoints = fillData.points;
      const fillLowPoints = [];
      const strokeHighPoints = strokeData.points;
      const strokeLowPoints = [];
      let lastXValue;
      let lastYHighDatum = -Infinity;
      let lastYLowDatum = -Infinity;
      (_b = this.processedData) == null ? void 0 : _b.data.forEach(({ keys, datum, values }, datumIdx) => {
        const dataValues = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });
        const { xValue, yHighValue, yLowValue } = dataValues;
        const invalidRange = yHighValue == null || yLowValue == null;
        const points = invalidRange ? [] : createCoordinates(xValue, yHighValue, yLowValue);
        const inverted = yLowValue > yHighValue;
        points.forEach(({ point: { x, y }, size, itemId: datumItemId = "", yValue }) => {
          markerData.push({
            index: datumIdx,
            series: this,
            itemId: datumItemId,
            datum,
            midPoint: { x, y },
            yHighValue,
            yLowValue,
            xValue,
            xKey,
            yLowKey,
            yHighKey,
            point: { x, y, size }
          });
          const labelDatum = this.createLabelData({
            point: { x, y },
            value: yValue,
            yLowValue,
            yHighValue,
            itemId: datumItemId,
            inverted,
            datum,
            series: this
          });
          labelData.push(labelDatum);
        });
        const lastYValid = lastYHighDatum != null && lastYLowDatum != null;
        const lastValid = lastXValue != null && lastYValid;
        const xValid = xValue != null;
        const yValid = yHighValue != null && yLowValue != null;
        let [high, low] = createCoordinates(xValue, yHighValue != null ? yHighValue : 0, yLowValue != null ? yLowValue : 0);
        if (!connectMissingData) {
          if (!yValid) {
            const [prevHigh, prevLow] = createCoordinates(lastXValue, 0, 0);
            fillHighPoints.push(prevHigh);
            fillLowPoints.push(prevLow);
          } else if (!lastYValid) {
            const [prevHigh, prevLow] = createCoordinates(xValue, 0, 0);
            fillHighPoints.push(prevHigh);
            fillLowPoints.push(prevLow);
          }
        }
        if (xValid && yValid) {
          fillHighPoints.push(high);
          fillLowPoints.push(low);
        }
        const move = xValid && yValid && !lastValid && !connectMissingData && datumIdx > 0;
        if (move) {
          high = createMovePoint(high);
          low = createMovePoint(low);
        }
        if (xValid && yValid) {
          strokeHighPoints.push(high);
          strokeLowPoints.push(low);
        }
        lastXValue = xValue;
        lastYHighDatum = yHighValue;
        lastYLowDatum = yLowValue;
      });
      if (fillHighPoints.length > 0) {
        fillHighPoints[0] = createMovePoint(fillHighPoints[0]);
      }
      fillHighPoints.push(...fillLowPoints.reverse());
      if (strokeLowPoints.length > 0) {
        strokeLowPoints[0] = createMovePoint(strokeLowPoints[0]);
      }
      strokeHighPoints.push(...strokeLowPoints);
      return context;
    });
  }
  createLabelData({
    point,
    value,
    itemId,
    inverted,
    datum,
    series
  }) {
    const { xKey, yLowKey, yHighKey, xName, yName, yLowName, yHighName, label } = this.properties;
    const { placement, padding = 10 } = label;
    let actualItemId = itemId;
    if (inverted) {
      actualItemId = itemId === "low" ? "high" : "low";
    }
    const direction = placement === "outside" && actualItemId === "high" || placement === "inside" && actualItemId === "low" ? -1 : 1;
    return {
      x: point.x,
      y: point.y + padding * direction,
      series,
      itemId,
      datum,
      text: this.getLabelText(
        label,
        { value, datum, itemId, xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName },
        (v) => isFiniteNumber8(v) ? v.toFixed(2) : String(v)
      ),
      textAlign: "center",
      textBaseline: direction === -1 ? "bottom" : "top"
    };
  }
  isPathOrSelectionDirty() {
    return this.properties.marker.isDirty();
  }
  markerFactory() {
    const { shape } = this.properties.marker;
    const MarkerShape = getMarker3(shape);
    return new MarkerShape();
  }
  updatePathNodes(opts) {
    return __async2(this, null, function* () {
      const { opacity, visible } = opts;
      const [fill, stroke] = opts.paths;
      const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);
      stroke.setProperties({
        tag: AreaSeriesTag2.Stroke,
        fill: void 0,
        lineJoin: stroke.lineCap = "round",
        pointerEvents: PointerEvents7.None,
        stroke: this.properties.stroke,
        strokeWidth,
        strokeOpacity: this.properties.strokeOpacity,
        lineDash: this.properties.lineDash,
        lineDashOffset: this.properties.lineDashOffset,
        opacity,
        visible
      });
      fill.setProperties({
        tag: AreaSeriesTag2.Fill,
        stroke: void 0,
        lineJoin: "round",
        pointerEvents: PointerEvents7.None,
        fill: this.properties.fill,
        fillOpacity: this.properties.fillOpacity,
        lineDash: this.properties.lineDash,
        lineDashOffset: this.properties.lineDashOffset,
        strokeOpacity: this.properties.strokeOpacity,
        fillShadow: this.properties.shadow,
        strokeWidth,
        opacity,
        visible
      });
      updateClipPath2(this, stroke);
      updateClipPath2(this, fill);
    });
  }
  updatePaths(opts) {
    return __async2(this, null, function* () {
      this.updateAreaPaths(opts.paths, opts.contextData);
    });
  }
  updateAreaPaths(paths, contextData) {
    this.updateFillPath(paths, contextData);
    this.updateStrokePath(paths, contextData);
  }
  updateFillPath(paths, contextData) {
    const { fillData } = contextData;
    const [fill] = paths;
    const { path: fillPath } = fill;
    fillPath.clear(true);
    for (const { point } of fillData.points) {
      if (point.moveTo) {
        fillPath.moveTo(point.x, point.y);
      } else {
        fillPath.lineTo(point.x, point.y);
      }
    }
    fillPath.closePath();
    fill.checkPathDirty();
  }
  updateStrokePath(paths, contextData) {
    const { strokeData } = contextData;
    const [, stroke] = paths;
    const { path: strokePath } = stroke;
    strokePath.clear(true);
    for (const { point } of strokeData.points) {
      if (point.moveTo) {
        strokePath.moveTo(point.x, point.y);
      } else {
        strokePath.lineTo(point.x, point.y);
      }
    }
    stroke.checkPathDirty();
  }
  updateMarkerSelection(opts) {
    return __async2(this, null, function* () {
      const { nodeData, markerSelection } = opts;
      if (this.properties.marker.isDirty()) {
        markerSelection.clear();
        markerSelection.cleanup();
      }
      return markerSelection.update(this.properties.marker.enabled ? nodeData : []);
    });
  }
  updateMarkerNodes(opts) {
    return __async2(this, null, function* () {
      const { markerSelection, isHighlight: highlighted } = opts;
      const { xKey, yLowKey, yHighKey, marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity } = this.properties;
      const baseStyle = mergeDefaults8(highlighted && this.properties.highlightStyle.item, marker.getStyle(), {
        fill,
        fillOpacity,
        stroke,
        strokeWidth,
        strokeOpacity
      });
      markerSelection.each((node, datum) => {
        this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yHighKey, yLowKey }, baseStyle);
      });
      if (!highlighted) {
        this.properties.marker.markClean();
      }
    });
  }
  updateLabelSelection(opts) {
    return __async2(this, null, function* () {
      const { labelData, labelSelection } = opts;
      return labelSelection.update(labelData, (text) => {
        text.tag = AreaSeriesTag2.Label;
        text.pointerEvents = PointerEvents7.None;
      });
    });
  }
  updateLabelNodes(opts) {
    return __async2(this, null, function* () {
      opts.labelSelection.each((textNode, datum) => {
        updateLabelNode2(textNode, this.properties.label, datum);
      });
    });
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter((ld) => ld.datum === highlightedItem.datum);
    return labelItems.length > 0 ? labelItems : void 0;
  }
  getHighlightData(nodeData, highlightedItem) {
    const highlightItems = nodeData.filter((nodeDatum) => nodeDatum.datum === highlightedItem.datum);
    return highlightItems.length > 0 ? highlightItems : void 0;
  }
  getTooltipHtml(nodeDatum) {
    const xAxis = this.axes[ChartAxisDirection14.X];
    const yAxis = this.axes[ChartAxisDirection14.Y];
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return import_ag_charts_community121._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const { id: seriesId } = this;
    const { xKey, yLowKey, yHighKey, xName, yName, yLowName, yHighName, fill, tooltip } = this.properties;
    const { datum, itemId, xValue, yLowValue, yHighValue } = nodeDatum;
    const color = fill != null ? fill : "gray";
    const xString = sanitizeHtml10(xAxis.formatDatum(xValue));
    const yLowString = sanitizeHtml10(yAxis.formatDatum(yLowValue));
    const yHighString = sanitizeHtml10(yAxis.formatDatum(yHighValue));
    const xSubheading = xName != null ? xName : xKey;
    const yLowSubheading = yLowName != null ? yLowName : yLowKey;
    const yHighSubheading = yHighName != null ? yHighName : yHighKey;
    const title = sanitizeHtml10(yName);
    const content = yName ? `<b>${sanitizeHtml10(xSubheading)}</b>: ${xString}<br><b>${sanitizeHtml10(yLowSubheading)}</b>: ${yLowString}<br><b>${sanitizeHtml10(yHighSubheading)}</b>: ${yHighString}<br>` : `${xString}: ${yLowString} - ${yHighString}`;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      {
        seriesId,
        itemId,
        datum,
        xKey,
        yLowKey,
        yHighKey,
        xName,
        yLowName,
        yHighName,
        yName,
        color,
        title,
        yHighValue,
        yLowValue
      }
    );
  }
  getLegendData(legendType) {
    var _a2, _b;
    if (legendType !== "category") {
      return [];
    }
    const {
      yLowKey,
      yHighKey,
      yName,
      yLowName,
      yHighName,
      fill,
      stroke,
      strokeWidth,
      strokeOpacity,
      lineDash,
      visible,
      marker
    } = this.properties;
    const legendItemText = yName != null ? yName : `${yLowName != null ? yLowName : yLowKey} - ${yHighName != null ? yHighName : yHighKey}`;
    return [
      {
        legendType: "category",
        id: this.id,
        itemId: `${yLowKey}-${yHighKey}`,
        seriesId: this.id,
        enabled: visible,
        label: { text: `${legendItemText}` },
        marker: {
          shape: marker.shape,
          fill: (_a2 = marker.fill) != null ? _a2 : fill,
          stroke: (_b = marker.stroke) != null ? _b : stroke,
          fillOpacity: marker.fillOpacity,
          strokeOpacity: marker.strokeOpacity,
          strokeWidth: marker.strokeWidth
        },
        line: {
          stroke,
          strokeOpacity,
          strokeWidth,
          lineDash
        }
      }
    ];
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  onDataChange() {
  }
  nodeFactory() {
    return new import_ag_charts_community121._Scene.Group();
  }
  animateEmptyUpdateReady(animationData) {
    const { markerSelection, labelSelection, contextData, paths } = animationData;
    const { animationManager } = this.ctx;
    this.updateAreaPaths(paths, contextData);
    pathSwipeInAnimation2(this, animationManager, ...paths);
    resetMotion2([markerSelection], resetMarkerPositionFn2);
    markerSwipeScaleInAnimation2(this, animationManager, markerSelection);
    seriesLabelFadeInAnimation5(this, "labels", animationManager, labelSelection);
  }
  animateReadyResize(animationData) {
    const { contextData, paths } = animationData;
    this.updateAreaPaths(paths, contextData);
    super.animateReadyResize(animationData);
  }
  animateWaitingUpdateReady(animationData) {
    const { contextData, paths } = animationData;
    super.animateWaitingUpdateReady(animationData);
    this.updateAreaPaths(paths, contextData);
  }
  getFormattedMarkerStyle(datum) {
    const { xKey, yLowKey, yHighKey } = this.properties;
    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yLowKey, yHighKey, highlighted: true });
  }
  computeFocusBounds(opts) {
    return computeMarkerFocusBounds3(this, opts);
  }
};
RangeAreaSeries.className = "RangeAreaSeries";
RangeAreaSeries.type = "range-area";
var import_ag_charts_community122 = (init_main(), __toCommonJS(main_exports));
var RANGE_AREA_SERIES_THEME = {
  series: {
    __extends__: import_ag_charts_community122._Theme.EXTENDS_SERIES_DEFAULTS,
    fillOpacity: 0.7,
    nodeClickRange: "nearest",
    marker: {
      __extends__: import_ag_charts_community122._Theme.EXTENDS_CARTESIAN_MARKER_DEFAULTS,
      enabled: false,
      fillOpacity: 1,
      strokeWidth: 2,
      size: 6
    },
    label: {
      enabled: false,
      placement: "outside",
      padding: 10,
      fontSize: 12,
      fontFamily: import_ag_charts_community122._Theme.DEFAULT_FONT_FAMILY,
      color: import_ag_charts_community122._Theme.DEFAULT_LABEL_COLOUR
    }
  },
  axes: {
    [import_ag_charts_community122._Theme.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: {
        enabled: true,
        snap: false
      }
    }
  }
};
var { markerPaletteFactory: markerPaletteFactory22 } = import_ag_charts_community123._ModuleSupport;
var RangeAreaModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "range-area",
  instanceConstructor: RangeAreaSeries,
  defaultAxes: [
    {
      type: import_ag_charts_community123._Theme.CARTESIAN_AXIS_TYPE.NUMBER,
      position: import_ag_charts_community123._Theme.POSITION.LEFT
    },
    {
      type: import_ag_charts_community123._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: import_ag_charts_community123._Theme.POSITION.BOTTOM
    }
  ],
  themeTemplate: RANGE_AREA_SERIES_THEME,
  paletteFactory: (params) => {
    const { marker } = markerPaletteFactory22(params);
    return {
      fill: marker.fill,
      stroke: marker.stroke,
      marker
    };
  }
};
var import_ag_charts_community127 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community125 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community124 = (init_main(), __toCommonJS(main_exports));
var { DropShadow: DropShadow22, Label: Label8 } = import_ag_charts_community124._Scene;
var {
  AbstractBarSeriesProperties: AbstractBarSeriesProperties4,
  SeriesTooltip: SeriesTooltip14,
  Validate: Validate50,
  COLOR_STRING: COLOR_STRING21,
  FUNCTION: FUNCTION14,
  LINE_DASH: LINE_DASH17,
  OBJECT: OBJECT19,
  PLACEMENT: PLACEMENT22,
  POSITIVE_NUMBER: POSITIVE_NUMBER25,
  RATIO: RATIO27,
  STRING: STRING18
} = import_ag_charts_community124._ModuleSupport;
var RangeBarSeriesLabel = class extends Label8 {
  constructor() {
    super(...arguments);
    this.placement = "inside";
    this.padding = 6;
  }
};
__decorateClass2([
  Validate50(PLACEMENT22)
], RangeBarSeriesLabel.prototype, "placement", 2);
__decorateClass2([
  Validate50(POSITIVE_NUMBER25)
], RangeBarSeriesLabel.prototype, "padding", 2);
var RangeBarProperties = class extends AbstractBarSeriesProperties4 {
  constructor() {
    super(...arguments);
    this.fill = "#99CCFF";
    this.fillOpacity = 1;
    this.stroke = "#99CCFF";
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.cornerRadius = 0;
    this.shadow = new DropShadow22().set({ enabled: false });
    this.label = new RangeBarSeriesLabel();
    this.tooltip = new SeriesTooltip14();
  }
};
__decorateClass2([
  Validate50(STRING18)
], RangeBarProperties.prototype, "xKey", 2);
__decorateClass2([
  Validate50(STRING18)
], RangeBarProperties.prototype, "yLowKey", 2);
__decorateClass2([
  Validate50(STRING18)
], RangeBarProperties.prototype, "yHighKey", 2);
__decorateClass2([
  Validate50(STRING18, { optional: true })
], RangeBarProperties.prototype, "xName", 2);
__decorateClass2([
  Validate50(STRING18, { optional: true })
], RangeBarProperties.prototype, "yName", 2);
__decorateClass2([
  Validate50(STRING18, { optional: true })
], RangeBarProperties.prototype, "yLowName", 2);
__decorateClass2([
  Validate50(STRING18, { optional: true })
], RangeBarProperties.prototype, "yHighName", 2);
__decorateClass2([
  Validate50(COLOR_STRING21)
], RangeBarProperties.prototype, "fill", 2);
__decorateClass2([
  Validate50(RATIO27)
], RangeBarProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate50(COLOR_STRING21)
], RangeBarProperties.prototype, "stroke", 2);
__decorateClass2([
  Validate50(POSITIVE_NUMBER25)
], RangeBarProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate50(RATIO27)
], RangeBarProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate50(LINE_DASH17)
], RangeBarProperties.prototype, "lineDash", 2);
__decorateClass2([
  Validate50(POSITIVE_NUMBER25)
], RangeBarProperties.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate50(POSITIVE_NUMBER25)
], RangeBarProperties.prototype, "cornerRadius", 2);
__decorateClass2([
  Validate50(FUNCTION14, { optional: true })
], RangeBarProperties.prototype, "formatter", 2);
__decorateClass2([
  Validate50(OBJECT19)
], RangeBarProperties.prototype, "shadow", 2);
__decorateClass2([
  Validate50(OBJECT19)
], RangeBarProperties.prototype, "label", 2);
__decorateClass2([
  Validate50(OBJECT19)
], RangeBarProperties.prototype, "tooltip", 2);
var {
  SeriesNodePickMode: SeriesNodePickMode11,
  valueProperty: valueProperty13,
  keyProperty: keyProperty7,
  ChartAxisDirection: ChartAxisDirection15,
  getRectConfig: getRectConfig2,
  updateRect: updateRect2,
  checkCrisp: checkCrisp2,
  updateLabelNode: updateLabelNode22,
  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL3,
  diff: diff7,
  prepareBarAnimationFunctions: prepareBarAnimationFunctions22,
  midpointStartingBarPosition: midpointStartingBarPosition2,
  resetBarSelectionsFn: resetBarSelectionsFn22,
  fixNumericExtent: fixNumericExtent8,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation6,
  resetLabelFn: resetLabelFn4,
  animationValidation: animationValidation8,
  createDatumId: createDatumId7,
  isFiniteNumber: isFiniteNumber9,
  computeBarFocusBounds: computeBarFocusBounds5
} = import_ag_charts_community125._ModuleSupport;
var { Rect: Rect4, PointerEvents: PointerEvents8, motion: motion8 } = import_ag_charts_community125._Scene;
var { sanitizeHtml: sanitizeHtml11, isNumber: isNumber3, extent: extent5 } = import_ag_charts_community125._Util;
var { ContinuousScale: ContinuousScale3 } = import_ag_charts_community125._Scale;
var RangeBarSeriesNodeEvent = class extends import_ag_charts_community125._ModuleSupport.SeriesNodeEvent {
  constructor(type, nativeEvent, datum, series) {
    super(type, nativeEvent, datum, series);
    this.xKey = series.properties.xKey;
    this.yLowKey = series.properties.yLowKey;
    this.yHighKey = series.properties.yHighKey;
  }
};
var RangeBarSeries = class extends import_ag_charts_community125._ModuleSupport.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      pickModes: [SeriesNodePickMode11.EXACT_SHAPE_MATCH],
      hasHighlightedLabels: true,
      directionKeys: {
        x: ["xKey"],
        y: ["yLowKey", "yHighKey"]
      },
      directionNames: {
        x: ["xName"],
        y: ["yLowName", "yHighName", "yName"]
      },
      datumSelectionGarbageCollection: false,
      animationResetFns: {
        datum: resetBarSelectionsFn22,
        label: resetLabelFn4
      }
    });
    this.properties = new RangeBarProperties();
    this.NodeEvent = RangeBarSeriesNodeEvent;
  }
  processData(dataController) {
    return __async2(this, null, function* () {
      var _a2, _b, _c;
      if (!this.properties.isValid()) {
        return;
      }
      const { xKey, yLowKey, yHighKey } = this.properties;
      const xScale = (_a2 = this.getCategoryAxis()) == null ? void 0 : _a2.scale;
      const yScale = (_b = this.getValueAxis()) == null ? void 0 : _b.scale;
      const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
      const extraProps = [];
      if (!this.ctx.animationManager.isSkipped()) {
        if (this.processedData) {
          extraProps.push(diff7(this.processedData));
        }
        extraProps.push(animationValidation8());
      }
      const visibleProps = this.visible ? {} : { forceValue: 0 };
      const { processedData } = yield this.requestDataModel(dataController, this.data, {
        props: [
          keyProperty7(xKey, xScaleType, { id: "xValue" }),
          valueProperty13(yLowKey, yScaleType, __spreadValues2({ id: `yLowValue` }, visibleProps)),
          valueProperty13(yHighKey, yScaleType, __spreadValues2({ id: `yHighValue` }, visibleProps)),
          ...isContinuousX ? [SMALLEST_KEY_INTERVAL3] : [],
          ...extraProps
        ],
        groupByKeys: true
      });
      this.smallestDataInterval = (_c = processedData.reduced) == null ? void 0 : _c.smallestKeyInterval;
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    var _a2;
    const { processedData, dataModel, smallestDataInterval } = this;
    if (!(processedData && dataModel))
      return [];
    const {
      domain: {
        keys: [keys],
        values
      }
    } = processedData;
    if (direction === this.getCategoryDirection()) {
      const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
      if ((keyDef == null ? void 0 : keyDef.def.type) === "key" && (keyDef == null ? void 0 : keyDef.def.valueType) === "category") {
        return keys;
      }
      const scalePadding = isFiniteNumber9(smallestDataInterval) ? smallestDataInterval : 0;
      const keysExtent = (_a2 = extent5(keys)) != null ? _a2 : [NaN, NaN];
      const categoryAxis = this.getCategoryAxis();
      const d0 = keysExtent[0] + -scalePadding;
      const d1 = keysExtent[1] + scalePadding;
      return fixNumericExtent8([d0, d1], categoryAxis);
    } else {
      const yLowIndex = dataModel.resolveProcessedDataIndexById(this, "yLowValue");
      const yLowExtent = values[yLowIndex];
      const yHighIndex = dataModel.resolveProcessedDataIndexById(this, "yHighValue");
      const yHighExtent = values[yHighIndex];
      const fixedYExtent = [
        yLowExtent[0] > yHighExtent[0] ? yHighExtent[0] : yLowExtent[0],
        yHighExtent[1] < yLowExtent[1] ? yLowExtent[1] : yHighExtent[1]
      ];
      return fixNumericExtent8(fixedYExtent);
    }
  }
  createNodeData() {
    return __async2(this, null, function* () {
      const {
        data,
        dataModel,
        groupScale,
        processedData,
        properties: { visible }
      } = this;
      const xAxis = this.getCategoryAxis();
      const yAxis = this.getValueAxis();
      if (!(data && xAxis && yAxis && dataModel)) {
        return;
      }
      const xScale = xAxis.scale;
      const yScale = yAxis.scale;
      const barAlongX = this.getBarDirection() === ChartAxisDirection15.X;
      const { xKey, yLowKey, yHighKey, fill, stroke, strokeWidth } = this.properties;
      const itemId = `${yLowKey}-${yHighKey}`;
      const context = {
        itemId,
        nodeData: [],
        labelData: [],
        scales: this.calculateScaling(),
        visible: this.visible
      };
      if (!visible)
        return context;
      const yLowIndex = dataModel.resolveProcessedDataIndexById(this, `yLowValue`);
      const yHighIndex = dataModel.resolveProcessedDataIndexById(this, `yHighValue`);
      const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);
      const { barWidth, groupIndex } = this.updateGroupScale(xAxis);
      const barOffset = ContinuousScale3.is(xScale) ? barWidth * -0.5 : 0;
      processedData == null ? void 0 : processedData.data.forEach(({ keys, datum, values }, dataIndex) => {
        values.forEach((value, valueIndex) => {
          const xDatum = keys[xIndex];
          const x = Math.round(xScale.convert(xDatum)) + groupScale.convert(String(groupIndex)) + barOffset;
          const rawLowValue = value[yLowIndex];
          const rawHighValue = value[yHighIndex];
          if (!import_ag_charts_community125._Util.isNumber(rawHighValue) || !import_ag_charts_community125._Util.isNumber(rawLowValue)) {
            return;
          }
          const yLowValue = Math.min(rawLowValue, rawHighValue);
          const yHighValue = Math.max(rawLowValue, rawHighValue);
          const yLow = Math.round(yScale.convert(yLowValue));
          const yHigh = Math.round(yScale.convert(yHighValue));
          const y = yHigh;
          const bottomY = yLow;
          const barHeight = Math.max(strokeWidth, Math.abs(bottomY - y));
          const rect = {
            x: barAlongX ? Math.min(y, bottomY) : x,
            y: barAlongX ? x : Math.min(y, bottomY),
            width: barAlongX ? barHeight : barWidth,
            height: barAlongX ? barWidth : barHeight
          };
          const nodeMidPoint = {
            x: rect.x + rect.width / 2,
            y: rect.y + rect.height / 2
          };
          const labelData = this.createLabelData({
            rect,
            barAlongX,
            yLowValue,
            yHighValue,
            datum: datum[valueIndex],
            series: this
          });
          const nodeDatum = {
            index: dataIndex,
            valueIndex,
            series: this,
            itemId,
            datum: datum[valueIndex],
            xValue: xDatum,
            yLowValue: rawLowValue,
            yHighValue: rawHighValue,
            yLowKey,
            yHighKey,
            xKey,
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height,
            midPoint: nodeMidPoint,
            fill,
            stroke,
            strokeWidth,
            opacity: 1,
            labels: labelData
          };
          context.nodeData.push(nodeDatum);
          context.labelData.push(...labelData);
        });
      });
      return context;
    });
  }
  createLabelData({
    rect,
    barAlongX,
    yLowValue,
    yHighValue,
    datum,
    series
  }) {
    const { xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName, label } = this.properties;
    const labelParams = { datum, xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName };
    const { placement, padding } = label;
    const paddingDirection = placement === "outside" ? 1 : -1;
    const labelPadding = padding * paddingDirection;
    const yLowLabel = {
      x: rect.x + (barAlongX ? -labelPadding : rect.width / 2),
      y: rect.y + (barAlongX ? rect.height / 2 : rect.height + labelPadding),
      textAlign: barAlongX ? "left" : "center",
      textBaseline: barAlongX ? "middle" : "bottom",
      text: this.getLabelText(
        label,
        __spreadValues2({ itemId: "low", value: yLowValue }, labelParams),
        (v) => isFiniteNumber9(v) ? v.toFixed(2) : String(v)
      ),
      itemId: "low",
      datum,
      series
    };
    const yHighLabel = {
      x: rect.x + (barAlongX ? rect.width + labelPadding : rect.width / 2),
      y: rect.y + (barAlongX ? rect.height / 2 : -labelPadding),
      textAlign: barAlongX ? "right" : "center",
      textBaseline: barAlongX ? "middle" : "top",
      text: this.getLabelText(
        label,
        __spreadValues2({ itemId: "high", value: yHighValue }, labelParams),
        (value) => isNumber3(value) ? value.toFixed(2) : ""
      ),
      itemId: "high",
      datum,
      series
    };
    if (placement === "outside") {
      yLowLabel.textAlign = barAlongX ? "right" : "center";
      yLowLabel.textBaseline = barAlongX ? "middle" : "top";
      yHighLabel.textAlign = barAlongX ? "left" : "center";
      yHighLabel.textBaseline = barAlongX ? "middle" : "bottom";
    }
    return [yLowLabel, yHighLabel];
  }
  nodeFactory() {
    return new Rect4();
  }
  updateDatumSelection(opts) {
    return __async2(this, null, function* () {
      const { nodeData, datumSelection } = opts;
      const data = nodeData != null ? nodeData : [];
      return datumSelection.update(data, void 0, (datum) => this.getDatumId(datum));
    });
  }
  updateDatumNodes(opts) {
    return __async2(this, null, function* () {
      const { datumSelection, isHighlight } = opts;
      const { id: seriesId, ctx } = this;
      const {
        yLowKey,
        yHighKey,
        highlightStyle: { item: itemHighlightStyle }
      } = this.properties;
      const xAxis = this.axes[ChartAxisDirection15.X];
      const crisp = checkCrisp2(xAxis == null ? void 0 : xAxis.visibleRange);
      const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection15.X;
      datumSelection.each((rect, datum) => {
        const {
          fillOpacity,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset,
          formatter,
          shadow: fillShadow
        } = this.properties;
        const style = {
          fill: datum.fill,
          stroke: datum.stroke,
          fillOpacity,
          strokeOpacity,
          lineDash,
          lineDashOffset,
          fillShadow,
          strokeWidth: this.getStrokeWidth(strokeWidth),
          cornerRadius: this.properties.cornerRadius
        };
        const visible = categoryAlongX ? datum.width > 0 : datum.height > 0;
        const config = getRectConfig2({
          datum,
          lowValue: datum.yLowValue,
          highValue: datum.yHighValue,
          isHighlighted: isHighlight,
          style,
          highlightStyle: itemHighlightStyle,
          formatter,
          seriesId,
          itemId: datum.itemId,
          ctx,
          yLowKey,
          yHighKey
        });
        config.crisp = crisp;
        config.visible = visible;
        updateRect2({ rect, config });
      });
    });
  }
  getHighlightLabelData(labelData, highlightedItem) {
    const labelItems = labelData.filter((ld) => ld.datum === highlightedItem.datum);
    return labelItems.length > 0 ? labelItems : void 0;
  }
  updateLabelSelection(opts) {
    return __async2(this, null, function* () {
      const labelData = this.properties.label.enabled ? opts.labelData : [];
      return opts.labelSelection.update(labelData, (text) => {
        text.pointerEvents = PointerEvents8.None;
      });
    });
  }
  updateLabelNodes(opts) {
    return __async2(this, null, function* () {
      opts.labelSelection.each((textNode, datum) => {
        updateLabelNode22(textNode, this.properties.label, datum);
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    var _a2, _b;
    const {
      id: seriesId,
      ctx: { callbackCache }
    } = this;
    const xAxis = this.getCategoryAxis();
    const yAxis = this.getValueAxis();
    if (!this.properties.isValid() || !xAxis || !yAxis) {
      return import_ag_charts_community125._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const { xKey, yLowKey, yHighKey, xName, yLowName, yHighName, yName, fill, strokeWidth, formatter, tooltip } = this.properties;
    const { datum, itemId, xValue, yLowValue, yHighValue } = nodeDatum;
    let format2;
    if (formatter) {
      format2 = callbackCache.call(formatter, {
        datum,
        xKey,
        yLowKey,
        yHighKey,
        fill,
        strokeWidth,
        highlighted: false,
        seriesId,
        itemId
      });
    }
    const color = (_b = (_a2 = format2 == null ? void 0 : format2.fill) != null ? _a2 : fill) != null ? _b : "gray";
    const xString = sanitizeHtml11(xAxis.formatDatum(xValue));
    const yLowString = sanitizeHtml11(yAxis.formatDatum(yLowValue));
    const yHighString = sanitizeHtml11(yAxis.formatDatum(yHighValue));
    const xSubheading = xName != null ? xName : xKey;
    const yLowSubheading = yLowName != null ? yLowName : yLowKey;
    const yHighSubheading = yHighName != null ? yHighName : yHighKey;
    const title = sanitizeHtml11(yName);
    const content = yName ? `<b>${sanitizeHtml11(xSubheading)}</b>: ${xString}<br><b>${sanitizeHtml11(yLowSubheading)}</b>: ${yLowString}<br><b>${sanitizeHtml11(yHighSubheading)}</b>: ${yHighString}<br>` : `${xString}: ${yLowString} - ${yHighString}`;
    const defaults = {
      title,
      content,
      backgroundColor: color
    };
    return tooltip.toTooltipHtml(defaults, {
      datum,
      xKey,
      xName,
      yLowKey,
      yLowName,
      yHighKey,
      yHighName,
      yName,
      color,
      seriesId,
      itemId,
      title,
      yHighValue,
      yLowValue
    });
  }
  getLegendData(legendType) {
    const { id, visible } = this;
    if (legendType !== "category") {
      return [];
    }
    const { fill, stroke, strokeWidth, fillOpacity, strokeOpacity, yName, yLowName, yHighName, yLowKey, yHighKey } = this.properties;
    const legendItemText = yName != null ? yName : `${yLowName != null ? yLowName : yLowKey} - ${yHighName != null ? yHighName : yHighKey}`;
    return [
      {
        legendType: "category",
        id,
        itemId: `${yLowKey}-${yHighKey}`,
        seriesId: id,
        enabled: visible,
        label: { text: `${legendItemText}` },
        marker: { fill, stroke, fillOpacity, strokeOpacity, strokeWidth }
      }
    ];
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection }) {
    const fns = prepareBarAnimationFunctions22(midpointStartingBarPosition2(this.isVertical(), "normal"));
    motion8.fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation6(this, "labels", this.ctx.animationManager, labelSelection);
  }
  animateWaitingUpdateReady(data) {
    var _a2;
    const { datumSelection: datumSelections, labelSelection: labelSelections } = data;
    const { processedData } = this;
    const dataDiff = (_a2 = processedData == null ? void 0 : processedData.reduced) == null ? void 0 : _a2.diff;
    this.ctx.animationManager.stopByAnimationGroupId(this.id);
    const fns = prepareBarAnimationFunctions22(midpointStartingBarPosition2(this.isVertical(), "fade"));
    motion8.fromToMotion(
      this.id,
      "datums",
      this.ctx.animationManager,
      [datumSelections],
      fns,
      (_, datum) => createDatumId7(datum.xValue, datum.valueIndex),
      dataDiff
    );
    seriesLabelFadeInAnimation6(this, "labels", this.ctx.animationManager, labelSelections);
  }
  getDatumId(datum) {
    return `${datum.xValue}-${datum.valueIndex}`;
  }
  isLabelEnabled() {
    return this.properties.label.enabled;
  }
  onDataChange() {
  }
  computeFocusBounds({ datumIndex, seriesRect }) {
    var _a2;
    return computeBarFocusBounds5((_a2 = this.contextNodeData) == null ? void 0 : _a2.nodeData[datumIndex], this.contentGroup, seriesRect);
  }
};
RangeBarSeries.className = "RangeBarSeries";
RangeBarSeries.type = "range-bar";
var import_ag_charts_community126 = (init_main(), __toCommonJS(main_exports));
var RANGE_BAR_SERIES_THEME = {
  series: {
    __extends__: import_ag_charts_community126._Theme.EXTENDS_SERIES_DEFAULTS,
    direction: "vertical",
    strokeWidth: 0,
    label: {
      enabled: false,
      fontSize: 12,
      fontFamily: import_ag_charts_community126._Theme.DEFAULT_FONT_FAMILY,
      color: import_ag_charts_community126._Theme.DEFAULT_INSIDE_SERIES_LABEL_COLOUR,
      placement: "inside"
    }
  },
  axes: {
    [import_ag_charts_community126._Theme.CARTESIAN_AXIS_TYPE.NUMBER]: {
      crosshair: {
        enabled: true,
        snap: false
      }
    }
  }
};
var RangeBarModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "range-bar",
  instanceConstructor: RangeBarSeries,
  defaultAxes: [
    {
      type: import_ag_charts_community127._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: import_ag_charts_community127._Theme.POSITION.BOTTOM
    },
    {
      type: import_ag_charts_community127._Theme.CARTESIAN_AXIS_TYPE.NUMBER,
      position: import_ag_charts_community127._Theme.POSITION.LEFT
    }
  ],
  themeTemplate: RANGE_BAR_SERIES_THEME,
  paletteFactory: ({ takeColors }) => {
    const {
      fills: [fill],
      strokes: [stroke]
    } = takeColors(1);
    return {
      fill,
      stroke
    };
  },
  groupable: true,
  swapDefaultAxesCondition: ({ direction }) => direction === "horizontal"
};
var import_ag_charts_community130 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community129 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community128 = (init_main(), __toCommonJS(main_exports));
var {
  HierarchySeriesProperties: HierarchySeriesProperties2,
  HighlightStyle: HighlightStyle2,
  SeriesTooltip: SeriesTooltip15,
  Validate: Validate51,
  COLOR_STRING: COLOR_STRING222,
  FUNCTION: FUNCTION15,
  NUMBER: NUMBER12,
  OBJECT: OBJECT20,
  POSITIVE_NUMBER: POSITIVE_NUMBER26,
  RATIO: RATIO28,
  STRING: STRING19
} = import_ag_charts_community128._ModuleSupport;
var SunburstSeriesTileHighlightStyle = class extends HighlightStyle2 {
  constructor() {
    super(...arguments);
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizedLabel();
  }
};
__decorateClass2([
  Validate51(STRING19, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "fill", 2);
__decorateClass2([
  Validate51(RATIO28, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate51(COLOR_STRING222, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "stroke", 2);
__decorateClass2([
  Validate51(POSITIVE_NUMBER26, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate51(RATIO28, { optional: true })
], SunburstSeriesTileHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate51(OBJECT20)
], SunburstSeriesTileHighlightStyle.prototype, "label", 2);
__decorateClass2([
  Validate51(OBJECT20)
], SunburstSeriesTileHighlightStyle.prototype, "secondaryLabel", 2);
var SunburstSeriesProperties = class extends HierarchySeriesProperties2 {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeWidth = 0;
    this.strokeOpacity = 1;
    this.cornerRadius = 0;
    this.highlightStyle = new SunburstSeriesTileHighlightStyle();
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizeableSecondaryLabel();
    this.tooltip = new SeriesTooltip15();
  }
};
__decorateClass2([
  Validate51(STRING19, { optional: true })
], SunburstSeriesProperties.prototype, "sizeName", 2);
__decorateClass2([
  Validate51(STRING19, { optional: true })
], SunburstSeriesProperties.prototype, "labelKey", 2);
__decorateClass2([
  Validate51(STRING19, { optional: true })
], SunburstSeriesProperties.prototype, "secondaryLabelKey", 2);
__decorateClass2([
  Validate51(RATIO28)
], SunburstSeriesProperties.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate51(POSITIVE_NUMBER26)
], SunburstSeriesProperties.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate51(RATIO28)
], SunburstSeriesProperties.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate51(POSITIVE_NUMBER26)
], SunburstSeriesProperties.prototype, "cornerRadius", 2);
__decorateClass2([
  Validate51(NUMBER12, { optional: true })
], SunburstSeriesProperties.prototype, "sectorSpacing", 2);
__decorateClass2([
  Validate51(NUMBER12, { optional: true })
], SunburstSeriesProperties.prototype, "padding", 2);
__decorateClass2([
  Validate51(FUNCTION15, { optional: true })
], SunburstSeriesProperties.prototype, "formatter", 2);
__decorateClass2([
  Validate51(OBJECT20)
], SunburstSeriesProperties.prototype, "highlightStyle", 2);
__decorateClass2([
  Validate51(OBJECT20)
], SunburstSeriesProperties.prototype, "label", 2);
__decorateClass2([
  Validate51(OBJECT20)
], SunburstSeriesProperties.prototype, "secondaryLabel", 2);
__decorateClass2([
  Validate51(OBJECT20)
], SunburstSeriesProperties.prototype, "tooltip", 2);
var { fromToMotion: fromToMotion3 } = import_ag_charts_community129._ModuleSupport;
var { Sector: Sector5, Group: Group13, Selection: Selection10, Text: Text10 } = import_ag_charts_community129._Scene;
var { sanitizeHtml: sanitizeHtml12 } = import_ag_charts_community129._Util;
var getAngleData = (node, startAngle = 0, angleScale = 2 * Math.PI / node.sumSize, angleData = Array.from(node, () => void 0)) => {
  let currentAngle = startAngle;
  for (const child of node.children) {
    const start = currentAngle;
    const end = currentAngle + child.sumSize * angleScale;
    angleData[child.index] = { start, end };
    getAngleData(child, start, angleScale, angleData);
    currentAngle = end;
  }
  return angleData;
};
var _SunburstSeries = class _SunburstSeries2 extends import_ag_charts_community129._ModuleSupport.HierarchySeries {
  constructor() {
    super(...arguments);
    this.properties = new SunburstSeriesProperties();
    this.groupSelection = Selection10.select(this.contentGroup, Group13);
    this.highlightSelection = Selection10.select(
      this.highlightGroup,
      Group13
    );
    this.angleData = [];
  }
  processData() {
    return __async2(this, null, function* () {
      const { childrenKey, colorKey, colorName, labelKey, secondaryLabelKey, sizeKey, sizeName } = this.properties;
      yield __superGet2(_SunburstSeries2.prototype, this, "processData").call(this);
      this.angleData = getAngleData(this.rootNode);
      const defaultLabelFormatter = (value) => {
        if (typeof value === "number") {
          return value.toFixed(2);
        } else if (typeof value === "string") {
          return value;
        } else {
          return "";
        }
      };
      this.labelData = Array.from(this.rootNode, ({ datum, depth }) => {
        let label;
        if (datum != null && depth != null && labelKey != null) {
          const value = datum[labelKey];
          label = this.getLabelText(
            this.properties.label,
            {
              depth,
              datum,
              childrenKey,
              colorKey,
              colorName,
              labelKey,
              secondaryLabelKey,
              sizeKey,
              sizeName,
              value
            },
            defaultLabelFormatter
          );
        }
        if (label === "") {
          label = void 0;
        }
        let secondaryLabel;
        if (datum != null && depth != null && secondaryLabelKey != null) {
          const value = datum[secondaryLabelKey];
          secondaryLabel = this.getLabelText(
            this.properties.secondaryLabel,
            {
              depth,
              datum,
              childrenKey,
              colorKey,
              colorName,
              labelKey,
              secondaryLabelKey,
              sizeKey,
              sizeName,
              value
            },
            defaultLabelFormatter
          );
        }
        if (secondaryLabel === "") {
          secondaryLabel = void 0;
        }
        return label != null || secondaryLabel != null ? { label, secondaryLabel } : void 0;
      });
    });
  }
  updateSelections() {
    return __async2(this, null, function* () {
      if (!this.nodeDataRefresh)
        return;
      this.nodeDataRefresh = false;
      const { chart } = this;
      if (chart == null)
        return;
      const seriesRect = chart.seriesRect;
      if (seriesRect == null)
        return;
      const descendants = Array.from(this.rootNode);
      const updateGroup = (group2) => {
        group2.append([
          new Sector5(),
          new Text10({
            tag: 0
            /* Primary */
          }),
          new Text10({
            tag: 1
            /* Secondary */
          })
        ]);
      };
      this.groupSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));
      this.highlightSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));
    });
  }
  updateNodes() {
    return __async2(this, null, function* () {
      var _a2;
      const { chart, data, maxDepth, labelData } = this;
      if (chart == null || data == null || labelData == null) {
        return;
      }
      const { width, height } = chart.seriesRect;
      const { sectorSpacing = 0, padding = 0, cornerRadius, highlightStyle } = this.properties;
      this.contentGroup.translationX = width / 2;
      this.contentGroup.translationY = height / 2;
      this.highlightGroup.translationX = width / 2;
      this.highlightGroup.translationY = height / 2;
      const baseInset = sectorSpacing * 0.5;
      const radius = Math.min(width, height) / 2;
      const radiusScale = radius / (maxDepth + 1);
      const angleOffset = -Math.PI / 2;
      const highlightedNode = (_a2 = this.ctx.highlightManager) == null ? void 0 : _a2.getActiveHighlight();
      const labelTextNode = new Text10();
      labelTextNode.setFont(this.properties.label);
      this.rootNode.walk((node) => {
        const angleDatum = this.angleData[node.index];
        if (node.depth != null && angleDatum != null) {
          const midAngle = angleDatum.end - angleDatum.start;
          const midRadius = (node.depth + 0.5) * radiusScale;
          node.midPoint.x = Math.cos(midAngle) * midRadius;
          node.midPoint.y = Math.sin(midAngle) * midRadius;
        }
      });
      const updateSector = (node, sector, highlighted) => {
        var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        const { depth } = node;
        const angleDatum = this.angleData[node.index];
        if (depth == null || angleDatum == null) {
          sector.visible = false;
          return;
        }
        sector.visible = true;
        let highlightedFill;
        let highlightedFillOpacity;
        let highlightedStroke;
        let highlightedStrokeWidth;
        let highlightedStrokeOpacity;
        if (highlighted) {
          highlightedFill = highlightStyle.fill;
          highlightedFillOpacity = highlightStyle.fillOpacity;
          highlightedStroke = highlightStyle.stroke;
          highlightedStrokeWidth = highlightStyle.strokeWidth;
          highlightedStrokeOpacity = highlightStyle.strokeOpacity;
        }
        const format2 = this.getSectorFormat(node, highlighted);
        const fill = (_b = (_a3 = format2 == null ? void 0 : format2.fill) != null ? _a3 : highlightedFill) != null ? _b : node.fill;
        const fillOpacity = (_d = (_c = format2 == null ? void 0 : format2.fillOpacity) != null ? _c : highlightedFillOpacity) != null ? _d : this.properties.fillOpacity;
        const stroke = (_f = (_e = format2 == null ? void 0 : format2.stroke) != null ? _e : highlightedStroke) != null ? _f : node.stroke;
        const strokeWidth = (_h = (_g = format2 == null ? void 0 : format2.strokeWidth) != null ? _g : highlightedStrokeWidth) != null ? _h : this.properties.strokeWidth;
        const strokeOpacity = (_j = (_i = format2 == null ? void 0 : format2.strokeOpacity) != null ? _i : highlightedStrokeOpacity) != null ? _j : this.properties.strokeOpacity;
        sector.fill = fill;
        sector.fillOpacity = fillOpacity;
        sector.stroke = stroke;
        sector.strokeWidth = strokeWidth;
        sector.strokeOpacity = strokeOpacity;
        sector.centerX = 0;
        sector.centerY = 0;
        sector.innerRadius = depth * radiusScale;
        sector.outerRadius = (depth + 1) * radiusScale;
        sector.startAngle = angleDatum.start + angleOffset;
        sector.endAngle = angleDatum.end + angleOffset;
        sector.inset = baseInset + strokeWidth * 0.5;
        sector.cornerRadius = cornerRadius;
      };
      this.groupSelection.selectByClass(Sector5).forEach((sector) => {
        updateSector(sector.datum, sector, false);
      });
      this.highlightSelection.selectByClass(Sector5).forEach((sector) => {
        const node = sector.datum;
        const isHighlighted = highlightedNode === node;
        sector.visible = isHighlighted;
        if (sector.visible) {
          updateSector(sector.datum, sector, isHighlighted);
        }
      });
      const labelMeta = Array.from(this.rootNode, (node, index) => {
        const { depth } = node;
        const labelDatum = labelData[index];
        const angleData = this.angleData[index];
        if (depth == null || angleData == null) {
          return;
        }
        const innerRadius = depth * radiusScale + baseInset;
        const outerRadius = (depth + 1) * radiusScale - baseInset;
        const innerAngleOffset = innerRadius > baseInset ? baseInset / innerRadius : baseInset;
        const outerAngleOffset = outerRadius > baseInset ? baseInset / outerRadius : baseInset;
        const innerStartAngle = angleData.start + innerAngleOffset;
        const innerEndAngle = angleData.end + innerAngleOffset;
        const deltaInnerAngle = innerEndAngle - innerStartAngle;
        const outerStartAngle = angleData.start + outerAngleOffset;
        const outerEndAngle = angleData.end + outerAngleOffset;
        const deltaOuterAngle = outerEndAngle - outerStartAngle;
        const sizeFittingHeight = (labelHeight2) => {
          var _a3;
          const isCenterCircle = depth === 0 && ((_a3 = node.parent) == null ? void 0 : _a3.sumSize) === node.sumSize;
          if (isCenterCircle) {
            const labelWidth2 = 2 * Math.sqrt(__pow2(outerRadius, 2) - __pow2(labelHeight2 * 0.5, 2));
            return {
              width: labelWidth2,
              height: labelHeight2,
              meta: 0
              /* CenterCircle */
            };
          }
          const parallelHeight = labelHeight2;
          const availableWidthUntilItHitsTheOuterRadius = 2 * Math.sqrt(__pow2(outerRadius, 2) - __pow2(innerRadius + parallelHeight, 2));
          const availableWidthUntilItHitsTheStraightEdges = deltaInnerAngle < Math.PI ? 2 * innerRadius * Math.tan(deltaInnerAngle * 0.5) : Infinity;
          const parallelWidth = Math.min(
            availableWidthUntilItHitsTheOuterRadius,
            availableWidthUntilItHitsTheStraightEdges
          );
          let perpendicularHeight;
          let perpendicularWidth;
          if (depth === 0) {
            perpendicularHeight = labelHeight2;
            perpendicularWidth = Math.sqrt(__pow2(outerRadius, 2) - __pow2(perpendicularHeight / 2, 2)) - labelHeight2 / (2 * Math.tan(deltaOuterAngle * 0.5));
          } else {
            perpendicularHeight = 2 * innerRadius * Math.tan(deltaInnerAngle * 0.5);
            perpendicularWidth = Math.sqrt(__pow2(outerRadius, 2) - __pow2(perpendicularHeight / 2, 2)) - innerRadius;
          }
          return parallelWidth >= perpendicularWidth ? {
            width: parallelWidth,
            height: parallelHeight,
            meta: 1
            /* Parallel */
          } : {
            width: perpendicularWidth,
            height: perpendicularHeight,
            meta: 2
            /* Perpendicular */
          };
        };
        const formatting = formatLabels(
          labelDatum == null ? void 0 : labelDatum.label,
          this.properties.label,
          labelDatum == null ? void 0 : labelDatum.secondaryLabel,
          this.properties.secondaryLabel,
          { padding },
          sizeFittingHeight
        );
        if (formatting == null) {
          return;
        }
        const { width: labelWidth, height: labelHeight, meta: labelPlacement, label, secondaryLabel } = formatting;
        const theta = angleOffset + (angleData.start + angleData.end) / 2;
        const top = Math.sin(theta) >= 0;
        const right = Math.cos(theta) >= 0;
        const circleQuarter = (top ? 3 : 12) & (right ? 6 : 9);
        let labelRadius;
        switch (labelPlacement) {
          case 0:
            labelRadius = 0;
            break;
          case 1: {
            const opticalCentering = 0.58;
            const idealRadius = outerRadius - (radiusScale - labelHeight) * opticalCentering;
            const maximumRadius = Math.sqrt(__pow2(outerRadius - padding, 2) - __pow2(labelWidth / 2, 2));
            labelRadius = Math.min(idealRadius, maximumRadius);
            break;
          }
          case 2:
            if (depth === 0) {
              const minimumRadius = labelHeight / (2 * Math.tan(deltaInnerAngle * 0.5)) + labelWidth * 0.5;
              const maximumRadius = Math.sqrt(__pow2(outerRadius, 2) - __pow2(labelHeight * 0.5, 2)) - labelWidth * 0.5;
              labelRadius = (minimumRadius + maximumRadius) * 0.5;
            } else {
              labelRadius = (innerRadius + outerRadius) * 0.5;
            }
            break;
        }
        return {
          width: labelWidth,
          height: labelHeight,
          labelPlacement,
          circleQuarter,
          radius: labelRadius,
          theta,
          label,
          secondaryLabel
        };
      });
      const updateText = (node, text, tag, highlighted) => {
        const { index, depth } = node;
        const meta = labelMeta == null ? void 0 : labelMeta[index];
        const labelStyle = tag === 0 ? this.properties.label : this.properties.secondaryLabel;
        const label = tag === 0 ? meta == null ? void 0 : meta.label : meta == null ? void 0 : meta.secondaryLabel;
        if (depth == null || meta == null || label == null) {
          text.visible = false;
          return;
        }
        const { height: textHeight, labelPlacement, circleQuarter, radius: textRadius, theta } = meta;
        let highlightedColor;
        if (highlighted) {
          const highlightedLabelStyle = tag === 0 ? this.properties.highlightStyle.label : this.properties.highlightStyle.secondaryLabel;
          highlightedColor = highlightedLabelStyle.color;
        }
        text.text = label.text;
        text.fontSize = label.fontSize;
        text.lineHeight = label.lineHeight;
        text.fontStyle = labelStyle.fontStyle;
        text.fontFamily = labelStyle.fontFamily;
        text.fontWeight = labelStyle.fontWeight;
        text.fill = highlightedColor != null ? highlightedColor : labelStyle.color;
        switch (labelPlacement) {
          case 0:
            text.textAlign = "center";
            text.textBaseline = "top";
            text.translationX = 0;
            text.translationY = (tag === 0 ? 0 : textHeight - label.height) - textHeight * 0.5;
            text.rotation = 0;
            break;
          case 1: {
            const topHalf = (circleQuarter & 3) !== 0;
            const translationRadius = tag === 0 === !topHalf ? textRadius : textRadius - (textHeight - label.height);
            text.textAlign = "center";
            text.textBaseline = topHalf ? "bottom" : "top";
            text.translationX = Math.cos(theta) * translationRadius;
            text.translationY = Math.sin(theta) * translationRadius;
            text.rotation = topHalf ? theta - Math.PI * 0.5 : theta + Math.PI * 0.5;
            break;
          }
          case 2: {
            const rightHalf = (circleQuarter & 6) !== 0;
            const translation = tag === 0 === !rightHalf ? (textHeight - label.height) * 0.5 : (label.height - textHeight) * 0.5;
            text.textAlign = "center";
            text.textBaseline = "middle";
            text.translationX = Math.cos(theta) * textRadius + Math.cos(theta + Math.PI / 2) * translation;
            text.translationY = Math.sin(theta) * textRadius + Math.sin(theta + Math.PI / 2) * translation;
            text.rotation = rightHalf ? theta : theta + Math.PI;
            break;
          }
        }
        text.visible = true;
      };
      this.groupSelection.selectByClass(Text10).forEach((text) => {
        updateText(text.datum, text, text.tag, false);
      });
      this.highlightSelection.selectByClass(Text10).forEach((text) => {
        const node = text.datum;
        const isHighlighted = highlightedNode === node;
        text.visible = isHighlighted;
        if (text.visible) {
          updateText(text.datum, text, text.tag, isHighlighted);
        }
      });
    });
  }
  getSectorFormat(node, isHighlighted) {
    const { datum, fill, stroke, depth } = node;
    const {
      ctx: { callbackCache },
      properties: { formatter }
    } = this;
    if (!formatter || datum == null || depth == null) {
      return {};
    }
    const { colorKey, labelKey, sizeKey, strokeWidth } = this.properties;
    const result = callbackCache.call(formatter, {
      seriesId: this.id,
      depth,
      datum,
      colorKey,
      labelKey,
      sizeKey,
      fill,
      stroke,
      strokeWidth,
      highlighted: isHighlighted
    });
    return result != null ? result : {};
  }
  getTooltipHtml(node) {
    var _a2;
    const { id: seriesId } = this;
    const {
      tooltip,
      colorKey,
      colorName = colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      sizeName = sizeKey,
      childrenKey
    } = this.properties;
    const { datum, depth } = node;
    if (datum == null || depth == null) {
      return import_ag_charts_community129._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const title = labelKey != null ? datum[labelKey] : void 0;
    const format2 = this.getSectorFormat(node, false);
    const color = (_a2 = format2 == null ? void 0 : format2.fill) != null ? _a2 : node.fill;
    if (!tooltip.renderer && !title) {
      return import_ag_charts_community129._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const contentArray = [];
    const datumSecondaryLabel = secondaryLabelKey != null ? datum[secondaryLabelKey] : void 0;
    if (datumSecondaryLabel != null && secondaryLabelKey !== colorKey && secondaryLabelKey !== sizeKey) {
      contentArray.push(sanitizeHtml12(datumSecondaryLabel));
    }
    const datumSize = sizeKey != null ? datum[sizeKey] : void 0;
    if (datumSize != null) {
      contentArray.push(`${sizeName}: ${sanitizeHtml12(datumSize)}`);
    }
    const datumColor = colorKey != null ? datum[colorKey] : void 0;
    if (datumColor != null) {
      contentArray.push(`${colorName}: ${sanitizeHtml12(datumColor)}`);
    }
    const content = contentArray.join("<br>");
    const defaults = {
      title,
      color: this.properties.label.color,
      backgroundColor: color,
      content
    };
    return tooltip.toTooltipHtml(defaults, {
      depth,
      datum,
      colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      title,
      color,
      seriesId,
      childrenKey,
      colorName,
      itemId: void 0,
      sizeName
    });
  }
  createNodeData() {
    return __async2(this, null, function* () {
      return void 0;
    });
  }
  pickNodeClosestDatum(point) {
    return this.pickNodeNearestDistantObject(point, this.groupSelection.selectByClass(Sector5));
  }
  animateEmptyUpdateReady({
    datumSelections
  }) {
    fromToMotion3(this.id, "nodes", this.ctx.animationManager, datumSelections, {
      toFn(_group, _datum, _status) {
        return { scalingX: 1, scalingY: 1 };
      },
      fromFn(group2, datum, status) {
        if (status === "unknown" && datum != null && group2.previousDatum == null) {
          return { scalingX: 0, scalingY: 0 };
        } else {
          return { scalingX: 1, scalingY: 1 };
        }
      }
    });
  }
};
_SunburstSeries.className = "SunburstSeries";
_SunburstSeries.type = "sunburst";
var SunburstSeries = _SunburstSeries;
var { EXTENDS_SERIES_DEFAULTS: EXTENDS_SERIES_DEFAULTS5, DEFAULT_INSIDE_SERIES_LABEL_COLOUR: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2 } = import_ag_charts_community130._Theme;
var SunburstModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["hierarchy"],
  identifier: "sunburst",
  instanceConstructor: SunburstSeries,
  solo: true,
  themeTemplate: {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS5,
      label: {
        fontSize: 14,
        minimumFontSize: 9,
        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2,
        overflowStrategy: "ellipsis",
        wrapping: "never",
        spacing: 2
      },
      secondaryLabel: {
        fontSize: 8,
        minimumFontSize: 7,
        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2,
        overflowStrategy: "ellipsis",
        wrapping: "never"
      },
      sectorSpacing: 2,
      padding: 3,
      highlightStyle: {
        label: {
          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2
        },
        secondaryLabel: {
          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR2
        },
        stroke: `rgba(0, 0, 0, 0.4)`,
        strokeWidth: 2
      }
    },
    gradientLegend: {
      enabled: true
    }
  },
  paletteFactory: ({ takeColors, colorsCount, themeTemplateParameters }) => {
    const { properties } = themeTemplateParameters;
    const { fills, strokes } = takeColors(colorsCount);
    const defaultColorRange = properties.get(import_ag_charts_community130._Theme.DEFAULT_DIVERGING_SERIES_COLOUR_RANGE);
    return { fills, strokes, colorRange: defaultColorRange };
  }
};
var import_ag_charts_community133 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community132 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community131 = (init_main(), __toCommonJS(main_exports));
var { Label: Label9 } = import_ag_charts_community131._Scene;
var {
  BaseProperties: BaseProperties10,
  HierarchySeriesProperties: HierarchySeriesProperties22,
  HighlightStyle: HighlightStyle22,
  SeriesTooltip: SeriesTooltip16,
  Validate: Validate52,
  BOOLEAN: BOOLEAN17,
  COLOR_STRING: COLOR_STRING23,
  FUNCTION: FUNCTION16,
  NUMBER: NUMBER13,
  OBJECT: OBJECT21,
  POSITIVE_NUMBER: POSITIVE_NUMBER27,
  RATIO: RATIO29,
  STRING: STRING20,
  STRING_ARRAY: STRING_ARRAY2,
  TEXT_ALIGN: TEXT_ALIGN22,
  VERTICAL_ALIGN: VERTICAL_ALIGN22
} = import_ag_charts_community131._ModuleSupport;
var TreemapGroupLabel = class extends Label9 {
  constructor() {
    super(...arguments);
    this.spacing = 0;
  }
};
__decorateClass2([
  Validate52(NUMBER13)
], TreemapGroupLabel.prototype, "spacing", 2);
var TreemapSeriesGroup = class extends BaseProperties10 {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.cornerRadius = 0;
    this.textAlign = "center";
    this.gap = 0;
    this.padding = 0;
    this.interactive = true;
    this.label = new TreemapGroupLabel();
  }
};
__decorateClass2([
  Validate52(STRING20, { optional: true })
], TreemapSeriesGroup.prototype, "fill", 2);
__decorateClass2([
  Validate52(RATIO29)
], TreemapSeriesGroup.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate52(COLOR_STRING23, { optional: true })
], TreemapSeriesGroup.prototype, "stroke", 2);
__decorateClass2([
  Validate52(POSITIVE_NUMBER27)
], TreemapSeriesGroup.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate52(RATIO29)
], TreemapSeriesGroup.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate52(POSITIVE_NUMBER27)
], TreemapSeriesGroup.prototype, "cornerRadius", 2);
__decorateClass2([
  Validate52(TEXT_ALIGN22)
], TreemapSeriesGroup.prototype, "textAlign", 2);
__decorateClass2([
  Validate52(POSITIVE_NUMBER27)
], TreemapSeriesGroup.prototype, "gap", 2);
__decorateClass2([
  Validate52(POSITIVE_NUMBER27)
], TreemapSeriesGroup.prototype, "padding", 2);
__decorateClass2([
  Validate52(BOOLEAN17)
], TreemapSeriesGroup.prototype, "interactive", 2);
__decorateClass2([
  Validate52(OBJECT21)
], TreemapSeriesGroup.prototype, "label", 2);
var TreemapSeriesTile = class extends BaseProperties10 {
  constructor() {
    super(...arguments);
    this.fillOpacity = 1;
    this.strokeWidth = 1;
    this.strokeOpacity = 1;
    this.cornerRadius = 0;
    this.textAlign = "center";
    this.verticalAlign = "middle";
    this.gap = 0;
    this.padding = 0;
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizeableSecondaryLabel();
  }
};
__decorateClass2([
  Validate52(STRING20, { optional: true })
], TreemapSeriesTile.prototype, "fill", 2);
__decorateClass2([
  Validate52(RATIO29)
], TreemapSeriesTile.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate52(COLOR_STRING23, { optional: true })
], TreemapSeriesTile.prototype, "stroke", 2);
__decorateClass2([
  Validate52(POSITIVE_NUMBER27, { optional: true })
], TreemapSeriesTile.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate52(RATIO29)
], TreemapSeriesTile.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate52(POSITIVE_NUMBER27)
], TreemapSeriesTile.prototype, "cornerRadius", 2);
__decorateClass2([
  Validate52(TEXT_ALIGN22)
], TreemapSeriesTile.prototype, "textAlign", 2);
__decorateClass2([
  Validate52(VERTICAL_ALIGN22)
], TreemapSeriesTile.prototype, "verticalAlign", 2);
__decorateClass2([
  Validate52(POSITIVE_NUMBER27)
], TreemapSeriesTile.prototype, "gap", 2);
__decorateClass2([
  Validate52(POSITIVE_NUMBER27)
], TreemapSeriesTile.prototype, "padding", 2);
__decorateClass2([
  Validate52(OBJECT21)
], TreemapSeriesTile.prototype, "label", 2);
__decorateClass2([
  Validate52(OBJECT21)
], TreemapSeriesTile.prototype, "secondaryLabel", 2);
var TreemapSeriesGroupHighlightStyle = class extends BaseProperties10 {
  constructor() {
    super(...arguments);
    this.label = new AutoSizedLabel();
  }
};
__decorateClass2([
  Validate52(STRING20, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "fill", 2);
__decorateClass2([
  Validate52(RATIO29, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate52(COLOR_STRING23, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "stroke", 2);
__decorateClass2([
  Validate52(POSITIVE_NUMBER27, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate52(RATIO29, { optional: true })
], TreemapSeriesGroupHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate52(OBJECT21)
], TreemapSeriesGroupHighlightStyle.prototype, "label", 2);
var TreemapSeriesTileHighlightStyle = class extends BaseProperties10 {
  constructor() {
    super(...arguments);
    this.label = new AutoSizedLabel();
    this.secondaryLabel = new AutoSizeableSecondaryLabel();
  }
};
__decorateClass2([
  Validate52(STRING20, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "fill", 2);
__decorateClass2([
  Validate52(RATIO29, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate52(COLOR_STRING23, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "stroke", 2);
__decorateClass2([
  Validate52(POSITIVE_NUMBER27, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate52(RATIO29, { optional: true })
], TreemapSeriesTileHighlightStyle.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate52(OBJECT21)
], TreemapSeriesTileHighlightStyle.prototype, "label", 2);
__decorateClass2([
  Validate52(OBJECT21)
], TreemapSeriesTileHighlightStyle.prototype, "secondaryLabel", 2);
var TreemapSeriesHighlightStyle = class extends HighlightStyle22 {
  constructor() {
    super(...arguments);
    this.group = new TreemapSeriesGroupHighlightStyle();
    this.tile = new TreemapSeriesTileHighlightStyle();
  }
};
__decorateClass2([
  Validate52(OBJECT21)
], TreemapSeriesHighlightStyle.prototype, "group", 2);
__decorateClass2([
  Validate52(OBJECT21)
], TreemapSeriesHighlightStyle.prototype, "tile", 2);
var TreemapSeriesProperties = class extends HierarchySeriesProperties22 {
  constructor() {
    super(...arguments);
    this.highlightStyle = new TreemapSeriesHighlightStyle();
    this.tooltip = new SeriesTooltip16();
    this.group = new TreemapSeriesGroup();
    this.tile = new TreemapSeriesTile();
    this.undocumentedGroupFills = [];
    this.undocumentedGroupStrokes = [];
  }
};
__decorateClass2([
  Validate52(STRING20, { optional: true })
], TreemapSeriesProperties.prototype, "sizeName", 2);
__decorateClass2([
  Validate52(STRING20, { optional: true })
], TreemapSeriesProperties.prototype, "labelKey", 2);
__decorateClass2([
  Validate52(STRING20, { optional: true })
], TreemapSeriesProperties.prototype, "secondaryLabelKey", 2);
__decorateClass2([
  Validate52(FUNCTION16, { optional: true })
], TreemapSeriesProperties.prototype, "formatter", 2);
__decorateClass2([
  Validate52(OBJECT21)
], TreemapSeriesProperties.prototype, "highlightStyle", 2);
__decorateClass2([
  Validate52(OBJECT21)
], TreemapSeriesProperties.prototype, "tooltip", 2);
__decorateClass2([
  Validate52(OBJECT21)
], TreemapSeriesProperties.prototype, "group", 2);
__decorateClass2([
  Validate52(OBJECT21)
], TreemapSeriesProperties.prototype, "tile", 2);
__decorateClass2([
  Validate52(STRING_ARRAY2)
], TreemapSeriesProperties.prototype, "undocumentedGroupFills", 2);
__decorateClass2([
  Validate52(STRING_ARRAY2)
], TreemapSeriesProperties.prototype, "undocumentedGroupStrokes", 2);
var { Rect: Rect5, Group: Group14, BBox: BBox10, Selection: Selection11, Text: Text11 } = import_ag_charts_community132._Scene;
var { Color: Color22, Logger: Logger13, isEqual: isEqual22, sanitizeHtml: sanitizeHtml13 } = import_ag_charts_community132._Util;
var tempText = new Text11();
function getTextSize(text, style) {
  const { fontStyle, fontWeight, fontSize, fontFamily } = style;
  tempText.setProperties({
    text,
    fontStyle,
    fontWeight,
    fontSize,
    fontFamily,
    textAlign: "left",
    textBaseline: "top"
  });
  const { width, height } = tempText.computeBBox();
  return { width, height };
}
function validateColor(color) {
  if (typeof color === "string" && !Color22.validColorString(color)) {
    const fallbackColor = "black";
    Logger13.warnOnce(
      `invalid Treemap tile colour string "${color}". Affected treemap tiles will be coloured ${fallbackColor}.`
    );
    return fallbackColor;
  }
  return color;
}
function nodeSize(node) {
  return node.children.length > 0 ? node.sumSize - node.size : node.size;
}
var textAlignFactors2 = {
  left: 0,
  center: 0.5,
  right: 1
};
var verticalAlignFactors2 = {
  top: 0,
  middle: 0.5,
  bottom: 1
};
var DistantGroup = class extends import_ag_charts_community132._Scene.Group {
  distanceSquared(x, y) {
    return this.computeBBox().distanceSquared(x, y);
  }
};
var _TreemapSeries = class _TreemapSeries2 extends import_ag_charts_community132._ModuleSupport.HierarchySeries {
  constructor() {
    super(...arguments);
    this.properties = new TreemapSeriesProperties();
    this.groupSelection = Selection11.select(this.contentGroup, DistantGroup);
    this.highlightSelection = Selection11.select(
      this.highlightGroup,
      Group14
    );
  }
  groupTitleHeight(node, bbox) {
    var _a2, _b;
    const label = (_b = (_a2 = this.labelData) == null ? void 0 : _a2[node.index]) == null ? void 0 : _b.label;
    const { label: font } = this.properties.group;
    const heightRatioThreshold = 3;
    if (label == null) {
      return;
    } else if (font.fontSize > bbox.width / heightRatioThreshold || font.fontSize > bbox.height / heightRatioThreshold) {
      return;
    } else {
      const { height: fontHeight } = getTextSize(label, font);
      return Math.max(fontHeight, font.fontSize);
    }
  }
  getNodePadding(node, bbox) {
    if (node.index === 0) {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    } else if (node.children.length === 0) {
      const { padding: padding2 } = this.properties.tile;
      return {
        top: padding2,
        right: padding2,
        bottom: padding2,
        left: padding2
      };
    }
    const {
      label: { spacing },
      padding
    } = this.properties.group;
    const fontHeight = this.groupTitleHeight(node, bbox);
    const titleHeight = fontHeight != null ? fontHeight + spacing : 0;
    return {
      top: padding + titleHeight,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  processData() {
    return __async2(this, null, function* () {
      var _a2;
      yield __superGet2(_TreemapSeries2.prototype, this, "processData").call(this);
      const { childrenKey, colorKey, colorName, labelKey, secondaryLabelKey, sizeKey, sizeName, tile, group: group2 } = this.properties;
      if (!((_a2 = this.data) == null ? void 0 : _a2.length)) {
        this.labelData = void 0;
        return;
      }
      const defaultLabelFormatter = (value) => {
        if (typeof value === "number") {
          return value.toFixed(2);
        } else if (typeof value === "string") {
          return value;
        } else {
          return "";
        }
      };
      this.labelData = Array.from(this.rootNode, ({ datum, depth, children }) => {
        const isLeaf = children.length === 0;
        const labelStyle = isLeaf ? tile.label : group2.label;
        let label;
        if (datum != null && depth != null && labelKey != null) {
          const value = datum[labelKey];
          label = this.getLabelText(
            labelStyle,
            {
              depth,
              datum,
              childrenKey,
              colorKey,
              colorName,
              labelKey,
              secondaryLabelKey,
              sizeKey,
              sizeName,
              value
            },
            defaultLabelFormatter
          );
        }
        if (label === "") {
          label = void 0;
        }
        let secondaryLabel;
        if (isLeaf && datum != null && depth != null && secondaryLabelKey != null) {
          const value = datum[secondaryLabelKey];
          secondaryLabel = this.getLabelText(
            tile.secondaryLabel,
            {
              depth,
              datum,
              childrenKey,
              colorKey,
              colorName,
              labelKey,
              secondaryLabelKey,
              sizeKey,
              sizeName,
              value
            },
            defaultLabelFormatter
          );
        }
        if (secondaryLabel === "") {
          secondaryLabel = void 0;
        }
        return label != null || secondaryLabel != null ? { label, secondaryLabel } : void 0;
      });
    });
  }
  /**
   * Squarified Treemap algorithm
   * https://www.win.tue.nl/~vanwijk/stm.pdf
   */
  squarify(node, bbox, outputBoxes, outputPadding) {
    const { index, datum, children } = node;
    if (bbox.width <= 0 || bbox.height <= 0) {
      outputBoxes[index] = void 0;
      outputPadding[index] = void 0;
      return;
    }
    const padding = datum != null ? this.getNodePadding(node, bbox) : { top: 0, right: 0, bottom: 0, left: 0 };
    outputBoxes[index] = index === 0 ? void 0 : bbox;
    outputPadding[index] = index === 0 ? void 0 : padding;
    const sortedChildrenIndices = Array.from(children, (_, i2) => i2).filter((i2) => nodeSize(children[i2]) > 0).sort((aIndex, bIndex) => nodeSize(children[bIndex]) - nodeSize(children[aIndex]));
    const childAt = (i2) => {
      const sortedIndex = sortedChildrenIndices[i2];
      return children[sortedIndex];
    };
    const allLeafNodes = sortedChildrenIndices.every((sortedIndex) => children[sortedIndex].children.length === 0);
    const targetTileAspectRatio = 1;
    const width = bbox.width - padding.left - padding.right;
    const height = bbox.height - padding.top - padding.bottom;
    if (width <= 0 || height <= 0)
      return;
    const numChildren = sortedChildrenIndices.length;
    let stackSum = 0;
    let startIndex = 0;
    let minRatioDiff = Infinity;
    let partitionSum = sortedChildrenIndices.reduce((sum2, sortedIndex) => sum2 + nodeSize(children[sortedIndex]), 0);
    const innerBox = new BBox10(bbox.x + padding.left, bbox.y + padding.top, width, height);
    const partition = innerBox.clone();
    let i = 0;
    while (i < numChildren) {
      const value = nodeSize(childAt(i));
      const firstValue = nodeSize(childAt(startIndex));
      const isVertical2 = partition.width < partition.height;
      stackSum += value;
      const partThickness = isVertical2 ? partition.height : partition.width;
      const partLength = isVertical2 ? partition.width : partition.height;
      const firstTileLength = partLength * firstValue / stackSum;
      let stackThickness = partThickness * stackSum / partitionSum;
      const ratio = Math.max(firstTileLength, stackThickness) / Math.min(firstTileLength, stackThickness);
      const diff8 = Math.abs(targetTileAspectRatio - ratio);
      if (diff8 < minRatioDiff) {
        minRatioDiff = diff8;
        i++;
        continue;
      }
      stackSum -= value;
      stackThickness = partThickness * stackSum / partitionSum;
      let start2 = isVertical2 ? partition.x : partition.y;
      for (let j = startIndex; j < i; j++) {
        const child = childAt(j);
        const childSize = nodeSize(child);
        const x = isVertical2 ? start2 : partition.x;
        const y = isVertical2 ? partition.y : start2;
        const length = partLength * childSize / stackSum;
        const stackWidth = isVertical2 ? length : stackThickness;
        const stackHeight = isVertical2 ? stackThickness : length;
        const childBbox = new BBox10(x, y, stackWidth, stackHeight);
        this.applyGap(innerBox, childBbox, allLeafNodes);
        this.squarify(child, childBbox, outputBoxes, outputPadding);
        partitionSum -= childSize;
        start2 += length;
      }
      if (isVertical2) {
        partition.y += stackThickness;
        partition.height -= stackThickness;
      } else {
        partition.x += stackThickness;
        partition.width -= stackThickness;
      }
      startIndex = i;
      stackSum = 0;
      minRatioDiff = Infinity;
    }
    const isVertical = partition.width < partition.height;
    let start = isVertical ? partition.x : partition.y;
    for (let childIdx = startIndex; childIdx < numChildren; childIdx++) {
      const child = childAt(childIdx);
      const x = isVertical ? start : partition.x;
      const y = isVertical ? partition.y : start;
      const part = nodeSize(child) / partitionSum;
      const childWidth = partition.width * (isVertical ? part : 1);
      const childHeight = partition.height * (isVertical ? 1 : part);
      const childBox = new BBox10(x, y, childWidth, childHeight);
      this.applyGap(innerBox, childBox, allLeafNodes);
      this.squarify(child, childBox, outputBoxes, outputPadding);
      start += isVertical ? childWidth : childHeight;
    }
  }
  applyGap(innerBox, childBox, allLeafNodes) {
    const gap = allLeafNodes ? this.properties.tile.gap * 0.5 : this.properties.group.gap * 0.5;
    const getBounds = (box) => ({
      left: box.x,
      top: box.y,
      right: box.x + box.width,
      bottom: box.y + box.height
    });
    const innerBounds = getBounds(innerBox);
    const childBounds = getBounds(childBox);
    const sides = ["top", "right", "bottom", "left"];
    sides.forEach((side) => {
      if (!isEqual22(innerBounds[side], childBounds[side])) {
        childBox.shrink(gap, side);
      }
    });
  }
  createNodeData() {
    return __async2(this, null, function* () {
      return void 0;
    });
  }
  updateSelections() {
    return __async2(this, null, function* () {
      var _a2;
      if (!this.nodeDataRefresh) {
        return;
      }
      this.nodeDataRefresh = false;
      const { seriesRect } = (_a2 = this.chart) != null ? _a2 : {};
      if (!seriesRect)
        return;
      const descendants = Array.from(this.rootNode);
      const updateGroup = (group2) => {
        group2.append([
          new Rect5(),
          new Text11({
            tag: 0
            /* Primary */
          }),
          new Text11({
            tag: 1
            /* Secondary */
          })
        ]);
      };
      this.groupSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));
      this.highlightSelection.update(descendants, updateGroup, (node) => this.getDatumId(node));
    });
  }
  getTileFormat(node, isHighlighted) {
    const { datum, depth, children } = node;
    const { colorKey, labelKey, secondaryLabelKey, sizeKey, tile, group: group2, formatter } = this.properties;
    if (!formatter || datum == null || depth == null) {
      return {};
    }
    const isLeaf = children.length === 0;
    const fill = this.getNodeFill(node);
    const stroke = this.getNodeStroke(node);
    const strokeWidth = isLeaf ? tile.strokeWidth : group2.strokeWidth;
    const result = this.ctx.callbackCache.call(formatter, {
      seriesId: this.id,
      depth,
      datum,
      colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      fill,
      stroke,
      strokeWidth,
      highlighted: isHighlighted
    });
    return result != null ? result : {};
  }
  getNodeFill(node) {
    var _a2, _b, _c;
    const isLeaf = node.children.length === 0;
    if (isLeaf) {
      return (_a2 = this.properties.tile.fill) != null ? _a2 : node.fill;
    }
    const { undocumentedGroupFills } = this.properties;
    const defaultFill = undocumentedGroupFills[Math.min((_b = node.depth) != null ? _b : 0, undocumentedGroupFills.length)];
    return (_c = this.properties.group.fill) != null ? _c : defaultFill;
  }
  getNodeStroke(node) {
    var _a2, _b, _c;
    const isLeaf = node.children.length === 0;
    if (isLeaf) {
      return (_a2 = this.properties.tile.stroke) != null ? _a2 : node.stroke;
    }
    const { undocumentedGroupStrokes } = this.properties;
    const defaultStroke = undocumentedGroupStrokes[Math.min((_b = node.depth) != null ? _b : 0, undocumentedGroupStrokes.length)];
    return (_c = this.properties.group.stroke) != null ? _c : defaultStroke;
  }
  updateNodes() {
    return __async2(this, null, function* () {
      var _a2, _b;
      const { rootNode, data } = this;
      const { highlightStyle, tile, group: group2 } = this.properties;
      const { seriesRect } = (_a2 = this.chart) != null ? _a2 : {};
      if (!seriesRect || !data)
        return;
      const { width, height } = seriesRect;
      const bboxes = Array.from(this.rootNode, () => void 0);
      const paddings = Array.from(this.rootNode, () => void 0);
      this.squarify(rootNode, new BBox10(0, 0, width, height), bboxes, paddings);
      let highlightedNode = (_b = this.ctx.highlightManager) == null ? void 0 : _b.getActiveHighlight();
      if (highlightedNode != null && !this.properties.group.interactive && highlightedNode.children.length !== 0) {
        highlightedNode = void 0;
      }
      this.updateNodeMidPoint(bboxes);
      const updateRectFn = (node, rect, highlighted) => {
        var _a3, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        const bbox = bboxes[node.index];
        if (bbox == null) {
          rect.visible = false;
          return;
        }
        const isLeaf = node.children.length === 0;
        let highlightedFill;
        let highlightedFillOpacity;
        let highlightedStroke;
        let highlightedStrokeWidth;
        let highlightedStrokeOpacity;
        if (highlighted) {
          const { tile: hTitle, group: hGroup } = highlightStyle;
          highlightedFill = isLeaf ? hTitle.fill : hGroup.fill;
          highlightedFillOpacity = isLeaf ? hTitle.fillOpacity : hGroup.fillOpacity;
          highlightedStroke = isLeaf ? hTitle.stroke : hGroup.stroke;
          highlightedStrokeWidth = isLeaf ? hTitle.strokeWidth : hGroup.strokeWidth;
          highlightedStrokeOpacity = isLeaf ? hTitle.strokeOpacity : hGroup.strokeOpacity;
        }
        const format2 = this.getTileFormat(node, highlighted);
        const fill = (_b2 = (_a3 = format2 == null ? void 0 : format2.fill) != null ? _a3 : highlightedFill) != null ? _b2 : this.getNodeFill(node);
        const fillOpacity = (_d = (_c = format2 == null ? void 0 : format2.fillOpacity) != null ? _c : highlightedFillOpacity) != null ? _d : isLeaf ? tile.fillOpacity : group2.fillOpacity;
        const stroke = (_f = (_e = format2 == null ? void 0 : format2.stroke) != null ? _e : highlightedStroke) != null ? _f : this.getNodeStroke(node);
        const strokeWidth = (_h = (_g = format2 == null ? void 0 : format2.strokeWidth) != null ? _g : highlightedStrokeWidth) != null ? _h : isLeaf ? tile.strokeWidth : group2.strokeWidth;
        const strokeOpacity = (_j = (_i = format2 == null ? void 0 : format2.strokeOpacity) != null ? _i : highlightedStrokeOpacity) != null ? _j : isLeaf ? tile.strokeOpacity : group2.strokeOpacity;
        rect.crisp = true;
        rect.fill = validateColor(fill);
        rect.fillOpacity = fillOpacity;
        rect.stroke = validateColor(stroke);
        rect.strokeWidth = strokeWidth;
        rect.strokeOpacity = strokeOpacity;
        rect.cornerRadius = isLeaf ? tile.cornerRadius : group2.cornerRadius;
        const onlyLeaves = (_k = node.parent) == null ? void 0 : _k.children.every((n) => n.children.length === 0);
        const parentBbox = node.parent != null ? bboxes[node.parent.index] : void 0;
        const parentPadding = node.parent != null ? paddings[node.parent.index] : void 0;
        if (onlyLeaves === true && parentBbox != null && parentPadding != null) {
          rect.clipBBox = bbox;
          rect.x = parentBbox.x + parentPadding.left;
          rect.y = parentBbox.y + parentPadding.top;
          rect.width = parentBbox.width - (parentPadding.left + parentPadding.right);
          rect.height = parentBbox.height - (parentPadding.top + parentPadding.bottom);
        } else {
          rect.clipBBox = void 0;
          rect.x = bbox.x;
          rect.y = bbox.y;
          rect.width = bbox.width;
          rect.height = bbox.height;
        }
        rect.visible = true;
      };
      this.groupSelection.selectByClass(Rect5).forEach((rect) => updateRectFn(rect.datum, rect, false));
      this.highlightSelection.selectByClass(Rect5).forEach((rect) => {
        var _a3;
        const isDatumHighlighted = rect.datum === highlightedNode;
        rect.visible = isDatumHighlighted || ((_a3 = highlightedNode == null ? void 0 : highlightedNode.contains(rect.datum)) != null ? _a3 : false);
        if (rect.visible) {
          updateRectFn(rect.datum, rect, isDatumHighlighted);
        }
      });
      const labelMeta = Array.from(this.rootNode, (node) => {
        var _a3, _b2, _c, _d;
        const { index, children } = node;
        const bbox = bboxes[index];
        const labelDatum = (_a3 = this.labelData) == null ? void 0 : _a3[index];
        if (bbox == null || labelDatum == null) {
          return;
        }
        if (children.length === 0) {
          const layout = {
            width: bbox.width,
            height: bbox.height,
            meta: null
          };
          const formatting = formatLabels(
            labelDatum.label,
            this.properties.tile.label,
            labelDatum.secondaryLabel,
            this.properties.tile.secondaryLabel,
            { padding: tile.padding },
            () => layout
          );
          if (formatting == null) {
            return;
          }
          const { height: labelHeight, label, secondaryLabel } = formatting;
          const { textAlign, verticalAlign, padding } = tile;
          const textAlignFactor = (_b2 = textAlignFactors2[textAlign]) != null ? _b2 : 0.5;
          const labelX = bbox.x + padding + (bbox.width - 2 * padding) * textAlignFactor;
          const verticalAlignFactor = (_c = verticalAlignFactors2[verticalAlign]) != null ? _c : 0.5;
          const labelYStart = bbox.y + padding + labelHeight * 0.5 + (bbox.height - 2 * padding - labelHeight) * verticalAlignFactor;
          return {
            label: label != null ? {
              text: label.text,
              fontSize: label.fontSize,
              lineHeight: label.lineHeight,
              style: this.properties.tile.label,
              x: labelX,
              y: labelYStart - (labelHeight - label.height) * 0.5
            } : void 0,
            secondaryLabel: secondaryLabel != null ? {
              text: secondaryLabel.text,
              fontSize: secondaryLabel.fontSize,
              lineHeight: secondaryLabel.fontSize,
              style: this.properties.tile.secondaryLabel,
              x: labelX,
              y: labelYStart + (labelHeight - secondaryLabel.height) * 0.5
            } : void 0,
            verticalAlign: "middle",
            textAlign
          };
        } else if ((labelDatum == null ? void 0 : labelDatum.label) == null) {
          return;
        } else {
          const { padding, textAlign } = group2;
          const groupTitleHeight = this.groupTitleHeight(node, bbox);
          if (groupTitleHeight == null) {
            return;
          }
          const innerWidth = bbox.width - 2 * padding;
          const { text } = Text11.wrap(labelDatum.label, bbox.width - 2 * padding, Infinity, group2.label, "never");
          const textAlignFactor = (_d = textAlignFactors2[textAlign]) != null ? _d : 0.5;
          return {
            label: {
              text,
              fontSize: group2.label.fontSize,
              lineHeight: AutoSizedLabel.lineHeight(group2.label.fontSize),
              style: this.properties.group.label,
              x: bbox.x + padding + innerWidth * textAlignFactor,
              y: bbox.y + padding + groupTitleHeight * 0.5
            },
            secondaryLabel: void 0,
            verticalAlign: "middle",
            textAlign
          };
        }
      });
      const updateLabelFn = (node, text, tag, highlighted) => {
        const isLeaf = node.children.length === 0;
        const meta = labelMeta[node.index];
        const label = tag === 0 ? meta == null ? void 0 : meta.label : meta == null ? void 0 : meta.secondaryLabel;
        if (meta == null || label == null) {
          text.visible = false;
          return;
        }
        let highlightedColor;
        if (highlighted) {
          const { tile: hTitle, group: hGroup } = highlightStyle;
          highlightedColor = hTitle.secondaryLabel.color;
          if (!isLeaf) {
            highlightedColor = hGroup.label.color;
          } else if (tag === 0) {
            highlightedColor = hTitle.label.color;
          }
        }
        text.text = label.text;
        text.fontSize = label.fontSize;
        text.lineHeight = label.lineHeight;
        text.fontStyle = label.style.fontStyle;
        text.fontFamily = label.style.fontFamily;
        text.fontWeight = label.style.fontWeight;
        text.fill = highlightedColor != null ? highlightedColor : label.style.color;
        text.textAlign = meta.textAlign;
        text.textBaseline = meta.verticalAlign;
        text.x = label.x;
        text.y = label.y;
        text.visible = true;
      };
      this.groupSelection.selectByClass(Text11).forEach((text) => {
        updateLabelFn(text.datum, text, text.tag, false);
      });
      this.highlightSelection.selectByClass(Text11).forEach((text) => {
        var _a3;
        const isDatumHighlighted = text.datum === highlightedNode;
        text.visible = isDatumHighlighted || ((_a3 = highlightedNode == null ? void 0 : highlightedNode.contains(text.datum)) != null ? _a3 : false);
        if (text.visible) {
          updateLabelFn(text.datum, text, text.tag, isDatumHighlighted);
        }
      });
    });
  }
  updateNodeMidPoint(bboxes) {
    this.rootNode.walk((node) => {
      const bbox = bboxes[node.index];
      if (bbox != null) {
        node.midPoint.x = bbox.x + bbox.width / 2;
        node.midPoint.y = bbox.y;
      }
    });
  }
  pickNodeClosestDatum(point) {
    return this.pickNodeNearestDistantObject(point, this.groupSelection.nodes());
  }
  getTooltipHtml(node) {
    var _a2;
    const { datum, depth } = node;
    const { id: seriesId } = this;
    const {
      tooltip,
      colorKey,
      colorName = colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      sizeName = sizeKey,
      childrenKey
    } = this.properties;
    const isLeaf = node.children.length === 0;
    const interactive = isLeaf || this.properties.group.interactive;
    if (datum == null || depth == null || !interactive) {
      return import_ag_charts_community132._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const title = labelKey != null ? datum[labelKey] : void 0;
    const format2 = this.getTileFormat(node, false);
    const color = (_a2 = format2 == null ? void 0 : format2.fill) != null ? _a2 : this.getNodeFill(node);
    if (!tooltip.renderer && !title) {
      return import_ag_charts_community132._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const contentArray = [];
    const datumSecondaryLabel = secondaryLabelKey != null ? datum[secondaryLabelKey] : void 0;
    if (datumSecondaryLabel != null && secondaryLabelKey !== colorKey && secondaryLabelKey !== sizeKey) {
      contentArray.push(sanitizeHtml13(datumSecondaryLabel));
    }
    const datumSize = sizeKey != null ? datum[sizeKey] : void 0;
    if (datumSize != null) {
      contentArray.push(`${sizeName}: ${sanitizeHtml13(datumSize)}`);
    }
    const datumColor = colorKey != null ? datum[colorKey] : void 0;
    if (datumColor != null) {
      contentArray.push(`${colorName}: ${sanitizeHtml13(datumColor)}`);
    }
    const content = contentArray.join("<br>");
    const defaults = {
      title,
      color: isLeaf ? this.properties.tile.label.color : this.properties.group.label.color,
      backgroundColor: color,
      content
    };
    return tooltip.toTooltipHtml(defaults, {
      depth,
      datum,
      colorKey,
      labelKey,
      secondaryLabelKey,
      sizeKey,
      title,
      color,
      seriesId,
      childrenKey,
      colorName,
      itemId: void 0,
      sizeName
    });
  }
};
_TreemapSeries.className = "TreemapSeries";
_TreemapSeries.type = "treemap";
var TreemapSeries = _TreemapSeries;
var {
  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE4,
  DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY22,
  DEFAULT_HIERARCHY_FILLS: DEFAULT_HIERARCHY_FILLS22,
  DEFAULT_HIERARCHY_STROKES: DEFAULT_HIERARCHY_STROKES22,
  DEFAULT_INSIDE_SERIES_LABEL_COLOUR: DEFAULT_INSIDE_SERIES_LABEL_COLOUR22,
  EXTENDS_SERIES_DEFAULTS: EXTENDS_SERIES_DEFAULTS6,
  DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR3,
  FONT_WEIGHT: FONT_WEIGHT22
} = import_ag_charts_community133._Theme;
var TreemapModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["hierarchy"],
  identifier: "treemap",
  instanceConstructor: TreemapSeries,
  solo: true,
  themeTemplate: {
    series: {
      __extends__: EXTENDS_SERIES_DEFAULTS6,
      group: {
        label: {
          enabled: true,
          color: DEFAULT_LABEL_COLOUR3,
          fontStyle: void 0,
          fontWeight: FONT_WEIGHT22.NORMAL,
          fontSize: 12,
          fontFamily: DEFAULT_FONT_FAMILY22,
          spacing: 4
        },
        fill: void 0,
        // Override default fill
        stroke: void 0,
        // Override default stroke
        strokeWidth: 1,
        padding: 4,
        gap: 2,
        textAlign: "left"
      },
      tile: {
        label: {
          enabled: true,
          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR22,
          fontStyle: void 0,
          fontWeight: FONT_WEIGHT22.NORMAL,
          fontSize: 18,
          minimumFontSize: 10,
          fontFamily: DEFAULT_FONT_FAMILY22,
          wrapping: "on-space",
          overflowStrategy: "ellipsis",
          spacing: 2
        },
        secondaryLabel: {
          enabled: true,
          color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR22,
          fontStyle: void 0,
          fontWeight: void 0,
          fontSize: 12,
          minimumFontSize: 10,
          fontFamily: DEFAULT_FONT_FAMILY22,
          wrapping: "never",
          overflowStrategy: "ellipsis"
        },
        fill: void 0,
        // Override default fill
        stroke: void 0,
        // Override default stroke
        strokeWidth: 0,
        padding: 3,
        gap: 1
      },
      // Override defaults
      highlightStyle: {
        group: {
          label: {
            color: DEFAULT_LABEL_COLOUR3
          },
          fill: void 0,
          stroke: `rgba(0, 0, 0, 0.4)`,
          strokeWidth: 2
        },
        tile: {
          label: {
            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR22
          },
          secondaryLabel: {
            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR22
          },
          fill: void 0,
          stroke: `rgba(0, 0, 0, 0.4)`,
          strokeWidth: 2
        }
      }
    },
    gradientLegend: {
      enabled: true
    }
  },
  paletteFactory: ({ takeColors, colorsCount, themeTemplateParameters }) => {
    const { properties } = themeTemplateParameters;
    const { fills, strokes } = takeColors(colorsCount);
    const defaultColorRange = properties.get(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE4);
    const groupFills = properties.get(DEFAULT_HIERARCHY_FILLS22);
    const groupStrokes = properties.get(DEFAULT_HIERARCHY_STROKES22);
    return {
      fills,
      strokes,
      colorRange: defaultColorRange,
      undocumentedGroupFills: groupFills,
      undocumentedGroupStrokes: groupStrokes
    };
  }
};
var import_ag_charts_community137 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community135 = (init_main(), __toCommonJS(main_exports));
var import_ag_charts_community134 = (init_main(), __toCommonJS(main_exports));
var { DropShadow: DropShadow3, Label: Label10 } = import_ag_charts_community134._Scene;
var {
  AbstractBarSeriesProperties: AbstractBarSeriesProperties5,
  BaseProperties: BaseProperties11,
  PropertiesArray: PropertiesArray3,
  SeriesTooltip: SeriesTooltip17,
  Validate: Validate53,
  BOOLEAN: BOOLEAN18,
  COLOR_STRING: COLOR_STRING24,
  FUNCTION: FUNCTION17,
  LINE_DASH: LINE_DASH18,
  NUMBER: NUMBER14,
  OBJECT: OBJECT222,
  OBJECT_ARRAY: OBJECT_ARRAY22,
  POSITIVE_NUMBER: POSITIVE_NUMBER28,
  RATIO: RATIO30,
  STRING: STRING21,
  UNION: UNION6
} = import_ag_charts_community134._ModuleSupport;
var WaterfallSeriesTotal = class extends BaseProperties11 {
};
__decorateClass2([
  Validate53(UNION6(["subtotal", "total"], "a total type"))
], WaterfallSeriesTotal.prototype, "totalType", 2);
__decorateClass2([
  Validate53(NUMBER14)
], WaterfallSeriesTotal.prototype, "index", 2);
__decorateClass2([
  Validate53(STRING21)
], WaterfallSeriesTotal.prototype, "axisLabel", 2);
var WaterfallSeriesItemTooltip = class extends BaseProperties11 {
};
__decorateClass2([
  Validate53(FUNCTION17, { optional: true })
], WaterfallSeriesItemTooltip.prototype, "renderer", 2);
var WaterfallSeriesLabel = class extends Label10 {
  constructor() {
    super(...arguments);
    this.placement = "end";
    this.padding = 6;
  }
};
__decorateClass2([
  Validate53(UNION6(["start", "end", "inside"], "a placement"))
], WaterfallSeriesLabel.prototype, "placement", 2);
__decorateClass2([
  Validate53(POSITIVE_NUMBER28)
], WaterfallSeriesLabel.prototype, "padding", 2);
var WaterfallSeriesItem = class extends BaseProperties11 {
  constructor() {
    super(...arguments);
    this.fill = "#c16068";
    this.stroke = "#c16068";
    this.fillOpacity = 1;
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.strokeWidth = 1;
    this.cornerRadius = 0;
    this.shadow = new DropShadow3().set({ enabled: false });
    this.label = new WaterfallSeriesLabel();
    this.tooltip = new WaterfallSeriesItemTooltip();
  }
};
__decorateClass2([
  Validate53(STRING21, { optional: true })
], WaterfallSeriesItem.prototype, "name", 2);
__decorateClass2([
  Validate53(COLOR_STRING24)
], WaterfallSeriesItem.prototype, "fill", 2);
__decorateClass2([
  Validate53(COLOR_STRING24)
], WaterfallSeriesItem.prototype, "stroke", 2);
__decorateClass2([
  Validate53(RATIO30)
], WaterfallSeriesItem.prototype, "fillOpacity", 2);
__decorateClass2([
  Validate53(RATIO30)
], WaterfallSeriesItem.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate53(LINE_DASH18)
], WaterfallSeriesItem.prototype, "lineDash", 2);
__decorateClass2([
  Validate53(POSITIVE_NUMBER28)
], WaterfallSeriesItem.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate53(POSITIVE_NUMBER28)
], WaterfallSeriesItem.prototype, "strokeWidth", 2);
__decorateClass2([
  Validate53(POSITIVE_NUMBER28)
], WaterfallSeriesItem.prototype, "cornerRadius", 2);
__decorateClass2([
  Validate53(FUNCTION17, { optional: true })
], WaterfallSeriesItem.prototype, "formatter", 2);
__decorateClass2([
  Validate53(OBJECT222)
], WaterfallSeriesItem.prototype, "shadow", 2);
__decorateClass2([
  Validate53(OBJECT222)
], WaterfallSeriesItem.prototype, "label", 2);
__decorateClass2([
  Validate53(OBJECT222)
], WaterfallSeriesItem.prototype, "tooltip", 2);
var WaterfallSeriesConnectorLine = class extends BaseProperties11 {
  constructor() {
    super(...arguments);
    this.enabled = true;
    this.stroke = "black";
    this.strokeOpacity = 1;
    this.lineDash = [0];
    this.lineDashOffset = 0;
    this.strokeWidth = 2;
  }
};
__decorateClass2([
  Validate53(BOOLEAN18)
], WaterfallSeriesConnectorLine.prototype, "enabled", 2);
__decorateClass2([
  Validate53(COLOR_STRING24)
], WaterfallSeriesConnectorLine.prototype, "stroke", 2);
__decorateClass2([
  Validate53(RATIO30)
], WaterfallSeriesConnectorLine.prototype, "strokeOpacity", 2);
__decorateClass2([
  Validate53(LINE_DASH18)
], WaterfallSeriesConnectorLine.prototype, "lineDash", 2);
__decorateClass2([
  Validate53(POSITIVE_NUMBER28)
], WaterfallSeriesConnectorLine.prototype, "lineDashOffset", 2);
__decorateClass2([
  Validate53(POSITIVE_NUMBER28)
], WaterfallSeriesConnectorLine.prototype, "strokeWidth", 2);
var WaterfallSeriesItems = class extends BaseProperties11 {
  constructor() {
    super(...arguments);
    this.positive = new WaterfallSeriesItem();
    this.negative = new WaterfallSeriesItem();
    this.total = new WaterfallSeriesItem();
  }
};
__decorateClass2([
  Validate53(OBJECT222)
], WaterfallSeriesItems.prototype, "positive", 2);
__decorateClass2([
  Validate53(OBJECT222)
], WaterfallSeriesItems.prototype, "negative", 2);
__decorateClass2([
  Validate53(OBJECT222)
], WaterfallSeriesItems.prototype, "total", 2);
var WaterfallSeriesProperties = class extends AbstractBarSeriesProperties5 {
  constructor() {
    super(...arguments);
    this.item = new WaterfallSeriesItems();
    this.totals = new PropertiesArray3(WaterfallSeriesTotal);
    this.line = new WaterfallSeriesConnectorLine();
    this.tooltip = new SeriesTooltip17();
  }
};
__decorateClass2([
  Validate53(STRING21)
], WaterfallSeriesProperties.prototype, "xKey", 2);
__decorateClass2([
  Validate53(STRING21)
], WaterfallSeriesProperties.prototype, "yKey", 2);
__decorateClass2([
  Validate53(STRING21, { optional: true })
], WaterfallSeriesProperties.prototype, "xName", 2);
__decorateClass2([
  Validate53(STRING21, { optional: true })
], WaterfallSeriesProperties.prototype, "yName", 2);
__decorateClass2([
  Validate53(OBJECT222)
], WaterfallSeriesProperties.prototype, "item", 2);
__decorateClass2([
  Validate53(OBJECT_ARRAY22)
], WaterfallSeriesProperties.prototype, "totals", 2);
__decorateClass2([
  Validate53(OBJECT222)
], WaterfallSeriesProperties.prototype, "line", 2);
__decorateClass2([
  Validate53(OBJECT222)
], WaterfallSeriesProperties.prototype, "tooltip", 2);
var {
  adjustLabelPlacement: adjustLabelPlacement2,
  SeriesNodePickMode: SeriesNodePickMode12,
  fixNumericExtent: fixNumericExtent9,
  valueProperty: valueProperty14,
  keyProperty: keyProperty8,
  accumulativeValueProperty: accumulativeValueProperty2,
  trailingAccumulatedValueProperty: trailingAccumulatedValueProperty2,
  ChartAxisDirection: ChartAxisDirection16,
  getRectConfig: getRectConfig22,
  updateRect: updateRect22,
  checkCrisp: checkCrisp22,
  updateLabelNode: updateLabelNode3,
  prepareBarAnimationFunctions: prepareBarAnimationFunctions3,
  collapsedStartingBarPosition: collapsedStartingBarPosition22,
  resetBarSelectionsFn: resetBarSelectionsFn3,
  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation7,
  resetLabelFn: resetLabelFn5,
  animationValidation: animationValidation9,
  DEFAULT_CARTESIAN_DIRECTION_KEYS: DEFAULT_CARTESIAN_DIRECTION_KEYS22,
  DEFAULT_CARTESIAN_DIRECTION_NAMES: DEFAULT_CARTESIAN_DIRECTION_NAMES22,
  isFiniteNumber: isFiniteNumber10,
  computeBarFocusBounds: computeBarFocusBounds6
} = import_ag_charts_community135._ModuleSupport;
var { Rect: Rect6, motion: motion9 } = import_ag_charts_community135._Scene;
var { sanitizeHtml: sanitizeHtml14, isContinuous: isContinuous2 } = import_ag_charts_community135._Util;
var { ContinuousScale: ContinuousScale4 } = import_ag_charts_community135._Scale;
var WaterfallSeries = class extends import_ag_charts_community135._ModuleSupport.AbstractBarSeries {
  constructor(moduleCtx) {
    super({
      moduleCtx,
      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS22,
      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES22,
      pickModes: [SeriesNodePickMode12.EXACT_SHAPE_MATCH],
      pathsPerSeries: 1,
      hasHighlightedLabels: true,
      pathsZIndexSubOrderOffset: [-1, -1],
      animationResetFns: {
        datum: resetBarSelectionsFn3,
        label: resetLabelFn5
      }
    });
    this.properties = new WaterfallSeriesProperties();
    this.seriesItemTypes = /* @__PURE__ */ new Set(["positive", "negative", "total"]);
  }
  processData(dataController) {
    return __async2(this, null, function* () {
      var _a2, _b, _c;
      const { xKey, yKey, totals } = this.properties;
      const { data = [] } = this;
      if (!this.properties.isValid() || !this.visible)
        return;
      const positiveNumber = (v) => {
        return isContinuous2(v) && Number(v) >= 0;
      };
      const negativeNumber = (v) => {
        return isContinuous2(v) && Number(v) < 0;
      };
      const totalTypeValue = (v) => {
        return v === "total" || v === "subtotal";
      };
      const propertyDefinition = {
        missingValue: void 0,
        invalidValue: void 0
      };
      const dataWithTotals = [];
      const totalsMap = totals.reduce((result, total) => {
        const totalsAtIndex = result.get(total.index);
        if (totalsAtIndex) {
          totalsAtIndex.push(total);
        } else {
          result.set(total.index, [total]);
        }
        return result;
      }, /* @__PURE__ */ new Map());
      data.forEach((datum, i) => {
        var _a3;
        dataWithTotals.push(datum);
        (_a3 = totalsMap.get(i)) == null ? void 0 : _a3.forEach((total) => dataWithTotals.push(__spreadProps2(__spreadValues2({}, total.toJson()), { [xKey]: total.axisLabel })));
      });
      const extraProps = [];
      if (!this.ctx.animationManager.isSkipped()) {
        extraProps.push(animationValidation9());
      }
      const xScale = (_a2 = this.getCategoryAxis()) == null ? void 0 : _a2.scale;
      const yScale = (_b = this.getValueAxis()) == null ? void 0 : _b.scale;
      const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });
      const { processedData } = yield this.requestDataModel(dataController, dataWithTotals, {
        props: [
          keyProperty8(xKey, xScaleType, { id: `xValue` }),
          accumulativeValueProperty2(yKey, yScaleType, __spreadProps2(__spreadValues2({}, propertyDefinition), {
            id: `yCurrent`
          })),
          accumulativeValueProperty2(yKey, yScaleType, __spreadProps2(__spreadValues2({}, propertyDefinition), {
            missingValue: 0,
            id: `yCurrentTotal`
          })),
          accumulativeValueProperty2(yKey, yScaleType, __spreadProps2(__spreadValues2({}, propertyDefinition), {
            id: `yCurrentPositive`,
            validation: positiveNumber
          })),
          accumulativeValueProperty2(yKey, yScaleType, __spreadProps2(__spreadValues2({}, propertyDefinition), {
            id: `yCurrentNegative`,
            validation: negativeNumber
          })),
          trailingAccumulatedValueProperty2(yKey, yScaleType, __spreadProps2(__spreadValues2({}, propertyDefinition), {
            id: `yPrevious`
          })),
          valueProperty14(yKey, yScaleType, { id: `yRaw` }),
          // Raw value pass-through.
          valueProperty14("totalType", "band", {
            id: `totalTypeValue`,
            missingValue: void 0,
            validation: totalTypeValue
          }),
          ...isContinuousX ? [import_ag_charts_community135._ModuleSupport.SMALLEST_KEY_INTERVAL] : [],
          ...extraProps
        ]
      });
      this.smallestDataInterval = (_c = processedData.reduced) == null ? void 0 : _c.smallestKeyInterval;
      this.updateSeriesItemTypes();
      this.animationState.transition("updateData");
    });
  }
  getSeriesDomain(direction) {
    var _a2;
    const { processedData, dataModel, smallestDataInterval } = this;
    if (!processedData || !dataModel)
      return [];
    const {
      keys: [keys],
      values
    } = processedData.domain;
    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);
    if (direction === this.getCategoryDirection()) {
      if ((keyDef == null ? void 0 : keyDef.def.type) === "key" && (keyDef == null ? void 0 : keyDef.def.valueType) === "category") {
        return keys;
      }
      const scalePadding = isFiniteNumber10(smallestDataInterval) ? smallestDataInterval : 0;
      const keysExtent = (_a2 = import_ag_charts_community135._ModuleSupport.extent(keys)) != null ? _a2 : [NaN, NaN];
      const categoryAxis = this.getCategoryAxis();
      const isReversed = Boolean(categoryAxis == null ? void 0 : categoryAxis.isReversed());
      const isDirectionY = direction === ChartAxisDirection16.Y;
      const padding0 = isReversed === isDirectionY ? 0 : -scalePadding;
      const padding1 = isReversed === isDirectionY ? scalePadding : 0;
      const d0 = keysExtent[0] + padding0;
      const d1 = keysExtent[1] + padding1;
      return fixNumericExtent9([d0, d1], categoryAxis);
    } else {
      const yCurrIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrent");
      const yExtent = values[yCurrIndex];
      const fixedYExtent = [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])];
      return fixNumericExtent9(fixedYExtent);
    }
  }
  createNodeData() {
    return __async2(this, null, function* () {
      var _a2, _b, _c;
      const { data, dataModel, smallestDataInterval } = this;
      const { line } = this.properties;
      const categoryAxis = this.getCategoryAxis();
      const valueAxis = this.getValueAxis();
      if (!(data && categoryAxis && valueAxis && dataModel)) {
        return;
      }
      const xScale = categoryAxis.scale;
      const yScale = valueAxis.scale;
      const categoryAxisReversed = categoryAxis.isReversed();
      const barAlongX = this.getBarDirection() === ChartAxisDirection16.X;
      const barWidth = (_a2 = ContinuousScale4.is(xScale) ? xScale.calcBandwidth(smallestDataInterval) : xScale.bandwidth) != null ? _a2 : 10;
      if (((_b = this.processedData) == null ? void 0 : _b.type) !== "ungrouped") {
        return;
      }
      const context = {
        itemId: this.properties.yKey,
        nodeData: [],
        labelData: [],
        pointData: [],
        scales: this.calculateScaling(),
        visible: this.visible
      };
      if (!this.visible)
        return context;
      const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yRaw`);
      const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);
      const totalTypeIndex = dataModel.resolveProcessedDataIndexById(this, `totalTypeValue`);
      const pointData = [];
      const yCurrIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrent");
      const yPrevIndex = dataModel.resolveProcessedDataIndexById(this, "yPrevious");
      const yCurrTotalIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrentTotal");
      function getValues(isTotal, isSubtotal, values) {
        if (isTotal || isSubtotal) {
          return {
            cumulativeValue: values[yCurrTotalIndex],
            trailingValue: isSubtotal ? trailingSubtotal : 0
          };
        }
        return {
          cumulativeValue: values[yCurrIndex],
          trailingValue: values[yPrevIndex]
        };
      }
      function getValue(isTotal, isSubtotal, rawValue, cumulativeValue, trailingValue) {
        if (isTotal) {
          return cumulativeValue;
        }
        if (isSubtotal) {
          return (cumulativeValue != null ? cumulativeValue : 0) - (trailingValue != null ? trailingValue : 0);
        }
        return rawValue;
      }
      let trailingSubtotal = 0;
      const { xKey, yKey, xName, yName } = this.properties;
      (_c = this.processedData) == null ? void 0 : _c.data.forEach(({ keys, datum, values }, dataIndex) => {
        const datumType = values[totalTypeIndex];
        const isSubtotal = this.isSubtotal(datumType);
        const isTotal = this.isTotal(datumType);
        const isTotalOrSubtotal = isTotal || isSubtotal;
        const xDatum = keys[xIndex];
        const x = Math.round(xScale.convert(xDatum));
        const rawValue = values[yRawIndex];
        const { cumulativeValue, trailingValue } = getValues(isTotal, isSubtotal, values);
        if (isTotalOrSubtotal) {
          trailingSubtotal = cumulativeValue != null ? cumulativeValue : 0;
        }
        const currY = Math.round(yScale.convert(cumulativeValue));
        const trailY = Math.round(yScale.convert(trailingValue));
        const value = getValue(isTotal, isSubtotal, rawValue, cumulativeValue, trailingValue);
        const isPositive = (value != null ? value : 0) >= 0;
        const seriesItemType = this.getSeriesItemType(isPositive, datumType);
        const { fill, stroke, strokeWidth, label } = this.getItemConfig(seriesItemType);
        const y = isPositive ? currY : trailY;
        const bottomY = isPositive ? trailY : currY;
        const barHeight = Math.max(strokeWidth, Math.abs(bottomY - y));
        const rect = {
          x: barAlongX ? Math.min(y, bottomY) : x,
          y: barAlongX ? x : Math.min(y, bottomY),
          width: barAlongX ? barHeight : barWidth,
          height: barAlongX ? barWidth : barHeight
        };
        const nodeMidPoint = {
          x: rect.x + rect.width / 2,
          y: rect.y + rect.height / 2
        };
        const pointY = isTotalOrSubtotal ? currY : trailY;
        const pixelAlignmentOffset = Math.floor(line.strokeWidth) % 2 / 2;
        const startY = categoryAxisReversed ? currY : pointY;
        const stopY = categoryAxisReversed ? pointY : currY;
        let startCoordinates;
        let stopCoordinates;
        if (barAlongX) {
          startCoordinates = {
            x: startY + pixelAlignmentOffset,
            y: rect.y
          };
          stopCoordinates = {
            x: stopY + pixelAlignmentOffset,
            y: rect.y + rect.height
          };
        } else {
          startCoordinates = {
            x: rect.x,
            y: startY + pixelAlignmentOffset
          };
          stopCoordinates = {
            x: rect.x + rect.width,
            y: stopY + pixelAlignmentOffset
          };
        }
        const pathPoint = {
          // lineTo
          x: categoryAxisReversed ? stopCoordinates.x : startCoordinates.x,
          y: categoryAxisReversed ? stopCoordinates.y : startCoordinates.y,
          // moveTo
          x2: categoryAxisReversed ? startCoordinates.x : stopCoordinates.x,
          y2: categoryAxisReversed ? startCoordinates.y : stopCoordinates.y,
          size: 0
        };
        pointData.push(pathPoint);
        const labelText = this.getLabelText(
          label,
          {
            itemId: seriesItemType === "subtotal" ? "total" : seriesItemType,
            value,
            datum,
            xKey,
            yKey,
            xName,
            yName
          },
          (v) => isFiniteNumber10(v) ? v.toFixed(2) : String(v)
        );
        const nodeDatum = {
          index: dataIndex,
          series: this,
          itemId: seriesItemType,
          datum,
          cumulativeValue: cumulativeValue != null ? cumulativeValue : 0,
          xValue: xDatum,
          yValue: value,
          yKey,
          xKey,
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height,
          midPoint: nodeMidPoint,
          fill,
          stroke,
          strokeWidth,
          opacity: 1,
          label: __spreadValues2({
            text: labelText
          }, adjustLabelPlacement2({
            isPositive: (value != null ? value : -1) >= 0,
            isVertical: !barAlongX,
            placement: label.placement,
            padding: label.padding,
            rect
          }))
        };
        context.nodeData.push(nodeDatum);
        context.labelData.push(nodeDatum);
      });
      const connectorLinesEnabled = this.properties.line.enabled;
      if (yCurrIndex !== void 0 && connectorLinesEnabled) {
        context.pointData = pointData;
      }
      return context;
    });
  }
  updateSeriesItemTypes() {
    var _a2, _b;
    const { dataModel, seriesItemTypes, processedData } = this;
    if (!dataModel || !processedData) {
      return;
    }
    seriesItemTypes.clear();
    const yPositiveIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrentPositive");
    const yNegativeIndex = dataModel.resolveProcessedDataIndexById(this, "yCurrentNegative");
    const totalTypeIndex = dataModel.resolveProcessedDataIndexById(this, `totalTypeValue`);
    const positiveDomain = (_a2 = processedData.domain.values[yPositiveIndex]) != null ? _a2 : [];
    const negativeDomain = (_b = processedData.domain.values[yNegativeIndex]) != null ? _b : [];
    if (positiveDomain.length > 0) {
      seriesItemTypes.add("positive");
    }
    if (negativeDomain.length > 0) {
      seriesItemTypes.add("negative");
    }
    const itemTypes = processedData == null ? void 0 : processedData.domain.values[totalTypeIndex];
    if (!itemTypes) {
      return;
    }
    itemTypes.forEach((type) => {
      if (type === "total" || type === "subtotal") {
        seriesItemTypes.add("total");
      }
    });
  }
  isSubtotal(datumType) {
    return datumType === "subtotal";
  }
  isTotal(datumType) {
    return datumType === "total";
  }
  nodeFactory() {
    return new Rect6();
  }
  getSeriesItemType(isPositive, datumType) {
    return datumType != null ? datumType : isPositive ? "positive" : "negative";
  }
  getItemConfig(seriesItemType) {
    switch (seriesItemType) {
      case "positive": {
        return this.properties.item.positive;
      }
      case "negative": {
        return this.properties.item.negative;
      }
      case "subtotal":
      case "total": {
        return this.properties.item.total;
      }
    }
  }
  updateDatumSelection(opts) {
    return __async2(this, null, function* () {
      const { nodeData, datumSelection } = opts;
      const data = nodeData != null ? nodeData : [];
      return datumSelection.update(data);
    });
  }
  updateDatumNodes(opts) {
    return __async2(this, null, function* () {
      const { datumSelection, isHighlight } = opts;
      const { id: seriesId, ctx } = this;
      const {
        yKey,
        highlightStyle: { item: itemHighlightStyle }
      } = this.properties;
      const categoryAxis = this.getCategoryAxis();
      const crisp = checkCrisp22(categoryAxis == null ? void 0 : categoryAxis.visibleRange);
      const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection16.X;
      datumSelection.each((rect, datum) => {
        const seriesItemType = datum.itemId;
        const {
          fillOpacity,
          strokeOpacity,
          strokeWidth,
          lineDash,
          lineDashOffset,
          cornerRadius,
          formatter,
          shadow: fillShadow
        } = this.getItemConfig(seriesItemType);
        const style = {
          fill: datum.fill,
          stroke: datum.stroke,
          fillOpacity,
          strokeOpacity,
          lineDash,
          lineDashOffset,
          fillShadow,
          strokeWidth: this.getStrokeWidth(strokeWidth),
          cornerRadius
        };
        const visible = categoryAlongX ? datum.width > 0 : datum.height > 0;
        const config = getRectConfig22({
          datum,
          isHighlighted: isHighlight,
          style,
          highlightStyle: itemHighlightStyle,
          formatter,
          seriesId,
          itemId: datum.itemId,
          ctx,
          value: datum.yValue,
          yKey
        });
        config.crisp = crisp;
        config.visible = visible;
        updateRect22({ rect, config });
      });
    });
  }
  updateLabelSelection(opts) {
    return __async2(this, null, function* () {
      const { labelData, labelSelection } = opts;
      if (labelData.length === 0) {
        return labelSelection.update([]);
      }
      const itemId = labelData[0].itemId;
      const { label } = this.getItemConfig(itemId);
      const data = label.enabled ? labelData : [];
      return labelSelection.update(data);
    });
  }
  updateLabelNodes(opts) {
    return __async2(this, null, function* () {
      opts.labelSelection.each((textNode, datum) => {
        updateLabelNode3(textNode, this.getItemConfig(datum.itemId).label, datum.label);
      });
    });
  }
  getTooltipHtml(nodeDatum) {
    var _a2, _b, _c;
    const categoryAxis = this.getCategoryAxis();
    const valueAxis = this.getValueAxis();
    if (!this.properties.isValid() || !categoryAxis || !valueAxis) {
      return import_ag_charts_community135._ModuleSupport.EMPTY_TOOLTIP_CONTENT;
    }
    const { id: seriesId } = this;
    const { xKey, yKey, xName, yName, tooltip } = this.properties;
    const { datum, itemId, xValue, yValue } = nodeDatum;
    const { fill, strokeWidth, name, formatter } = this.getItemConfig(itemId);
    let format2;
    if (formatter) {
      format2 = this.ctx.callbackCache.call(formatter, {
        datum,
        value: yValue,
        xKey,
        yKey,
        fill,
        strokeWidth,
        highlighted: false,
        seriesId,
        itemId: nodeDatum.itemId
      });
    }
    const color = (_b = (_a2 = format2 == null ? void 0 : format2.fill) != null ? _a2 : fill) != null ? _b : "gray";
    const xString = sanitizeHtml14(categoryAxis.formatDatum(xValue));
    const yString = sanitizeHtml14(valueAxis.formatDatum(yValue));
    const isTotal = this.isTotal(itemId);
    const isSubtotal = this.isSubtotal(itemId);
    let ySubheading;
    if (isTotal) {
      ySubheading = "Total";
    } else if (isSubtotal) {
      ySubheading = "Subtotal";
    } else {
      ySubheading = (_c = name != null ? name : yName) != null ? _c : yKey;
    }
    const title = sanitizeHtml14(yName);
    const content = `<b>${sanitizeHtml14(xName != null ? xName : xKey)}</b>: ${xString}<br/><b>${sanitizeHtml14(ySubheading)}</b>: ${yString}`;
    return tooltip.toTooltipHtml(
      { title, content, backgroundColor: color },
      { seriesId, itemId, datum, xKey, yKey, xName, yName, color, title }
    );
  }
  getLegendData(legendType) {
    if (legendType !== "category") {
      return [];
    }
    const { id, seriesItemTypes } = this;
    const legendData = [];
    const capitalise = (text) => text.charAt(0).toUpperCase() + text.substring(1);
    seriesItemTypes.forEach((item) => {
      const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth, name } = this.getItemConfig(item);
      legendData.push({
        legendType: "category",
        id,
        itemId: item,
        seriesId: id,
        enabled: true,
        label: { text: name != null ? name : capitalise(item) },
        marker: { fill, stroke, fillOpacity, strokeOpacity, strokeWidth }
      });
    });
    return legendData;
  }
  toggleSeriesItem() {
  }
  animateEmptyUpdateReady({ datumSelection, labelSelection, contextData, paths }) {
    const fns = prepareBarAnimationFunctions3(collapsedStartingBarPosition22(this.isVertical(), this.axes, "normal"));
    motion9.fromToMotion(this.id, "datums", this.ctx.animationManager, [datumSelection], fns);
    seriesLabelFadeInAnimation7(this, "labels", this.ctx.animationManager, labelSelection);
    const { pointData } = contextData;
    if (!pointData)
      return;
    const [lineNode] = paths;
    if (this.isVertical()) {
      this.animateConnectorLinesVertical(lineNode, pointData);
    } else {
      this.animateConnectorLinesHorizontal(lineNode, pointData);
    }
  }
  animateConnectorLinesHorizontal(lineNode, pointData) {
    const { path: linePath } = lineNode;
    this.updateLineNode(lineNode);
    const valueAxis = this.getValueAxis();
    const valueAxisReversed = valueAxis == null ? void 0 : valueAxis.isReversed();
    const compare = valueAxisReversed ? (v, v2) => v < v2 : (v, v2) => v > v2;
    const startX = valueAxis == null ? void 0 : valueAxis.scale.convert(0);
    const endX = pointData.reduce(
      (end, point) => {
        if (compare(point.x, end)) {
          end = point.x;
        }
        return end;
      },
      valueAxisReversed ? Infinity : 0
    );
    const scale2 = (value, start1, end1, start2, end2) => {
      return (value - start1) / (end1 - start1) * (end2 - start2) + start2;
    };
    this.ctx.animationManager.animate({
      id: `${this.id}_connectors`,
      groupId: this.id,
      phase: "initial",
      from: startX,
      to: endX,
      ease: import_ag_charts_community135._ModuleSupport.Motion.easeOut,
      collapsable: false,
      onUpdate(pointX) {
        linePath.clear(true);
        pointData.forEach((point, index) => {
          const x = scale2(pointX, startX, endX, startX, point.x);
          const x2 = scale2(pointX, startX, endX, startX, point.x2);
          if (index !== 0) {
            linePath.lineTo(x, point.y);
          }
          linePath.moveTo(x2, point.y2);
        });
        lineNode.checkPathDirty();
      }
    });
  }
  animateConnectorLinesVertical(lineNode, pointData) {
    const { path: linePath } = lineNode;
    this.updateLineNode(lineNode);
    const valueAxis = this.getValueAxis();
    const valueAxisReversed = valueAxis == null ? void 0 : valueAxis.isReversed();
    const compare = valueAxisReversed ? (v, v2) => v > v2 : (v, v2) => v < v2;
    const startY = valueAxis == null ? void 0 : valueAxis.scale.convert(0);
    const endY = pointData.reduce(
      (end, point) => {
        if (compare(point.y, end)) {
          end = point.y;
        }
        return end;
      },
      valueAxisReversed ? 0 : Infinity
    );
    const scale2 = (value, start1, end1, start2, end2) => {
      return (value - start1) / (end1 - start1) * (end2 - start2) + start2;
    };
    this.ctx.animationManager.animate({
      id: `${this.id}_connectors`,
      groupId: this.id,
      phase: "initial",
      from: startY,
      to: endY,
      ease: import_ag_charts_community135._ModuleSupport.Motion.easeOut,
      collapsable: false,
      onUpdate(pointY) {
        linePath.clear(true);
        pointData.forEach((point, index) => {
          const y = scale2(pointY, startY, endY, startY, point.y);
          const y2 = scale2(pointY, startY, endY, startY, point.y2);
          if (index !== 0) {
            linePath.lineTo(point.x, y);
          }
          linePath.moveTo(point.x2, y2);
        });
        lineNode.checkPathDirty();
      }
    });
  }
  animateReadyResize(data) {
    super.animateReadyResize(data);
    this.resetConnectorLinesPath(data);
  }
  updatePaths(opts) {
    return __async2(this, null, function* () {
      this.resetConnectorLinesPath({ contextData: opts.contextData, paths: opts.paths });
    });
  }
  resetConnectorLinesPath({ contextData, paths }) {
    if (paths.length === 0) {
      return;
    }
    const [lineNode] = paths;
    this.updateLineNode(lineNode);
    const { path: linePath } = lineNode;
    linePath.clear(true);
    const { pointData } = contextData;
    if (!pointData) {
      return;
    }
    pointData.forEach((point, index) => {
      if (index !== 0) {
        linePath.lineTo(point.x, point.y);
      }
      linePath.moveTo(point.x2, point.y2);
    });
    lineNode.checkPathDirty();
  }
  updateLineNode(lineNode) {
    const { stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset } = this.properties.line;
    lineNode.setProperties({
      fill: void 0,
      stroke,
      strokeWidth: this.getStrokeWidth(strokeWidth),
      strokeOpacity,
      lineDash,
      lineDashOffset,
      lineJoin: "round",
      pointerEvents: import_ag_charts_community135._Scene.PointerEvents.None
    });
  }
  isLabelEnabled() {
    const { positive, negative, total } = this.properties.item;
    return positive.label.enabled || negative.label.enabled || total.label.enabled;
  }
  onDataChange() {
  }
  computeFocusBounds({ datumIndex, seriesRect }) {
    var _a2;
    return computeBarFocusBounds6((_a2 = this.contextNodeData) == null ? void 0 : _a2.nodeData[datumIndex], this.contentGroup, seriesRect);
  }
};
WaterfallSeries.className = "WaterfallSeries";
WaterfallSeries.type = "waterfall";
var import_ag_charts_community136 = (init_main(), __toCommonJS(main_exports));
var itemTheme = {
  strokeWidth: 0,
  label: {
    enabled: false,
    fontStyle: void 0,
    fontWeight: import_ag_charts_community136._Theme.FONT_WEIGHT.NORMAL,
    fontSize: 12,
    fontFamily: import_ag_charts_community136._Theme.DEFAULT_FONT_FAMILY,
    color: import_ag_charts_community136._Theme.DEFAULT_LABEL_COLOUR,
    formatter: void 0,
    placement: "end"
  }
};
var WATERFALL_SERIES_THEME = {
  series: {
    __extends__: import_ag_charts_community136._Theme.EXTENDS_SERIES_DEFAULTS,
    item: {
      positive: itemTheme,
      negative: itemTheme,
      total: itemTheme
    },
    line: {
      stroke: import_ag_charts_community136._Theme.DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,
      strokeOpacity: 1,
      lineDash: [0],
      lineDashOffset: 0,
      strokeWidth: 2
    }
  },
  legend: {
    enabled: true,
    item: {
      toggleSeriesVisible: false
    }
  }
};
var WaterfallModule = {
  type: "series",
  optionsKey: "series[]",
  packageType: "enterprise",
  chartTypes: ["cartesian"],
  identifier: "waterfall",
  solo: true,
  instanceConstructor: WaterfallSeries,
  defaultAxes: [
    {
      type: import_ag_charts_community137._Theme.CARTESIAN_AXIS_TYPE.CATEGORY,
      position: import_ag_charts_community137._Theme.POSITION.BOTTOM
    },
    {
      type: import_ag_charts_community137._Theme.CARTESIAN_AXIS_TYPE.NUMBER,
      position: import_ag_charts_community137._Theme.POSITION.LEFT
    }
  ],
  themeTemplate: WATERFALL_SERIES_THEME,
  swapDefaultAxesCondition: ({ direction }) => direction === "horizontal",
  paletteFactory: ({ takeColors, colorsCount, userPalette, themeTemplateParameters }) => {
    const { properties } = themeTemplateParameters;
    const { fills, strokes } = takeColors(colorsCount);
    return userPalette ? {
      item: {
        positive: {
          fill: fills[0],
          stroke: strokes[0]
        },
        negative: {
          fill: fills[1],
          stroke: strokes[1]
        },
        total: {
          fill: fills[2],
          stroke: strokes[2]
        }
      }
    } : {
      item: {
        positive: properties.get(import_ag_charts_community137._Theme.DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS),
        negative: properties.get(import_ag_charts_community137._Theme.DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS),
        total: properties.get(import_ag_charts_community137._Theme.DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS)
      }
    };
  }
};
function setupEnterpriseModules() {
  import_ag_charts_community138._ModuleSupport.moduleRegistry.register(
    AngleCategoryAxisModule,
    AngleNumberAxisModule,
    AnimationModule,
    AnnotationsModule,
    BackgroundModule2,
    BoxPlotModule,
    CandlestickModule,
    OhlcModule,
    BulletModule,
    ContextMenuModule,
    CrosshairModule,
    DataSourceModule,
    ErrorBarsModule,
    MapLineModule,
    MapLineBackgroundModule,
    MapMarkerModule,
    MapShapeModule,
    MapShapeBackgroundModule,
    NavigatorModule2,
    GradientLegendModule,
    HeatmapModule,
    NightingaleModule,
    OrdinalTimeAxisModule,
    RadarAreaModule,
    RadarLineModule,
    RadialBarModule,
    RadialColumnModule,
    RadiusCategoryAxisModule,
    RadiusNumberAxisModule,
    RangeBarModule,
    RangeAreaModule,
    SunburstModule,
    SyncModule,
    TreemapModule,
    WaterfallModule,
    ZoomModule
  );
  import_ag_charts_community138._ModuleSupport.enterpriseModule.isEnterprise = true;
  import_ag_charts_community138._ModuleSupport.enterpriseModule.licenseManager = (options) => {
    var _a2, _b;
    return new LicenseManager(
      (_b = (_a2 = options.container) == null ? void 0 : _a2.ownerDocument) != null ? _b : typeof document === "undefined" ? void 0 : document
    );
  };
  import_ag_charts_community138._ModuleSupport.enterpriseModule.injectWatermark = injectWatermark;
}
__reExport(main_exports2, (init_main(), __toCommonJS(main_exports)), module.exports);
setupEnterpriseModules();
if (typeof module.exports == "object" && typeof exports == "object") {
  var __cp = (to, from, except, desc) => {
    if ((from && typeof from === "object") || typeof from === "function") {
      for (let key of Object.getOwnPropertyNames(from)) {
        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)
        Object.defineProperty(to, key, {
          get: () => from[key],
          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,
        });
      }
    }
    return to;
  };
  module.exports = __cp(module.exports, exports);
}
return module.exports;
}))
